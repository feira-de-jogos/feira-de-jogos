!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e() : typeof define === 'function' && define.amd ? define('Phaser', [], e) : typeof exports === 'object' ? exports.Phaser = e() : t.Phaser = e() }(this, () => (() => { const t = { 50792: t => { 'use strict'; const e = Object.prototype.hasOwnProperty; let i = '~'; function s () { } function n (t, e, i) { this.fn = t, this.context = e, this.once = i || !1 } function r (t, e, s, r, o) { if (typeof s !== 'function') throw new TypeError('The listener must be a function'); const a = new n(s, r || t, o); const h = i ? i + e : e; return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a, t._eventsCount++), t } function o (t, e) { --t._eventsCount == 0 ? t._events = new s() : delete t._events[e] } function a () { this._events = new s(), this._eventsCount = 0 } Object.create && (s.prototype = Object.create(null), (new s()).__proto__ || (i = !1)), a.prototype.eventNames = function () { let t; let s; const n = []; if (this._eventsCount === 0) return n; for (s in t = this._events) e.call(t, s) && n.push(i ? s.slice(1) : s); return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n }, a.prototype.listeners = function (t) { const e = i ? i + t : t; const s = this._events[e]; if (!s) return []; if (s.fn) return [s.fn]; for (var n = 0, r = s.length, o = new Array(r); n < r; n++)o[n] = s[n].fn; return o }, a.prototype.listenerCount = function (t) { const e = i ? i + t : t; const s = this._events[e]; return s ? s.fn ? 1 : s.length : 0 }, a.prototype.emit = function (t, e, s, n, r, o) { const a = i ? i + t : t; if (!this._events[a]) return !1; let h; let l; const u = this._events[a]; const c = arguments.length; if (u.fn) { switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) { case 1: return u.fn.call(u.context), !0; case 2: return u.fn.call(u.context, e), !0; case 3: return u.fn.call(u.context, e, s), !0; case 4: return u.fn.call(u.context, e, s, n), !0; case 5: return u.fn.call(u.context, e, s, n, r), !0; case 6: return u.fn.call(u.context, e, s, n, r, o), !0 } for (l = 1, h = new Array(c - 1); l < c; l++)h[l - 1] = arguments[l]; u.fn.apply(u.context, h) } else { let d; const f = u.length; for (l = 0; l < f; l++) switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0), c) { case 1: u[l].fn.call(u[l].context); break; case 2: u[l].fn.call(u[l].context, e); break; case 3: u[l].fn.call(u[l].context, e, s); break; case 4: u[l].fn.call(u[l].context, e, s, n); break; default: if (!h) for (d = 1, h = new Array(c - 1); d < c; d++)h[d - 1] = arguments[d]; u[l].fn.apply(u[l].context, h) } } return !0 }, a.prototype.on = function (t, e, i) { return r(this, t, e, i, !1) }, a.prototype.once = function (t, e, i) { return r(this, t, e, i, !0) }, a.prototype.removeListener = function (t, e, s, n) { const r = i ? i + t : t; if (!this._events[r]) return this; if (!e) return o(this, r), this; const a = this._events[r]; if (a.fn) a.fn !== e || n && !a.once || s && a.context !== s || o(this, r); else { for (var h = 0, l = [], u = a.length; h < u; h++)(a[h].fn !== e || n && !a[h].once || s && a[h].context !== s) && l.push(a[h]); l.length ? this._events[r] = l.length === 1 ? l[0] : l : o(this, r) } return this }, a.prototype.removeAllListeners = function (t) { let e; return t ? (e = i ? i + t : t, this._events[e] && o(this, e)) : (this._events = new s(), this._eventsCount = 0), this }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = i, a.EventEmitter = a, t.exports = a }, 11517: (t, e, i) => { const s = i(38829); t.exports = function (t, e, i, n) { for (let r = t[0], o = 1; o < t.length; o++) { const a = t[o]; s(a, r, e, i, n), r = a } return t } }, 80318: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'angle', e, i, n, r) } }, 60757: t => { t.exports = function (t, e, i) { for (let s = 0; s < t.length; s++) { const n = t[s]; e.call(i, n) } return t } }, 69927: t => { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let s = i; s < t.length; s++) { const n = t[s]; let r = !0; for (const o in e) n[o] !== e[o] && (r = !1); if (r) return n } return null } }, 32265: t => { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let s = t.length - 1; s >= i; s--) { const n = t[s]; let r = !0; for (const o in e) n[o] !== e[o] && (r = !1); if (r) return n } return null } }, 94420: (t, e, i) => { const s = i(11879); const n = i(60461); const r = i(95540); const o = i(29747); const a = new (i(41481))({ sys: { queueDepthSort: o, events: { once: o } } }, 0, 0, 1, 1).setOrigin(0, 0); t.exports = function (t, e) { void 0 === e && (e = {}); const i = e.hasOwnProperty('width'); const o = e.hasOwnProperty('height'); const h = r(e, 'width', -1); const l = r(e, 'height', -1); const u = r(e, 'cellWidth', 1); const c = r(e, 'cellHeight', u); const d = r(e, 'position', n.TOP_LEFT); const f = r(e, 'x', 0); const p = r(e, 'y', 0); let v = 0; let g = 0; const m = h * u; const y = l * c; a.setPosition(f, p), a.setSize(u, c); for (let x = 0; x < t.length; x++) if (s(t[x], a, d), i && h === -1) a.x += u; else if (o && l === -1) a.y += c; else if (o && !i) { if (g += c, a.y += c, g === y && (g = 0, v += u, a.y = p, a.x += u, v === m)) break } else if (v += u, a.x += u, v === m && (v = 0, g += c, a.x = f, a.y += c, g === y)) break; return t } }, 41721: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'alpha', e, i, n, r) } }, 67285: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'x', e, i, n, r) } }, 9074: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'x', e, n, o, a), s(t, 'y', i, r, o, a) } }, 75222: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'y', e, i, n, r) } }, 22983: t => { t.exports = function (t, e, i, s) { void 0 === i && (i = 0), void 0 === s && (s = 6.28); for (let n = i, r = (s - i) / t.length, o = e.x, a = e.y, h = e.radius, l = 0; l < t.length; l++)t[l].x = o + h * Math.cos(n), t[l].y = a + h * Math.sin(n), n += r; return t } }, 95253: t => { t.exports = function (t, e, i, s) { void 0 === i && (i = 0), void 0 === s && (s = 6.28); for (let n = i, r = (s - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++)t[h].x = e.x + o * Math.cos(n), t[h].y = e.y + a * Math.sin(n), n += r; return t } }, 88505: (t, e, i) => { const s = i(15258); const n = i(26708); t.exports = function (t, e, i) { let r; r = i ? n(e, i, t.length) : s(e, t.length); for (let o = 0; o < t.length; o++) { const a = t[o]; const h = r[o]; a.x = h.x, a.y = h.y } return t } }, 41346: (t, e, i) => { const s = i(14649); const n = i(86003); const r = i(49498); t.exports = function (t, e, i) { void 0 === i && (i = 0); const o = s(e, !1, t.length); i > 0 ? n(o, i) : i < 0 && r(o, Math.abs(i)); for (let a = 0; a < t.length; a++)t[a].x = o[a].x, t[a].y = o[a].y; return t } }, 11575: (t, e, i) => { const s = i(84993); t.exports = function (t, e, i) { let n = s({ x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2 }, i); const r = s({ x1: e.x2, y1: e.y2, x2: e.x3, y2: e.y3 }, i); const o = s({ x1: e.x3, y1: e.y3, x2: e.x1, y2: e.y1 }, i); n.pop(), r.pop(), o.pop(); for (let a = (n = n.concat(r, o)).length / t.length, h = 0, l = 0; l < t.length; l++) { const u = t[l]; const c = n[Math.floor(h)]; u.x = c.x, u.y = c.y, h += a } return t } }, 29953: t => { t.exports = function (t, e, i) { for (let s = 0; s < t.length; s++) { const n = t[s]; n.anims && n.anims.play(e, i) } return t } }, 66979: t => { t.exports = function (t, e, i, s, n, r) { let o; void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = n; o < h; o++)t[o][e] += i + a * s, a++; else for (o = n; o >= 0; o--)t[o][e] += i + a * s, a++; return t } }, 43967: t => { t.exports = function (t, e, i, s, n, r) { let o; void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = n; o < h; o++)t[o][e] = i + a * s, a++; else for (o = n; o >= 0; o--)t[o][e] = i + a * s, a++; return t } }, 88926: (t, e, i) => { const s = i(28176); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)s(e, t[i]); return t } }, 33286: (t, e, i) => { const s = i(24820); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)s(e, t[i]); return t } }, 96e3: (t, e, i) => { const s = i(65822); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)s(e, t[i]); return t } }, 28789: (t, e, i) => { const s = i(26597); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)s(e, t[i]); return t } }, 97154: (t, e, i) => { const s = i(90260); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)s(e, t[i]); return t } }, 20510: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'rotation', e, i, n, r) } }, 91051: (t, e, i) => { const s = i(1163); const n = i(20339); t.exports = function (t, e, i) { for (let r = e.x, o = e.y, a = 0; a < t.length; a++) { const h = t[a]; s(h, r, o, i, Math.max(1, n(h.x, h.y, r, o))) } return t } }, 76332: (t, e, i) => { const s = i(1163); t.exports = function (t, e, i, n) { const r = e.x; const o = e.y; if (n === 0) return t; for (let a = 0; a < t.length; a++)s(t[a], r, o, i, n); return t } }, 61619: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'scaleX', e, i, n, r) } }, 94868: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'scaleX', e, n, o, a), s(t, 'scaleY', i, r, o, a) } }, 95532: (t, e, i) => { const s = i(66979); t.exports = function (t, e, i, n, r) { return s(t, 'scaleY', e, i, n, r) } }, 8689: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'alpha', e, i, n, r) } }, 2645: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n) { return s(t, 'blendMode', e, 0, i, n) } }, 32372: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'depth', e, i, n, r) } }, 85373: t => { t.exports = function (t, e, i) { for (let s = 0; s < t.length; s++)t[s].setInteractive(e, i); return t } }, 81583: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'originX', e, n, o, a), s(t, 'originY', i, r, o, a), t.forEach(function (t) { t.updateDisplayOrigin() }), t } }, 79939: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'rotation', e, i, n, r) } }, 2699: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'scaleX', e, n, o, a), s(t, 'scaleY', i, r, o, a) } }, 98739: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'scaleX', e, i, n, r) } }, 98476: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'scaleY', e, i, n, r) } }, 6207: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'scrollFactorX', e, n, o, a), s(t, 'scrollFactorY', i, r, o, a) } }, 6607: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'scrollFactorX', e, i, n, r) } }, 72248: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'scrollFactorY', e, i, n, r) } }, 14036: t => { t.exports = function (t, e, i, s, n) { for (let r = 0; r < t.length; r++)t[r].setTint(e, i, s, n); return t } }, 50159: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n) { return s(t, 'visible', e, 0, i, n) } }, 77597: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'x', e, i, n, r) } }, 83194: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r, o, a) { return i == null && (i = e), s(t, 'x', e, n, o, a), s(t, 'y', i, r, o, a) } }, 67678: (t, e, i) => { const s = i(43967); t.exports = function (t, e, i, n, r) { return s(t, 'y', e, i, n, r) } }, 35850: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r) { let o, a; void 0 === n && (n = 0), void 0 === r && (r = new s()); const h = t.length; if (h === 1) o = t[0].x, a = t[0].y, t[0].x = e, t[0].y = i; else { let l = 1; let u = 0; n === 0 && (u = h - 1, l = h - 2), o = t[u].x, a = t[u].y, t[u].x = e, t[u].y = i; for (let c = 0; c < h; c++) if (!(l >= h || l === -1)) { const d = t[l]; const f = d.x; const p = d.y; d.x = o, d.y = a, o = f, a = p, n === 0 ? l-- : l++ } } return r.x = o, r.y = a, r } }, 8628: (t, e, i) => { const s = i(33680); t.exports = function (t) { return s(t) } }, 21837: (t, e, i) => { const s = i(7602); t.exports = function (t, e, i, n, r) { void 0 === r && (r = !1); let o; const a = Math.abs(n - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += s(o * a, i, n); else for (o = 0; o < t.length; o++)t[o][e] = s(o * a, i, n); return t } }, 21910: (t, e, i) => { const s = i(54261); t.exports = function (t, e, i, n, r) { void 0 === r && (r = !1); let o; const a = Math.abs(n - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += s(o * a, i, n); else for (o = 0; o < t.length; o++)t[o][e] = s(o * a, i, n); return t } }, 62054: t => { t.exports = function (t, e, i, s, n) { if (void 0 === n && (n = !1), t.length === 0) return t; if (t.length === 1) return n ? t[0][e] += (s + i) / 2 : t[0][e] = (s + i) / 2, t; let r; const o = Math.abs(s - i) / (t.length - 1); if (n) for (r = 0; r < t.length; r++)t[r][e] += r * o + i; else for (r = 0; r < t.length; r++)t[r][e] = r * o + i; return t } }, 79815: t => { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].visible = !t[e].visible; return t } }, 39665: (t, e, i) => { const s = i(15994); t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = 0; n < t.length; n++) { const r = t[n]; r.x = s(r.x, e.left - i, e.right + i), r.y = s(r.y, e.top - i, e.bottom + i) } return t } }, 61061: (t, e, i) => { t.exports = { AlignTo: i(11517), Angle: i(80318), Call: i(60757), GetFirst: i(69927), GetLast: i(32265), GridAlign: i(94420), IncAlpha: i(41721), IncX: i(67285), IncXY: i(9074), IncY: i(75222), PlaceOnCircle: i(22983), PlaceOnEllipse: i(95253), PlaceOnLine: i(88505), PlaceOnRectangle: i(41346), PlaceOnTriangle: i(11575), PlayAnimation: i(29953), PropertyValueInc: i(66979), PropertyValueSet: i(43967), RandomCircle: i(88926), RandomEllipse: i(33286), RandomLine: i(96e3), RandomRectangle: i(28789), RandomTriangle: i(97154), Rotate: i(20510), RotateAround: i(91051), RotateAroundDistance: i(76332), ScaleX: i(61619), ScaleXY: i(94868), ScaleY: i(95532), SetAlpha: i(8689), SetBlendMode: i(2645), SetDepth: i(32372), SetHitArea: i(85373), SetOrigin: i(81583), SetRotation: i(79939), SetScale: i(2699), SetScaleX: i(98739), SetScaleY: i(98476), SetScrollFactor: i(6207), SetScrollFactorX: i(6607), SetScrollFactorY: i(72248), SetTint: i(14036), SetVisible: i(50159), SetX: i(77597), SetXY: i(83194), SetY: i(67678), ShiftPosition: i(35850), Shuffle: i(8628), SmootherStep: i(21910), SmoothStep: i(21837), Spread: i(62054), ToggleVisible: i(79815), WrapInRectangle: i(39665) } }, 42099: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(74943); const o = i(81957); const a = i(41138); const h = i(35154); const l = i(90126); const u = new n({ initialize: function (t, e, i) { this.manager = t, this.key = e, this.type = 'frame', this.frames = this.getFrames(t.textureManager, h(i, 'frames', []), h(i, 'defaultTextureKey', null), h(i, 'sortFrames', !0)), this.frameRate = h(i, 'frameRate', null), this.duration = h(i, 'duration', null), this.msPerFrame, this.skipMissedFrames = h(i, 'skipMissedFrames', !0), this.delay = h(i, 'delay', 0), this.repeat = h(i, 'repeat', 0), this.repeatDelay = h(i, 'repeatDelay', 0), this.yoyo = h(i, 'yoyo', !1), this.showBeforeDelay = h(i, 'showBeforeDelay', !1), this.showOnStart = h(i, 'showOnStart', !1), this.hideOnComplete = h(i, 'hideOnComplete', !1), this.randomFrame = h(i, 'randomFrame', !1), this.paused = !1, this.calculateDuration(this, this.getTotalFrames(), this.duration, this.frameRate), this.manager.on && (this.manager.on(r.PAUSE_ALL, this.pause, this), this.manager.on(r.RESUME_ALL, this.resume, this)) }, getTotalFrames: function () { return this.frames.length }, calculateDuration: function (t, e, i, s) { i === null && s === null ? (t.frameRate = 24, t.duration = 24 / e * 1e3) : i && s === null ? (t.duration = i, t.frameRate = e / (i / 1e3)) : (t.frameRate = s, t.duration = e / s * 1e3), t.msPerFrame = 1e3 / t.frameRate }, addFrame: function (t) { return this.addFrameAt(this.frames.length, t) }, addFrameAt: function (t, e) { const i = this.getFrames(this.manager.textureManager, e); if (i.length > 0) { if (t === 0) this.frames = i.concat(this.frames); else if (t === this.frames.length) this.frames = this.frames.concat(i); else { const s = this.frames.slice(0, t); const n = this.frames.slice(t); this.frames = s.concat(i, n) } this.updateFrameSequence() } return this }, checkFrame: function (t) { return t >= 0 && t < this.frames.length }, getFirstTick: function (t) { t.accumulator = 0, t.nextTick = t.currentFrame.duration ? t.currentFrame.duration : t.msPerFrame }, getFrameAt: function (t) { return this.frames[t] }, getFrames: function (t, e, i, s) { void 0 === s && (s = !0); let n; let r; let o; let u; const c = []; let d = 1; if (typeof e === 'string') { if (u = e, !t.exists(u)) return console.warn('Texture "%s" not found', u), c; const f = t.get(u).getFrameNames(); s && l(f), e = [], f.forEach(function (t) { e.push({ key: u, frame: t }) }) } if (!Array.isArray(e) || e.length === 0) return c; for (o = 0; o < e.length; o++) { const p = e[o]; const v = h(p, 'key', i); if (v) { const g = h(p, 'frame', 0); const m = t.getFrame(v, g); m ? ((r = new a(v, g, d, m)).duration = h(p, 'duration', 0), r.isFirst = !n, n && (n.nextFrame = r, r.prevFrame = n), c.push(r), n = r, d++) : console.warn('Texture "%s" not found', v) } } if (c.length > 0) { r.isLast = !0, r.nextFrame = c[0], c[0].prevFrame = r; const y = 1 / (c.length - 1); for (o = 0; o < c.length; o++)c[o].progress = o * y } return c }, getNextTick: function (t) { t.accumulator -= t.nextTick, t.nextTick = t.currentFrame.duration ? t.currentFrame.duration : t.msPerFrame }, getFrameByProgress: function (t) { return t = s(t, 0, 1), o(t, this.frames, 'progress') }, nextFrame: function (t) { const e = t.currentFrame; e.isLast ? t.yoyo ? this.handleYoyoFrame(t, !1) : t.repeatCounter > 0 ? t.inReverse && t.forward ? t.forward = !1 : this.repeatAnimation(t) : t.complete() : this.updateAndGetNextTick(t, e.nextFrame) }, handleYoyoFrame: function (t, e) { if (e || (e = !1), t.inReverse === !e && t.repeatCounter > 0) return (t.repeatDelay === 0 || t.pendingRepeat) && (t.forward = e), void this.repeatAnimation(t); if (t.inReverse === e || t.repeatCounter !== 0) { t.forward = e; const i = e ? t.currentFrame.nextFrame : t.currentFrame.prevFrame; this.updateAndGetNextTick(t, i) } else t.complete() }, getLastFrame: function () { return this.frames[this.frames.length - 1] }, previousFrame: function (t) { const e = t.currentFrame; e.isFirst ? t.yoyo ? this.handleYoyoFrame(t, !0) : t.repeatCounter > 0 ? (t.inReverse && !t.forward || (t.forward = !0), this.repeatAnimation(t)) : t.complete() : this.updateAndGetNextTick(t, e.prevFrame) }, updateAndGetNextTick: function (t, e) { t.setCurrentFrame(e), this.getNextTick(t) }, removeFrame: function (t) { const e = this.frames.indexOf(t); return e !== -1 && this.removeFrameAt(e), this }, removeFrameAt: function (t) { return this.frames.splice(t, 1), this.updateFrameSequence(), this }, repeatAnimation: function (t) { if (t._pendingStop === 2) { if (t._pendingStopValue === 0) return t.stop(); t._pendingStopValue-- } t.repeatDelay > 0 && !t.pendingRepeat ? (t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t.repeatDelay) : (t.repeatCounter--, t.forward ? t.setCurrentFrame(t.currentFrame.nextFrame) : t.setCurrentFrame(t.currentFrame.prevFrame), t.isPlaying && (this.getNextTick(t), t.handleRepeat())) }, toJSON: function () { const t = { key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showBeforeDelay: this.showBeforeDelay, showOnStart: this.showOnStart, randomFrame: this.randomFrame, hideOnComplete: this.hideOnComplete }; return this.frames.forEach(function (e) { t.frames.push(e.toJSON()) }), t }, updateFrameSequence: function () { for (var t, e = this.frames.length, i = 1 / (e - 1), s = 0; s < e; s++)(t = this.frames[s]).index = s + 1, t.isFirst = !1, t.isLast = !1, t.progress = s * i, s === 0 ? (t.isFirst = !0, e === 1 ? (t.isLast = !0, t.nextFrame = t, t.prevFrame = t) : (t.isLast = !1, t.prevFrame = this.frames[e - 1], t.nextFrame = this.frames[s + 1])) : s === e - 1 && e > 1 ? (t.isLast = !0, t.prevFrame = this.frames[e - 2], t.nextFrame = this.frames[0]) : e > 1 && (t.prevFrame = this.frames[s - 1], t.nextFrame = this.frames[s + 1]); return this }, pause: function () { return this.paused = !0, this }, resume: function () { return this.paused = !1, this }, destroy: function () { this.manager.off && (this.manager.off(r.PAUSE_ALL, this.pause, this), this.manager.off(r.RESUME_ALL, this.resume, this)), this.manager.remove(this.key); for (let t = 0; t < this.frames.length; t++) this.frames[t].destroy(); this.frames = [], this.manager = null } }); t.exports = u }, 41138: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s, n) { void 0 === n && (n = !1), this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = s, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0, this.isKeyFrame = n }, toJSON: function () { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration, keyframe: this.isKeyFrame } }, destroy: function () { this.frame = void 0 } }); t.exports = s }, 60848: (t, e, i) => { const s = i(42099); const n = i(83419); const r = i(90330); const o = i(50792); const a = i(74943); const h = i(8443); const l = i(95540); const u = i(35154); const c = i(36383); const d = i(20283); const f = i(41836); const p = new n({ Extends: o, initialize: function (t) { o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r(), this.mixes = new r(), this.paused = !1, this.name = 'AnimationManager', t.events.once(h.BOOT, this.boot, this) }, boot: function () { this.textureManager = this.game.textures, this.game.events.once(h.DESTROY, this.destroy, this) }, addMix: function (t, e, i) { const s = this.anims; const n = this.mixes; const r = typeof t === 'string' ? t : t.key; const o = typeof e === 'string' ? e : e.key; if (s.has(r) && s.has(o)) { let a = n.get(r); a || (a = {}), a[o] = i, n.set(r, a) } return this }, removeMix: function (t, e) { const i = this.mixes; const s = typeof t === 'string' ? t : t.key; const n = i.get(s); if (n) if (e) { const r = typeof e === 'string' ? e : e.key; n.hasOwnProperty(r) && delete n[r] } else e || i.delete(s); return this }, getMix: function (t, e) { const i = this.mixes; const s = typeof t === 'string' ? t : t.key; const n = typeof e === 'string' ? e : e.key; const r = i.get(s); return r && r.hasOwnProperty(n) ? r[n] : 0 }, add: function (t, e) { return this.anims.has(t) ? (console.warn('Animation key exists: ' + t), this) : (e.key = t, this.anims.set(t, e), this.emit(a.ADD_ANIMATION, t, e), this) }, exists: function (t) { return this.anims.has(t) }, createFromAseprite: function (t, e, i) { const s = []; const n = this.game.cache.json.get(t); if (!n) return console.warn('No Aseprite data found for: ' + t), s; const r = this; const o = u(n, 'meta', null); const a = u(n, 'frames', null); o && a && u(o, 'frameTags', []).forEach(function (n) { let o = []; const h = l(n, 'name', null); const u = l(n, 'from', 0); const d = l(n, 'to', 0); const f = l(n, 'direction', 'forward'); if (h && (!e || e && e.indexOf(h) > -1)) { for (var p = 0, v = u; v <= d; v++) { const g = v.toString(); const m = a[g]; if (m) { const y = l(m, 'duration', c.MAX_SAFE_INTEGER); o.push({ key: t, frame: g, duration: y }), p += y } } f === 'reverse' && (o = o.reverse()); let x; const T = { key: h, frames: o, duration: p, yoyo: f === 'pingpong' }; i ? i.anims && (x = i.anims.create(T)) : x = r.create(T), x && s.push(x) } }); return s }, create: function (t) { const e = t.key; let i = !1; return e && ((i = this.get(e)) ? console.warn('AnimationManager key already exists: ' + e) : (i = new s(this, e, t), this.anims.set(e, i), this.emit(a.ADD_ANIMATION, e, i))), i }, fromJSON: function (t, e) { void 0 === e && (e = !1), e && this.anims.clear(), typeof t === 'string' && (t = JSON.parse(t)); const i = []; if (t.hasOwnProperty('anims') && Array.isArray(t.anims)) { for (let s = 0; s < t.anims.length; s++)i.push(this.create(t.anims[s])); t.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = t.globalTimeScale) } else t.hasOwnProperty('key') && t.type === 'frame' && i.push(this.create(t)); return i }, generateFrameNames: function (t, e) { const i = u(e, 'prefix', ''); const s = u(e, 'start', 0); const n = u(e, 'end', 0); const r = u(e, 'suffix', ''); const o = u(e, 'zeroPad', 0); const a = u(e, 'outputArray', []); let h = u(e, 'frames', !1); if (!this.textureManager.exists(t)) return console.warn('Texture "%s" not found', t), a; let l; const c = this.textureManager.get(t); if (!c) return a; if (e) for (h || (h = d(s, n)), l = 0; l < h.length; l++) { const p = i + f(h[l], o, '0', 1) + r; c.has(p) ? a.push({ key: t, frame: p }) : console.warn('Frame "%s" not found in texture "%s"', p, t) } else for (h = c.getFrameNames(), l = 0; l < h.length; l++)a.push({ key: t, frame: h[l] }); return a }, generateFrameNumbers: function (t, e) { const i = u(e, 'start', 0); let s = u(e, 'end', -1); const n = u(e, 'first', !1); const r = u(e, 'outputArray', []); let o = u(e, 'frames', !1); if (!this.textureManager.exists(t)) return console.warn('Texture "%s" not found', t), r; const a = this.textureManager.get(t); if (!a) return r; n && a.has(n) && r.push({ key: t, frame: n }), o || (s === -1 && (s = a.frameTotal - 2), o = d(i, s)); for (let h = 0; h < o.length; h++) { const l = o[h]; a.has(l) ? r.push({ key: t, frame: l }) : console.warn('Frame "%s" not found in texture "%s"', l, t) } return r }, get: function (t) { return this.anims.get(t) }, getAnimsFromTexture: function (t) { for (var e = this.textureManager.get(t).key, i = this.anims.getArray(), s = [], n = 0; n < i.length; n++) for (let r = i[n], o = r.frames, a = 0; a < o.length; a++) if (o[a].textureKey === e) { s.push(r.key); break } return s }, pauseAll: function () { return this.paused || (this.paused = !0, this.emit(a.PAUSE_ALL)), this }, play: function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)e[i].anims.play(t); return this }, staggerPlay: function (t, e, i, s) { void 0 === i && (i = 0), void 0 === s && (s = !0), Array.isArray(e) || (e = [e]); let n = e.length; s || n--; for (let r = 0; r < e.length; r++) { const o = i < 0 ? Math.abs(i) * (n - r) : i * r; e[r].anims.playAfterDelay(t, o) } return this }, remove: function (t) { const e = this.get(t); return e && (this.emit(a.REMOVE_ANIMATION, t, e), this.anims.delete(t), this.removeMix(t)), e }, resumeAll: function () { return this.paused && (this.paused = !1, this.emit(a.RESUME_ALL)), this }, toJSON: function (t) { const e = { anims: [], globalTimeScale: this.globalTimeScale }; return void 0 !== t && t !== '' ? e.anims.push(this.anims.get(t).toJSON()) : this.anims.each(function (t, i) { e.anims.push(i.toJSON()) }), e }, destroy: function () { this.anims.clear(), this.mixes.clear(), this.textureManager = null, this.game = null } }); t.exports = p }, 9674: (t, e, i) => { const s = i(42099); const n = i(30976); const r = i(83419); const o = i(90330); const a = i(74943); const h = i(95540); const l = new r({ initialize: function (t) { this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.on(a.REMOVE_ANIMATION, this.globalRemove, this), this.textureManager = this.animationManager.textureManager, this.anims = null, this.isPlaying = !1, this.hasStarted = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this.nextAnimsQueue = [], this.timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this.randomFrame = !1, this.delay = 0, this.repeat = 0, this.repeatDelay = 0, this.yoyo = !1, this.showBeforeDelay = !1, this.showOnStart = !1, this.hideOnComplete = !1, this.forward = !0, this.inReverse = !1, this.accumulator = 0, this.nextTick = 0, this.delayCounter = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue }, chain: function (t) { const e = this.parent; if (void 0 === t) return this.nextAnimsQueue.length = 0, this.nextAnim = null, e; Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; this.nextAnim ? this.nextAnimsQueue.push(s) : this.nextAnim = s } return this.parent }, getName: function () { return this.currentAnim ? this.currentAnim.key : '' }, getFrameName: function () { return this.currentFrame ? this.currentFrame.textureFrame : '' }, load: function (t) { this.isPlaying && this.stop(); const e = this.animationManager; const i = typeof t === 'string' ? t : h(t, 'key', null); const s = this.exists(i) ? this.get(i) : e.get(i); if (s) { this.currentAnim = s; const r = s.getTotalFrames(); const o = h(t, 'frameRate', s.frameRate); const a = h(t, 'duration', s.duration); s.calculateDuration(this, r, a, o), this.delay = h(t, 'delay', s.delay), this.repeat = h(t, 'repeat', s.repeat), this.repeatDelay = h(t, 'repeatDelay', s.repeatDelay), this.yoyo = h(t, 'yoyo', s.yoyo), this.showBeforeDelay = h(t, 'showBeforeDelay', s.showBeforeDelay), this.showOnStart = h(t, 'showOnStart', s.showOnStart), this.hideOnComplete = h(t, 'hideOnComplete', s.hideOnComplete), this.skipMissedFrames = h(t, 'skipMissedFrames', s.skipMissedFrames), this.randomFrame = h(t, 'randomFrame', s.randomFrame), this.timeScale = h(t, 'timeScale', this.timeScale); let l = h(t, 'startFrame', 0); l > r && (l = 0), this.randomFrame && (l = n(0, r - 1)); let u = s.frames[l]; l !== 0 || this.forward || (u = s.getLastFrame()), this.currentFrame = u } else console.warn('Missing animation: ' + i); return this.parent }, pause: function (t) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.setCurrentFrame(t), this.parent }, resume: function (t) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.setCurrentFrame(t), this.parent }, playAfterDelay: function (t, e) { if (this.isPlaying) { const i = this.nextAnim; const s = this.nextAnimsQueue; i && s.unshift(i), this.nextAnim = t, this._pendingStop = 1, this._pendingStopValue = e } else this.delayCounter = e, this.play(t, !0); return this.parent }, playAfterRepeat: function (t, e) { if (void 0 === e && (e = 1), this.isPlaying) { const i = this.nextAnim; const s = this.nextAnimsQueue; i && s.unshift(i), this.repeatCounter !== -1 && e > this.repeatCounter && (e = this.repeatCounter), this.nextAnim = t, this._pendingStop = 2, this._pendingStopValue = e } else this.play(t); return this.parent }, play: function (t, e) { void 0 === e && (e = !1); const i = this.currentAnim; const s = this.parent; const n = typeof t === 'string' ? t : t.key; if (e && this.isPlaying && i.key === n) return s; if (i && this.isPlaying) { const r = this.animationManager.getMix(i.key, t); if (r > 0) return this.playAfterDelay(t, r) } return this.forward = !0, this.inReverse = !1, this._paused = !1, this._wasPlaying = !0, this.startAnimation(t) }, playReverse: function (t, e) { void 0 === e && (e = !1); const i = typeof t === 'string' ? t : t.key; return e && this.isPlaying && this.currentAnim.key === i ? this.parent : (this.forward = !1, this.inReverse = !0, this._paused = !1, this._wasPlaying = !0, this.startAnimation(t)) }, startAnimation: function (t) { this.load(t); const e = this.currentAnim; const i = this.parent; return e ? (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat, e.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !1, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.delayCounter += this.delay, this.delayCounter === 0 ? this.handleStart() : this.showBeforeDelay && this.setCurrentFrame(this.currentFrame), i) : i }, handleStart: function () { this.showOnStart && this.parent.setVisible(!0), this.setCurrentFrame(this.currentFrame), this.hasStarted = !0, this.emitEvents(a.ANIMATION_START) }, handleRepeat: function () { this.pendingRepeat = !1, this.emitEvents(a.ANIMATION_REPEAT) }, handleStop: function () { this._pendingStop = 0, this.isPlaying = !1, this.emitEvents(a.ANIMATION_STOP) }, handleComplete: function () { this._pendingStop = 0, this.isPlaying = !1, this.hideOnComplete && this.parent.setVisible(!1), this.emitEvents(a.ANIMATION_COMPLETE, a.ANIMATION_COMPLETE_KEY) }, emitEvents: function (t, e) { const i = this.currentAnim; if (i) { const s = this.currentFrame; const n = this.parent; const r = s.textureFrame; n.emit(t, i, s, n, r), e && n.emit(e + i.key, i, s, n, r) } }, reverse: function () { return this.isPlaying && (this.inReverse = !this.inReverse, this.forward = !this.forward), this.parent }, getProgress: function () { const t = this.currentFrame; if (!t) return 0; let e = t.progress; return this.inReverse && (e *= -1), e }, setProgress: function (t) { return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent }, setRepeat: function (t) { return this.repeatCounter = t === -1 ? Number.MAX_VALUE : t, this.parent }, globalRemove: function (t, e) { void 0 === e && (e = this.currentAnim), this.isPlaying && e.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])) }, restart: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); const i = this.currentAnim; const s = this.parent; return i ? (e && (this.repeatCounter = this.repeat === -1 ? Number.MAX_VALUE : this.repeat), i.getFirstTick(this), this.emitEvents(a.ANIMATION_RESTART), this.isPlaying = !0, this.pendingRepeat = !1, this.hasStarted = !t, this._pendingStop = 0, this._pendingStopValue = 0, this._paused = !1, this.setCurrentFrame(i.frames[0]), this.parent) : s }, complete: function () { if (this._pendingStop = 0, this.isPlaying = !1, this.currentAnim && this.handleComplete(), this.nextAnim) { const t = this.nextAnim; this.nextAnim = this.nextAnimsQueue.length > 0 ? this.nextAnimsQueue.shift() : null, this.play(t) } return this.parent }, stop: function () { if (this._pendingStop = 0, this.isPlaying = !1, this.delayCounter = 0, this.currentAnim && this.handleStop(), this.nextAnim) { const t = this.nextAnim; this.nextAnim = this.nextAnimsQueue.shift(), this.play(t) } return this.parent }, stopAfterDelay: function (t) { return this._pendingStop = 1, this._pendingStopValue = t, this.parent }, stopAfterRepeat: function (t) { return void 0 === t && (t = 1), this.repeatCounter !== -1 && t > this.repeatCounter && (t = this.repeatCounter), this._pendingStop = 2, this._pendingStopValue = t, this.parent }, stopOnFrame: function (t) { return this._pendingStop = 3, this._pendingStopValue = t, this.parent }, getTotalFrames: function () { return this.currentAnim ? this.currentAnim.getTotalFrames() : 0 }, update: function (t, e) { const i = this.currentAnim; if (this.isPlaying && i && !i.paused) { if (this.accumulator += e * this.timeScale * this.animationManager.globalTimeScale, this._pendingStop === 1 && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.stop(); if (this.hasStarted) { if (this.accumulator >= this.nextTick && (this.forward ? i.nextFrame(this) : i.previousFrame(this), this.isPlaying && this._pendingStop === 0 && this.skipMissedFrames && this.accumulator > this.nextTick)) { let s = 0; do { this.forward ? i.nextFrame(this) : i.previousFrame(this), s++ } while (this.isPlaying && this.accumulator > this.nextTick && s < 60) } } else this.accumulator >= this.delayCounter && (this.accumulator -= this.delayCounter, this.handleStart()) } }, setCurrentFrame: function (t) { const e = this.parent; return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.isCropped && e.frame.updateCropUVs(e._crop, e.flipX, e.flipY), t.setAlpha && (e.alpha = t.alpha), e.setSizeToFrame(), e._originComponent && (t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin()), this.isPlaying && this.hasStarted && (this.emitEvents(a.ANIMATION_UPDATE), this._pendingStop === 3 && this._pendingStopValue === t && this.stop()), e }, nextFrame: function () { return this.currentAnim && this.currentAnim.nextFrame(this), this.parent }, previousFrame: function () { return this.currentAnim && this.currentAnim.previousFrame(this), this.parent }, get: function (t) { return this.anims ? this.anims.get(t) : null }, exists: function (t) { return !!this.anims && this.anims.has(t) }, create: function (t) { const e = t.key; let i = !1; return e && ((i = this.get(e)) ? console.warn('Animation key already exists: ' + e) : (i = new s(this, e, t), this.anims || (this.anims = new o()), this.anims.set(e, i))), i }, createFromAseprite: function (t, e) { return this.animationManager.createFromAseprite(t, e, this.parent) }, generateFrameNames: function (t, e) { return this.animationManager.generateFrameNames(t, e) }, generateFrameNumbers: function (t, e) { return this.animationManager.generateFrameNumbers(t, e) }, remove: function (t) { const e = this.get(t); return e && (this.currentAnim === e && this.stop(), this.anims.delete(t)), e }, destroy: function () { this.animationManager.off(a.REMOVE_ANIMATION, this.globalRemove, this), this.anims && this.anims.clear(), this.animationManager = null, this.parent = null, this.nextAnim = null, this.nextAnimsQueue.length = 0, this.currentAnim = null, this.currentFrame = null }, isPaused: { get: function () { return this._paused } } }); t.exports = l }, 57090: t => { t.exports = 'add' }, 25312: t => { t.exports = 'animationcomplete' }, 89580: t => { t.exports = 'animationcomplete-' }, 52860: t => { t.exports = 'animationrepeat' }, 63850: t => { t.exports = 'animationrestart' }, 99085: t => { t.exports = 'animationstart' }, 28087: t => { t.exports = 'animationstop' }, 1794: t => { t.exports = 'animationupdate' }, 52562: t => { t.exports = 'pauseall' }, 57953: t => { t.exports = 'remove' }, 68339: t => { t.exports = 'resumeall' }, 74943: (t, e, i) => { t.exports = { ADD_ANIMATION: i(57090), ANIMATION_COMPLETE: i(25312), ANIMATION_COMPLETE_KEY: i(89580), ANIMATION_REPEAT: i(52860), ANIMATION_RESTART: i(63850), ANIMATION_START: i(99085), ANIMATION_STOP: i(28087), ANIMATION_UPDATE: i(1794), PAUSE_ALL: i(52562), REMOVE_ANIMATION: i(57953), RESUME_ALL: i(68339) } }, 60421: (t, e, i) => { t.exports = { Animation: i(42099), AnimationFrame: i(41138), AnimationManager: i(60848), AnimationState: i(9674), Events: i(74943) } }, 2161: (t, e, i) => { const s = i(83419); const n = i(90330); const r = i(50792); const o = i(24736); const a = new s({ initialize: function () { this.entries = new n(), this.events = new r() }, add: function (t, e) { return this.entries.set(t, e), this.events.emit(o.ADD, this, t, e), this }, has: function (t) { return this.entries.has(t) }, exists: function (t) { return this.entries.has(t) }, get: function (t) { return this.entries.get(t) }, remove: function (t) { const e = this.get(t); return e && (this.entries.delete(t), this.events.emit(o.REMOVE, this, t, e.data)), this }, getKeys: function () { return this.entries.keys() }, destroy: function () { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null } }); t.exports = a }, 24047: (t, e, i) => { const s = i(2161); const n = i(83419); const r = i(8443); const o = new n({ initialize: function (t) { this.game = t, this.binary = new s(), this.bitmapFont = new s(), this.json = new s(), this.physics = new s(), this.shader = new s(), this.audio = new s(), this.video = new s(), this.text = new s(), this.html = new s(), this.obj = new s(), this.tilemap = new s(), this.xml = new s(), this.custom = {}, this.game.events.once(r.DESTROY, this.destroy, this) }, addCustom: function (t) { return this.custom.hasOwnProperty(t) || (this.custom[t] = new s()), this.custom[t] }, destroy: function () { for (let t = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'video', 'text', 'html', 'obj', 'tilemap', 'xml'], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null; for (const i in this.custom) this.custom[i].destroy(); this.custom = null, this.game = null } }); t.exports = o }, 51464: t => { t.exports = 'add' }, 59261: t => { t.exports = 'remove' }, 24736: (t, e, i) => { t.exports = { ADD: i(51464), REMOVE: i(59261) } }, 83388: (t, e, i) => { t.exports = { BaseCache: i(2161), CacheManager: i(24047), Events: i(24736) } }, 71911: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(39506); const o = i(50792); const a = i(19715); const h = i(87841); const l = i(61340); const u = i(80333); const c = i(26099); const d = new s({ Extends: o, Mixins: [n.AlphaSingle, n.Visible], initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), o.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = '', this.roundPixels = !1, this.useBounds = !1, this.worldView = new h(), this.dirty = !0, this._x = t, this._y = e, this._width = i, this._height = s, this._bounds = new h(), this._scrollX = 0, this._scrollY = 0, this._zoomX = 1, this._zoomY = 1, this._rotation = 0, this.matrix = new l(), this.transparent = !0, this.backgroundColor = u('rgba(0,0,0,0)'), this.disableCull = !1, this.culledObjects = [], this.midPoint = new c(i / 2, s / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = !1, this.mask = null, this._maskCamera = null, this.renderList = [], this.isSceneCamera = !0 }, addToRenderList: function (t) { this.renderList.push(t) }, setOrigin: function (t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this }, getScroll: function (t, e, i) { void 0 === i && (i = new c()); const s = 0.5 * this.width; const n = 0.5 * this.height; return i.x = t - s, i.y = e - n, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(i.y)), i }, centerOnX: function (t) { const e = 0.5 * this.width; return this.midPoint.x = t, this.scrollX = t - e, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this }, centerOnY: function (t) { const e = 0.5 * this.height; return this.midPoint.y = t, this.scrollY = t - e, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this }, centerOn: function (t, e) { return this.centerOnX(t), this.centerOnY(e), this }, centerToBounds: function () { if (this.useBounds) { const t = this._bounds; const e = 0.5 * this.width; const i = 0.5 * this.height; this.midPoint.set(t.centerX, t.centerY), this.scrollX = t.centerX - e, this.scrollY = t.centerY - i } return this }, centerToSize: function () { return this.scrollX = 0.5 * this.width, this.scrollY = 0.5 * this.height, this }, cull: function (t) { if (this.disableCull) return t; const e = this.matrix.matrix; const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; let o = i * r - s * n; if (!o) return t; const a = e[4]; const h = e[5]; const l = this.scrollX; const u = this.scrollY; const c = this.width; const d = this.height; const f = this.y; const p = f + d; const v = this.x; const g = v + c; const m = this.culledObjects; const y = t.length; o = 1 / o, m.length = 0; for (let x = 0; x < y; ++x) { const T = t[x]; if (T.hasOwnProperty('width') && !T.parentContainer) { const w = T.width; const b = T.height; const S = T.x - l * T.scrollFactorX - w * T.originX; const E = T.y - u * T.scrollFactorY - b * T.originY; (S + w) * i + (E + b) * n + a > v && S * i + E * n + a < g && (S + w) * s + (E + b) * r + h > f && S * s + E * r + h < p && m.push(T) } else m.push(T) } return m }, getWorldPoint: function (t, e, i) { void 0 === i && (i = new c()); const s = this.matrix.matrix; const n = s[0]; const r = s[1]; const o = s[2]; const a = s[3]; const h = s[4]; const l = s[5]; let u = n * a - r * o; if (!u) return i.x = t, i.y = e, i; const d = a * (u = 1 / u); const f = -r * u; const p = -o * u; const v = n * u; const g = (o * l - a * h) * u; const m = (r * h - n * l) * u; const y = Math.cos(this.rotation); const x = Math.sin(this.rotation); const T = this.zoomX; const w = this.zoomY; const b = this.scrollX; const S = this.scrollY; const E = t + (b * y - S * x) * T; const A = e + (b * x + S * y) * w; return i.x = E * d + A * p + g, i.y = E * f + A * v + m, i }, ignore: function (t) { const e = this.id; Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; Array.isArray(s) ? this.ignore(s) : s.isParent ? this.ignore(s.getChildren()) : s.cameraFilter |= e } return this }, preRender: function () { this.renderList.length = 0; const t = this.width; const e = this.height; const i = 0.5 * t; const s = 0.5 * e; const n = this.zoomX; const r = this.zoomY; const o = this.matrix; const a = t * this.originX; const h = e * this.originY; let l = this.scrollX; let u = this.scrollY; this.useBounds && (l = this.clampX(l), u = this.clampY(u)), this.scrollX = l, this.scrollY = u; const c = l + i; const d = u + s; this.midPoint.set(c, d); const f = t / n; const p = e / r; this.worldView.setTo(c - f / 2, d - p / 2, f, p), o.applyITRS(this.x + a, this.y + h, this.rotation, n, r), o.translate(-a, -h) }, clampX: function (t) { const e = this._bounds; const i = this.displayWidth; const s = e.x + (i - this.width) / 2; const n = Math.max(s, s + e.width - i); return t < s ? t = s : t > n && (t = n), t }, clampY: function (t) { const e = this._bounds; const i = this.displayHeight; const s = e.y + (i - this.height) / 2; const n = Math.max(s, s + e.height - i); return t < s ? t = s : t > n && (t = n), t }, removeBounds: function () { return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this }, setAngle: function (t) { return void 0 === t && (t = 0), this.rotation = r(t), this }, setBackgroundColor: function (t) { return void 0 === t && (t = 'rgba(0,0,0,0)'), this.backgroundColor = u(t), this.transparent = this.backgroundColor.alpha === 0, this }, setBounds: function (t, e, i, s, n) { return void 0 === n && (n = !1), this._bounds.setTo(t, e, i, s), this.dirty = !0, this.useBounds = !0, n ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this }, getBounds: function (t) { void 0 === t && (t = new h()); const e = this._bounds; return t.setTo(e.x, e.y, e.width, e.height), t }, setName: function (t) { return void 0 === t && (t = ''), this.name = t, this }, setPosition: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this }, setRotation: function (t) { return void 0 === t && (t = 0), this.rotation = t, this }, setRoundPixels: function (t) { return this.roundPixels = t, this }, setScene: function (t, e) { void 0 === e && (e = !0), this.scene && this._customViewport && this.sceneManager.customViewports--, this.scene = t, this.isSceneCamera = e; const i = t.sys; return this.sceneManager = i.game.scene, this.scaleManager = i.scale, this.cameraManager = i.cameras, this.updateSystem(), this }, setScroll: function (t, e) { return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this }, setSize: function (t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this }, setViewport: function (t, e, i, s) { return this.x = t, this.y = e, this.width = i, this.height = s, this }, setZoom: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), t === 0 && (t = 0.001), e === 0 && (e = 0.001), this.zoomX = t, this.zoomY = e, this }, setMask: function (t, e) { return void 0 === e && (e = !0), this.mask = t, this._maskCamera = e ? this.cameraManager.default : this, this }, clearMask: function (t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this }, toJSON: function () { const t = { name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba }; return this.useBounds && (t.bounds = { x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height }), t }, update: function () { }, setIsSceneCamera: function (t) { return this.isSceneCamera = t, this }, updateSystem: function () { if (this.scaleManager && this.isSceneCamera) { const t = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height; const e = this.sceneManager; t && !this._customViewport ? e.customViewports++ : !t && this._customViewport && e.customViewports--, this.dirty = !0, this._customViewport = t } }, destroy: function () { this.emit(a.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this.renderList = [], this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null }, x: { get: function () { return this._x }, set: function (t) { this._x = t, this.updateSystem() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.updateSystem() } }, width: { get: function () { return this._width }, set: function (t) { this._width = t, this.updateSystem() } }, height: { get: function () { return this._height }, set: function (t) { this._height = t, this.updateSystem() } }, scrollX: { get: function () { return this._scrollX }, set: function (t) { t !== this._scrollX && (this._scrollX = t, this.dirty = !0) } }, scrollY: { get: function () { return this._scrollY }, set: function (t) { t !== this._scrollY && (this._scrollY = t, this.dirty = !0) } }, zoom: { get: function () { return (this._zoomX + this._zoomY) / 2 }, set: function (t) { this._zoomX = t, this._zoomY = t, this.dirty = !0 } }, zoomX: { get: function () { return this._zoomX }, set: function (t) { this._zoomX = t, this.dirty = !0 } }, zoomY: { get: function () { return this._zoomY }, set: function (t) { this._zoomY = t, this.dirty = !0 } }, rotation: { get: function () { return this._rotation }, set: function (t) { this._rotation = t, this.dirty = !0 } }, centerX: { get: function () { return this.x + 0.5 * this.width } }, centerY: { get: function () { return this.y + 0.5 * this.height } }, displayWidth: { get: function () { return this.width / this.zoomX } }, displayHeight: { get: function () { return this.height / this.zoomY } } }); t.exports = d }, 38058: (t, e, i) => { const s = i(71911); const n = i(67502); const r = i(45319); const o = i(83419); const a = i(31401); const h = i(20052); const l = i(19715); const u = i(28915); const c = i(87841); const d = i(26099); const f = new o({ Extends: s, Mixins: [a.PostPipeline], initialize: function (t, e, i, n) { s.call(this, t, e, i, n), this.initPostPipeline(), this.inputEnabled = !0, this.fadeEffect = new h.Fade(this), this.flashEffect = new h.Flash(this), this.shakeEffect = new h.Shake(this), this.panEffect = new h.Pan(this), this.rotateToEffect = new h.RotateTo(this), this.zoomEffect = new h.Zoom(this), this.lerp = new d(1, 1), this.followOffset = new d(), this.deadzone = null, this._follow = null }, setDeadzone: function (t, e) { if (void 0 === t) this.deadzone = null; else { if (this.deadzone ? (this.deadzone.width = t, this.deadzone.height = e) : this.deadzone = new c(0, 0, t, e), this._follow) { const i = this.width / 2; const s = this.height / 2; const r = this._follow.x - this.followOffset.x; const o = this._follow.y - this.followOffset.y; this.midPoint.set(r, o), this.scrollX = r - i, this.scrollY = o - s } n(this.deadzone, this.midPoint.x, this.midPoint.y) } return this }, fadeIn: function (t, e, i, s, n, r) { return this.fadeEffect.start(!1, t, e, i, s, !0, n, r) }, fadeOut: function (t, e, i, s, n, r) { return this.fadeEffect.start(!0, t, e, i, s, !0, n, r) }, fadeFrom: function (t, e, i, s, n, r, o) { return this.fadeEffect.start(!1, t, e, i, s, n, r, o) }, fade: function (t, e, i, s, n, r, o) { return this.fadeEffect.start(!0, t, e, i, s, n, r, o) }, flash: function (t, e, i, s, n, r, o) { return this.flashEffect.start(t, e, i, s, n, r, o) }, shake: function (t, e, i, s, n) { return this.shakeEffect.start(t, e, i, s, n) }, pan: function (t, e, i, s, n, r, o) { return this.panEffect.start(t, e, i, s, n, r, o) }, rotateTo: function (t, e, i, s, n, r, o) { return this.rotateToEffect.start(t, e, i, s, n, r, o) }, zoomTo: function (t, e, i, s, n, r) { return this.zoomEffect.start(t, e, i, s, n, r) }, preRender: function () { this.renderList.length = 0; const t = this.width; const e = this.height; const i = 0.5 * t; const s = 0.5 * e; const r = this.zoom; const o = this.matrix; const a = t * this.originX; const h = e * this.originY; const c = this._follow; const d = this.deadzone; let f = this.scrollX; let p = this.scrollY; d && n(d, this.midPoint.x, this.midPoint.y); let v = !1; if (c && !this.panEffect.isRunning) { const g = this.lerp; const m = c.x - this.followOffset.x; const y = c.y - this.followOffset.y; d ? (m < d.x ? f = u(f, f - (d.x - m), g.x) : m > d.right && (f = u(f, f + (m - d.right), g.x)), y < d.y ? p = u(p, p - (d.y - y), g.y) : y > d.bottom && (p = u(p, p + (y - d.bottom), g.y))) : (f = u(f, m - a, g.x), p = u(p, y - h, g.y)), v = !0 } this.useBounds && (f = this.clampX(f), p = this.clampY(p)), this.scrollX = f, this.scrollY = p; const x = f + i; const T = p + s; this.midPoint.set(x, T); const w = t / r; const b = e / r; const S = Math.floor(x - w / 2); const E = Math.floor(T - b / 2); this.worldView.setTo(S, E, w, b), o.applyITRS(Math.floor(this.x + a), Math.floor(this.y + h), this.rotation, r, r), o.translate(-a, -h), this.shakeEffect.preRender(), v && this.emit(l.FOLLOW_UPDATE, this, c) }, setLerp: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this }, setFollowOffset: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this }, startFollow: function (t, e, i, s, n, o) { void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === s && (s = i), void 0 === n && (n = 0), void 0 === o && (o = n), this._follow = t, this.roundPixels = e, i = r(i, 0, 1), s = r(s, 0, 1), this.lerp.set(i, s), this.followOffset.set(n, o); const a = this.width / 2; const h = this.height / 2; const l = t.x - n; const u = t.y - o; return this.midPoint.set(l, u), this.scrollX = l - a, this.scrollY = u - h, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this }, stopFollow: function () { return this._follow = null, this }, resetFX: function () { return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this }, update: function (t, e) { this.visible && (this.rotateToEffect.update(t, e), this.panEffect.update(t, e), this.zoomEffect.update(t, e), this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e)) }, destroy: function () { this.resetFX(), s.prototype.destroy.call(this), this._follow = null, this.deadzone = null } }); t.exports = f }, 32743: (t, e, i) => { const s = i(38058); const n = i(83419); const r = i(95540); const o = i(37277); const a = i(37303); const h = i(97480); const l = i(44594); const u = new n({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, t.sys.events.once(l.BOOT, this.boot, this), t.sys.events.on(l.START, this.start, this) }, boot: function () { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new s(0, 0, t.scale.width, t.scale.height).setScene(this.scene), t.game.scale.on(h.RESIZE, this.onResize, this), this.systems.events.once(l.DESTROY, this.destroy, this) }, start: function () { if (!this.main) { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0] } const e = this.systems.events; e.on(l.UPDATE, this.update, this), e.once(l.SHUTDOWN, this.shutdown, this) }, add: function (t, e, i, n, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), void 0 === r && (r = !1), void 0 === o && (o = ''); const a = new s(t, e, i, n); return a.setName(o), a.setScene(this.scene), a.setRoundPixels(this.roundPixels), a.id = this.getNextID(), this.cameras.push(a), r && (this.main = a), a }, addExisting: function (t, e) { return void 0 === e && (e = !1), this.cameras.indexOf(t) === -1 ? (t.id = this.getNextID(), t.setRoundPixels(this.roundPixels), this.cameras.push(t), e && (this.main = t), t) : null }, getNextID: function () { for (let t = this.cameras, e = 1, i = 0; i < 32; i++) { for (var s = !1, n = 0; n < t.length; n++) { const r = t[n]; r && r.id === e && (s = !0) } if (!s) return e; e <<= 1 } return 0 }, getTotal: function (t) { void 0 === t && (t = !1); for (var e = 0, i = this.cameras, s = 0; s < i.length; s++) { const n = i[s]; (!t || t && n.visible) && e++ } return e }, fromJSON: function (t) { Array.isArray(t) || (t = [t]); for (let e = this.scene.sys.scale.width, i = this.scene.sys.scale.height, s = 0; s < t.length; s++) { const n = t[s]; const o = r(n, 'x', 0); const a = r(n, 'y', 0); const h = r(n, 'width', e); const l = r(n, 'height', i); const u = this.add(o, a, h, l); u.name = r(n, 'name', ''), u.zoom = r(n, 'zoom', 1), u.rotation = r(n, 'rotation', 0), u.scrollX = r(n, 'scrollX', 0), u.scrollY = r(n, 'scrollY', 0), u.roundPixels = r(n, 'roundPixels', !1), u.visible = r(n, 'visible', !0); const c = r(n, 'backgroundColor', !1); c && u.setBackgroundColor(c); const d = r(n, 'bounds', null); if (d) { const f = r(d, 'x', 0); const p = r(d, 'y', 0); const v = r(d, 'width', e); const g = r(d, 'height', i); u.setBounds(f, p, v, g) } } return this }, getCamera: function (t) { for (let e = this.cameras, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]; return null }, getCamerasBelowPointer: function (t) { for (var e = this.cameras, i = t.x, s = t.y, n = [], r = 0; r < e.length; r++) { const o = e[r]; o.visible && o.inputEnabled && a(o, i, s) && n.unshift(o) } return n }, remove: function (t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (var i = 0, s = this.cameras, n = 0; n < t.length; n++) { const r = s.indexOf(t[n]); r !== -1 && (e ? s[r].destroy() : s[r].renderList = [], s.splice(r, 1), i++) } return !this.main && s[0] && (this.main = s[0]), i }, render: function (t, e) { for (let i = this.scene, s = this.cameras, n = 0; n < s.length; n++) { const r = s[n]; if (r.visible && r.alpha > 0) { r.preRender(); const o = this.getVisibleChildren(e.getChildren(), r); t.render(i, o, r) } } }, getVisibleChildren: function (t, e) { return t.filter(function (t) { return t.willRender(e) }) }, resetAll: function () { for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); return this.cameras = [], this.main = this.add(), this.main }, update: function (t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].update(t, e) }, onResize: function (t, e, i, s, n) { for (let r = 0; r < this.cameras.length; r++) { const o = this.cameras[r]; o._x === 0 && o._y === 0 && o._width === s && o._height === n && o.setSize(e.width, e.height) } }, resize: function (t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(t, e) }, shutdown: function () { this.main = void 0; for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); this.cameras = []; const e = this.systems.events; e.off(l.UPDATE, this.update, this), e.off(l.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.default.destroy(), this.systems.events.off(l.START, this.start, this), this.systems.events.off(l.DESTROY, this.destroy, this), this.systems.game.scale.off(h.RESIZE, this.onResize, this), this.scene = null, this.systems = null } }); o.register('CameraManager', u, 'cameras'), t.exports = u }, 5020: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(19715); const o = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (t, e, i, s, n, o, a, h) { if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), !o && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = s, this.blue = n, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h; const l = t ? r.FADE_OUT_START : r.FADE_IN_START; return this.camera.emit(l, this.camera, this, e, i, s, n), this.camera }, update: function (t, e) { this.isRunning && (this._elapsed += e, this.progress = s(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete())) }, postRenderCanvas: function (t) { if (!this.isRunning && !this.isComplete) return !1; const e = this.camera; return t.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')', t.fillRect(e.x, e.y, e.width, e.height), !0 }, postRenderWebGL: function (t, e) { if (!this.isRunning && !this.isComplete) return !1; const i = this.camera; const s = this.red / 255; const n = this.green / 255; const r = this.blue / 255; return t.drawFillRect(i.x, i.y, i.width, i.height, e(r, n, s, 1), this.alpha), !0 }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const t = this.direction ? r.FADE_OUT_COMPLETE : r.FADE_IN_COMPLETE; this.camera.emit(t, this.camera, this) }, reset: function () { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); t.exports = o }, 10662: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(19715); const o = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 1, this.progress = 0, this._elapsed = 0, this._alpha, this._onUpdate, this._onUpdateScope }, start: function (t, e, i, s, n, o, a) { return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === s && (s = 255), void 0 === n && (n = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !n && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = s, this._alpha = this.alpha, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a, this.camera.emit(r.FLASH_START, this.camera, this, t, e, i, s)), this.camera }, update: function (t, e) { this.isRunning && (this._elapsed += e, this.progress = s(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this._alpha * (1 - this.progress) : this.effectComplete()) }, postRenderCanvas: function (t) { if (!this.isRunning) return !1; const e = this.camera; return t.fillStyle = 'rgba(' + this.red + ',' + this.green + ',' + this.blue + ',' + this.alpha + ')', t.fillRect(e.x, e.y, e.width, e.height), !0 }, postRenderWebGL: function (t, e) { if (!this.isRunning) return !1; const i = this.camera; const s = this.red / 255; const n = this.green / 255; const r = this.blue / 255; return t.drawFillRect(i.x, i.y, i.width, i.height, e(r, n, s, 1), this.alpha), !0 }, effectComplete: function () { this.alpha = this._alpha, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.FLASH_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); t.exports = o }, 20359: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(62640); const o = i(19715); const a = i(26099); const h = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = new a(), this.current = new a(), this.destination = new a(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (t, e, i, s, n, a, h) { void 0 === i && (i = 1e3), void 0 === s && (s = r.Linear), void 0 === n && (n = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene); const l = this.camera; return !n && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source.set(l.scrollX, l.scrollY), this.destination.set(t, e), l.getScroll(t, e, this.current), typeof s === 'string' && r.hasOwnProperty(s) ? this.ease = r[s] : typeof s === 'function' && (this.ease = s), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.camera.emit(o.PAN_START, this.camera, this, i, t, e)), l }, update: function (t, e) { if (this.isRunning) { this._elapsed += e; const i = s(this._elapsed / this.duration, 0, 1); this.progress = i; const n = this.camera; if (this._elapsed < this.duration) { const r = this.ease(i); n.getScroll(this.destination.x, this.destination.y, this.current); const o = this.source.x + (this.current.x - this.source.x) * r; const a = this.source.y + (this.current.y - this.source.y) * r; n.setScroll(o, a), this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, o, a) } else n.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, n.scrollX, n.scrollY), this.effectComplete() } }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.PAN_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.source = null, this.destination = null } }); t.exports = h }, 34208: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(19715); const o = i(62640); const a = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1 }, start: function (t, e, i, s, n, a, h) { void 0 === i && (i = 1e3), void 0 === s && (s = o.Linear), void 0 === n && (n = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), void 0 === e && (e = !1), this.shortestPath = e; let l = t; t < 0 ? (l = -1 * t, this.clockwise = !1) : this.clockwise = !0; const u = 360 * Math.PI / 180; l -= Math.floor(l / u) * u; const c = this.camera; if (!n && this.isRunning) return c; if (this.isRunning = !0, this.duration = i, this.progress = 0, this.source = c.rotation, this.destination = l, typeof s === 'string' && o.hasOwnProperty(s) ? this.ease = o[s] : typeof s === 'function' && (this.ease = s), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.shortestPath) { let d = 0; let f = 0; (d = this.destination > this.source ? Math.abs(this.destination - this.source) : Math.abs(this.destination + u) - this.source) < (f = this.source > this.destination ? Math.abs(this.source - this.destination) : Math.abs(this.source + u) - this.destination) ? this.clockwise = !0 : d > f && (this.clockwise = !1) } return this.camera.emit(r.ROTATE_START, this.camera, this, i, l), c }, update: function (t, e) { if (this.isRunning) { this._elapsed += e; const i = s(this._elapsed / this.duration, 0, 1); this.progress = i; const n = this.camera; if (this._elapsed < this.duration) { const r = this.ease(i); this.current = n.rotation; let o = 0; const a = 360 * Math.PI / 180; let h = this.destination; let l = this.current; !1 === this.clockwise && (h = this.current, l = this.destination), o = h >= l ? Math.abs(h - l) : Math.abs(h + a) - l; let u = 0; u = this.clockwise ? n.rotation + o * r : n.rotation - o * r, n.rotation = u, this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, u) } else n.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, n, i, this.destination), this.effectComplete() } }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.ROTATE_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.source = null, this.destination = null } }); t.exports = a }, 30330: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(19715); const o = i(26099); const a = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new o(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope }, start: function (t, e, i, s, n) { return void 0 === t && (t = 100), void 0 === e && (e = 0.05), void 0 === i && (i = !1), void 0 === s && (s = null), void 0 === n && (n = this.camera.scene), !i && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, typeof e === 'number' ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = s, this._onUpdateScope = n, this.camera.emit(r.SHAKE_START, this.camera, this, t, e)), this.camera }, preRender: function () { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY) }, update: function (t, e) { if (this.isRunning) if (this._elapsed += e, this.progress = s(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration) { const i = this.intensity; const n = this.camera.width; const r = this.camera.height; const o = this.camera.zoom; this._offsetX = (Math.random() * i.x * n * 2 - i.x * n) * o, this._offsetY = (Math.random() * i.y * r * 2 - i.y * r) * o, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY)) } else this.effectComplete() }, effectComplete: function () { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.SHAKE_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null, this.intensity = null } }); t.exports = a }, 45641: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(62640); const o = i(19715); const a = new n({ initialize: function (t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope }, start: function (t, e, i, s, n, a) { void 0 === e && (e = 1e3), void 0 === i && (i = r.Linear), void 0 === s && (s = !1), void 0 === n && (n = null), void 0 === a && (a = this.camera.scene); const h = this.camera; return !s && this.isRunning || (this.isRunning = !0, this.duration = e, this.progress = 0, this.source = h.zoom, this.destination = t, typeof i === 'string' && r.hasOwnProperty(i) ? this.ease = r[i] : typeof i === 'function' && (this.ease = i), this._elapsed = 0, this._onUpdate = n, this._onUpdateScope = a, this.camera.emit(o.ZOOM_START, this.camera, this, e, t)), h }, update: function (t, e) { this.isRunning && (this._elapsed += e, this.progress = s(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete())) }, effectComplete: function () { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.ZOOM_COMPLETE, this.camera, this) }, reset: function () { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null }, destroy: function () { this.reset(), this.camera = null } }); t.exports = a }, 20052: (t, e, i) => { t.exports = { Fade: i(5020), Flash: i(10662), Pan: i(20359), Shake: i(30330), RotateTo: i(34208), Zoom: i(45641) } }, 16438: t => { t.exports = 'cameradestroy' }, 32726: t => { t.exports = 'camerafadeincomplete' }, 87807: t => { t.exports = 'camerafadeinstart' }, 45917: t => { t.exports = 'camerafadeoutcomplete' }, 95666: t => { t.exports = 'camerafadeoutstart' }, 47056: t => { t.exports = 'cameraflashcomplete' }, 91261: t => { t.exports = 'cameraflashstart' }, 45047: t => { t.exports = 'followupdate' }, 81927: t => { t.exports = 'camerapancomplete' }, 74264: t => { t.exports = 'camerapanstart' }, 54419: t => { t.exports = 'postrender' }, 79330: t => { t.exports = 'prerender' }, 93183: t => { t.exports = 'camerarotatecomplete' }, 80112: t => { t.exports = 'camerarotatestart' }, 62252: t => { t.exports = 'camerashakecomplete' }, 86017: t => { t.exports = 'camerashakestart' }, 539: t => { t.exports = 'camerazoomcomplete' }, 51892: t => { t.exports = 'camerazoomstart' }, 19715: (t, e, i) => { t.exports = { DESTROY: i(16438), FADE_IN_COMPLETE: i(32726), FADE_IN_START: i(87807), FADE_OUT_COMPLETE: i(45917), FADE_OUT_START: i(95666), FLASH_COMPLETE: i(47056), FLASH_START: i(91261), FOLLOW_UPDATE: i(45047), PAN_COMPLETE: i(81927), PAN_START: i(74264), POST_RENDER: i(54419), PRE_RENDER: i(79330), ROTATE_COMPLETE: i(93183), ROTATE_START: i(80112), SHAKE_COMPLETE: i(62252), SHAKE_START: i(86017), ZOOM_COMPLETE: i(539), ZOOM_START: i(51892) } }, 87969: (t, e, i) => { t.exports = { Camera: i(38058), BaseCamera: i(71911), CameraManager: i(32743), Effects: i(20052), Events: i(19715) } }, 63091: (t, e, i) => { const s = i(83419); const n = i(35154); const r = new s({ initialize: function (t) { this.camera = n(t, 'camera', null), this.left = n(t, 'left', null), this.right = n(t, 'right', null), this.up = n(t, 'up', null), this.down = n(t, 'down', null), this.zoomIn = n(t, 'zoomIn', null), this.zoomOut = n(t, 'zoomOut', null), this.zoomSpeed = n(t, 'zoomSpeed', 0.01), this.minZoom = n(t, 'minZoom', 0.001), this.maxZoom = n(t, 'maxZoom', 1e3), this.speedX = 0, this.speedY = 0; const e = n(t, 'speed', null); typeof e === 'number' ? (this.speedX = e, this.speedY = e) : (this.speedX = n(t, 'speed.x', 0), this.speedY = n(t, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null }, start: function () { return this.active = this.camera !== null, this }, stop: function () { return this.active = !1, this }, setCamera: function (t) { return this.camera = t, this }, update: function (t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < this.minZoom && (e.zoom = this.minZoom)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed, e.zoom > this.maxZoom && (e.zoom = this.maxZoom)) } }, destroy: function () { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null } }); t.exports = r }, 58818: (t, e, i) => { const s = i(83419); const n = i(35154); const r = new s({ initialize: function (t) { this.camera = n(t, 'camera', null), this.left = n(t, 'left', null), this.right = n(t, 'right', null), this.up = n(t, 'up', null), this.down = n(t, 'down', null), this.zoomIn = n(t, 'zoomIn', null), this.zoomOut = n(t, 'zoomOut', null), this.zoomSpeed = n(t, 'zoomSpeed', 0.01), this.minZoom = n(t, 'minZoom', 0.001), this.maxZoom = n(t, 'maxZoom', 1e3), this.accelX = 0, this.accelY = 0; const e = n(t, 'acceleration', null); typeof e === 'number' ? (this.accelX = e, this.accelY = e) : (this.accelX = n(t, 'acceleration.x', 0), this.accelY = n(t, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const i = n(t, 'drag', null); typeof i === 'number' ? (this.dragX = i, this.dragY = i) : (this.dragX = n(t, 'drag.x', 0), this.dragY = n(t, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const s = n(t, 'maxSpeed', null); typeof s === 'number' ? (this.maxSpeedX = s, this.maxSpeedY = s) : (this.maxSpeedX = n(t, 'maxSpeed.x', 0), this.maxSpeedY = n(t, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null }, start: function () { return this.active = this.camera !== null, this }, stop: function () { return this.active = !1, this }, setCamera: function (t) { return this.camera = t, this }, update: function (t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this._speedX > 0 ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (e.scrollX -= this._speedX * t | 0), this._speedY !== 0 && (e.scrollY -= this._speedY * t | 0), this._zoom !== 0 && (e.zoom += this._zoom, e.zoom < this.minZoom ? e.zoom = this.minZoom : e.zoom > this.maxZoom && (e.zoom = this.maxZoom)) } }, destroy: function () { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null } }); t.exports = r }, 38865: (t, e, i) => { t.exports = { FixedKeyControl: i(63091), SmoothedKeyControl: i(58818) } }, 26638: (t, e, i) => { t.exports = { Controls: i(38865), Scene2D: i(87969) } }, 8054: (t, e, i) => { const s = { VERSION: '3.80.1', BlendModes: i(10312), ScaleModes: i(29795), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8 }; t.exports = s }, 69547: (t, e, i) => { const s = i(83419); const n = i(8054); const r = i(42363); const o = i(82264); const a = i(95540); const h = i(35154); const l = i(41212); const u = i(29747); const c = i(75508); const d = i(36060); const f = i(80333); const p = new s({ initialize: function (t) { void 0 === t && (t = {}); const e = h(t, 'scale', null); this.width = h(e, 'width', 1024, t), this.height = h(e, 'height', 768, t), this.zoom = h(e, 'zoom', 1, t), this.parent = h(e, 'parent', void 0, t), this.scaleMode = h(e, e ? 'mode' : 'scaleMode', 0, t), this.expandParent = h(e, 'expandParent', !0, t), this.autoRound = h(e, 'autoRound', !1, t), this.autoCenter = h(e, 'autoCenter', 0, t), this.resizeInterval = h(e, 'resizeInterval', 500, t), this.fullscreenTarget = h(e, 'fullscreenTarget', null, t), this.minWidth = h(e, 'min.width', 0, t), this.maxWidth = h(e, 'max.width', 0, t), this.minHeight = h(e, 'min.height', 0, t), this.maxHeight = h(e, 'max.height', 0, t), this.snapWidth = h(e, 'snap.width', 0, t), this.snapHeight = h(e, 'snap.height', 0, t), this.renderType = h(t, 'type', n.AUTO), this.canvas = h(t, 'canvas', null), this.context = h(t, 'context', null), this.canvasStyle = h(t, 'canvasStyle', null), this.customEnvironment = h(t, 'customEnvironment', !1), this.sceneConfig = h(t, 'scene', null), this.seed = h(t, 'seed', [(Date.now() * Math.random()).toString()]), c.RND = new c.RandomDataGenerator(this.seed), this.gameTitle = h(t, 'title', ''), this.gameURL = h(t, 'url', 'https://phaser.io'), this.gameVersion = h(t, 'version', ''), this.autoFocus = h(t, 'autoFocus', !0), this.stableSort = h(t, 'stableSort', -1), this.stableSort === -1 && (this.stableSort = o.browser.es2019 ? 1 : 0), o.features.stableSort = this.stableSort, this.domCreateContainer = h(t, 'dom.createContainer', !1), this.domPointerEvents = h(t, 'dom.pointerEvents', 'none'), this.inputKeyboard = h(t, 'input.keyboard', !0), this.inputKeyboardEventTarget = h(t, 'input.keyboard.target', window), this.inputKeyboardCapture = h(t, 'input.keyboard.capture', []), this.inputMouse = h(t, 'input.mouse', !0), this.inputMouseEventTarget = h(t, 'input.mouse.target', null), this.inputMousePreventDefaultDown = h(t, 'input.mouse.preventDefaultDown', !0), this.inputMousePreventDefaultUp = h(t, 'input.mouse.preventDefaultUp', !0), this.inputMousePreventDefaultMove = h(t, 'input.mouse.preventDefaultMove', !0), this.inputMousePreventDefaultWheel = h(t, 'input.mouse.preventDefaultWheel', !0), this.inputTouch = h(t, 'input.touch', o.input.touch), this.inputTouchEventTarget = h(t, 'input.touch.target', null), this.inputTouchCapture = h(t, 'input.touch.capture', !0), this.inputActivePointers = h(t, 'input.activePointers', 1), this.inputSmoothFactor = h(t, 'input.smoothFactor', 0), this.inputWindowEvents = h(t, 'input.windowEvents', !0), this.inputGamepad = h(t, 'input.gamepad', !1), this.inputGamepadEventTarget = h(t, 'input.gamepad.target', window), this.disableContextMenu = h(t, 'disableContextMenu', !1), this.audio = h(t, 'audio', {}), this.hideBanner = !1 === h(t, 'banner', null), this.hidePhaser = h(t, 'banner.hidePhaser', !1), this.bannerTextColor = h(t, 'banner.text', '#ffffff'), this.bannerBackgroundColor = h(t, 'banner.background', ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = h(t, 'fps', null), this.disablePreFX = h(t, 'disablePreFX', !1), this.disablePostFX = h(t, 'disablePostFX', !1); const i = h(t, 'render', null); this.pipeline = h(i, 'pipeline', null, t), this.autoMobilePipeline = h(i, 'autoMobilePipeline', !0, t), this.defaultPipeline = h(i, 'defaultPipeline', d.MULTI_PIPELINE, t), this.antialias = h(i, 'antialias', !0, t), this.antialiasGL = h(i, 'antialiasGL', !0, t), this.mipmapFilter = h(i, 'mipmapFilter', '', t), this.desynchronized = h(i, 'desynchronized', !1, t), this.roundPixels = h(i, 'roundPixels', !0, t), this.pixelArt = h(i, 'pixelArt', this.zoom !== 1, t), this.pixelArt && (this.antialias = !1, this.antialiasGL = !1, this.roundPixels = !0), this.transparent = h(i, 'transparent', !1, t), this.clearBeforeRender = h(i, 'clearBeforeRender', !0, t), this.preserveDrawingBuffer = h(i, 'preserveDrawingBuffer', !1, t), this.premultipliedAlpha = h(i, 'premultipliedAlpha', !0, t), this.failIfMajorPerformanceCaveat = h(i, 'failIfMajorPerformanceCaveat', !1, t), this.powerPreference = h(i, 'powerPreference', 'default', t), this.batchSize = h(i, 'batchSize', 4096, t), this.maxTextures = h(i, 'maxTextures', -1, t), this.maxLights = h(i, 'maxLights', 10, t); const s = h(t, 'backgroundColor', 0); this.backgroundColor = f(s), this.transparent && (this.backgroundColor = f(0), this.backgroundColor.alpha = 0), this.preBoot = h(t, 'callbacks.preBoot', u), this.postBoot = h(t, 'callbacks.postBoot', u), this.physics = h(t, 'physics', {}), this.defaultPhysicsSystem = h(this.physics, 'default', !1), this.loaderBaseURL = h(t, 'loader.baseURL', ''), this.loaderPath = h(t, 'loader.path', ''), this.loaderMaxParallelDownloads = h(t, 'loader.maxParallelDownloads', o.os.android ? 6 : 32), this.loaderCrossOrigin = h(t, 'loader.crossOrigin', void 0), this.loaderResponseType = h(t, 'loader.responseType', ''), this.loaderAsync = h(t, 'loader.async', !0), this.loaderUser = h(t, 'loader.user', ''), this.loaderPassword = h(t, 'loader.password', ''), this.loaderTimeout = h(t, 'loader.timeout', 0), this.loaderWithCredentials = h(t, 'loader.withCredentials', !1), this.loaderImageLoadType = h(t, 'loader.imageLoadType', 'XHR'), this.loaderLocalScheme = h(t, 'loader.localScheme', ['file://', 'capacitor://']), this.glowFXQuality = h(t, 'fx.glow.quality', 0.1), this.glowFXDistance = h(t, 'fx.glow.distance', 10), this.installGlobalPlugins = [], this.installScenePlugins = []; const p = h(t, 'plugins', null); let v = r.DefaultScene; p && (Array.isArray(p) ? this.defaultPlugins = p : l(p) && (this.installGlobalPlugins = a(p, 'global', []), this.installScenePlugins = a(p, 'scene', []), Array.isArray(p.default) ? v = p.default : Array.isArray(p.defaultMerge) && (v = v.concat(p.defaultMerge)))), this.defaultPlugins = v; const g = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = h(t, 'images.default', g + 'AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=='), this.missingImage = h(t, 'images.missing', g + 'CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=='), this.whiteImage = h(t, 'images.white', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABdJREFUeNpi/P//PwMMMDEgAdwcgAADAJZuAwXJYZOzAAAAAElFTkSuQmCC'), window && (window.FORCE_WEBGL ? this.renderType = n.WEBGL : window.FORCE_CANVAS && (this.renderType = n.CANVAS)) } }); t.exports = p }, 86054: (t, e, i) => { const s = i(20623); const n = i(27919); const r = i(8054); const o = i(89357); t.exports = function (t) { const e = t.config; if ((e.customEnvironment || e.canvas) && e.renderType === r.AUTO) throw new Error('Must set explicit renderType in custom environment'); if (!e.customEnvironment && !e.canvas && e.renderType !== r.HEADLESS) if (e.renderType === r.AUTO && (e.renderType = o.webGL ? r.WEBGL : r.CANVAS), e.renderType === r.WEBGL) { if (!o.webGL) throw new Error('Cannot create WebGL context, aborting.') } else { if (e.renderType !== r.CANVAS) throw new Error('Unknown value for renderer type: ' + e.renderType); if (!o.canvas) throw new Error('Cannot create Canvas context, aborting.') } e.antialias || n.disableSmoothing(); let a; let h; const l = t.scale.baseSize; const u = l.width; const c = l.height; (e.canvas ? (t.canvas = e.canvas, t.canvas.width = u, t.canvas.height = c) : t.canvas = n.create(t, u, c, e.renderType), e.canvasStyle && (t.canvas.style = e.canvasStyle), e.antialias || s.setCrisp(t.canvas), e.renderType !== r.HEADLESS) && (a = i(68627), h = i(74797), e.renderType === r.WEBGL ? t.renderer = new h(t) : (t.renderer = new a(t), t.context = t.renderer.gameContext)) } }, 96391: (t, e, i) => { const s = i(8054); t.exports = function (t) { const e = t.config; if (!e.hideBanner) { let i = 'WebGL'; e.renderType === s.CANVAS ? i = 'Canvas' : e.renderType === s.HEADLESS && (i = 'Headless'); let n; const r = e.audio; const o = t.device.audio; if (n = o.webAudio && !r.disableWebAudio ? 'Web Audio' : r.noAudio || !o.webAudio && !o.audioData ? 'No Audio' : 'HTML5 Audio', t.device.browser.ie) window.console && console.log('Phaser v' + s.VERSION + ' / https://phaser.io'); else { let a; let h = ''; const l = [h]; if (Array.isArray(e.bannerBackgroundColor)) e.bannerBackgroundColor.forEach(function (t) { h = h.concat('%c '), l.push('background: ' + t), a = t }), l[l.length - 1] = 'color: ' + e.bannerTextColor + '; background: ' + a; else h = h.concat('%c '), l.push('color: ' + e.bannerTextColor + '; background: ' + e.bannerBackgroundColor); l.push('background: transparent'), e.gameTitle && (h = h.concat(e.gameTitle), e.gameVersion && (h = h.concat(' v' + e.gameVersion)), e.hidePhaser || (h = h.concat(' / '))); e.hidePhaser || (h = h.concat('Phaser v' + s.VERSION + ' (' + i + ' | ' + n + ')')), h = h.concat(' %c ' + e.gameURL), l[0] = h, console.log.apply(console, l) } } } }, 50127: (t, e, i) => { const s = i(40366); const n = i(60848); const r = i(24047); const o = i(27919); const a = i(83419); const h = i(69547); const l = i(83719); const u = i(86054); const c = i(45893); const d = i(96391); const f = i(82264); const p = i(57264); const v = i(50792); const g = i(8443); const m = i(7003); const y = i(37277); const x = i(77332); const T = i(76531); const w = i(60903); const b = i(69442); const S = i(17130); const E = i(65898); const A = i(51085); const C = i(14747); const _ = new a({ initialize: function (t) { this.config = new h(t), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new v(), this.anims = new n(this), this.textures = new S(this), this.cache = new r(this), this.registry = new c(this, new v()), this.input = new m(this, this.config), this.scene = new w(this, this.config.sceneConfig), this.device = f, this.scale = new T(this, this.config), this.sound = null, this.sound = C.create(this), this.loop = new E(this, this.config.fps), this.plugins = new x(this, this.config), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, this.isPaused = !1, p(this.boot.bind(this)) }, boot: function () { y.hasCore('EventEmitter') ? (this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), u(this), l(this), d(this), s(this.canvas, this.config.parent), this.textures.once(b.READY, this.texturesReady, this), this.events.emit(g.BOOT)) : console.warn('Aborting. Core Plugins missing.') }, texturesReady: function () { this.events.emit(g.READY), this.start() }, start: function () { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), A(this); const t = this.events; t.on(g.HIDDEN, this.onHidden, this), t.on(g.VISIBLE, this.onVisible, this), t.on(g.BLUR, this.onBlur, this), t.on(g.FOCUS, this.onFocus, this) }, step: function (t, e) { if (this.pendingDestroy) return this.runDestroy(); if (!this.isPaused) { const i = this.events; i.emit(g.PRE_STEP, t, e), i.emit(g.STEP, t, e), this.scene.update(t, e), i.emit(g.POST_STEP, t, e); const s = this.renderer; s.preRender(), i.emit(g.PRE_RENDER, s, t, e), this.scene.render(s), s.postRender(), i.emit(g.POST_RENDER, s, t, e) } }, headlessStep: function (t, e) { if (this.pendingDestroy) return this.runDestroy(); if (!this.isPaused) { const i = this.events; i.emit(g.PRE_STEP, t, e), i.emit(g.STEP, t, e), this.scene.update(t, e), i.emit(g.POST_STEP, t, e), this.scene.isProcessing = !1, i.emit(g.PRE_RENDER, null, t, e), i.emit(g.POST_RENDER, null, t, e) } }, onHidden: function () { this.loop.pause(), this.events.emit(g.PAUSE) }, pause: function () { const t = this.isPaused; this.isPaused = !0, t || this.events.emit(g.PAUSE) }, onVisible: function () { this.loop.resume(), this.events.emit(g.RESUME) }, resume: function () { const t = this.isPaused; this.isPaused = !1, t && this.events.emit(g.RESUME) }, onBlur: function () { this.hasFocus = !1, this.loop.blur() }, onFocus: function () { this.hasFocus = !0, this.loop.focus() }, getFrame: function () { return this.loop.frame }, getTime: function () { return this.loop.now }, destroy: function (t, e) { void 0 === e && (e = !1), this.pendingDestroy = !0, this.removeCanvas = t, this.noReturn = e }, runDestroy: function () { this.scene.destroy(), this.events.emit(g.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1 } }); t.exports = _ }, 65898: (t, e, i) => { const s = i(83419); const n = i(35154); const r = i(29747); const o = i(43092); const a = new s({ initialize: function (t, e) { this.game = t, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = n(e, 'min', 5), this.targetFps = n(e, 'target', 60), this.fpsLimit = n(e, 'limit', 0), this.hasFpsLimit = this.fpsLimit > 0, this._limitRate = this.hasFpsLimit ? 1e3 / this.fpsLimit : 0, this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = n(e, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = n(e, 'deltaHistory', 10), this.panicMax = n(e, 'panicMax', 120), this.rawDelta = 0, this.now = 0, this.smoothStep = n(e, 'smoothStep', !0) }, blur: function () { this.inFocus = !1 }, focus: function () { this.inFocus = !0, this.resetDelta() }, pause: function () { this._pauseTime = window.performance.now() }, resume: function () { this.resetDelta(), this.startTime += this.time - this._pauseTime }, resetDelta: function () { const t = window.performance.now(); this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax }, start: function (t) { if (this.started) return this; this.started = !0, this.running = !0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = t; const i = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this); this.raf.start(i, this.forceSetTimeOut, this._target) }, smoothDelta: function (t) { const e = this.deltaIndex; const i = this.deltaHistory; const s = this.deltaSmoothingMax; (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, t = Math.min(t, this._target)), t > this._min && (t = i[e], t = Math.min(t, this._min)), i[e] = t, this.deltaIndex++, this.deltaIndex >= s && (this.deltaIndex = 0); for (var n = 0, r = 0; r < s; r++)n += i[r]; return n /= s }, updateFPS: function (t) { this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0 }, stepLimitFPS: function (t) { this.now = t; let e = Math.max(0, t - this.lastTime); this.rawDelta = e, this.time += this.rawDelta, this.smoothStep && (e = this.smoothDelta(e)), this.delta += e, t >= this.nextFpsUpdate && this.updateFPS(t), this.framesThisSecond++, this.delta >= this._limitRate && (this.callback(t, this.delta), this.delta = 0), this.lastTime = t, this.frame++ }, step: function (t) { this.now = t; let e = Math.max(0, t - this.lastTime); this.rawDelta = e, this.time += this.rawDelta, this.smoothStep && (e = this.smoothDelta(e)), this.delta = e, t >= this.nextFpsUpdate && this.updateFPS(t), this.framesThisSecond++, this.callback(t, e), this.lastTime = t, this.frame++ }, tick: function () { const t = window.performance.now(); this.hasFpsLimit ? this.stepLimitFPS(t) : this.step(t) }, sleep: function () { this.running && (this.raf.stop(), this.running = !1) }, wake: function (t) { void 0 === t && (t = !1); const e = window.performance.now(); if (!this.running) { t && (this.startTime += -this.lastTime + (this.lastTime + e)); const i = this.hasFpsLimit ? this.stepLimitFPS.bind(this) : this.step.bind(this); this.raf.start(i, this.forceSetTimeOut, this._target), this.running = !0, this.nextFpsUpdate = e + 1e3, this.framesThisSecond = 0, this.fpsLimitTriggered = !1, this.tick() } }, getDuration: function () { return Math.round(this.lastTime - this.startTime) / 1e3 }, getDurationMS: function () { return Math.round(this.lastTime - this.startTime) }, stop: function () { return this.running = !1, this.started = !1, this.raf.stop(), this }, destroy: function () { this.stop(), this.raf.destroy(), this.raf = null, this.game = null, this.callback = null } }); t.exports = a }, 51085: (t, e, i) => { const s = i(8443); t.exports = function (t) { let e; const i = t.events; if (void 0 !== document.hidden) e = 'visibilitychange'; else { ['webkit', 'moz', 'ms'].forEach(function (t) { void 0 !== document[t + 'Hidden'] && (document.hidden = function () { return document[t + 'Hidden'] }, e = t + 'visibilitychange') }) } e && document.addEventListener(e, function (t) { document.hidden || t.type === 'pause' ? i.emit(s.HIDDEN) : i.emit(s.VISIBLE) }, !1), window.onblur = function () { i.emit(s.BLUR) }, window.onfocus = function () { i.emit(s.FOCUS) }, window.focus && t.config.autoFocus && window.focus() } }, 97217: t => { t.exports = 'blur' }, 47548: t => { t.exports = 'boot' }, 19814: t => { t.exports = 'contextlost' }, 68446: t => { t.exports = 'destroy' }, 41700: t => { t.exports = 'focus' }, 25432: t => { t.exports = 'hidden' }, 65942: t => { t.exports = 'pause' }, 59211: t => { t.exports = 'postrender' }, 47789: t => { t.exports = 'poststep' }, 39066: t => { t.exports = 'prerender' }, 460: t => { t.exports = 'prestep' }, 16175: t => { t.exports = 'ready' }, 42331: t => { t.exports = 'resume' }, 11966: t => { t.exports = 'step' }, 32969: t => { t.exports = 'systemready' }, 94830: t => { t.exports = 'visible' }, 8443: (t, e, i) => { t.exports = { BLUR: i(97217), BOOT: i(47548), CONTEXT_LOST: i(19814), DESTROY: i(68446), FOCUS: i(41700), HIDDEN: i(25432), PAUSE: i(65942), POST_RENDER: i(59211), POST_STEP: i(47789), PRE_RENDER: i(39066), PRE_STEP: i(460), READY: i(16175), RESUME: i(42331), STEP: i(11966), SYSTEM_READY: i(32969), VISIBLE: i(94830) } }, 42857: (t, e, i) => { t.exports = { Config: i(69547), CreateRenderer: i(86054), DebugHeader: i(96391), Events: i(8443), TimeStep: i(65898), VisibilityHandler: i(51085) } }, 99584: (t, e, i) => { const s = i(5290); const n = i(27919); const r = i(35154); t.exports = function (t) { const e = r(t, 'data', []); let i = r(t, 'canvas', null); const o = r(t, 'palette', s); const a = r(t, 'pixelWidth', 1); const h = r(t, 'pixelHeight', a); let l = r(t, 'resizeCanvas', !0); let u = r(t, 'clearCanvas', !0); const c = r(t, 'preRender', null); const d = r(t, 'postRender', null); const f = Math.floor(Math.abs(e[0].length * a)); const p = Math.floor(Math.abs(e.length * h)); i || (i = n.create2D(this, f, p), l = !1, u = !1), l && (i.width = f, i.height = p); const v = i.getContext('2d', { willReadFrequently: !0 }); u && v.clearRect(0, 0, f, p), c && c(i, v); for (let g = 0; g < e.length; g++) for (let m = e[g], y = 0; y < m.length; y++) { const x = m[y]; x !== '.' && x !== ' ' && (v.fillStyle = o[x], v.fillRect(y * a, g * h, a, h)) } return d && d(i, v), i } }, 15822: (t, e, i) => { t.exports = { GenerateTexture: i(99584), Palettes: i(57763) } }, 5290: t => { t.exports = { 0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF' } }, 23816: t => { t.exports = { 0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac' } }, 9866: t => { t.exports = { 0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff' } }, 77552: t => { t.exports = { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb' } }, 92259: t => { t.exports = { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff' } }, 57763: (t, e, i) => { t.exports = { ARNE16: i(5290), C64: i(23816), CGA: i(9866), JMP: i(77552), MSX: i(92259) } }, 46728: (t, e, i) => { const s = i(83419); const n = i(36316); const r = i(80021); const o = i(26099); const a = new s({ Extends: r, initialize: function (t, e, i, s) { r.call(this, 'CubicBezierCurve'), Array.isArray(t) && (s = new o(t[6], t[7]), i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = s }, getStartPoint: function (t) { return void 0 === t && (t = new o()), t.copy(this.p0) }, getResolution: function (t) { return t }, getPoint: function (t, e) { void 0 === e && (e = new o()); const i = this.p0; const s = this.p1; const r = this.p2; const a = this.p3; return e.set(n(t, i.x, s.x, r.x, a.x), n(t, i.y, s.y, r.y, a.y)) }, draw: function (t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let s = 1; s < i.length; s++)t.lineTo(i[s].x, i[s].y); return t.strokePath(), t }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] } } }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const s = new o(e[2], e[3]); const n = new o(e[4], e[5]); const r = new o(e[6], e[7]); return new a(i, s, n, r) }, t.exports = a }, 80021: (t, e, i) => { const s = i(83419); const n = i(19217); const r = i(87841); const o = i(26099); const a = new s({ initialize: function (t) { this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o() }, draw: function (t, e) { return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e)) }, getBounds: function (t, e) { t || (t = new r()), void 0 === e && (e = 16); const i = this.getLength(); e > i && (e = i / 2); const s = Math.max(1, Math.round(i / e)); return n(this.getSpacedPoints(s), t) }, getDistancePoints: function (t) { const e = this.getLength(); const i = Math.max(1, e / t); return this.getSpacedPoints(i) }, getEndPoint: function (t) { return void 0 === t && (t = new o()), this.getPointAt(1, t) }, getLength: function () { const t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; const i = []; const s = this.getPoint(0, this._tmpVec2A); let n = 0; i.push(0); for (let r = 1; r <= t; r++)n += (e = this.getPoint(r / t, this._tmpVec2B)).distance(s), i.push(n), s.copy(e); return this.cacheArcLengths = i, i }, getPointAt: function (t, e) { const i = this.getUtoTmapping(t); return this.getPoint(i, e) }, getPoints: function (t, e, i) { void 0 === i && (i = []), t || (t = e ? this.getLength() / e : this.defaultDivisions); for (let s = 0; s <= t; s++)i.push(this.getPoint(s / t)); return i }, getRandomPoint: function (t) { return void 0 === t && (t = new o()), this.getPoint(Math.random(), t) }, getSpacedPoints: function (t, e, i) { void 0 === i && (i = []), t || (t = e ? this.getLength() / e : this.defaultDivisions); for (let s = 0; s <= t; s++) { const n = this.getUtoTmapping(s / t, null, t); i.push(this.getPoint(n)) } return i }, getStartPoint: function (t) { return void 0 === t && (t = new o()), this.getPointAt(0, t) }, getTangent: function (t, e) { void 0 === e && (e = new o()); const i = 1e-4; let s = t - i; let n = t + i; return s < 0 && (s = 0), n > 1 && (n = 1), this.getPoint(s, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize() }, getTangentAt: function (t, e) { const i = this.getUtoTmapping(t); return this.getTangent(i, e) }, getTFromDistance: function (t, e) { return t <= 0 ? 0 : this.getUtoTmapping(0, t, e) }, getUtoTmapping: function (t, e, i) { let s; const n = this.getLengths(i); let r = 0; const o = n.length; s = e ? Math.min(e, n[o - 1]) : t * n[o - 1]; for (var a, h = 0, l = o - 1; h <= l;) if ((a = n[r = Math.floor(h + (l - h) / 2)] - s) < 0) h = r + 1; else { if (!(a > 0)) { l = r; break } l = r - 1 } if (n[r = l] === s) return r / (o - 1); const u = n[r]; return (r + (s - u) / (n[r + 1] - u)) / (o - 1) }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() } }); t.exports = a }, 73825: (t, e, i) => { const s = i(83419); const n = i(80021); const r = i(39506); const o = i(35154); const a = i(43396); const h = i(26099); const l = new s({ Extends: n, initialize: function (t, e, i, s, a, l, u, c) { if (typeof t === 'object') { const d = t; t = o(d, 'x', 0), e = o(d, 'y', 0), i = o(d, 'xRadius', 0), s = o(d, 'yRadius', i), a = o(d, 'startAngle', 0), l = o(d, 'endAngle', 360), u = o(d, 'clockwise', !1), c = o(d, 'rotation', 0) } else void 0 === s && (s = i), void 0 === a && (a = 0), void 0 === l && (l = 360), void 0 === u && (u = !1), void 0 === c && (c = 0); n.call(this, 'EllipseCurve'), this.p0 = new h(t, e), this._xRadius = i, this._yRadius = s, this._startAngle = r(a), this._endAngle = r(l), this._clockwise = u, this._rotation = r(c) }, getStartPoint: function (t) { return void 0 === t && (t = new h()), this.getPoint(0, t) }, getResolution: function (t) { return 2 * t }, getPoint: function (t, e) { void 0 === e && (e = new h()); for (var i = 2 * Math.PI, s = this._endAngle - this._startAngle, n = Math.abs(s) < Number.EPSILON; s < 0;)s += i; for (; s > i;)s -= i; s < Number.EPSILON && (s = n ? 0 : i), this._clockwise && !n && (s === i ? s = -i : s -= i); const r = this._startAngle + t * s; let o = this.p0.x + this._xRadius * Math.cos(r); let a = this.p0.y + this._yRadius * Math.sin(r); if (this._rotation !== 0) { const l = Math.cos(this._rotation); const u = Math.sin(this._rotation); const c = o - this.p0.x; const d = a - this.p0.y; o = c * l - d * u + this.p0.x, a = c * u + d * l + this.p0.y } return e.set(o, a) }, setXRadius: function (t) { return this.xRadius = t, this }, setYRadius: function (t) { return this.yRadius = t, this }, setWidth: function (t) { return this.xRadius = t / 2, this }, setHeight: function (t) { return this.yRadius = t / 2, this }, setStartAngle: function (t) { return this.startAngle = t, this }, setEndAngle: function (t) { return this.endAngle = t, this }, setClockwise: function (t) { return this.clockwise = t, this }, setRotation: function (t) { return this.rotation = t, this }, x: { get: function () { return this.p0.x }, set: function (t) { this.p0.x = t } }, y: { get: function () { return this.p0.y }, set: function (t) { this.p0.y = t } }, xRadius: { get: function () { return this._xRadius }, set: function (t) { this._xRadius = t } }, yRadius: { get: function () { return this._yRadius }, set: function (t) { this._yRadius = t } }, startAngle: { get: function () { return a(this._startAngle) }, set: function (t) { this._startAngle = r(t) } }, endAngle: { get: function () { return a(this._endAngle) }, set: function (t) { this._endAngle = r(t) } }, clockwise: { get: function () { return this._clockwise }, set: function (t) { this._clockwise = t } }, angle: { get: function () { return a(this._rotation) }, set: function (t) { this._rotation = r(t) } }, rotation: { get: function () { return this._rotation }, set: function (t) { this._rotation = t } }, toJSON: function () { return { type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: a(this._startAngle), endAngle: a(this._endAngle), clockwise: this._clockwise, rotation: a(this._rotation) } } }); l.fromJSON = function (t) { return new l(t) }, t.exports = l }, 33951: (t, e, i) => { const s = i(83419); const n = i(80021); const r = i(19217); const o = i(87841); const a = i(26099); const h = new s({ Extends: n, initialize: function (t, e) { n.call(this, 'LineCurve'), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e, this.arcLengthDivisions = 1 }, getBounds: function (t) { return void 0 === t && (t = new o()), r([this.p0, this.p1], t) }, getStartPoint: function (t) { return void 0 === t && (t = new a()), t.copy(this.p0) }, getResolution: function (t) { return void 0 === t && (t = 1), t }, getPoint: function (t, e) { return void 0 === e && (e = new a()), t === 1 ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e) }, getPointAt: function (t, e) { return this.getPoint(t, e) }, getTangent: function (t, e) { return void 0 === e && (e = new a()), e.copy(this.p1).subtract(this.p0).normalize(), e }, getUtoTmapping: function (t, e, i) { let s; if (e) { const n = this.getLengths(i); const r = n[n.length - 1]; s = Math.min(e, r) / r } else s = t; return s }, draw: function (t) { return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] } } }); h.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const s = new a(e[2], e[3]); return new h(i, s) }, t.exports = h }, 14744: (t, e, i) => { const s = i(83419); const n = i(80021); const r = i(32112); const o = i(26099); const a = new s({ Extends: n, initialize: function (t, e, i) { n.call(this, 'QuadraticBezierCurve'), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i }, getStartPoint: function (t) { return void 0 === t && (t = new o()), t.copy(this.p0) }, getResolution: function (t) { return t }, getPoint: function (t, e) { void 0 === e && (e = new o()); const i = this.p0; const s = this.p1; const n = this.p2; return e.set(r(t, i.x, s.x, n.x), r(t, i.y, s.y, n.y)) }, draw: function (t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let s = 1; s < i.length; s++)t.lineTo(i[s].x, i[s].y); return t.strokePath(), t }, toJSON: function () { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] } } }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const s = new o(e[2], e[3]); const n = new o(e[4], e[5]); return new a(i, s, n) }, t.exports = a }, 42534: (t, e, i) => { const s = i(87842); const n = i(83419); const r = i(80021); const o = i(26099); const a = new n({ Extends: r, initialize: function (t) { void 0 === t && (t = []), r.call(this, 'SplineCurve'), this.points = [], this.addPoints(t) }, addPoints: function (t) { for (let e = 0; e < t.length; e++) { const i = new o(); typeof t[e] === 'number' ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i) } return this }, addPoint: function (t, e) { const i = new o(t, e); return this.points.push(i), i }, getStartPoint: function (t) { return void 0 === t && (t = new o()), t.copy(this.points[0]) }, getResolution: function (t) { return t * this.points.length }, getPoint: function (t, e) { void 0 === e && (e = new o()); const i = this.points; const n = (i.length - 1) * t; const r = Math.floor(n); const a = n - r; const h = i[r === 0 ? r : r - 1]; const l = i[r]; const u = i[r > i.length - 2 ? i.length - 1 : r + 1]; const c = i[r > i.length - 3 ? i.length - 1 : r + 2]; return e.set(s(a, h.x, l.x, u.x, c.x), s(a, h.y, l.y, u.y, c.y)) }, toJSON: function () { for (var t = [], e = 0; e < this.points.length; e++)t.push(this.points[e].x), t.push(this.points[e].y); return { type: this.type, points: t } } }); a.fromJSON = function (t) { return new a(t.points) }, t.exports = a }, 25410: (t, e, i) => { t.exports = { Path: i(46669), MoveTo: i(68618), CubicBezier: i(46728), Curve: i(80021), Ellipse: i(73825), Line: i(33951), QuadraticBezier: i(14744), Spline: i(42534) } }, 68618: (t, e, i) => { const s = i(83419); const n = i(26099); const r = new s({ initialize: function (t, e) { this.active = !1, this.p0 = new n(t, e) }, getPoint: function (t, e) { return void 0 === e && (e = new n()), e.copy(this.p0) }, getPointAt: function (t, e) { return this.getPoint(t, e) }, getResolution: function () { return 1 }, getLength: function () { return 0 }, toJSON: function () { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] } } }); t.exports = r }, 46669: (t, e, i) => { const s = i(83419); const n = i(46728); const r = i(73825); const o = i(39429); const a = i(33951); const h = i(68618); const l = i(14744); const u = i(87841); const c = i(42534); const d = i(26099); const f = i(36383); const p = new s({ initialize: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = '', this.defaultDivisions = 12, this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d(), this._tmpVec2A = new d(), this._tmpVec2B = new d(), typeof t === 'object' ? this.fromJSON(t) : this.startPoint.set(t, e) }, add: function (t) { return this.curves.push(t), this }, circleTo: function (t, e, i) { return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i) }, closePath: function () { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); return t.equals(e) || this.curves.push(new a(e, t)), this }, cubicBezierTo: function (t, e, i, s, r, o) { let a; let h; let l; const u = this.getEndPoint(); return t instanceof d ? (a = t, h = e, l = i) : (a = new d(i, s), h = new d(r, o), l = new d(t, e)), this.add(new n(u, a, h, l)) }, quadraticBezierTo: function (t, e, i, s) { let n; let r; const o = this.getEndPoint(); return t instanceof d ? (n = t, r = e) : (n = new d(i, s), r = new d(t, e)), this.add(new l(o, n, r)) }, draw: function (t, e) { for (let i = 0; i < this.curves.length; i++) { const s = this.curves[i]; s.active && s.draw(t, e) } return t }, ellipseTo: function (t, e, i, s, n, o) { const a = new r(0, 0, t, e, i, s, n, o); const h = this.getEndPoint(this._tmpVec2A); const l = a.getStartPoint(this._tmpVec2B); return h.subtract(l), a.x = h.x, a.y = h.y, this.add(a) }, fromJSON: function (t) { this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose; for (let e = 0; e < t.curves.length; e++) { const i = t.curves[e]; switch (i.type) { case 'LineCurve': this.add(a.fromJSON(i)); break; case 'EllipseCurve': this.add(r.fromJSON(i)); break; case 'SplineCurve': this.add(c.fromJSON(i)); break; case 'CubicBezierCurve': this.add(n.fromJSON(i)); break; case 'QuadraticBezierCurve': this.add(l.fromJSON(i)) } } return this }, getBounds: function (t, e) { void 0 === t && (t = new u()), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE; for (var i = new u(), s = f.MIN_SAFE_INTEGER, n = f.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) { const o = this.curves[r]; o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), s = Math.max(s, i.right), n = Math.max(n, i.bottom)) } return t.right = s, t.bottom = n, t }, getCurveLengths: function () { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0; i < this.curves.length; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t, t }, getCurveAt: function (t) { for (let e = t * this.getLength(), i = this.getCurveLengths(), s = 0; s < i.length;) { if (i[s] >= e) return this.curves[s]; s++ } return null }, getEndPoint: function (t) { return void 0 === t && (t = new d()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t }, getLength: function () { const t = this.getCurveLengths(); return t[t.length - 1] }, getPoint: function (t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), s = this.getCurveLengths(), n = 0; n < s.length;) { if (s[n] >= i) { const r = s[n] - i; const o = this.curves[n]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getPointAt(h, e) } n++ } return null }, getPoints: function (t, e) { t || e || (t = this.defaultDivisions); for (var i, s = [], n = 0; n < this.curves.length; n++) { const r = this.curves[n]; if (r.active) for (let o = r.getResolution(t), a = r.getPoints(o, e), h = 0; h < a.length; h++) { const l = a[h]; i && i.equals(l) || (s.push(l), i = l) } } return this.autoClose && s.length > 1 && !s[s.length - 1].equals(s[0]) && s.push(s[0]), s }, getRandomPoint: function (t) { return void 0 === t && (t = new d()), this.getPoint(Math.random(), t) }, getSpacedPoints: function (t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e }, getStartPoint: function (t) { return void 0 === t && (t = new d()), t.copy(this.startPoint) }, getTangent: function (t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), s = this.getCurveLengths(), n = 0; n < s.length;) { if (s[n] >= i) { const r = s[n] - i; const o = this.curves[n]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getTangentAt(h, e) } n++ } return null }, lineTo: function (t, e) { t instanceof d ? this._tmpVec2B.copy(t) : typeof t === 'object' ? this._tmpVec2B.setFromObject(t) : this._tmpVec2B.set(t, e); const i = this.getEndPoint(this._tmpVec2A); return this.add(new a([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y])) }, splineTo: function (t) { return t.unshift(this.getEndPoint()), this.add(new c(t)) }, moveTo: function (t, e) { return t instanceof d ? this.add(new h(t.x, t.y)) : this.add(new h(t, e)) }, toJSON: function () { for (var t = [], e = 0; e < this.curves.length; e++)t.push(this.curves[e].toJSON()); return { type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: t } }, updateArcLengths: function () { this.cacheLengths = [], this.getCurveLengths() }, destroy: function () { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0 } }); o.register('path', function (t, e) { return new p(t, e) }), t.exports = p }, 45893: (t, e, i) => { const s = i(83419); const n = i(24882); const r = new s({ initialize: function (t, e) { this.parent = t, this.events = e, e || (this.events = t.events ? t.events : t), this.list = {}, this.values = {}, this._frozen = !1, !t.hasOwnProperty('sys') && this.events && this.events.once(n.DESTROY, this.destroy, this) }, get: function (t) { const e = this.list; if (Array.isArray(t)) { for (var i = [], s = 0; s < t.length; s++)i.push(e[t[s]]); return i } return e[t] }, getAll: function () { const t = {}; for (const e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]); return t }, query: function (t) { const e = {}; for (const i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]); return e }, set: function (t, e) { if (this._frozen) return this; if (typeof t === 'string') return this.setValue(t, e); for (const i in t) this.setValue(i, t[i]); return this }, inc: function (t, e) { if (this._frozen) return this; void 0 === e && (e = 1); let i = this.get(t); return void 0 === i && (i = 0), this.set(t, i + e), this }, toggle: function (t) { return this._frozen || this.set(t, !this.get(t)), this }, setValue: function (t, e) { if (this._frozen) return this; if (this.has(t)) this.values[t] = e; else { const i = this; const s = this.list; const r = this.events; const o = this.parent; Object.defineProperty(this.values, t, { enumerable: !0, configurable: !0, get: function () { return s[t] }, set: function (e) { if (!i._frozen) { const a = s[t]; s[t] = e, r.emit(n.CHANGE_DATA, o, t, e, a), r.emit(n.CHANGE_DATA_KEY + t, o, e, a) } } }), s[t] = e, r.emit(n.SET_DATA, o, t, e) } return this }, each: function (t, e) { for (var i = [this.parent, null, void 0], s = 1; s < arguments.length; s++)i.push(arguments[s]); for (const n in this.list) i[1] = n, i[2] = this.list[n], t.apply(e, i); return this }, merge: function (t, e) { for (const i in void 0 === e && (e = !0), t) t.hasOwnProperty(i) && (e || !e && !this.has(i)) && this.setValue(i, t[i]); return this }, remove: function (t) { if (this._frozen) return this; if (!Array.isArray(t)) return this.removeValue(t); for (let e = 0; e < t.length; e++) this.removeValue(t[e]); return this }, removeValue: function (t) { if (this.has(t)) { const e = this.list[t]; delete this.list[t], delete this.values[t], this.events.emit(n.REMOVE_DATA, this.parent, t, e) } return this }, pop: function (t) { let e = void 0; return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(n.REMOVE_DATA, this.parent, t, e)), e }, has: function (t) { return this.list.hasOwnProperty(t) }, setFreeze: function (t) { return this._frozen = t, this }, reset: function () { for (const t in this.list) delete this.list[t], delete this.values[t]; return this._frozen = !1, this }, destroy: function () { this.reset(), this.events.off(n.CHANGE_DATA), this.events.off(n.SET_DATA), this.events.off(n.REMOVE_DATA), this.parent = null }, freeze: { get: function () { return this._frozen }, set: function (t) { this._frozen = !!t } }, count: { get: function () { let t = 0; for (const e in this.list) void 0 !== this.list[e] && t++; return t } } }); t.exports = r }, 63646: (t, e, i) => { const s = i(83419); const n = i(45893); const r = i(37277); const o = i(44594); const a = new s({ Extends: n, initialize: function (t) { n.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this) }, boot: function () { this.events = this.systems.events, this.events.once(o.DESTROY, this.destroy, this) }, start: function () { this.events.once(o.SHUTDOWN, this.shutdown, this) }, shutdown: function () { this.systems.events.off(o.SHUTDOWN, this.shutdown, this) }, destroy: function () { n.prototype.destroy.call(this), this.events.off(o.START, this.start, this), this.scene = null, this.systems = null } }); r.register('DataManagerPlugin', a, 'data'), t.exports = a }, 10700: t => { t.exports = 'changedata' }, 93608: t => { t.exports = 'changedata-' }, 60883: t => { t.exports = 'destroy' }, 69780: t => { t.exports = 'removedata' }, 22166: t => { t.exports = 'setdata' }, 24882: (t, e, i) => { t.exports = { CHANGE_DATA: i(10700), CHANGE_DATA_KEY: i(93608), DESTROY: i(60883), REMOVE_DATA: i(69780), SET_DATA: i(22166) } }, 44965: (t, e, i) => { t.exports = { DataManager: i(45893), DataManagerPlugin: i(63646), Events: i(24882) } }, 7098: (t, e, i) => { const s = i(84148); const n = { flac: !1, aac: !1, audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1 }; t.exports = (function () { if (typeof importScripts === 'function') return n; n.audioData = !!window.Audio, n.webAudio = !(!window.AudioContext && !window.webkitAudioContext); const t = document.createElement('audio'); const e = !!t.canPlayType; try { if (e) { const i = function (e, i) { const s = t.canPlayType('audio/' + e).replace(/^no$/, ''); return i ? Boolean(s || t.canPlayType('audio/' + i).replace(/^no$/, '')) : Boolean(s) }; if (n.ogg = i('ogg; codecs="vorbis"'), n.opus = i('ogg; codecs="opus"', 'opus'), n.mp3 = i('mpeg'), n.wav = i('wav'), n.m4a = i('x-m4a'), n.aac = i('aac'), n.flac = i('flac', 'x-flac'), n.webm = i('webm; codecs="vorbis"'), t.canPlayType('audio/mp4; codecs="ec-3"') !== '') if (s.edge) n.dolby = !0; else if (s.safari && s.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { const r = parseInt(RegExp.$1, 10); const o = parseInt(RegExp.$2, 10); (r === 10 && o >= 11 || r > 10) && (n.dolby = !0) } } } catch (t) { } return n }()) }, 84148: (t, e, i) => { let s; const n = i(25892); const r = { chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0, es2019: !1 }; t.exports = (s = navigator.userAgent, /Edg\/\d+/.test(s) ? (r.edge = !0, r.es2019 = !0) : /OPR/.test(s) ? (r.opera = !0, r.es2019 = !0) : /Chrome\/(\d+)/.test(s) && !n.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10), r.es2019 = r.chromeVersion > 69) : /Firefox\D+(\d+)/.test(s) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10), r.es2019 = r.firefoxVersion > 10) : /AppleWebKit\/(?!.*CriOS)/.test(s) && n.iOS ? (r.mobileSafari = !0, r.es2019 = !0) : /MSIE (\d+\.\d+);/.test(s) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Version\/(\d+\.\d+(\.\d+)?) Safari/.test(s) && !n.windowsPhone ? (r.safari = !0, r.safariVersion = parseInt(RegExp.$1, 10), r.es2019 = r.safariVersion > 10) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(s) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(s) && (r.silk = !0), r) }, 89289: (t, e, i) => { let s; let n; let r; const o = i(27919); const a = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; t.exports = (typeof importScripts !== 'function' && void 0 !== document && (a.supportNewBlendModes = (s = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/', n = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==', (r = new Image()).onload = function () { const t = new Image(); t.onload = function () { const e = o.create2D(t, 6).getContext('2d', { willReadFrequently: !0 }); if (e.globalCompositeOperation = 'multiply', e.drawImage(r, 0, 0), e.drawImage(t, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1; const i = e.getImageData(2, 0, 1, 1).data; o.remove(t), a.supportNewBlendModes = i[0] === 255 && i[1] === 0 && i[2] === 0 }, t.src = s + '/wCKxvRF' + n }, r.src = s + 'AP804Oa6' + n, !1), a.supportInverseAlpha = (function () { const t = o.create2D(this, 2).getContext('2d', { willReadFrequently: !0 }); t.fillStyle = 'rgba(10, 20, 30, 0.5)', t.fillRect(0, 0, 1, 1); const e = t.getImageData(0, 0, 1, 1); if (e === null) return !1; t.putImageData(e, 1, 0); const i = t.getImageData(1, 0, 1, 1); const s = i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]; return o.remove(this), s }())), a) }, 89357: (t, e, i) => { const s = i(25892); const n = i(84148); const r = i(27919); const o = { canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, stableSort: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1 }; t.exports = (function () { if (typeof importScripts === 'function') return o; o.canvas = !!window.CanvasRenderingContext2D; try { o.localStorage = !!localStorage.getItem } catch (t) { o.localStorage = !1 } o.file = !!(window.File && window.FileReader && window.FileList && window.Blob), o.fileSystem = !!window.requestFileSystem; let t; let e; let i; let a = !1; return o.webGL = (function () { if (window.WebGLRenderingContext) try { const t = r.createWebGL(this); const e = t.getContext('webgl') || t.getContext('experimental-webgl'); const i = r.create2D(this); const s = i.getContext('2d', { willReadFrequently: !0 }).createImageData(1, 1); return a = s.data instanceof Uint8ClampedArray, r.remove(t), r.remove(i), !!e } catch (t) { return !1 } return !1 }()), o.worker = !!window.Worker, o.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, n.firefox && n.firefoxVersion < 21 && (o.getUserMedia = !1), !s.iOS && (n.ie || n.firefox || n.chrome) && (o.canvasBitBltShift = !0), (n.safari || n.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (o.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, i[0] === 3569595041 || i[0] !== 2712847316 && null)), o.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && o.littleEndian !== null && a, o }()) }, 91639: t => { const e = { available: !1, cancel: '', keyboard: !1, request: '' }; t.exports = (function () { if (typeof importScripts === 'function') return e; let t; const i = 'Fullscreen'; const s = 'FullScreen'; const n = ['request' + i, 'request' + s, 'webkitRequest' + i, 'webkitRequest' + s, 'msRequest' + i, 'msRequest' + s, 'mozRequest' + s, 'mozRequest' + i]; for (t = 0; t < n.length; t++) if (document.documentElement[n[t]]) { e.available = !0, e.request = n[t]; break } const r = ['cancel' + s, 'exit' + i, 'webkitCancel' + s, 'webkitExit' + i, 'msCancel' + s, 'msExit' + i, 'mozCancel' + s, 'mozExit' + i]; if (e.available) for (t = 0; t < r.length; t++) if (document[r[t]]) { e.cancel = r[t]; break } return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (e.keyboard = !0), Object.defineProperty(e, 'active', { get: function () { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) } }), e }()) }, 31784: (t, e, i) => { const s = i(84148); const n = { gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null }; t.exports = (typeof importScripts === 'function' || (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (n.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (n.mspointer = !0), navigator.getGamepads && (n.gamepads = !0), 'onwheel' in window || s.ie && 'WheelEvent' in window ? n.wheelEvent = 'wheel' : 'onmousewheel' in window ? n.wheelEvent = 'mousewheel' : s.firefox && 'MouseScrollEvent' in window && (n.wheelEvent = 'DOMMouseScroll')), n) }, 25892: t => { const e = { android: !1, chromeOS: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1 }; t.exports = (function () { if (typeof importScripts === 'function') return e; const t = navigator.userAgent; /Windows/.test(t) ? e.windows = !0 : /Mac OS/.test(t) && !/like Mac OS/.test(t) ? navigator.maxTouchPoints && navigator.maxTouchPoints > 2 ? (e.iOS = !0, e.iPad = !0, navigator.appVersion.match(/Version\/(\d+)/), e.iOSVersion = parseInt(RegExp.$1, 10)) : e.macOS = !0 : /Android/.test(t) ? e.android = !0 : /Linux/.test(t) ? e.linux = !0 : /iP[ao]d|iPhone/i.test(t) ? (e.iOS = !0, navigator.appVersion.match(/OS (\d+)/), e.iOSVersion = parseInt(RegExp.$1, 10), e.iPhone = t.toLowerCase().indexOf('iphone') !== -1, e.iPad = t.toLowerCase().indexOf('ipad') !== -1) : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? e.kindle = !0 : /CrOS/.test(t) && (e.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (e.android = !1, e.iOS = !1, e.macOS = !1, e.windows = !0, e.windowsPhone = !0); const i = /Silk/.test(t); return (e.windows || e.macOS || e.linux && !i || e.chromeOS) && (e.desktop = !0), (e.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (e.desktop = !1), navigator.standalone && (e.webApp = !0), typeof importScripts !== 'function' && (void 0 !== window.cordova && (e.cordova = !0), void 0 !== window.ejecta && (e.ejecta = !0)), typeof process !== 'undefined' && process.versions && process.versions.node && (e.node = !0), e.node && typeof process.versions === 'object' && (e.nodeWebkit = !!process.versions['node-webkit'], e.electron = !!process.versions.electron), /Crosswalk/.test(t) && (e.crosswalk = !0), e.pixelRatio = window.devicePixelRatio || 1, e }()) }, 43267: (t, e, i) => { const s = i(95540); const n = { h264: !1, hls: !1, mp4: !1, m4v: !1, ogg: !1, vp9: !1, webm: !1, hasRequestVideoFrame: !1 }; t.exports = (function () { if (typeof importScripts === 'function') return n; const t = document.createElement('video'); const e = !!t.canPlayType; const i = /^no$/; try { e && (t.canPlayType('video/ogg; codecs="theora"').replace(i, '') && (n.ogg = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(i, '') && (n.h264 = !0, n.mp4 = !0), t.canPlayType('video/x-m4v').replace(i, '') && (n.m4v = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(i, '') && (n.webm = !0), t.canPlayType('video/webm; codecs="vp9"').replace(i, '') && (n.vp9 = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(i, '') && (n.hls = !0)) } catch (t) { } return t.parentNode && t.parentNode.removeChild(t), n.getVideoURL = function (t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { var i; const r = s(t[e], 'url', t[e]); if (r.indexOf('blob:') === 0) return { url: r, type: '' }; if (i = r.indexOf('data:') === 0 ? r.split(',')[0].match(/\/(.*?);/) : r.match(/\.([a-zA-Z0-9]+)($|\?)/), i = s(t[e], 'type', i ? i[1] : '').toLowerCase(), n[i]) return { url: r, type: i } } return null }, n }()) }, 82264: (t, e, i) => { t.exports = { os: i(25892), browser: i(84148), features: i(89357), input: i(31784), audio: i(7098), video: i(43267), fullscreen: i(91639), canvasFeatures: i(89289) } }, 89422: (t, e, i) => { const s = i(83419); const n = new Float32Array(20); var r = new s({ initialize: function () { this._matrix = new Float32Array(20), this.alpha = 1, this._dirty = !0, this._data = new Float32Array(20), this.reset() }, set: function (t) { return this._matrix.set(t), this._dirty = !0, this }, reset: function () { const t = this._matrix; return t.fill(0), t[0] = 1, t[6] = 1, t[12] = 1, t[18] = 1, this.alpha = 1, this._dirty = !0, this }, getData: function () { const t = this._data; return this._dirty && (t.set(this._matrix), t[4] /= 255, t[9] /= 255, t[14] /= 255, t[19] /= 255, this._dirty = !1), t }, brightness: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = !1); const i = t; return this.multiply([i, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, i, 0, 0, 0, 0, 0, 1, 0], e) }, saturate: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = !1); const i = 2 * t / 3 + 1; const s = -0.5 * (i - 1); return this.multiply([i, s, s, 0, 0, s, i, s, 0, 0, s, s, i, 0, 0, 0, 0, 0, 1, 0], e) }, desaturate: function (t) { return void 0 === t && (t = !1), this.saturate(-1, t) }, hue: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = !1), t = t / 180 * Math.PI; const i = Math.cos(t); const s = Math.sin(t); const n = 0.213; const r = 0.715; const o = 0.072; return this.multiply([n + 0.787 * i + s * -n, r + i * -r + s * -r, o + i * -o + 0.928 * s, 0, 0, n + i * -n + 0.143 * s, r + i * (1 - r) + 0.14 * s, o + i * -o + -0.283 * s, 0, 0, n + i * -n + -0.787 * s, r + i * -r + s * r, o + 0.928 * i + s * o, 0, 0, 0, 0, 0, 1, 0], e) }, grayscale: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = !1), this.saturate(-t, e) }, blackWhite: function (t) { return void 0 === t && (t = !1), this.multiply(r.BLACK_WHITE, t) }, contrast: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = !1); const i = t + 1; const s = -0.5 * (i - 1); return this.multiply([i, 0, 0, 0, s, 0, i, 0, 0, s, 0, 0, i, 0, s, 0, 0, 0, 1, 0], e) }, negative: function (t) { return void 0 === t && (t = !1), this.multiply(r.NEGATIVE, t) }, desaturateLuminance: function (t) { return void 0 === t && (t = !1), this.multiply(r.DESATURATE_LUMINANCE, t) }, sepia: function (t) { return void 0 === t && (t = !1), this.multiply(r.SEPIA, t) }, night: function (t, e) { return void 0 === t && (t = 0.1), void 0 === e && (e = !1), this.multiply([-2 * t, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0], e) }, lsd: function (t) { return void 0 === t && (t = !1), this.multiply(r.LSD, t) }, brown: function (t) { return void 0 === t && (t = !1), this.multiply(r.BROWN, t) }, vintagePinhole: function (t) { return void 0 === t && (t = !1), this.multiply(r.VINTAGE, t) }, kodachrome: function (t) { return void 0 === t && (t = !1), this.multiply(r.KODACHROME, t) }, technicolor: function (t) { return void 0 === t && (t = !1), this.multiply(r.TECHNICOLOR, t) }, polaroid: function (t) { return void 0 === t && (t = !1), this.multiply(r.POLAROID, t) }, shiftToBGR: function (t) { return void 0 === t && (t = !1), this.multiply(r.SHIFT_BGR, t) }, multiply: function (t, e) { void 0 === e && (e = !1), e || this.reset(); const i = this._matrix; const s = n; return s.set(i), i.set([s[0] * t[0] + s[1] * t[5] + s[2] * t[10] + s[3] * t[15], s[0] * t[1] + s[1] * t[6] + s[2] * t[11] + s[3] * t[16], s[0] * t[2] + s[1] * t[7] + s[2] * t[12] + s[3] * t[17], s[0] * t[3] + s[1] * t[8] + s[2] * t[13] + s[3] * t[18], s[0] * t[4] + s[1] * t[9] + s[2] * t[14] + s[3] * t[19] + s[4], s[5] * t[0] + s[6] * t[5] + s[7] * t[10] + s[8] * t[15], s[5] * t[1] + s[6] * t[6] + s[7] * t[11] + s[8] * t[16], s[5] * t[2] + s[6] * t[7] + s[7] * t[12] + s[8] * t[17], s[5] * t[3] + s[6] * t[8] + s[7] * t[13] + s[8] * t[18], s[5] * t[4] + s[6] * t[9] + s[7] * t[14] + s[8] * t[19] + s[9], s[10] * t[0] + s[11] * t[5] + s[12] * t[10] + s[13] * t[15], s[10] * t[1] + s[11] * t[6] + s[12] * t[11] + s[13] * t[16], s[10] * t[2] + s[11] * t[7] + s[12] * t[12] + s[13] * t[17], s[10] * t[3] + s[11] * t[8] + s[12] * t[13] + s[13] * t[18], s[10] * t[4] + s[11] * t[9] + s[12] * t[14] + s[13] * t[19] + s[14], s[15] * t[0] + s[16] * t[5] + s[17] * t[10] + s[18] * t[15], s[15] * t[1] + s[16] * t[6] + s[17] * t[11] + s[18] * t[16], s[15] * t[2] + s[16] * t[7] + s[17] * t[12] + s[18] * t[17], s[15] * t[3] + s[16] * t[8] + s[17] * t[13] + s[18] * t[18], s[15] * t[4] + s[16] * t[9] + s[17] * t[14] + s[18] * t[19] + s[19]]), this._dirty = !0, this } }); r.BLACK_WHITE = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], r.NEGATIVE = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], r.DESATURATE_LUMINANCE = [0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0.2764723, 0.929708, 0.0938197, 0, -37.1, 0, 0, 0, 1, 0], r.SEPIA = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], r.LSD = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], r.BROWN = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], r.VINTAGE = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], r.KODACHROME = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], r.TECHNICOLOR = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], r.POLAROID = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], r.SHIFT_BGR = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t.exports = r }, 51767: (t, e, i) => { const s = i(83419); const n = i(29747); const r = new s({ initialize: function (t, e, i) { this._rgb = [0, 0, 0], this.onChangeCallback = n, this.dirty = !1, this.set(t, e, i) }, set: function (t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this._rgb = [t, e, i], this.onChange(), this }, equals: function (t, e, i) { const s = this._rgb; return s[0] === t && s[1] === e && s[2] === i }, onChange: function () { this.dirty = !0; const t = this._rgb; this.onChangeCallback.call(this, t[0], t[1], t[2]) }, r: { get: function () { return this._rgb[0] }, set: function (t) { this._rgb[0] = t, this.onChange() } }, g: { get: function () { return this._rgb[1] }, set: function (t) { this._rgb[1] = t, this.onChange() } }, b: { get: function () { return this._rgb[2] }, set: function (t) { this._rgb[2] = t, this.onChange() } }, destroy: function () { this.onChangeCallback = null } }); t.exports = r }, 60461: t => { t.exports = { TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12 } }, 54312: (t, e, i) => { const s = i(62235); const n = i(35893); const r = i(86327); const o = i(88417); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) + a), t } }, 46768: (t, e, i) => { const s = i(62235); const n = i(26541); const r = i(86327); const o = i(385); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) + a), t } }, 35827: (t, e, i) => { const s = i(62235); const n = i(54380); const r = i(86327); const o = i(40136); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) + a), t } }, 46871: (t, e, i) => { const s = i(66786); const n = i(35893); const r = i(7702); t.exports = function (t, e, i, o) { return void 0 === i && (i = 0), void 0 === o && (o = 0), s(t, n(e) + i, r(e) + o), t } }, 5198: (t, e, i) => { const s = i(7702); const n = i(26541); const r = i(20786); const o = i(385); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) + a), t } }, 11879: (t, e, i) => { const s = i(60461); const n = []; n[s.BOTTOM_CENTER] = i(54312), n[s.BOTTOM_LEFT] = i(46768), n[s.BOTTOM_RIGHT] = i(35827), n[s.CENTER] = i(46871), n[s.LEFT_CENTER] = i(5198), n[s.RIGHT_CENTER] = i(80503), n[s.TOP_CENTER] = i(89698), n[s.TOP_LEFT] = i(922), n[s.TOP_RIGHT] = i(21373), n[s.LEFT_BOTTOM] = n[s.BOTTOM_LEFT], n[s.LEFT_TOP] = n[s.TOP_LEFT], n[s.RIGHT_BOTTOM] = n[s.BOTTOM_RIGHT], n[s.RIGHT_TOP] = n[s.TOP_RIGHT]; t.exports = function (t, e, i, s, r) { return n[i](t, e, s, r) } }, 80503: (t, e, i) => { const s = i(7702); const n = i(54380); const r = i(20786); const o = i(40136); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) + a), t } }, 89698: (t, e, i) => { const s = i(35893); const n = i(17717); const r = i(88417); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) - a), t } }, 922: (t, e, i) => { const s = i(26541); const n = i(17717); const r = i(385); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) - a), t } }, 21373: (t, e, i) => { const s = i(54380); const n = i(17717); const r = i(40136); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) - a), t } }, 91660: (t, e, i) => { t.exports = { BottomCenter: i(54312), BottomLeft: i(46768), BottomRight: i(35827), Center: i(46871), LeftCenter: i(5198), QuickSet: i(11879), RightCenter: i(80503), TopCenter: i(89698), TopLeft: i(922), TopRight: i(21373) } }, 71926: (t, e, i) => { const s = i(60461); const n = i(79291); let r = { In: i(91660), To: i(16694) }; r = n(!1, r, s), t.exports = r }, 21578: (t, e, i) => { const s = i(62235); const n = i(35893); const r = i(88417); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) + a), t } }, 10210: (t, e, i) => { const s = i(62235); const n = i(26541); const r = i(385); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) + a), t } }, 82341: (t, e, i) => { const s = i(62235); const n = i(54380); const r = i(40136); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) + a), t } }, 87958: (t, e, i) => { const s = i(62235); const n = i(26541); const r = i(86327); const o = i(40136); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) + a), t } }, 40080: (t, e, i) => { const s = i(7702); const n = i(26541); const r = i(20786); const o = i(40136); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) + a), t } }, 88466: (t, e, i) => { const s = i(26541); const n = i(17717); const r = i(40136); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) - a), t } }, 38829: (t, e, i) => { const s = i(60461); const n = []; n[s.BOTTOM_CENTER] = i(21578), n[s.BOTTOM_LEFT] = i(10210), n[s.BOTTOM_RIGHT] = i(82341), n[s.LEFT_BOTTOM] = i(87958), n[s.LEFT_CENTER] = i(40080), n[s.LEFT_TOP] = i(88466), n[s.RIGHT_BOTTOM] = i(19211), n[s.RIGHT_CENTER] = i(34609), n[s.RIGHT_TOP] = i(48741), n[s.TOP_CENTER] = i(49440), n[s.TOP_LEFT] = i(81288), n[s.TOP_RIGHT] = i(61323); t.exports = function (t, e, i, s, r) { return n[i](t, e, s, r) } }, 19211: (t, e, i) => { const s = i(62235); const n = i(54380); const r = i(86327); const o = i(385); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) + a), t } }, 34609: (t, e, i) => { const s = i(7702); const n = i(54380); const r = i(20786); const o = i(385); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) + a), t } }, 48741: (t, e, i) => { const s = i(54380); const n = i(17717); const r = i(385); const o = i(66737); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) - a), t } }, 49440: (t, e, i) => { const s = i(35893); const n = i(17717); const r = i(86327); const o = i(88417); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) - a), t } }, 81288: (t, e, i) => { const s = i(26541); const n = i(17717); const r = i(86327); const o = i(385); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) - a), t } }, 61323: (t, e, i) => { const s = i(54380); const n = i(17717); const r = i(86327); const o = i(40136); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) - a), t } }, 16694: (t, e, i) => { t.exports = { BottomCenter: i(21578), BottomLeft: i(10210), BottomRight: i(82341), LeftBottom: i(87958), LeftCenter: i(40080), LeftTop: i(88466), QuickSet: i(38829), RightBottom: i(19211), RightCenter: i(34609), RightTop: i(48741), TopCenter: i(49440), TopLeft: i(81288), TopRight: i(61323) } }, 66786: (t, e, i) => { const s = i(88417); const n = i(20786); t.exports = function (t, e, i) { return s(t, e), n(t, i) } }, 62235: t => { t.exports = function (t) { return t.y + t.height - t.height * t.originY } }, 72873: (t, e, i) => { const s = i(62235); const n = i(26541); const r = i(54380); const o = i(17717); const a = i(87841); t.exports = function (t, e) { void 0 === e && (e = new a()); const i = n(t); const h = o(t); return e.x = i, e.y = h, e.width = r(t) - i, e.height = s(t) - h, e } }, 35893: t => { t.exports = function (t) { return t.x - t.width * t.originX + 0.5 * t.width } }, 7702: t => { t.exports = function (t) { return t.y - t.height * t.originY + 0.5 * t.height } }, 26541: t => { t.exports = function (t) { return t.x - t.width * t.originX } }, 87431: t => { t.exports = function (t) { return t.width * t.originX } }, 46928: t => { t.exports = function (t) { return t.height * t.originY } }, 54380: t => { t.exports = function (t) { return t.x + t.width - t.width * t.originX } }, 17717: t => { t.exports = function (t) { return t.y - t.height * t.originY } }, 86327: t => { t.exports = function (t, e) { return t.y = e - t.height + t.height * t.originY, t } }, 88417: t => { t.exports = function (t, e) { const i = t.width * t.originX; return t.x = e + i - 0.5 * t.width, t } }, 20786: t => { t.exports = function (t, e) { const i = t.height * t.originY; return t.y = e + i - 0.5 * t.height, t } }, 385: t => { t.exports = function (t, e) { return t.x = e + t.width * t.originX, t } }, 40136: t => { t.exports = function (t, e) { return t.x = e - t.width + t.width * t.originX, t } }, 66737: t => { t.exports = function (t, e) { return t.y = e + t.height * t.originY, t } }, 58724: (t, e, i) => { t.exports = { CenterOn: i(66786), GetBottom: i(62235), GetBounds: i(72873), GetCenterX: i(35893), GetCenterY: i(7702), GetLeft: i(26541), GetOffsetX: i(87431), GetOffsetY: i(46928), GetRight: i(54380), GetTop: i(17717), SetBottom: i(86327), SetCenterX: i(88417), SetCenterY: i(20786), SetLeft: i(385), SetRight: i(40136), SetTop: i(66737) } }, 20623: t => { t.exports = { setCrisp: function (t) { return ['optimizeSpeed', '-moz-crisp-edges', '-o-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'crisp-edges', 'pixelated'].forEach(function (e) { t.style['image-rendering'] = e }), t.style.msInterpolationMode = 'nearest-neighbor', t }, setBicubic: function (t) { return t.style['image-rendering'] = 'auto', t.style.msInterpolationMode = 'bicubic', t } } }, 27919: (t, e, i) => { let s; let n; let r; const o = i(8054); const a = i(68703); const h = []; let l = !1; t.exports = (r = function () { let t = 0; return h.forEach(function (e) { e.parent && t++ }), t }, { create2D: function (t, e, i) { return s(t, e, i, o.CANVAS) }, create: s = function (t, e, i, s, r) { let u; void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = o.CANVAS), void 0 === r && (r = !1); let c = n(s); return c === null ? (c = { parent: t, canvas: document.createElement('canvas'), type: s }, s === o.CANVAS && h.push(c), u = c.canvas) : (c.parent = t, u = c.canvas), r && (c.parent = u), u.width = e, u.height = i, l && s === o.CANVAS && a.disable(u.getContext('2d', { willReadFrequently: !1 })), u }, createWebGL: function (t, e, i) { return s(t, e, i, o.WEBGL) }, disableSmoothing: function () { l = !0 }, enableSmoothing: function () { l = !1 }, first: n = function (t) { if (void 0 === t && (t = o.CANVAS), t === o.WEBGL) return null; for (let e = 0; e < h.length; e++) { const i = h[e]; if (!i.parent && i.type === t) return i } return null }, free: function () { return h.length - r() }, pool: h, remove: function (t) { const e = t instanceof HTMLCanvasElement; h.forEach(function (i) { (e && i.canvas === t || !e && i.parent === t) && (i.parent = null, i.canvas.width = 1, i.canvas.height = 1) }) }, total: r }) }, 68703: t => { let e; let i = ''; t.exports = { disable: function (t) { return i === '' && (i = e(t)), i && (t[i] = !1), t }, enable: function (t) { return i === '' && (i = e(t)), i && (t[i] = !0), t }, getPrefix: e = function (t) { for (let e = ['i', 'webkitI', 'msI', 'mozI', 'oI'], i = 0; i < e.length; i++) { const s = e[i] + 'mageSmoothingEnabled'; if (s in t) return s } return null }, isEnabled: function (t) { return i !== null ? t[i] : null } } }, 65208: t => { t.exports = function (t, e) { return void 0 === e && (e = 'none'), t.style.msTouchAction = e, t.style['ms-touch-action'] = e, t.style['touch-action'] = e, t } }, 91610: t => { t.exports = function (t, e) { void 0 === e && (e = 'none'); return ['-webkit-', '-khtml-', '-moz-', '-ms-', ''].forEach(function (i) { t.style[i + 'user-select'] = e }), t.style['-webkit-touch-callout'] = e, t.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', t } }, 26253: (t, e, i) => { t.exports = { CanvasInterpolation: i(20623), CanvasPool: i(27919), Smoothing: i(68703), TouchAction: i(65208), UserSelect: i(91610) } }, 40987: (t, e, i) => { const s = i(83419); const n = i(37589); const r = i(1e3); const o = i(7537); const a = i(87837); var h = new s({ initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(t, e, i, s) }, transparent: function () { return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0) }, setTo: function (t, e, i, s, n) { return void 0 === s && (s = 255), void 0 === n && (n = !0), this._locked = !0, this.red = t, this.green = e, this.blue = i, this.alpha = s, this._locked = !1, this.update(n) }, setGLTo: function (t, e, i, s) { return void 0 === s && (s = 1), this._locked = !0, this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = s, this._locked = !1, this.update(!0) }, setFromRGB: function (t) { return this._locked = !0, this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty('a') && (this.alpha = t.a), this._locked = !1, this.update(!0) }, setFromHSV: function (t, e, i) { return o(t, e, i, this) }, update: function (t) { if (void 0 === t && (t = !1), this._locked) return this; const e = this.r; const i = this.g; const s = this.b; const o = this.a; return this._color = n(e, i, s), this._color32 = r(e, i, s, o), this._rgba = 'rgba(' + e + ',' + i + ',' + s + ',' + o / 255 + ')', t && a(e, i, s, this), this }, updateHSV: function () { const t = this.r; const e = this.g; const i = this.b; return a(t, e, i, this), this }, clone: function () { return new h(this.r, this.g, this.b, this.a) }, gray: function (t) { return this.setTo(t, t, t) }, random: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); const s = Math.floor(t + Math.random() * (e - t)); const n = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, s, n) }, randomGray: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, i, i) }, saturate: function (t) { return this.s += t / 100, this }, desaturate: function (t) { return this.s -= t / 100, this }, lighten: function (t) { return this.v += t / 100, this }, darken: function (t) { return this.v -= t / 100, this }, brighten: function (t) { let e = this.r; let i = this.g; let s = this.b; return e = Math.max(0, Math.min(255, e - Math.round(-t / 100 * 255))), i = Math.max(0, Math.min(255, i - Math.round(-t / 100 * 255))), s = Math.max(0, Math.min(255, s - Math.round(-t / 100 * 255))), this.setTo(e, i, s) }, color: { get: function () { return this._color } }, color32: { get: function () { return this._color32 } }, rgba: { get: function () { return this._rgba } }, redGL: { get: function () { return this.gl[0] }, set: function (t) { this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0) } }, greenGL: { get: function () { return this.gl[1] }, set: function (t) { this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0) } }, blueGL: { get: function () { return this.gl[2] }, set: function (t) { this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0) } }, alphaGL: { get: function () { return this.gl[3] }, set: function (t) { this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update() } }, red: { get: function () { return this.r }, set: function (t) { t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(!0) } }, green: { get: function () { return this.g }, set: function (t) { t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(!0) } }, blue: { get: function () { return this.b }, set: function (t) { t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(!0) } }, alpha: { get: function () { return this.a }, set: function (t) { t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update() } }, h: { get: function () { return this._h }, set: function (t) { this._h = t, o(t, this._s, this._v, this) } }, s: { get: function () { return this._s }, set: function (t) { this._s = t, o(this._h, t, this._v, this) } }, v: { get: function () { return this._v }, set: function (t) { this._v = t, o(this._h, this._s, t, this) } } }); t.exports = h }, 92728: (t, e, i) => { const s = i(37589); t.exports = function (t) { void 0 === t && (t = 1024); let e; const i = []; const n = 255; let r = 255; let o = 0; let a = 0; for (e = 0; e <= n; e++)i.push({ r, g: e, b: a, color: s(r, e, a) }); for (o = 255, e = n; e >= 0; e--)i.push({ r: e, g: o, b: a, color: s(e, o, a) }); for (r = 0, e = 0; e <= n; e++, o--)i.push({ r, g: o, b: e, color: s(r, o, e) }); for (o = 0, a = 255, e = 0; e <= n; e++, a--, r++)i.push({ r, g: o, b: a, color: s(r, o, a) }); if (t === 1024) return i; const h = []; let l = 0; const u = 1024 / t; for (e = 0; e < t; e++)h.push(i[Math.floor(l)]), l += u; return h } }, 91588: t => { t.exports = function (t) { const e = { r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t, a: 255 }; return t > 16777215 && (e.a = t >>> 24), e } }, 62957: t => { t.exports = function (t) { const e = t.toString(16); return e.length === 1 ? '0' + e : e } }, 37589: t => { t.exports = function (t, e, i) { return t << 16 | e << 8 | i } }, 1e3: t => { t.exports = function (t, e, i, s) { return s << 24 | t << 16 | e << 8 | i } }, 62183: (t, e, i) => { const s = i(40987); const n = i(89528); t.exports = function (t, e, i) { let r = i; let o = i; let a = i; if (e !== 0) { const h = i < 0.5 ? i * (1 + e) : i + e - i * e; const l = 2 * i - h; r = n(l, h, t + 1 / 3), o = n(l, h, t), a = n(l, h, t - 1 / 3) } return (new s()).setGLTo(r, o, a, 1) } }, 27939: (t, e, i) => { const s = i(7537); t.exports = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var i = [], n = 0; n <= 359; n++)i.push(s(n / 359, t, e)); return i } }, 7537: (t, e, i) => { const s = i(37589); function n (t, e, i, s) { const n = (t + 6 * e) % 6; const r = Math.min(n, 4 - n, 1); return Math.round(255 * (s - s * i * Math.max(0, r))) } t.exports = function (t, e, i, r) { void 0 === e && (e = 1), void 0 === i && (i = 1); const o = n(5, t, e, i); const a = n(3, t, e, i); const h = n(1, t, e, i); return r ? r.setTo ? r.setTo(o, a, h, r.alpha, !0) : (r.r = o, r.g = a, r.b = h, r.color = s(o, a, h), r) : { r: o, g: a, b: h, color: s(o, a, h) } } }, 70238: (t, e, i) => { const s = i(40987); t.exports = function (t) { const e = new s(); t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function (t, e, i, s) { return e + e + i + i + s + s }); const i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); if (i) { const n = parseInt(i[1], 16); const r = parseInt(i[2], 16); const o = parseInt(i[3], 16); e.setTo(n, r, o) } return e } }, 89528: t => { t.exports = function (t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t } }, 30100: (t, e, i) => { const s = i(40987); const n = i(90664); t.exports = function (t) { const e = n(t); return new s(e.r, e.g, e.b, e.a) } }, 90664: t => { t.exports = function (t) { return t > 16777215 ? { a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t } : { a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t } } }, 13699: (t, e, i) => { const s = i(28915); const n = function (t, e, i, n, r, o, a, h) { void 0 === a && (a = 100), void 0 === h && (h = 0); const l = h / a; return { r: s(t, n, l), g: s(e, r, l), b: s(i, o, l) } }; t.exports = { RGBWithRGB: n, ColorWithRGB: function (t, e, i, s, r, o) { return void 0 === r && (r = 100), void 0 === o && (o = 0), n(t.r, t.g, t.b, e, i, s, r, o) }, ColorWithColor: function (t, e, i, s) { return void 0 === i && (i = 100), void 0 === s && (s = 0), n(t.r, t.g, t.b, e.r, e.g, e.b, i, s) } } }, 68957: (t, e, i) => { const s = i(40987); t.exports = function (t) { return new s(t.r, t.g, t.b, t.a) } }, 87388: (t, e, i) => { const s = i(40987); t.exports = function (t) { const e = new s(); const i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase()); if (i) { const n = parseInt(i[1], 10); const r = parseInt(i[2], 10); const o = parseInt(i[3], 10); const a = void 0 !== i[4] ? parseFloat(i[4]) : 1; e.setTo(n, r, o, 255 * a) } return e } }, 87837: t => { t.exports = function (t, e, i, s) { void 0 === s && (s = { h: 0, s: 0, v: 0 }), t /= 255, e /= 255, i /= 255; const n = Math.min(t, e, i); const r = Math.max(t, e, i); const o = r - n; let a = 0; const h = r === 0 ? 0 : o / r; const l = r; return r !== n && (r === t ? a = (e - i) / o + (e < i ? 6 : 0) : r === e ? a = (i - t) / o + 2 : r === i && (a = (t - e) / o + 4), a /= 6), s.hasOwnProperty('_h') ? (s._h = a, s._s = h, s._v = l) : (s.h = a, s.s = h, s.v = l), s } }, 75723: (t, e, i) => { const s = i(62957); t.exports = function (t, e, i, n, r) { return void 0 === n && (n = 255), void 0 === r && (r = '#'), r === '#' ? '#' + ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1, 7) : '0x' + s(n) + s(t) + s(e) + s(i) } }, 85386: (t, e, i) => { const s = i(30976); const n = i(40987); t.exports = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 255), new n(s(t, e), s(t, e), s(t, e)) } }, 80333: (t, e, i) => { const s = i(70238); const n = i(30100); const r = i(68957); const o = i(87388); t.exports = function (t) { switch (typeof t) { case 'string': return t.substr(0, 3).toLowerCase() === 'rgb' ? o(t) : s(t); case 'number': return n(t); case 'object': return r(t) } } }, 3956: (t, e, i) => { const s = i(40987); s.ColorSpectrum = i(92728), s.ColorToRGBA = i(91588), s.ComponentToHex = i(62957), s.GetColor = i(37589), s.GetColor32 = i(1e3), s.HexStringToColor = i(70238), s.HSLToColor = i(62183), s.HSVColorWheel = i(27939), s.HSVToRGB = i(7537), s.HueToComponent = i(89528), s.IntegerToColor = i(30100), s.IntegerToRGB = i(90664), s.Interpolate = i(13699), s.ObjectToColor = i(68957), s.RandomRGB = i(85386), s.RGBStringToColor = i(87388), s.RGBToHSV = i(87837), s.RGBToString = i(75723), s.ValueToColor = i(80333), t.exports = s }, 27460: (t, e, i) => { t.exports = { Align: i(71926), BaseShader: i(73894), Bounds: i(58724), Canvas: i(26253), Color: i(3956), ColorMatrix: i(89422), Masks: i(69781), RGB: i(51767) } }, 6858: (t, e, i) => { const s = i(83419); const n = i(39429); const r = new s({ initialize: function (t, e, i, s, n, r) { e || (e = t.sys.make.image({ x: i, y: s, key: n, frame: r, add: !1 })), this.bitmapMask = e, this.invertAlpha = !1, this.isStencil = !1 }, setBitmap: function (t) { this.bitmapMask = t }, preRenderWebGL: function (t, e, i) { t.pipelines.BITMAPMASK_PIPELINE.beginMask(this, e, i) }, postRenderWebGL: function (t, e, i) { t.pipelines.BITMAPMASK_PIPELINE.endMask(this, e, i) }, preRenderCanvas: function () { }, postRenderCanvas: function () { }, destroy: function () { this.bitmapMask = null } }); n.register('bitmapMask', function (t, e, i, s, n) { return new r(this.scene, t, e, i, s, n) }), t.exports = r }, 80661: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e) { this.geometryMask = e, this.invertAlpha = !1, this.isStencil = !0, this.level = 0 }, setShape: function (t) { return this.geometryMask = t, this }, setInvertAlpha: function (t) { return void 0 === t && (t = !0), this.invertAlpha = t, this }, preRenderWebGL: function (t, e, i) { const s = t.gl; t.flush(), t.maskStack.length === 0 && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), t.maskCount = 0), t.currentCameraMask.mask !== this && (t.currentMask.mask = this), t.maskStack.push({ mask: this, camera: i }), this.applyStencil(t, i, !0), t.maskCount++ }, applyStencil: function (t, e, i) { const s = t.gl; const n = this.geometryMask; let r = t.maskCount; const o = 255; s.colorMask(!1, !1, !1, !1), i ? (s.stencilFunc(s.EQUAL, r, o), s.stencilOp(s.KEEP, s.KEEP, s.INCR), r++) : (s.stencilFunc(s.EQUAL, r + 1, o), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), this.level = r, n.renderWebGL(t, n, e), t.flush(), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.invertAlpha ? s.stencilFunc(s.NOTEQUAL, r, o) : s.stencilFunc(s.EQUAL, r, o) }, postRenderWebGL: function (t) { const e = t.gl; t.maskStack.pop(), t.maskCount--, t.flush(); const i = t.currentMask; if (t.maskStack.length === 0) i.mask = null, e.disable(e.STENCIL_TEST); else { const s = t.maskStack[t.maskStack.length - 1]; s.mask.applyStencil(t, s.camera, !1), t.currentCameraMask.mask !== s.mask ? (i.mask = s.mask, i.camera = s.camera) : i.mask = null } }, preRenderCanvas: function (t, e, i) { const s = this.geometryMask; t.currentContext.save(), s.renderCanvas(t, s, i, null, null, !0), t.currentContext.clip() }, postRenderCanvas: function (t) { t.currentContext.restore() }, destroy: function () { this.geometryMask = null } }); t.exports = s }, 69781: (t, e, i) => { t.exports = { BitmapMask: i(6858), GeometryMask: i(80661) } }, 73894: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s) { e && e !== '' || (e = ['precision mediump float;', 'uniform vec2 resolution;', 'varying vec2 fragCoord;', 'void main () {', '    vec2 uv = fragCoord / resolution.xy;', '    gl_FragColor = vec4(uv.xyx, 1.0);', '}'].join('\n')), i && i !== '' || (i = ['precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'varying vec2 fragCoord;', 'varying vec2 outTexCoord;', 'void main () {', '   gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);', '   fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);', '   outTexCoord = vec2(inPosition.x / uResolution.x, fragCoord.y / uResolution.y);', '}'].join('\n')), void 0 === s && (s = null), this.key = t, this.fragmentSrc = e, this.vertexSrc = i, this.uniforms = s } }); t.exports = s }, 40366: t => { t.exports = function (t, e) { let i; if (e) typeof e === 'string' ? i = document.getElementById(e) : typeof e === 'object' && e.nodeType === 1 && (i = e); else if (t.parentElement || e === null) return t; return i || (i = document.body), i.appendChild(t), t } }, 83719: (t, e, i) => { const s = i(40366); t.exports = function (t) { const e = t.config; if (e.parent && e.domCreateContainer) { const i = document.createElement('div'); i.style.cssText = ['display: block;', 'width: ' + t.scale.width + 'px;', 'height: ' + t.scale.height + 'px;', 'padding: 0; margin: 0;', 'position: absolute;', 'overflow: hidden;', 'pointer-events: ' + e.domPointerEvents + ';', 'transform: scale(1);', 'transform-origin: left top;'].join(' '), t.domContainer = i, s(i, e.parent) } } }, 57264: (t, e, i) => { const s = i(25892); t.exports = function (t) { if (document.readyState !== 'complete' && document.readyState !== 'interactive') { const e = function () { document.removeEventListener('deviceready', e, !0), document.removeEventListener('DOMContentLoaded', e, !0), window.removeEventListener('load', e, !0), t() }; document.body ? s.cordova ? document.addEventListener('deviceready', e, !1) : (document.addEventListener('DOMContentLoaded', e, !0), window.addEventListener('load', e, !0)) : window.setTimeout(e, 20) } else t() } }, 57811: t => { t.exports = function (t) { if (!t) return window.innerHeight; const e = Math.abs(window.orientation); const i = { w: 0, h: 0 }; let s = document.createElement('div'); return s.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0'), document.documentElement.appendChild(s), i.w = e === 90 ? s.offsetHeight : window.innerWidth, i.h = e === 90 ? window.innerWidth : s.offsetHeight, document.documentElement.removeChild(s), s = null, Math.abs(window.orientation) !== 90 ? i.h : i.w } }, 45818: (t, e, i) => { const s = i(13560); t.exports = function (t, e) { const i = window.screen; const n = !!i && (i.orientation || i.mozOrientation || i.msOrientation); return n && typeof n.type === 'string' ? n.type : typeof n === 'string' ? n : typeof window.orientation === 'number' ? window.orientation === 0 || window.orientation === 180 ? s.ORIENTATION.PORTRAIT : s.ORIENTATION.LANDSCAPE : window.matchMedia ? window.matchMedia('(orientation: portrait)').matches ? s.ORIENTATION.PORTRAIT : window.matchMedia('(orientation: landscape)').matches ? s.ORIENTATION.LANDSCAPE : void 0 : e > t ? s.ORIENTATION.PORTRAIT : s.ORIENTATION.LANDSCAPE } }, 74403: t => { t.exports = function (t) { let e; return t !== '' && (typeof t === 'string' ? e = document.getElementById(t) : t && t.nodeType === 1 && (e = t)), e || (e = document.body), e } }, 56836: t => { t.exports = function (t) { let e = ''; try { if (window.DOMParser) e = (new DOMParser()).parseFromString(t, 'text/xml'); else (e = new ActiveXObject('Microsoft.XMLDOM')).loadXML(t) } catch (t) { e = null } return e && e.documentElement && !e.getElementsByTagName('parsererror').length ? e : null } }, 35846: t => { t.exports = function (t) { t.parentNode && t.parentNode.removeChild(t) } }, 43092: (t, e, i) => { const s = i(83419); const n = i(29747); const r = new s({ initialize: function () { this.isRunning = !1, this.callback = n, this.isSetTimeOut = !1, this.timeOutID = null, this.delay = 0; const t = this; this.step = function e (i) { t.callback(i), t.isRunning && (t.timeOutID = window.requestAnimationFrame(e)) }, this.stepTimeout = function e () { t.isRunning && (t.timeOutID = window.setTimeout(e, t.delay)), t.callback(window.performance.now()) } }, start: function (t, e, i) { this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.delay = i, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)) }, stop: function () { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID) }, destroy: function () { this.stop(), this.callback = n } }); t.exports = r }, 84902: (t, e, i) => { const s = { AddToDOM: i(40366), DOMContentLoaded: i(57264), GetInnerHeight: i(57811), GetScreenOrientation: i(45818), GetTarget: i(74403), ParseXML: i(56836), RemoveFromDOM: i(35846), RequestAnimationFrame: i(43092) }; t.exports = s }, 47565: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(37277); const o = new s({ Extends: n, initialize: function () { n.call(this) }, shutdown: function () { this.removeAllListeners() }, destroy: function () { this.removeAllListeners() } }); r.register('EventEmitter', o, 'events'), t.exports = o }, 93055: (t, e, i) => { t.exports = { EventEmitter: i(47565) } }, 20122: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e) { void 0 === e && (e = 1), n.call(this, r.BARREL, t), this.amount = e } }); t.exports = o }, 32251: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h) { void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === o && (o = 1), void 0 === a && (a = 1), void 0 === h && (h = 4), n.call(this, r.BLOOM, t), this.steps = h, this.offsetX = i, this.offsetY = s, this.blurStrength = o, this.strength = a, this.glcolor = [1, 1, 1], e != null && (this.color = e) }, color: { get: function () { const t = this.glcolor; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } } }); t.exports = o }, 9047: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 2), void 0 === s && (s = 2), void 0 === o && (o = 1), void 0 === h && (h = 4), n.call(this, r.BLUR, t), this.quality = e, this.x = i, this.y = s, this.steps = h, this.strength = o, this.glcolor = [1, 1, 1], a != null && (this.color = a) }, color: { get: function () { const t = this.glcolor; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } } }); t.exports = o }, 27885: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h, l) { void 0 === e && (e = 0.5), void 0 === i && (i = 1), void 0 === s && (s = 0.2), void 0 === o && (o = !1), void 0 === a && (a = 1), void 0 === h && (h = 1), void 0 === l && (l = 1), n.call(this, r.BOKEH, t), this.radius = e, this.amount = i, this.contrast = s, this.isTiltShift = o, this.strength = l, this.blurX = a, this.blurY = h } }); t.exports = o }, 12578: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a) { void 0 === e && (e = 8), void 0 === o && (o = 1), void 0 === a && (a = 0.005), n.call(this, r.CIRCLE, t), this.scale = o, this.feather = a, this.thickness = e, this.glcolor = [1, 0.2, 0.7], this.glcolor2 = [1, 0, 0, 0.4], i != null && (this.color = i), s != null && (this.backgroundColor = s) }, color: { get: function () { const t = this.glcolor; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } }, backgroundColor: { get: function () { const t = this.glcolor2; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor2; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } }, backgroundAlpha: { get: function () { return this.glcolor2[3] }, set: function (t) { this.glcolor2[3] = t } } }); t.exports = o }, 15802: (t, e, i) => { const s = i(83419); const n = i(89422); const r = i(14811); const o = new s({ Extends: n, initialize: function (t) { n.call(this), this.type = r.COLOR_MATRIX, this.gameObject = t, this.active = !0 }, destroy: function () { this.gameObject = null, this._matrix = null, this._data = null } }); t.exports = o }, 72898: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e) { this.type = t, this.gameObject = e, this.active = !0 }, setActive: function (t) { return this.active = t, this }, destroy: function () { this.gameObject = null, this.active = !1 } }); t.exports = s }, 44553: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s) { void 0 === e && (e = '__WHITE'), void 0 === i && (i = 0.005), void 0 === s && (s = 0.005), n.call(this, r.DISPLACEMENT, t), this.x = i, this.y = s, this.glTexture, this.setTexture(e) }, setTexture: function (t) { const e = this.gameObject.scene.sys.textures.getFrame(t); return e && (this.glTexture = e.glTexture), this } }); t.exports = o }, 68531: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o) { void 0 === i && (i = 4), void 0 === s && (s = 0), void 0 === o && (o = !1), n.call(this, r.GLOW, t), this.outerStrength = i, this.innerStrength = s, this.knockout = o, this.glcolor = [1, 1, 1, 1], void 0 !== e && (this.color = e) }, color: { get: function () { const t = this.glcolor; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } } }); t.exports = o }, 37102: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h, l, u) { void 0 === s && (s = 0.2), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 1), void 0 === u && (u = 0), n.call(this, r.GRADIENT, t), this.alpha = s, this.size = u, this.fromX = o, this.fromY = a, this.toX = h, this.toY = l, this.glcolor1 = [255, 0, 0], this.glcolor2 = [0, 255, 0], e != null && (this.color1 = e), i != null && (this.color2 = i) }, color1: { get: function () { const t = this.glcolor1; return (t[0] << 16) + (t[1] << 8) + (0 | t[2]) }, set: function (t) { const e = this.glcolor1; e[0] = t >> 16 & 255, e[1] = t >> 8 & 255, e[2] = 255 & t } }, color2: { get: function () { const t = this.glcolor2; return (t[0] << 16) + (t[1] << 8) + (0 | t[2]) }, set: function (t) { const e = this.glcolor2; e[0] = t >> 16 & 255, e[1] = t >> 8 & 255, e[2] = 255 & t } } }); t.exports = o }, 86886: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e) { void 0 === e && (e = 1), n.call(this, r.PIXELATE, t), this.amount = e } }); t.exports = o }, 92322: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h, l) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0.1), void 0 === o && (o = 1), void 0 === h && (h = 6), void 0 === l && (l = 1), n.call(this, r.SHADOW, t), this.x = e, this.y = i, this.decay = s, this.power = o, this.glcolor = [0, 0, 0, 1], this.samples = h, this.intensity = l, void 0 !== a && (this.color = a) }, color: { get: function () { const t = this.glcolor; return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0) }, set: function (t) { const e = this.glcolor; e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255 } } }); t.exports = o }, 39563: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o) { void 0 === e && (e = 0.5), void 0 === i && (i = 0.5), void 0 === s && (s = 3), void 0 === o && (o = !1), n.call(this, r.SHINE, t), this.speed = e, this.lineWidth = i, this.gradient = s, this.reveal = o } }); t.exports = o }, 56448: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o) { void 0 === e && (e = 0.5), void 0 === i && (i = 0.5), void 0 === s && (s = 0.5), void 0 === o && (o = 0.5), n.call(this, r.VIGNETTE, t), this.x = e, this.y = i, this.radius = s, this.strength = o } }); t.exports = o }, 38433: (t, e, i) => { const s = i(83419); const n = i(72898); const r = i(14811); const o = new s({ Extends: n, initialize: function (t, e, i, s, o) { void 0 === e && (e = 0.1), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === o && (o = !1), n.call(this, r.WIPE, t), this.progress = 0, this.wipeWidth = e, this.direction = i, this.axis = s, this.reveal = o } }); t.exports = o }, 14811: t => { t.exports = { GLOW: 4, SHADOW: 5, PIXELATE: 6, VIGNETTE: 7, SHINE: 8, BLUR: 9, GRADIENT: 12, BLOOM: 13, COLOR_MATRIX: 14, CIRCLE: 15, BARREL: 16, DISPLACEMENT: 17, WIPE: 18, BOKEH: 19 } }, 66064: (t, e, i) => { const s = i(79291); const n = i(14811); let r = { Barrel: i(20122), Controller: i(72898), Bloom: i(32251), Blur: i(9047), Bokeh: i(27885), Circle: i(12578), ColorMatrix: i(15802), Displacement: i(44553), Glow: i(68531), Gradient: i(37102), Pixelate: i(86886), Shadow: i(92322), Shine: i(39563), Vignette: i(56448), Wipe: i(38433) }; r = s(!1, r, n), t.exports = r }, 25305: (t, e, i) => { const s = i(10312); const n = i(23568); t.exports = function (t, e, i) { e.x = n(i, 'x', 0), e.y = n(i, 'y', 0), e.depth = n(i, 'depth', 0), e.flipX = n(i, 'flipX', !1), e.flipY = n(i, 'flipY', !1); const r = n(i, 'scale', null); typeof r === 'number' ? e.setScale(r) : r !== null && (e.scaleX = n(r, 'x', 1), e.scaleY = n(r, 'y', 1)); const o = n(i, 'scrollFactor', null); typeof o === 'number' ? e.setScrollFactor(o) : o !== null && (e.scrollFactorX = n(o, 'x', 1), e.scrollFactorY = n(o, 'y', 1)), e.rotation = n(i, 'rotation', 0); const a = n(i, 'angle', null); a !== null && (e.angle = a), e.alpha = n(i, 'alpha', 1); const h = n(i, 'origin', null); if (typeof h === 'number') e.setOrigin(h); else if (h !== null) { const l = n(h, 'x', 0.5); const u = n(h, 'y', 0.5); e.setOrigin(l, u) } return e.blendMode = n(i, 'blendMode', s.NORMAL), e.visible = n(i, 'visible', !0), n(i, 'add', !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e } }, 13059: (t, e, i) => { const s = i(23568); t.exports = function (t, e) { const i = s(e, 'anims', null); if (i === null) return t; if (typeof i === 'string') t.anims.play(i); else if (typeof i === 'object') { const n = t.anims; const r = s(i, 'key', void 0); if (r) { const o = s(i, 'startFrame', void 0); const a = s(i, 'delay', 0); const h = s(i, 'repeat', 0); const l = s(i, 'repeatDelay', 0); const u = s(i, 'yoyo', !1); const c = s(i, 'play', !1); const d = s(i, 'delayedPlay', 0); const f = { key: r, delay: a, repeat: h, repeatDelay: l, yoyo: u, startFrame: o }; c ? n.play(f) : d > 0 ? n.playAfterDelay(f, d) : n.load(f) } } return t } }, 8050: (t, e, i) => { const s = i(83419); const n = i(73162); const r = i(37277); const o = i(51708); const a = i(44594); const h = i(19186); const l = new s({ Extends: n, initialize: function (t) { n.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, this.events = t.sys.events, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.events.once(a.BOOT, this.boot, this), this.events.on(a.START, this.start, this) }, boot: function () { this.events.once(a.DESTROY, this.destroy, this) }, addChildCallback: function (t) { t.displayList && t.displayList !== this && t.removeFromDisplayList(), t.parentContainer && t.parentContainer.remove(t), t.displayList || (this.queueDepthSort(), t.displayList = this, t.emit(o.ADDED_TO_SCENE, t, this.scene), this.events.emit(a.ADDED_TO_SCENE, t, this.scene)) }, removeChildCallback: function (t) { this.queueDepthSort(), t.displayList = null, t.emit(o.REMOVED_FROM_SCENE, t, this.scene), this.events.emit(a.REMOVED_FROM_SCENE, t, this.scene) }, start: function () { this.events.once(a.SHUTDOWN, this.shutdown, this) }, queueDepthSort: function () { this.sortChildrenFlag = !0 }, depthSort: function () { this.sortChildrenFlag && (h(this.list, this.sortByDepth), this.sortChildrenFlag = !1) }, sortByDepth: function (t, e) { return t._depth - e._depth }, getChildren: function () { return this.list }, shutdown: function () { for (let t = this.list; t.length;)t[0].destroy(!0); this.events.off(a.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(a.START, this.start, this), this.scene = null, this.systems = null, this.events = null } }); r.register('DisplayList', l, 'displayList'), t.exports = l }, 95643: (t, e, i) => { const s = i(83419); const n = i(53774); const r = i(45893); const o = i(50792); const a = i(51708); const h = i(44594); var l = new s({ Extends: o, initialize: function (t, e) { o.call(this), this.scene = t, this.displayList = null, this.type = e, this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.on(a.ADDED_TO_SCENE, this.addedToScene, this), this.on(a.REMOVED_FROM_SCENE, this.removedFromScene, this), t.sys.queueDepthSort() }, setActive: function (t) { return this.active = t, this }, setName: function (t) { return this.name = t, this }, setState: function (t) { return this.state = t, this }, setDataEnabled: function () { return this.data || (this.data = new r(this)), this }, setData: function (t, e) { return this.data || (this.data = new r(this)), this.data.set(t, e), this }, incData: function (t, e) { return this.data || (this.data = new r(this)), this.data.inc(t, e), this }, toggleData: function (t) { return this.data || (this.data = new r(this)), this.data.toggle(t), this }, getData: function (t) { return this.data || (this.data = new r(this)), this.data.get(t) }, setInteractive: function (t, e, i) { return this.scene.sys.input.enable(this, t, e, i), this }, disableInteractive: function () { return this.scene.sys.input.disable(this), this }, removeInteractive: function () { return this.scene.sys.input.clear(this), this.input = void 0, this }, addedToScene: function () { }, removedFromScene: function () { }, update: function () { }, toJSON: function () { return n(this) }, willRender: function (t) { return !(!(!this.displayList || !this.displayList.active || this.displayList.willRender(t)) || l.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id) }, getIndexList: function () { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), t = e, e.parentContainer);)e = e.parentContainer; return this.displayList ? i.unshift(this.displayList.getIndex(t)) : i.unshift(this.scene.sys.displayList.getIndex(t)), i }, addToDisplayList: function (t) { return void 0 === t && (t = this.scene.sys.displayList), this.displayList && this.displayList !== t && this.removeFromDisplayList(), t.exists(this) || (this.displayList = t, t.add(this, !0), t.queueDepthSort(), this.emit(a.ADDED_TO_SCENE, this, this.scene), t.events.emit(h.ADDED_TO_SCENE, this, this.scene)), this }, addToUpdateList: function () { return this.scene && this.preUpdate && this.scene.sys.updateList.add(this), this }, removeFromDisplayList: function () { const t = this.displayList || this.scene.sys.displayList; return t && t.exists(this) && (t.remove(this, !0), t.queueDepthSort(), this.displayList = null, this.emit(a.REMOVED_FROM_SCENE, this, this.scene), t.events.emit(h.REMOVED_FROM_SCENE, this, this.scene)), this }, removeFromUpdateList: function () { return this.scene && this.preUpdate && this.scene.sys.updateList.remove(this), this }, destroy: function (t) { this.scene && !this.ignoreDestroy && (void 0 === t && (t = !1), this.preDestroy && this.preDestroy.call(this), this.emit(a.DESTROY, this, t), this.removeAllListeners(), this.postPipelines && this.resetPostPipeline(!0), this.removeFromDisplayList(), this.removeFromUpdateList(), this.input && (this.scene.sys.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), this.preFX && (this.preFX.destroy(), this.preFX = void 0), this.postFX && (this.postFX.destroy(), this.postFX = void 0), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0) } }); l.RENDER_MASK = 15, t.exports = l }, 44603: (t, e, i) => { const s = i(83419); const n = i(37277); const r = i(44594); const o = new s({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.events = t.sys.events, this.displayList, this.updateList, this.events.once(r.BOOT, this.boot, this), this.events.on(r.START, this.start, this) }, boot: function () { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(r.DESTROY, this.destroy, this) }, start: function () { this.events.once(r.SHUTDOWN, this.shutdown, this) }, shutdown: function () { this.events.off(r.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null } }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e) }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t] }, n.register('GameObjectCreator', o, 'make'), t.exports = o }, 39429: (t, e, i) => { const s = i(83419); const n = i(37277); const r = i(44594); const o = new s({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.events = t.sys.events, this.displayList, this.updateList, this.events.once(r.BOOT, this.boot, this), this.events.on(r.START, this.start, this) }, boot: function () { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.events.once(r.DESTROY, this.destroy, this) }, start: function () { this.events.once(r.SHUTDOWN, this.shutdown, this) }, existing: function (t) { return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t }, shutdown: function () { this.events.off(r.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.events = null, this.displayList = null, this.updateList = null } }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e) }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t] }, n.register('GameObjectFactory', o, 'add'), t.exports = o }, 91296: (t, e, i) => { const s = i(61340); const n = new s(); const r = new s(); const o = new s(); const a = { camera: n, sprite: r, calc: o }; t.exports = function (t, e, i) { const s = n; const h = r; const l = o; return h.applyITRS(t.x, t.y, t.rotation, t.scaleX, t.scaleY), s.copyFrom(e.matrix), i ? (s.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), h.e = t.x, h.f = t.y) : (h.e -= e.scrollX * t.scrollFactorX, h.f -= e.scrollY * t.scrollFactorY), s.multiply(h, l), a } }, 45027: (t, e, i) => { const s = i(83419); const n = i(25774); const r = i(37277); const o = i(44594); const a = new s({ Extends: n, initialize: function (t) { n.call(this), this.checkQueue = !0, this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this) }, boot: function () { this.systems.events.once(o.DESTROY, this.destroy, this) }, start: function () { const t = this.systems.events; t.on(o.PRE_UPDATE, this.update, this), t.on(o.UPDATE, this.sceneUpdate, this), t.once(o.SHUTDOWN, this.shutdown, this) }, sceneUpdate: function (t, e) { for (let i = this._active, s = i.length, n = 0; n < s; n++) { const r = i[n]; r.active && r.preUpdate.call(r, t, e) } }, shutdown: function () { for (var t = this._active.length; t--;) this._active[t].destroy(!0); for (t = this._pending.length; t--;) this._pending[t].destroy(!0); for (t = this._destroy.length; t--;) this._destroy[t].destroy(!0); this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners(); const e = this.systems.events; e.off(o.PRE_UPDATE, this.update, this), e.off(o.UPDATE, this.sceneUpdate, this), e.off(o.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.systems.events.off(o.START, this.start, this), this.scene = null, this.systems = null } }); r.register('UpdateList', a, 'updateList'), t.exports = a }, 3217: t => { t.exports = function (t, e, i, s, n, r, o, a, h, l, u, c, d, f, p) { const v = i.x - e.displayOriginX + n; const g = i.y - e.displayOriginY + r; const m = v + i.w; const y = g + i.h; const x = o.getXRound(v, g, a); const T = o.getYRound(v, g, a); const w = o.getXRound(v, y, a); const b = o.getYRound(v, y, a); const S = o.getXRound(m, y, a); const E = o.getYRound(m, y, a); const A = o.getXRound(m, g, a); const C = o.getYRound(m, g, a); t.batchQuad(e, x, T, w, b, S, E, A, C, s.u0, s.v0, s.u1, s.v1, h, l, u, c, d, f, p) } }, 53048: t => { t.exports = function (t, e, i, s) { if (void 0 === i && (i = !1), void 0 === s) return s = { local: { x: 0, y: 0, width: 0, height: 0 }, global: { x: 0, y: 0, width: 0, height: 0 }, lines: { shortest: 0, longest: 0, lengths: null, height: 0 }, wrappedText: '', words: [], characters: [], scaleX: 0, scaleY: 0 }; let n; let r; let o; let a; let h = t.text; let l = h.length; const u = t.maxWidth; const c = t.wordWrapCharCode; let d = Number.MAX_VALUE; let f = Number.MAX_VALUE; let p = 0; let v = 0; const g = t.fontData.chars; const m = t.fontData.lineHeight; const y = t.letterSpacing; const x = t.lineSpacing; let T = 0; let w = 0; let b = 0; let S = null; const E = t._align; let A = 0; let C = 0; const _ = t.fontSize / t.fontData.size; const M = _ * t.scaleX; const P = _ * t.scaleY; let R = null; let L = 0; const O = []; let F = Number.MAX_VALUE; let D = 0; let k = 0; let I = 0; let B = []; const N = []; let U = null; if (u > 0) { for (n = 0; n < l; n++) if ((b = h.charCodeAt(n)) !== 10) { if (S = g[b]) { if (R !== null) var X = S.kerning[L]; b === c ? U !== null && (B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P, cr: !1 }), U = null) : (U === null && (U = { word: '', i: n, x: T, y: w, w: 0, h: m, cr: !1 }), U.word = U.word.concat(h[n]), U.w += S.xOffset + S.xAdvance + (void 0 !== X ? X : 0)), T += S.xAdvance + y, R = S, L = b } } else U !== null && (B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P, cr: !0 }), U = null), T = 0, w += m + x, R = null; let Y; U !== null && B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P, cr: !1 }), T = 0, w = 0, R = null, L = 0; let z = 0; const G = []; for (n = 0; n < B.length; n++) { const V = B[n]; const W = V.x; const H = V.x + V.w; if (Y) z = W - (W - (Y.x + Y.w) + Y.w), Y = null; W - z > u || H - z > u ? (G.push(V.i - 1), V.cr ? (G.push(V.i + V.word.length), z = 0, Y = null) : Y = V) : V.cr && (G.push(V.i + V.word.length), z = 0, Y = null) } for (n = G.length - 1; n >= 0; n--)r = h, o = G[n], a = '\n', h = r.substr(0, o) + a + r.substr(o + 1); s.wrappedText = h, l = h.length, B = [], U = null } let j = 0; for (n = 0; n < l; n++) if ((b = h.charCodeAt(n)) !== 10) { if (S = g[b]) { if (A = T, C = w, R !== null) { var q = S.kerning[L]; A += void 0 !== q ? q : 0 } d > A && (d = A), f > C && (f = C); const K = A + S.xAdvance; const Z = C + m; p < K && (p = K), v < Z && (v = Z); const J = S.xOffset + S.xAdvance + (void 0 !== q ? q : 0); b === c ? U !== null && (B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P }), U = null) : (U === null && (U = { word: '', i: j, x: T, y: w, w: 0, h: m }), U.word = U.word.concat(h[n]), U.w += J), N.push({ i: j, idx: n, char: h[n], code: b, x: (S.xOffset + A) * _, y: (S.yOffset + w) * _, w: S.width * _, h: S.height * _, t: w * _, r: K * _, b: m * _, line: k, glyph: S }), T += S.xAdvance + y + (void 0 !== q ? q : 0), R = S, L = b, I = K * _, j++ } } else U !== null && (B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P }), U = null), T = 0, w += m + x, R = null, O[k] = I, I > D && (D = I), I < F && (F = I), k++, I = 0; if (U !== null && B.push({ word: U.word, i: U.i, x: U.x * M, y: U.y * P, w: U.w * M, h: U.h * P }), O[k] = I, I > D && (D = I), I < F && (F = I), E > 0) for (let Q = 0; Q < N.length; Q++) { const $ = N[Q]; if (E === 1) { const tt = (D - O[$.line]) / 2; $.x += tt, $.r += tt } else if (E === 2) { const et = D - O[$.line]; $.x += et, $.r += et } } const it = s.local; const st = s.global; const nt = s.lines; return it.x = d * _, it.y = f * _, it.width = p * _, it.height = v * _, st.x = t.x - t._displayOriginX + d * M, st.y = t.y - t._displayOriginY + f * P, st.width = p * M, st.height = v * P, nt.shortest = F, nt.longest = D, nt.lengths = O, e && (it.x = Math.ceil(it.x), it.y = Math.ceil(it.y), it.width = Math.ceil(it.width), it.height = Math.ceil(it.height), st.x = Math.ceil(st.x), st.y = Math.ceil(st.y), st.width = Math.ceil(st.width), st.height = Math.ceil(st.height), nt.shortest = Math.ceil(F), nt.longest = Math.ceil(D)), i && (t._displayOriginX = t.originX * it.width, t._displayOriginY = t.originY * it.height, st.x = t.x - t._displayOriginX * t.scaleX, st.y = t.y - t._displayOriginY * t.scaleY, e && (st.x = Math.ceil(st.x), st.y = Math.ceil(st.y))), s.words = B, s.characters = N, s.lines.height = m, s.scale = _, s.scaleX = t.scaleX, s.scaleY = t.scaleY, s } }, 61327: (t, e, i) => { const s = i(21859); t.exports = function (t, e, i, n, r, o, a) { const h = t.sys.textures.get(i); const l = h.get(n); const u = t.sys.cache.xml.get(r); if (l && u) { const c = s(u, l, o, a, h); return t.sys.cache.bitmapFont.add(e, { data: c, texture: i, frame: n, fromAtlas: !0 }), !0 } return !1 } }, 6925: (t, e, i) => { const s = i(35154); t.exports = function (t, e) { const i = e.width; const n = e.height; const r = Math.floor(i / 2); const o = Math.floor(n / 2); const a = s(e, 'chars', ''); if (a !== '') { const h = s(e, 'image', ''); const l = t.sys.textures.getFrame(h); const u = l.cutX; const c = l.cutY; const d = l.source.width; const f = l.source.height; const p = s(e, 'offset.x', 0); const v = s(e, 'offset.y', 0); const g = s(e, 'spacing.x', 0); const m = s(e, 'spacing.y', 0); const y = s(e, 'lineSpacing', 0); let x = s(e, 'charsPerRow', null); x === null && (x = d / i) > a.length && (x = a.length); for (var T = p, w = v, b = { retroFont: !0, font: h, size: i, lineHeight: n + y, chars: {} }, S = 0, E = 0; E < a.length; E++) { const A = a.charCodeAt(E); const C = (u + T) / d; const _ = (c + w) / f; const M = (u + T + i) / d; const P = (c + w + n) / f; b.chars[A] = { x: T, y: w, width: i, height: n, centerX: r, centerY: o, xOffset: 0, yOffset: 0, xAdvance: i, data: {}, kerning: {}, u0: C, v0: _, u1: M, v1: P }, ++S === x ? (S = 0, T = p, w += n + m) : T += i + g } return { data: b, frame: null, texture: h } } } }, 21859: t => { function e (t, e) { return parseInt(t.getAttribute(e), 10) } t.exports = function (t, i, s, n, r) { void 0 === s && (s = 0), void 0 === n && (n = 0); const o = i.cutX; const a = i.cutY; const h = i.source.width; const l = i.source.height; const u = i.sourceIndex; const c = {}; const d = t.getElementsByTagName('info')[0]; const f = t.getElementsByTagName('common')[0]; c.font = d.getAttribute('face'), c.size = e(d, 'size'), c.lineHeight = e(f, 'lineHeight') + n, c.chars = {}; const p = t.getElementsByTagName('char'); const v = void 0 !== i && i.trimmed; if (v) var g = i.height, m = i.width; for (var y = 0; y < p.length; y++) { const x = p[y]; const T = e(x, 'id'); const w = String.fromCharCode(T); let b = e(x, 'x'); let S = e(x, 'y'); const E = e(x, 'width'); const A = e(x, 'height'); v && (b < m && (m = b), S < g && (g = S)), v && g !== 0 && m !== 0 && (b -= i.x, S -= i.y); const C = (o + b) / h; const _ = (a + S) / l; const M = (o + b + E) / h; const P = (a + S + A) / l; if (c.chars[T] = { x: b, y: S, width: E, height: A, centerX: Math.floor(E / 2), centerY: Math.floor(A / 2), xOffset: e(x, 'xoffset'), yOffset: e(x, 'yoffset'), xAdvance: e(x, 'xadvance') + s, data: {}, kerning: {}, u0: C, v0: _, u1: M, v1: P }, r && E !== 0 && A !== 0) { const R = r.add(w, u, b, S, E, A); R && R.setUVs(E, A, C, _, M, P) } } const L = t.getElementsByTagName('kerning'); for (y = 0; y < L.length; y++) { const O = L[y]; const F = e(O, 'first'); const D = e(O, 'second'); const k = e(O, 'amount'); c.chars[D].kerning[F] = k } return c } }, 196: (t, e, i) => { const s = i(87662); const n = i(79291); let r = { Parse: i(6925) }; r = n(!1, r, s), t.exports = r }, 87662: t => { t.exports = { TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789" } }, 2638: (t, e, i) => { const s = i(22186); const n = i(83419); const r = i(12310); const o = new n({ Extends: s, Mixins: [r], initialize: function (t, e, i, n, r, o, a) { s.call(this, t, e, i, n, r, o, a), this.type = 'DynamicBitmapText', this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = { parent: this, color: 0, tint: { topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0 }, index: 0, charCode: 0, x: 0, y: 0, scale: 0, rotation: 0, data: 0 } }, setSize: function (t, e) { return this.cropWidth = t, this.cropHeight = e, this }, setDisplayCallback: function (t) { return this.displayCallback = t, this }, setScrollX: function (t) { return this.scrollX = t, this }, setScrollY: function (t) { return this.scrollY = t, this } }); t.exports = o }, 86741: (t, e, i) => { const s = i(20926); t.exports = function (t, e, i, n) { const r = e._text; const o = r.length; const a = t.currentContext; if (o !== 0 && s(t, a, e, i, n)) { i.addToRenderList(e); const h = e.fromAtlas ? e.frame : e.texture.frames.__BASE; const l = e.displayCallback; const u = e.callbackData; const c = e.fontData.chars; const d = e.fontData.lineHeight; const f = e._letterSpacing; let p = 0; let v = 0; let g = 0; let m = null; let y = 0; let x = 0; let T = 0; let w = 0; let b = 0; let S = 0; let E = null; let A = 0; const C = e.frame.source.image; const _ = h.cutX; const M = h.cutY; let P = 0; let R = 0; const L = e._fontSize / e.fontData.size; const O = e._align; let F = 0; let D = 0; e.getTextBounds(!1); const k = e._bounds.lines; O === 1 ? D = (k.longest - k.lengths[0]) / 2 : O === 2 && (D = k.longest - k.lengths[0]), a.translate(-e.displayOriginX, -e.displayOriginY); const I = i.roundPixels; e.cropWidth > 0 && e.cropHeight > 0 && (a.beginPath(), a.rect(0, 0, e.cropWidth, e.cropHeight), a.clip()); for (let B = 0; B < o; B++) if (R = L, P = 0, (g = r.charCodeAt(B)) !== 10) { if (m = c[g]) { if (y = _ + m.x, x = M + m.y, T = m.width, w = m.height, b = m.xOffset + p - e.scrollX, S = m.yOffset + v - e.scrollY, E !== null) { var N = m.kerning[A]; b += void 0 !== N ? N : 0 } if (l) { u.index = B, u.charCode = g, u.x = b, u.y = S, u.scale = R, u.rotation = P, u.data = m.data; const U = l(u); b = U.x, S = U.y, R = U.scale, P = U.rotation } b *= R, S *= R, b += D, p += m.xAdvance + f + (void 0 !== N ? N : 0), E = m, A = g, T !== 0 && w !== 0 && g !== 32 && (I && (b = Math.round(b), S = Math.round(S)), a.save(), a.translate(b, S), a.rotate(P), a.scale(R, R), a.drawImage(C, y, x, T, w, 0, 0, T, w), a.restore()) } } else F++, O === 1 ? D = (k.longest - k.lengths[F]) / 2 : O === 2 && (D = k.longest - k.lengths[F]), p = 0, v += d, E = null; a.restore() } } }, 11164: (t, e, i) => { const s = i(2638); const n = i(25305); const r = i(44603); const o = i(23568); r.register('dynamicBitmapText', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'font', ''); const r = o(t, 'text', ''); const a = o(t, 'size', !1); const h = new s(this.scene, 0, 0, i, r, a); return void 0 !== e && (t.add = e), n(this.scene, h, t), h }) }, 72566: (t, e, i) => { const s = i(2638); i(39429).register('dynamicBitmapText', function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, n, r)) }) }, 12310: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(73482), r = i(86741), t.exports = { renderWebGL: n, renderCanvas: r } }, 73482: (t, e, i) => { const s = i(91296); const n = i(61340); const r = i(70554); const o = new n(); t.exports = function (t, e, i, n) { let a = e.text; let h = a.length; if (h !== 0) { i.addToRenderList(e); const l = t.pipelines.set(e.pipeline, e); const u = s(e, i, n); t.pipelines.preBatch(e); const c = u.sprite; const d = u.calc; const f = o; const p = e.cropWidth > 0 || e.cropHeight > 0; p && (l.flush(), t.pushScissor(d.tx, d.ty, e.cropWidth * d.scaleX, e.cropHeight * d.scaleY)); let v; let g; const m = e.frame.glTexture; const y = e.tintFill; let x = r.getTintAppendFloatAlpha(e.tintTopLeft, i.alpha * e._alphaTL); let T = r.getTintAppendFloatAlpha(e.tintTopRight, i.alpha * e._alphaTR); let w = r.getTintAppendFloatAlpha(e.tintBottomLeft, i.alpha * e._alphaBL); let b = r.getTintAppendFloatAlpha(e.tintBottomRight, i.alpha * e._alphaBR); let S = l.setGameObject(e); let E = 0; let A = 0; let C = 0; let _ = 0; const M = e.letterSpacing; let P = 0; let R = 0; const L = e.scrollX; const O = e.scrollY; const F = e.fontData; const D = F.chars; const k = F.lineHeight; let I = e.fontSize / F.size; let B = 0; const N = e._align; let U = 0; let X = 0; const Y = e.getTextBounds(!1); e.maxWidth > 0 && (h = (a = Y.wrappedText).length); const z = e._bounds.lines; N === 1 ? X = (z.longest - z.lengths[0]) / 2 : N === 2 && (X = z.longest - z.lengths[0]); for (let G = i.roundPixels, V = e.displayCallback, W = e.callbackData, H = 0; H < h; H++) if ((C = a.charCodeAt(H)) !== 10) { if (v = D[C]) { P = v.width, R = v.height; let j = v.xOffset + E - L; let q = v.yOffset + A - O; if (g !== null) { const K = v.kerning[_]; j += void 0 !== K ? K : 0 } if (E += v.xAdvance + M, g = v, _ = C, P !== 0 && R !== 0 && C !== 32) { if (I = e.fontSize / e.fontData.size, B = 0, V) { W.color = 0, W.tint.topLeft = x, W.tint.topRight = T, W.tint.bottomLeft = w, W.tint.bottomRight = b, W.index = H, W.charCode = C, W.x = j, W.y = q, W.scale = I, W.rotation = B, W.data = v.data; const Z = V(W); j = Z.x, q = Z.y, I = Z.scale, B = Z.rotation, Z.color ? (x = Z.color, T = Z.color, w = Z.color, b = Z.color) : (x = Z.tint.topLeft, T = Z.tint.topRight, w = Z.tint.bottomLeft, b = Z.tint.bottomRight), x = r.getTintAppendFloatAlpha(x, i.alpha * e._alphaTL), T = r.getTintAppendFloatAlpha(T, i.alpha * e._alphaTR), w = r.getTintAppendFloatAlpha(w, i.alpha * e._alphaBL), b = r.getTintAppendFloatAlpha(b, i.alpha * e._alphaBR) } j *= I, q *= I, j -= e.displayOriginX, q -= e.displayOriginY, j += X, f.applyITRS(j, q, B, I, I), d.multiply(f, c); const J = v.u0; const Q = v.v0; const $ = v.u1; const tt = v.v1; const et = P; const it = R; let st = c.e; let nt = c.f; let rt = it * c.c + c.e; let ot = it * c.d + c.f; let at = et * c.a + it * c.c + c.e; let ht = et * c.b + it * c.d + c.f; let lt = et * c.a + c.e; let ut = et * c.b + c.f; G && (st = Math.round(st), nt = Math.round(nt), rt = Math.round(rt), ot = Math.round(ot), at = Math.round(at), ht = Math.round(ht), lt = Math.round(lt), ut = Math.round(ut)), l.shouldFlush(6) && (l.flush(), S = l.setGameObject(e)), l.batchQuad(e, st, nt, rt, ot, at, ht, lt, ut, J, Q, $, tt, x, T, w, b, y, m, S) } } } else U++, N === 1 ? X = (z.longest - z.lengths[U]) / 2 : N === 2 && (X = z.longest - z.lengths[U]), E = 0, A += k, g = null; p && (l.flush(), t.popScissor()), t.pipelines.postBatch(e) } } }, 22186: (t, e, i) => { const s = i(83419); const n = i(45319); const r = i(31401); const o = i(95643); const a = i(53048); const h = i(61327); const l = i(21859); const u = i(87841); const c = i(18658); var d = new s({ Extends: o, Mixins: [r.Alpha, r.BlendMode, r.Depth, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.PostPipeline, r.ScrollFactor, r.Texture, r.Tint, r.Transform, r.Visible, c], initialize: function (t, e, i, s, n, r, h) { void 0 === n && (n = ''), void 0 === h && (h = 0), o.call(this, t, 'BitmapText'), this.font = s; const l = this.scene.sys.cache.bitmapFont.get(s); l || console.warn('Invalid BitmapText key: ' + s), this.fontData = l.data, this._text = '', this._fontSize = r || this.fontData.size, this._letterSpacing = 0, this._lineSpacing = 0, this._align = h, this._bounds = a(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.charColors = [], this.dropShadowX = 0, this.dropShadowY = 0, this.dropShadowColor = 0, this.dropShadowAlpha = 0.5, this.fromAtlas = l.fromAtlas, this.setTexture(l.texture, l.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.initPostPipeline(), this.setText(n) }, setLeftAlign: function () { return this._align = d.ALIGN_LEFT, this._dirty = !0, this }, setCenterAlign: function () { return this._align = d.ALIGN_CENTER, this._dirty = !0, this }, setRightAlign: function () { return this._align = d.ALIGN_RIGHT, this._dirty = !0, this }, setFontSize: function (t) { return this._fontSize = t, this._dirty = !0, this }, setLetterSpacing: function (t) { return void 0 === t && (t = 0), this._letterSpacing = t, this._dirty = !0, this }, setLineSpacing: function (t) { return void 0 === t && (t = 0), this.lineSpacing = t, this }, setText: function (t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this._text = t.toString(), this._dirty = !0, this.updateDisplayOrigin()), this }, setDropShadow: function (t, e, i, s) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0.5), this.dropShadowX = t, this.dropShadowY = e, this.dropShadowColor = i, this.dropShadowAlpha = s, this }, setCharacterTint: function (t, e, i, s, r, o, a) { void 0 === t && (t = 0), void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === s && (s = -1), void 0 === r && (r = s, o = s, a = s); const h = this.text.length; e === -1 && (e = h), t < 0 && (t = h + t), t = n(t, 0, h - 1); for (let l = n(t + e, t, h), u = this.charColors, c = t; c < l; c++) { const d = u[c]; if (s === -1) u[c] = null; else { const f = i ? 1 : 0; d ? (d.tintEffect = f, d.tintTL = s, d.tintTR = r, d.tintBL = o, d.tintBR = a) : u[c] = { tintEffect: f, tintTL: s, tintTR: r, tintBL: o, tintBR: a } } } return this }, setWordTint: function (t, e, i, s, n, r, o) { void 0 === e && (e = 1); for (let a = this.getTextBounds().words, h = typeof t === 'number', l = 0, u = 0; u < a.length; u++) { const c = a[u]; if ((h && u === t || !h && c.word === t) && (this.setCharacterTint(c.i, c.word.length, i, s, n, r, o), ++l === e)) return this } return this }, getTextBounds: function (t) { const e = this._bounds; return (this._dirty || t || this.scaleX !== e.scaleX || this.scaleY !== e.scaleY) && (a(this, t, !0, e), this._dirty = !1), e }, getCharacterAt: function (t, e, i) { for (let s = this.getLocalPoint(t, e, null, i), n = this.getTextBounds().characters, r = new u(), o = 0; o < n.length; o++) { const a = n[o]; if (r.setTo(a.x, a.t, a.r - a.x, a.b), r.contains(s.x, s.y)) return a } return null }, updateDisplayOrigin: function () { return this._dirty = !0, this.getTextBounds(!1), this }, setFont: function (t, e, i) { void 0 === e && (e = this._fontSize), void 0 === i && (i = this._align); const s = this.scene.sys.cache.bitmapFont.get(t); return s && (this.font = t, this.fontData = s.data, this._fontSize = e, this._align = i, this.fromAtlas = !0 === s.fromAtlas, this.setTexture(s.texture, s.frame), a(this, !1, !0, this._bounds)), this }, setMaxWidth: function (t, e) { return this._maxWidth = t, this._dirty = !0, void 0 !== e && (this.wordWrapCharCode = e), this }, align: { set: function (t) { this._align = t, this._dirty = !0 }, get: function () { return this._align } }, text: { set: function (t) { this.setText(t) }, get: function () { return this._text } }, fontSize: { set: function (t) { this._fontSize = t, this._dirty = !0 }, get: function () { return this._fontSize } }, letterSpacing: { set: function (t) { this._letterSpacing = t, this._dirty = !0 }, get: function () { return this._letterSpacing } }, lineSpacing: { set: function (t) { this._lineSpacing = t, this._dirty = !0 }, get: function () { return this._lineSpacing } }, maxWidth: { set: function (t) { this._maxWidth = t, this._dirty = !0 }, get: function () { return this._maxWidth } }, width: { get: function () { return this.getTextBounds(!1), this._bounds.global.width } }, height: { get: function () { return this.getTextBounds(!1), this._bounds.global.height } }, displayWidth: { get: function () { return this.width } }, displayHeight: { get: function () { return this.height } }, toJSON: function () { const t = r.ToJSON(this); const e = { font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, lineSpacing: this.lineSpacing, align: this.align }; return t.data = e, t }, preDestroy: function () { this.charColors.length = 0, this._bounds = null, this.fontData = null } }); d.ALIGN_LEFT = 0, d.ALIGN_CENTER = 1, d.ALIGN_RIGHT = 2, d.ParseFromAtlas = h, d.ParseXMLBitmapFont = l, t.exports = d }, 37289: (t, e, i) => { const s = i(20926); t.exports = function (t, e, i, n) { let r = e._text; let o = r.length; const a = t.currentContext; if (o !== 0 && s(t, a, e, i, n)) { i.addToRenderList(e); const h = e.fromAtlas ? e.frame : e.texture.frames.__BASE; const l = e.fontData.chars; const u = e.fontData.lineHeight; const c = e._letterSpacing; const d = e._lineSpacing; let f = 0; let p = 0; let v = 0; let g = null; let m = 0; let y = 0; let x = 0; let T = 0; let w = 0; let b = 0; let S = null; let E = 0; const A = h.source.image; const C = h.cutX; const _ = h.cutY; const M = e._fontSize / e.fontData.size; const P = e._align; let R = 0; let L = 0; const O = e.getTextBounds(!1); e.maxWidth > 0 && (o = (r = O.wrappedText).length); const F = e._bounds.lines; P === 1 ? L = (F.longest - F.lengths[0]) / 2 : P === 2 && (L = F.longest - F.lengths[0]), a.translate(-e.displayOriginX, -e.displayOriginY); for (let D = i.roundPixels, k = 0; k < o; k++) if ((v = r.charCodeAt(k)) !== 10) { if (g = l[v]) { if (m = C + g.x, y = _ + g.y, x = g.width, T = g.height, w = g.xOffset + f, b = g.yOffset + p, S !== null) { var I = g.kerning[E]; w += void 0 !== I ? I : 0 } w *= M, b *= M, w += L, f += g.xAdvance + c + (void 0 !== I ? I : 0), S = g, E = v, x !== 0 && T !== 0 && v !== 32 && (D && (w = Math.round(w), b = Math.round(b)), a.save(), a.translate(w, b), a.scale(M, M), a.drawImage(A, m, y, x, T, 0, 0, x, T), a.restore()) } } else R++, P === 1 ? L = (F.longest - F.lengths[R]) / 2 : P === 2 && (L = F.longest - F.lengths[R]), f = 0, p += u + d, S = null; a.restore() } } }, 57336: (t, e, i) => { const s = i(22186); const n = i(25305); const r = i(44603); const o = i(23568); const a = i(35154); r.register('bitmapText', function (t, e) { void 0 === t && (t = {}); const i = a(t, 'font', ''); const r = o(t, 'text', ''); const h = o(t, 'size', !1); const l = a(t, 'align', 0); const u = new s(this.scene, 0, 0, i, r, h, l); return void 0 !== e && (t.add = e), n(this.scene, u, t), u }) }, 34914: (t, e, i) => { const s = i(22186); i(39429).register('bitmapText', function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)) }) }, 18658: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(33590), r = i(37289), t.exports = { renderWebGL: n, renderCanvas: r } }, 33590: (t, e, i) => { const s = i(3217); const n = i(91296); const r = i(70554); t.exports = function (t, e, i, o) { if (e._text.length !== 0) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline, e); const h = n(e, i, o).calc; t.pipelines.preBatch(e); let l; let u; let c; const d = i.roundPixels; const f = i.alpha; const p = e.charColors; const v = e.tintFill; const g = r.getTintAppendFloatAlpha; const m = g(e.tintTopLeft, f * e._alphaTL); const y = g(e.tintTopRight, f * e._alphaTR); const x = g(e.tintBottomLeft, f * e._alphaBL); const T = g(e.tintBottomRight, f * e._alphaBR); const w = e.frame.glTexture; let b = a.setGameObject(e); const S = e.getTextBounds(!1).characters; const E = e.dropShadowX; const A = e.dropShadowY; if (E !== 0 || A !== 0) { const C = e.dropShadowColor; const _ = e.dropShadowAlpha; const M = g(C, f * _ * e._alphaTL); const P = g(C, f * _ * e._alphaTR); const R = g(C, f * _ * e._alphaBL); const L = g(C, f * _ * e._alphaBR); for (l = 0; l < S.length; l++)c = (u = S[l]).glyph, u.code !== 32 && c.width !== 0 && c.height !== 0 && s(a, e, u, c, E, A, h, d, M, P, R, L, 1, w, b) } for (l = 0; l < S.length; l++) if (c = (u = S[l]).glyph, u.code !== 32 && c.width !== 0 && c.height !== 0) if (a.shouldFlush(6) && (a.flush(), b = a.setGameObject(e)), p[u.i]) { const O = p[u.i]; const F = O.tintEffect; const D = g(O.tintTL, f * e._alphaTL); const k = g(O.tintTR, f * e._alphaTR); const I = g(O.tintBL, f * e._alphaBL); const B = g(O.tintBR, f * e._alphaBR); s(a, e, u, c, 0, 0, h, d, D, k, I, B, F, w, b) } else s(a, e, u, c, 0, 0, h, d, m, y, x, T, v, w, b); t.pipelines.postBatch(e) } } }, 6107: (t, e, i) => { const s = i(48011); const n = i(46590); const r = i(83419); const o = i(31401); const a = i(4327); const h = i(95643); const l = i(73162); const u = new r({ Extends: h, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.PostPipeline, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, s], initialize: function (t, e, i, s, n) { h.call(this, t, 'Blitter'), this.setTexture(s, n), this.setPosition(e, i), this.initPipeline(), this.initPostPipeline(), this.children = new l(), this.renderList = [], this.dirty = !1 }, create: function (t, e, i, s, r) { void 0 === s && (s = !0), void 0 === r && (r = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i)); const o = new n(this, t, e, i, s); return this.children.addAt(o, r, !1), this.dirty = !0, o }, createFromCallback: function (t, e, i, s) { for (var n = this.createMultiple(e, i, s), r = 0; r < n.length; r++) { const o = n[r]; t.call(this, o, r) } return n }, createMultiple: function (t, e, i) { void 0 === e && (e = this.frame.name), void 0 === i && (i = !0), Array.isArray(e) || (e = [e]); const s = []; const n = this; return e.forEach(function (e) { for (let r = 0; r < t; r++)s.push(n.create(0, 0, e, i)) }), s }, childCanRender: function (t) { return t.visible && t.alpha > 0 }, getRenderList: function () { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList }, clear: function () { this.children.removeAll(), this.dirty = !0 }, preDestroy: function () { this.children.destroy(), this.renderList = [] } }); t.exports = u }, 72396: t => { t.exports = function (t, e, i, s) { const n = e.getRenderList(); if (n.length !== 0) { const r = t.currentContext; const o = i.alpha * e.alpha; if (o !== 0) { i.addToRenderList(e), r.globalCompositeOperation = t.blendModes[e.blendMode], r.imageSmoothingEnabled = !e.frame.source.scaleMode; const a = e.x - i.scrollX * e.scrollFactorX; const h = e.y - i.scrollY * e.scrollFactorY; r.save(), s && s.copyToContext(r); for (let l = i.roundPixels, u = 0; u < n.length; u++) { const c = n[u]; const d = c.flipX || c.flipY; const f = c.frame; const p = f.canvasData; let v = f.x; let g = f.y; let m = 1; let y = 1; const x = c.alpha * o; x !== 0 && (r.globalAlpha = x, d ? (c.flipX && (m = -1, v -= p.width), c.flipY && (y = -1, g -= p.height), p.width > 0 && p.height > 0 && (r.save(), r.translate(c.x + a, c.y + h), r.scale(m, y), r.drawImage(f.source.image, p.x, p.y, p.width, p.height, v, g, p.width, p.height), r.restore())) : (l && (v = Math.round(v), g = Math.round(g)), p.width > 0 && p.height > 0 && r.drawImage(f.source.image, p.x, p.y, p.width, p.height, v + c.x + a, g + c.y + h, p.width, p.height))) } r.restore() } } } }, 9403: (t, e, i) => { const s = i(6107); const n = i(25305); const r = i(44603); const o = i(23568); r.register('blitter', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const a = new s(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, a, t), a }) }, 12709: (t, e, i) => { const s = i(6107); i(39429).register('blitter', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)) }) }, 48011: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(99485), r = i(72396), t.exports = { renderWebGL: n, renderCanvas: r } }, 99485: (t, e, i) => { const s = i(61340); const n = i(70554); const r = new s(); t.exports = function (t, e, i, s) { const o = e.getRenderList(); const a = i.alpha * e.alpha; if (o.length !== 0 && a !== 0) { i.addToRenderList(e); const h = t.pipelines.set(this.pipeline, e); let l = i.scrollX * e.scrollFactorX; let u = i.scrollY * e.scrollFactorY; const c = r.copyFrom(i.matrix); s && (c.multiplyWithOffset(s, -l, -u), l = 0, u = 0); const d = e.x - l; const f = e.y - u; let p = -1; t.pipelines.preBatch(e); for (let v = 0; v < o.length; v++) { const g = o[v]; const m = g.frame; const y = g.alpha * a; if (y !== 0) { let x = m.width; let T = m.height; let w = d + g.x + m.x; let b = f + g.y + m.y; g.flipX && (x *= -1, w += m.width), g.flipY && (T *= -1, b += m.height); const S = c.setQuad(w, b, w + x, b + T); const E = n.getTintAppendFloatAlpha(g.tint, y); if (m.sourceIndex !== p) { var A = h.setGameObject(e, m); p = m.sourceIndex } h.batchQuad(e, S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], m.u0, m.v0, m.u1, m.v1, E, E, E, E, false, m.glTexture, A) && (p = -1) } } t.pipelines.postBatch(e) } } }, 46590: (t, e, i) => { const s = i(83419); const n = i(4327); const r = new s({ initialize: function (t, e, i, s, n) { this.parent = t, this.x = e, this.y = i, this.frame = s, this.data = {}, this.tint = 16777215, this._visible = n, this._alpha = 1, this.flipX = !1, this.flipY = !1, this.hasTransformComponent = !0 }, setFrame: function (t) { return void 0 === t ? this.frame = this.parent.frame : t instanceof n && t.texture === this.parent.texture ? this.frame = t : this.frame = this.parent.texture.get(t), this }, resetFlip: function () { return this.flipX = !1, this.flipY = !1, this }, reset: function (t, e, i) { return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this }, setPosition: function (t, e) { return this.x = t, this.y = e, this }, setFlipX: function (t) { return this.flipX = t, this }, setFlipY: function (t) { return this.flipY = t, this }, setFlip: function (t, e) { return this.flipX = t, this.flipY = e, this }, setVisible: function (t) { return this.visible = t, this }, setAlpha: function (t) { return this.alpha = t, this }, setTint: function (t) { return this.tint = t, this }, destroy: function () { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0 }, visible: { get: function () { return this._visible }, set: function (t) { this.parent.dirty |= this._visible !== t, this._visible = t } }, alpha: { get: function () { return this._alpha }, set: function (t) { this.parent.dirty |= this._alpha > 0 != t > 0, this._alpha = t } } }); t.exports = r }, 16005: (t, e, i) => { const s = i(45319); const n = { _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha: function () { return this.setAlpha(1) }, setAlpha: function (t, e, i, n) { return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = s(t, 0, 1), this._alphaTR = s(e, 0, 1), this._alphaBL = s(i, 0, 1), this._alphaBR = s(n, 0, 1)), this }, alpha: { get: function () { return this._alpha }, set: function (t) { const e = s(t, 0, 1); this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, this._alphaBR = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2 } }, alphaTopLeft: { get: function () { return this._alphaTL }, set: function (t) { const e = s(t, 0, 1); this._alphaTL = e, e !== 0 && (this.renderFlags |= 2) } }, alphaTopRight: { get: function () { return this._alphaTR }, set: function (t) { const e = s(t, 0, 1); this._alphaTR = e, e !== 0 && (this.renderFlags |= 2) } }, alphaBottomLeft: { get: function () { return this._alphaBL }, set: function (t) { const e = s(t, 0, 1); this._alphaBL = e, e !== 0 && (this.renderFlags |= 2) } }, alphaBottomRight: { get: function () { return this._alphaBR }, set: function (t) { const e = s(t, 0, 1); this._alphaBR = e, e !== 0 && (this.renderFlags |= 2) } } }; t.exports = n }, 88509: (t, e, i) => { const s = i(45319); const n = { _alpha: 1, clearAlpha: function () { return this.setAlpha(1) }, setAlpha: function (t) { return void 0 === t && (t = 1), this.alpha = t, this }, alpha: { get: function () { return this._alpha }, set: function (t) { const e = s(t, 0, 1); this._alpha = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2 } } }; t.exports = n }, 90065: (t, e, i) => { const s = i(10312); const n = { _blendMode: s.NORMAL, blendMode: { get: function () { return this._blendMode }, set: function (t) { typeof t === 'string' && (t = s[t]), (t |= 0) >= -1 && (this._blendMode = t) } }, setBlendMode: function (t) { return this.blendMode = t, this } }; t.exports = n }, 94215: t => { t.exports = { width: 0, height: 0, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (t) { this.scaleX = t / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (t) { this.scaleY = t / this.height } }, setSize: function (t, e) { return this.width = t, this.height = e, this }, setDisplaySize: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this } } }, 61683: t => { const e = { texture: null, frame: null, isCropped: !1, setCrop: function (t, e, i, s) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, s, this.flipX, this.flipY); else { const n = t; this.frame.setCropUVs(this._crop, n.x, n.y, n.width, n.height, this.flipX, this.flipY) } this.isCropped = !0 } return this }, resetCropObject: function () { return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0 } } }; t.exports = e }, 89272: t => { const e = { _depth: 0, depth: { get: function () { return this._depth }, set: function (t) { this.displayList && this.displayList.queueDepthSort(), this._depth = t } }, setDepth: function (t) { return void 0 === t && (t = 0), this.depth = t, this } }; t.exports = e }, 47059: (t, e, i) => { const s = i(83419); const n = i(66064); const r = i(19133); const o = new s({ initialize: function (t, e) { this.gameObject = t, this.isPost = e, this.enabled = !1, this.list = [], this.padding = 0 }, setPadding: function (t) { return void 0 === t && (t = 0), this.padding = t, this.gameObject }, onFXCopy: function () { }, onFX: function () { }, enable: function (t) { if (!this.isPost) { const e = this.gameObject.scene.sys.renderer; e && e.pipelines ? (this.gameObject.pipeline = e.pipelines.FX_PIPELINE, void 0 !== t && (this.padding = t), this.enabled = !0) : this.enabled = !1 } }, clear: function () { if (this.isPost) this.gameObject.resetPostPipeline(!0); else { for (let t = this.list, e = 0; e < t.length; e++)t[e].destroy(); this.list = [] } return this.enabled = !1, this.gameObject }, remove: function (t) { let e; if (this.isPost) { let i = this.gameObject.getPostPipeline(String(t.type)); for (Array.isArray(i) || (i = [i]), e = 0; e < i.length; e++) { const s = i[e]; if (s.controller === t) { this.gameObject.removePostPipeline(s), t.destroy(); break } } } else { const n = this.list; for (e = 0; e < n.length; e++)n[e] === t && (r(n, e), t.destroy()) } return this.gameObject }, disable: function (t) { return void 0 === t && (t = !1), this.isPost || this.gameObject.resetPipeline(), this.enabled = !1, t && this.clear(), this.gameObject }, add: function (t, e) { if (!this.isPost) return this.enabled || this.enable(), this.list.push(t), t; const i = String(t.type); this.gameObject.setPostPipeline(i, e); let s = this.gameObject.getPostPipeline(i); return s ? (Array.isArray(s) && (s = s.pop()), s.controller = t, t) : void 0 }, addGlow: function (t, e, i, s, r, o) { return this.add(new n.Glow(this.gameObject, t, e, i, s), { quality: r, distance: o }) }, addShadow: function (t, e, i, s, r, o, a) { return this.add(new n.Shadow(this.gameObject, t, e, i, s, r, o, a)) }, addPixelate: function (t) { return this.add(new n.Pixelate(this.gameObject, t)) }, addVignette: function (t, e, i, s) { return this.add(new n.Vignette(this.gameObject, t, e, i, s)) }, addShine: function (t, e, i, s) { return this.add(new n.Shine(this.gameObject, t, e, i, s)) }, addBlur: function (t, e, i, s, r, o) { return this.add(new n.Blur(this.gameObject, t, e, i, s, r, o)) }, addGradient: function (t, e, i, s, r, o, a, h) { return this.add(new n.Gradient(this.gameObject, t, e, i, s, r, o, a, h)) }, addBloom: function (t, e, i, s, r, o) { return this.add(new n.Bloom(this.gameObject, t, e, i, s, r, o)) }, addColorMatrix: function () { return this.add(new n.ColorMatrix(this.gameObject)) }, addCircle: function (t, e, i, s, r) { return this.add(new n.Circle(this.gameObject, t, e, i, s, r)) }, addBarrel: function (t) { return this.add(new n.Barrel(this.gameObject, t)) }, addDisplacement: function (t, e, i) { return this.add(new n.Displacement(this.gameObject, t, e, i)) }, addWipe: function (t, e, i) { return this.add(new n.Wipe(this.gameObject, t, e, i)) }, addReveal: function (t, e, i) { return this.add(new n.Wipe(this.gameObject, t, e, i, !0)) }, addBokeh: function (t, e, i) { return this.add(new n.Bokeh(this.gameObject, t, e, i)) }, addTiltShift: function (t, e, i, s, r, o) { return this.add(new n.Bokeh(this.gameObject, t, e, i, !0, s, r, o)) }, destroy: function () { this.clear(), this.gameObject = null } }); t.exports = o }, 54434: t => { t.exports = { flipX: !1, flipY: !1, toggleFlipX: function () { return this.flipX = !this.flipX, this }, toggleFlipY: function () { return this.flipY = !this.flipY, this }, setFlipX: function (t) { return this.flipX = t, this }, setFlipY: function (t) { return this.flipY = t, this }, setFlip: function (t, e) { return this.flipX = t, this.flipY = e, this }, resetFlip: function () { return this.flipX = !1, this.flipY = !1, this } } }, 8004: (t, e, i) => { const s = i(87841); const n = i(11520); const r = i(26099); const o = { prepareBoundsOutput: function (t, e) { (void 0 === e && (e = !1), this.rotation !== 0 && n(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t }, getCenter: function (t, e) { return void 0 === t && (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e) }, getTopLeft: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e) }, getTopCenter: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e) }, getTopRight: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e) }, getLeftCenter: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e) }, getRightCenter: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e) }, getBottomLeft: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e) }, getBottomCenter: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e) }, getBottomRight: function (t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e) }, getBounds: function (t) { let e, i, n, r, o, a, h, l; if (void 0 === t && (t = new s()), this.parentContainer) { const u = this.parentContainer.getBoundsTransformMatrix(); this.getTopLeft(t), u.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), u.transformPoint(t.x, t.y, t), n = t.x, r = t.y, this.getBottomLeft(t), u.transformPoint(t.x, t.y, t), o = t.x, a = t.y, this.getBottomRight(t), u.transformPoint(t.x, t.y, t), h = t.x, l = t.y } else this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), n = t.x, r = t.y, this.getBottomLeft(t), o = t.x, a = t.y, this.getBottomRight(t), h = t.x, l = t.y; return t.x = Math.min(e, n, o, h), t.y = Math.min(i, r, a, l), t.width = Math.max(e, n, o, h) - t.x, t.height = Math.max(i, r, a, l) - t.y, t } }; t.exports = o }, 8573: (t, e, i) => { const s = i(6858); const n = i(80661); const r = { mask: null, setMask: function (t) { return this.mask = t, this }, clearMask: function (t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this }, createBitmapMask: function (t, e, i, n, r) { return void 0 === t && (this.texture || this.shader || this.geom) && (t = this), new s(this.scene, t, e, i, n, r) }, createGeometryMask: function (t) { return void 0 !== t || this.type !== 'Graphics' && !this.geom || (t = this), new n(this.scene, t) } }; t.exports = r }, 27387: t => { const e = { _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get: function () { return this._displayOriginX }, set: function (t) { this._displayOriginX = t, this.originX = t / this.width } }, displayOriginY: { get: function () { return this._displayOriginY }, set: function (t) { this._displayOriginY = t, this.originY = t / this.height } }, setOrigin: function (t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin() }, setOriginFromFrame: function () { return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin() }, setDisplayOrigin: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this }, updateDisplayOrigin: function () { return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this } }; t.exports = e }, 37640: (t, e, i) => { const s = i(39506); const n = i(57355); const r = i(35154); const o = i(86353); const a = i(26099); const h = { path: null, rotateToPath: !1, pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null, pathConfig: null, _prevDirection: o.PLAYING_FORWARD, setPath: function (t, e) { void 0 === e && (e = this.pathConfig); const i = this.pathTween; return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this }, setRotateToPath: function (t, e) { return void 0 === e && (e = 0), this.rotateToPath = t, this.pathRotationOffset = e, this }, isFollowing: function () { const t = this.pathTween; return t && t.isPlaying() }, startFollow: function (t, e) { void 0 === t && (t = {}), void 0 === e && (e = 0); const i = this.pathTween; i && i.isPlaying() && i.stop(), typeof t === 'number' && (t = { duration: t }), t.from = r(t, 'from', 0), t.to = r(t, 'to', 1); const h = n(t, 'positionOnPath', !1); this.rotateToPath = n(t, 'rotateToPath', !1), this.pathRotationOffset = r(t, 'rotationOffset', 0); const l = r(t, 'startAt', e); if (l && (t.onStart = function (t) { const e = t.data[0]; e.progress = l, e.elapsed = e.duration * l; const i = e.ease(e.progress); e.current = e.start + (e.end - e.start) * i, e.setTargetValue() }), this.pathOffset || (this.pathOffset = new a(this.x, this.y)), this.pathVector || (this.pathVector = new a()), this.pathDelta || (this.pathDelta = new a()), this.pathDelta.reset(), t.persist = !0, this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), h && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = o.PLAYING_FORWARD, this.rotateToPath) { const u = this.path.getPoint(0.1); this.rotation = Math.atan2(u.y - this.y, u.x - this.x) + s(this.pathRotationOffset) } return this.pathConfig = t, this }, pauseFollow: function () { const t = this.pathTween; return t && t.isPlaying() && t.pause(), this }, resumeFollow: function () { const t = this.pathTween; return t && t.isPaused() && t.resume(), this }, stopFollow: function () { const t = this.pathTween; return t && t.isPlaying() && t.stop(), this }, pathUpdate: function () { const t = this.pathTween; if (t && t.data) { const e = t.data[0]; const i = this.pathDelta; const n = this.pathVector; if (i.copy(n).negate(), e.state === o.COMPLETE) return this.path.getPoint(e.end, n), i.add(n), n.add(this.pathOffset), void this.setPosition(n.x, n.y); if (e.state !== o.PLAYING_FORWARD && e.state !== o.PLAYING_BACKWARD) return; this.path.getPoint(t.getValue(), n), i.add(n), n.add(this.pathOffset); const r = this.x; const a = this.y; this.setPosition(n.x, n.y); const h = this.x - r; const l = this.y - a; if (h === 0 && l === 0) return; if (e.state !== this._prevDirection) return void (this._prevDirection = e.state); this.rotateToPath && (this.rotation = Math.atan2(l, h) + s(this.pathRotationOffset)) } } }; t.exports = h }, 72699: (t, e, i) => { const s = i(62644); const n = { defaultPipeline: null, pipeline: null, pipelineData: null, initPipeline: function (t) { this.pipelineData = {}; const e = this.scene.sys.renderer; if (!e) return !1; const i = e.pipelines; if (i) { void 0 === t && (t = i.default); const s = i.get(t); if (s) return this.defaultPipeline = s, this.pipeline = s, !0 } return !1 }, setPipeline: function (t, e, i) { const n = this.scene.sys.renderer; if (!n) return this; const r = n.pipelines; if (r) { const o = r.get(t); o && (this.pipeline = o), e && (this.pipelineData = i ? s(e) : e) } return this }, setPipelineData: function (t, e) { const i = this.pipelineData; return void 0 === e ? delete i[t] : i[t] = e, this }, resetPipeline: function (t) { return void 0 === t && (t = !1), this.pipeline = this.defaultPipeline, t && (this.pipelineData = {}), this.pipeline !== null }, getPipelineName: function () { return this.pipeline.name } }; t.exports = n }, 17581: (t, e, i) => { const s = i(62644); const n = i(47059); const r = i(19133); const o = { hasPostPipeline: !1, postPipelines: null, postPipelineData: null, preFX: null, postFX: null, initPostPipeline: function (t) { this.postPipelines = [], this.postPipelineData = {}, this.postFX = new n(this, !0), t && (this.preFX = new n(this, !1)) }, setPostPipeline: function (t, e, i) { const n = this.scene.sys.renderer; if (!n) return this; const r = n.pipelines; if (r) { Array.isArray(t) || (t = [t]); for (let o = 0; o < t.length; o++) { const a = r.getPostPipeline(t[o], this, e); a && this.postPipelines.push(a) } e && (this.postPipelineData = i ? s(e) : e) } return this.hasPostPipeline = this.postPipelines.length > 0, this }, setPostPipelineData: function (t, e) { const i = this.postPipelineData; return void 0 === e ? delete i[t] : i[t] = e, this }, getPostPipeline: function (t) { for (var e = typeof t === 'string', i = this.postPipelines, s = [], n = 0; n < i.length; n++) { const r = i[n]; (e && r.name === t || !e && r instanceof t) && s.push(r) } return s.length === 1 ? s[0] : s }, resetPostPipeline: function (t) { void 0 === t && (t = !1); for (let e = this.postPipelines, i = 0; i < e.length; i++)e[i].destroy(); this.postPipelines = [], this.hasPostPipeline = !1, t && (this.postPipelineData = {}) }, removePostPipeline: function (t) { for (let e = typeof t === 'string', i = this.postPipelines, s = i.length - 1; s >= 0; s--) { const n = i[s]; (e && n.name === t || !e && n === t) && (n.destroy(), r(i, s)) } return this.hasPostPipeline = this.postPipelines.length > 0, this }, clearFX: function () { return this.preFX && this.preFX.clear(), this.postFX && this.postFX.clear(), this } }; t.exports = o }, 80227: t => { const e = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor: function (t, e) { return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this } }; t.exports = e }, 16736: t => { const e = { _sizeComponent: !0, width: 0, height: 0, displayWidth: { get: function () { return Math.abs(this.scaleX * this.frame.realWidth) }, set: function (t) { this.scaleX = t / this.frame.realWidth } }, displayHeight: { get: function () { return Math.abs(this.scaleY * this.frame.realHeight) }, set: function (t) { this.scaleY = t / this.frame.realHeight } }, setSizeToFrame: function (t) { t || (t = this.frame), this.width = t.realWidth, this.height = t.realHeight; const e = this.input; return e && !e.customHitArea && (e.hitArea.width = this.width, e.hitArea.height = this.height), this }, setSize: function (t, e) { return this.width = t, this.height = e, this }, setDisplaySize: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this } }; t.exports = e }, 37726: (t, e, i) => { const s = i(4327); const n = { texture: null, frame: null, isCropped: !1, setTexture: function (t, e, i, s) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e, i, s) }, setFrame: function (t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), t instanceof s ? (this.texture = this.scene.sys.textures.get(t.texture.key), this.frame = t) : this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this } }; t.exports = n }, 79812: (t, e, i) => { const s = i(4327); const n = { texture: null, frame: null, isCropped: !1, setCrop: function (t, e, i, s) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, s, this.flipX, this.flipY); else { const n = t; this.frame.setCropUVs(this._crop, n.x, n.y, n.width, n.height, this.flipX, this.flipY) } this.isCropped = !0 } return this }, setTexture: function (t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e) }, setFrame: function (t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), t instanceof s ? (this.texture = this.scene.sys.textures.get(t.texture.key), this.frame = t) : this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this }, resetCropObject: function () { return { u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0 } } }; t.exports = n }, 27472: t => { const e = { tintTopLeft: 16777215, tintTopRight: 16777215, tintBottomLeft: 16777215, tintBottomRight: 16777215, tintFill: !1, clearTint: function () { return this.setTint(16777215), this }, setTint: function (t, e, i, s) { return void 0 === t && (t = 16777215), void 0 === e && (e = t, i = t, s = t), this.tintTopLeft = t, this.tintTopRight = e, this.tintBottomLeft = i, this.tintBottomRight = s, this.tintFill = !1, this }, setTintFill: function (t, e, i, s) { return this.setTint(t, e, i, s), this.tintFill = !0, this }, tint: { get: function () { return this.tintTopLeft }, set: function (t) { this.setTint(t, t, t, t) } }, isTinted: { get: function () { const t = 16777215; return this.tintFill || this.tintTopLeft !== t || this.tintTopRight !== t || this.tintBottomLeft !== t || this.tintBottomRight !== t } } }; t.exports = e }, 53774: t => { t.exports = function (t) { const e = { name: t.name, type: t.type, x: t.x, y: t.y, depth: t.depth, scale: { x: t.scaleX, y: t.scaleY }, origin: { x: t.originX, y: t.originY }, flipX: t.flipX, flipY: t.flipY, rotation: t.rotation, alpha: t.alpha, visible: t.visible, blendMode: t.blendMode, textureKey: '', frameKey: '', data: {} }; return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e } }, 16901: (t, e, i) => { const s = i(36383); const n = i(61340); const r = i(85955); const o = i(86554); const a = i(30954); const h = i(26099); const l = { hasTransformComponent: !0, _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get: function () { return (this._scaleX + this._scaleY) / 2 }, set: function (t) { this._scaleX = t, this._scaleY = t, t === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4 } }, scaleX: { get: function () { return this._scaleX }, set: function (t) { this._scaleX = t, t === 0 ? this.renderFlags &= -5 : this._scaleY !== 0 && (this.renderFlags |= 4) } }, scaleY: { get: function () { return this._scaleY }, set: function (t) { this._scaleY = t, t === 0 ? this.renderFlags &= -5 : this._scaleX !== 0 && (this.renderFlags |= 4) } }, angle: { get: function () { return a(this._rotation * s.RAD_TO_DEG) }, set: function (t) { this.rotation = a(t) * s.DEG_TO_RAD } }, rotation: { get: function () { return this._rotation }, set: function (t) { this._rotation = o(t) } }, setPosition: function (t, e, i, s) { return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === s && (s = 0), this.x = t, this.y = e, this.z = i, this.w = s, this }, copyPosition: function (t) { return void 0 !== t.x && (this.x = t.x), void 0 !== t.y && (this.y = t.y), void 0 !== t.z && (this.z = t.z), void 0 !== t.w && (this.w = t.w), this }, setRandomPosition: function (t, e, i, s) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === s && (s = this.scene.sys.scale.height), this.x = t + Math.random() * i, this.y = e + Math.random() * s, this }, setRotation: function (t) { return void 0 === t && (t = 0), this.rotation = t, this }, setAngle: function (t) { return void 0 === t && (t = 0), this.angle = t, this }, setScale: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this }, setX: function (t) { return void 0 === t && (t = 0), this.x = t, this }, setY: function (t) { return void 0 === t && (t = 0), this.y = t, this }, setZ: function (t) { return void 0 === t && (t = 0), this.z = t, this }, setW: function (t) { return void 0 === t && (t = 0), this.w = t, this }, getLocalTransformMatrix: function (t) { return void 0 === t && (t = new n()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY) }, getWorldTransformMatrix: function (t, e) { void 0 === t && (t = new n()); let i = this.parentContainer; if (!i) return this.getLocalTransformMatrix(t); for (e || (e = new n()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); i;)e.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), e.multiply(t, t), i = i.parentContainer; return t }, getLocalPoint: function (t, e, i, s) { i || (i = new h()), s || (s = this.scene.sys.cameras.main); const n = s.scrollX; const o = s.scrollY; const a = t + n * this.scrollFactorX - n; const l = e + o * this.scrollFactorY - o; return this.parentContainer ? this.getWorldTransformMatrix().applyInverse(a, l, i) : r(a, l, this.x, this.y, this.rotation, this.scaleX, this.scaleY, i), this._originComponent && (i.x += this._displayOriginX, i.y += this._displayOriginY), i }, getParentRotation: function () { for (var t = 0, e = this.parentContainer; e;)t += e.rotation, e = e.parentContainer; return t } }; t.exports = l }, 61340: (t, e, i) => { const s = i(83419); const n = i(36383); const r = i(26099); const o = new s({ initialize: function (t, e, i, s, n, r) { void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, s, n, r, 0, 0, 1]), this.decomposedMatrix = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0 }, this.quad = new Float32Array(8) }, a: { get: function () { return this.matrix[0] }, set: function (t) { this.matrix[0] = t } }, b: { get: function () { return this.matrix[1] }, set: function (t) { this.matrix[1] = t } }, c: { get: function () { return this.matrix[2] }, set: function (t) { this.matrix[2] = t } }, d: { get: function () { return this.matrix[3] }, set: function (t) { this.matrix[3] = t } }, e: { get: function () { return this.matrix[4] }, set: function (t) { this.matrix[4] = t } }, f: { get: function () { return this.matrix[5] }, set: function (t) { this.matrix[5] = t } }, tx: { get: function () { return this.matrix[4] }, set: function (t) { this.matrix[4] = t } }, ty: { get: function () { return this.matrix[5] }, set: function (t) { this.matrix[5] = t } }, rotation: { get: function () { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1) } }, rotationNormalized: { get: function () { const t = this.matrix; const e = t[0]; const i = t[1]; const s = t[2]; const r = t[3]; return e || i ? i > 0 ? Math.acos(e / this.scaleX) : -Math.acos(e / this.scaleX) : s || r ? n.TAU - (r > 0 ? Math.acos(-s / this.scaleY) : -Math.acos(s / this.scaleY)) : 0 } }, scaleX: { get: function () { return Math.sqrt(this.a * this.a + this.b * this.b) } }, scaleY: { get: function () { return Math.sqrt(this.c * this.c + this.d * this.d) } }, loadIdentity: function () { const t = this.matrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this }, translate: function (t, e) { const i = this.matrix; return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this }, scale: function (t, e) { const i = this.matrix; return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this }, rotate: function (t) { const e = Math.sin(t); const i = Math.cos(t); const s = this.matrix; const n = s[0]; const r = s[1]; const o = s[2]; const a = s[3]; return s[0] = n * i + o * e, s[1] = r * i + a * e, s[2] = n * -e + o * i, s[3] = r * -e + a * i, this }, multiply: function (t, e) { const i = this.matrix; const s = t.matrix; const n = i[0]; const r = i[1]; const o = i[2]; const a = i[3]; const h = i[4]; const l = i[5]; const u = s[0]; const c = s[1]; const d = s[2]; const f = s[3]; const p = s[4]; const v = s[5]; const g = void 0 === e ? i : e.matrix; return g[0] = u * n + c * o, g[1] = u * r + c * a, g[2] = d * n + f * o, g[3] = d * r + f * a, g[4] = p * n + v * o + h, g[5] = p * r + v * a + l, g }, multiplyWithOffset: function (t, e, i) { const s = this.matrix; const n = t.matrix; const r = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = e * r + i * a + s[4]; const u = e * o + i * h + s[5]; const c = n[0]; const d = n[1]; const f = n[2]; const p = n[3]; const v = n[4]; const g = n[5]; return s[0] = c * r + d * a, s[1] = c * o + d * h, s[2] = f * r + p * a, s[3] = f * o + p * h, s[4] = v * r + g * a + l, s[5] = v * o + g * h + u, this }, transform: function (t, e, i, s, n, r) { const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = t * a + e * l, o[1] = t * h + e * u, o[2] = i * a + s * l, o[3] = i * h + s * u, o[4] = n * a + r * l + c, o[5] = n * h + r * u + d, this }, transformPoint: function (t, e, i) { void 0 === i && (i = { x: 0, y: 0 }); const s = this.matrix; const n = s[0]; const r = s[1]; const o = s[2]; const a = s[3]; const h = s[4]; const l = s[5]; return i.x = t * n + e * o + h, i.y = t * r + e * a + l, i }, invert: function () { const t = this.matrix; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = e * n - i * s; return t[0] = n / a, t[1] = -i / a, t[2] = -s / a, t[3] = e / a, t[4] = (s * o - n * r) / a, t[5] = -(e * o - i * r) / a, this }, copyFrom: function (t) { const e = this.matrix; return e[0] = t.a, e[1] = t.b, e[2] = t.c, e[3] = t.d, e[4] = t.e, e[5] = t.f, this }, copyFromArray: function (t) { const e = this.matrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], this }, copyToContext: function (t) { const e = this.matrix; return t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t }, setToContext: function (t) { return t.setTransform(this), t }, copyToArray: function (t) { const e = this.matrix; return void 0 === t ? t = [e[0], e[1], e[2], e[3], e[4], e[5]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5]), t }, setTransform: function (t, e, i, s, n, r) { const o = this.matrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = s, o[4] = n, o[5] = r, this }, decomposeMatrix: function () { const t = this.decomposedMatrix; const e = this.matrix; const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; const o = i * r - s * n; if (t.translateX = e[4], t.translateY = e[5], i || s) { const a = Math.sqrt(i * i + s * s); t.rotation = s > 0 ? Math.acos(i / a) : -Math.acos(i / a), t.scaleX = a, t.scaleY = o / a } else if (n || r) { const h = Math.sqrt(n * n + r * r); t.rotation = 0.5 * Math.PI - (r > 0 ? Math.acos(-n / h) : -Math.acos(n / h)), t.scaleX = o / h, t.scaleY = h } else t.rotation = 0, t.scaleX = 0, t.scaleY = 0; return t }, applyITRS: function (t, e, i, s, n) { const r = this.matrix; const o = Math.sin(i); const a = Math.cos(i); return r[4] = t, r[5] = e, r[0] = a * s, r[1] = o * s, r[2] = -o * n, r[3] = a * n, this }, applyInverse: function (t, e, i) { void 0 === i && (i = new r()); const s = this.matrix; const n = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = s[4]; const u = s[5]; const c = 1 / (n * h + a * -o); return i.x = h * c * t + -a * c * e + (u * a - l * h) * c, i.y = n * c * e + -o * c * t + (-u * n + l * o) * c, i }, setQuad: function (t, e, i, s, n, r) { void 0 === n && (n = !1), void 0 === r && (r = this.quad); const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return n ? (r[0] = Math.round(t * a + e * l + c), r[1] = Math.round(t * h + e * u + d), r[2] = Math.round(t * a + s * l + c), r[3] = Math.round(t * h + s * u + d), r[4] = Math.round(i * a + s * l + c), r[5] = Math.round(i * h + s * u + d), r[6] = Math.round(i * a + e * l + c), r[7] = Math.round(i * h + e * u + d)) : (r[0] = t * a + e * l + c, r[1] = t * h + e * u + d, r[2] = t * a + s * l + c, r[3] = t * h + s * u + d, r[4] = i * a + s * l + c, r[5] = i * h + s * u + d, r[6] = i * a + e * l + c, r[7] = i * h + e * u + d), r }, getX: function (t, e) { return t * this.a + e * this.c + this.e }, getY: function (t, e) { return t * this.b + e * this.d + this.f }, getXRound: function (t, e, i) { let s = this.getX(t, e); return i && (s = Math.round(s)), s }, getYRound: function (t, e, i) { let s = this.getY(t, e); return i && (s = Math.round(s)), s }, getCSSMatrix: function () { const t = this.matrix; return 'matrix(' + t[0] + ',' + t[1] + ',' + t[2] + ',' + t[3] + ',' + t[4] + ',' + t[5] + ')' }, destroy: function () { this.matrix = null, this.quad = null, this.decomposedMatrix = null } }); t.exports = o }, 59715: t => { const e = { _visible: !0, visible: { get: function () { return this._visible }, set: function (t) { t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2) } }, setVisible: function (t) { return this.visible = t, this } }; t.exports = e }, 31401: (t, e, i) => { t.exports = { Alpha: i(16005), AlphaSingle: i(88509), BlendMode: i(90065), ComputedSize: i(94215), Crop: i(61683), Depth: i(89272), Flip: i(54434), FX: i(47059), GetBounds: i(8004), Mask: i(8573), Origin: i(27387), PathFollower: i(37640), Pipeline: i(72699), PostPipeline: i(17581), ScrollFactor: i(80227), Size: i(16736), Texture: i(37726), TextureCrop: i(79812), Tint: i(27472), ToJSON: i(53774), Transform: i(16901), TransformMatrix: i(61340), Visible: i(59715) } }, 31559: (t, e, i) => { const s = i(37105); const n = i(10312); const r = i(83419); const o = i(31401); const a = i(51708); const h = i(95643); const l = i(87841); const u = i(29959); const c = i(36899); const d = i(26099); const f = new r({ Extends: h, Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.PostPipeline, o.Transform, o.Visible, u], initialize: function (t, e, i, s) { h.call(this, t, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix(), this.tempTransformMatrix = new o.TransformMatrix(), this._sortKey = '', this._sysEvents = t.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.initPostPipeline(), this.setPosition(e, i), this.setBlendMode(n.SKIP_CHECK), s && this.add(s) }, originX: { get: function () { return 0.5 } }, originY: { get: function () { return 0.5 } }, displayOriginX: { get: function () { return 0.5 * this.width } }, displayOriginY: { get: function () { return 0.5 * this.height } }, setExclusive: function (t) { return void 0 === t && (t = !0), this.exclusive = t, this }, getBounds: function (t) { if (void 0 === t && (t = new l()), t.setTo(this.x, this.y, 0, 0), this.parentContainer) { const e = this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x, this.y); t.setTo(e.x, e.y, 0, 0) } if (this.list.length > 0) { const i = this.list; const s = new l(); let n = !1; t.setEmpty(); for (let r = 0; r < i.length; r++) { const o = i[r]; o.getBounds && (o.getBounds(s), n ? c(s, t, t) : (t.setTo(s.x, s.y, s.width, s.height), n = !0)) } } return t }, addHandler: function (t) { t.once(a.DESTROY, this.onChildDestroyed, this), this.exclusive && (t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this, t.removeFromDisplayList(), t.addedToScene()) }, removeHandler: function (t) { t.off(a.DESTROY, this.remove, this), this.exclusive && (t.parentContainer = null, t.removedFromScene(), t.addToDisplayList()) }, pointToContainer: function (t, e) { void 0 === e && (e = new d()), this.parentContainer ? this.parentContainer.pointToContainer(t, e) : (e.x = t.x, e.y = t.y); const i = this.tempTransformMatrix; return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e }, getBoundsTransformMatrix: function () { return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform) }, add: function (t) { return s.Add(this.list, t, this.maxSize, this.addHandler, this), this }, addAt: function (t, e) { return s.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this }, getAt: function (t) { return this.list[t] }, getIndex: function (t) { return this.list.indexOf(t) }, sort: function (t, e) { return t ? (void 0 === e && (e = function (e, i) { return e[t] - i[t] }), s.StableSort(this.list, e), this) : this }, getByName: function (t) { return s.GetFirst(this.list, 'name', t) }, getRandom: function (t, e) { return s.GetRandom(this.list, t, e) }, getFirst: function (t, e, i, n) { return s.GetFirst(this.list, t, e, i, n) }, getAll: function (t, e, i, n) { return s.GetAll(this.list, t, e, i, n) }, count: function (t, e, i, n) { return s.CountAllMatching(this.list, t, e, i, n) }, swap: function (t, e) { return s.Swap(this.list, t, e), this }, moveTo: function (t, e) { return s.MoveTo(this.list, t, e), this }, moveAbove: function (t, e) { return s.MoveAbove(this.list, t, e), this }, moveBelow: function (t, e) { return s.MoveBelow(this.list, t, e), this }, remove: function (t, e) { let i = s.Remove(this.list, t, this.removeHandler, this); if (e && i) { Array.isArray(i) || (i = [i]); for (let n = 0; n < i.length; n++)i[n].destroy() } return this }, removeAt: function (t, e) { const i = s.RemoveAt(this.list, t, this.removeHandler, this); return e && i && i.destroy(), this }, removeBetween: function (t, e, i) { const n = s.RemoveBetween(this.list, t, e, this.removeHandler, this); if (i) for (let r = 0; r < n.length; r++)n[r].destroy(); return this }, removeAll: function (t) { const e = this.list; if (t) { for (let i = 0; i < e.length; i++)e[i] && e[i].scene && (e[i].off(a.DESTROY, this.onChildDestroyed, this), e[i].destroy()); this.list = [] } else s.RemoveBetween(e, 0, e.length, this.removeHandler, this); return this }, bringToTop: function (t) { return s.BringToTop(this.list, t), this }, sendToBack: function (t) { return s.SendToBack(this.list, t), this }, moveUp: function (t) { return s.MoveUp(this.list, t), this }, moveDown: function (t) { return s.MoveDown(this.list, t), this }, reverse: function () { return this.list.reverse(), this }, shuffle: function () { return s.Shuffle(this.list), this }, replace: function (t, e, i) { return s.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this }, exists: function (t) { return this.list.indexOf(t) > -1 }, setAll: function (t, e, i, n) { return s.SetAll(this.list, t, e, i, n), this }, each: function (t, e) { let i; const s = [null]; const n = this.list.slice(); const r = n.length; for (i = 2; i < arguments.length; i++)s.push(arguments[i]); for (i = 0; i < r; i++)s[0] = n[i], t.apply(e, s); return this }, iterate: function (t, e) { let i; const s = [null]; for (i = 2; i < arguments.length; i++)s.push(arguments[i]); for (i = 0; i < this.list.length; i++)s[0] = this.list[i], t.apply(e, s); return this }, setScrollFactor: function (t, e, i) { return void 0 === e && (e = t), void 0 === i && (i = !1), this.scrollFactorX = t, this.scrollFactorY = e, i && (s.SetAll(this.list, 'scrollFactorX', t), s.SetAll(this.list, 'scrollFactorY', e)), this }, length: { get: function () { return this.list.length } }, first: { get: function () { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }, last: { get: function () { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null } }, next: { get: function () { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }, previous: { get: function () { return this.position > 0 ? (this.position--, this.list[this.position]) : null } }, preDestroy: function () { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [] }, onChildDestroyed: function (t) { s.Remove(this.list, t), this.exclusive && (t.parentContainer = null, t.removedFromScene()) } }); t.exports = f }, 53584: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e); const n = e.list; if (n.length !== 0) { const r = e.localTransform; s ? (r.loadIdentity(), r.multiply(s), r.translate(e.x, e.y), r.rotate(e.rotation), r.scale(e.scaleX, e.scaleY)) : r.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const o = e.blendMode !== -1; o || t.setBlendMode(0); const a = e._alpha; const h = e.scrollFactorX; const l = e.scrollFactorY; e.mask && e.mask.preRenderCanvas(t, null, i); for (let u = 0; u < n.length; u++) { const c = n[u]; if (c.willRender(i)) { const d = c.alpha; const f = c.scrollFactorX; const p = c.scrollFactorY; o || c.blendMode === t.currentBlendMode || t.setBlendMode(c.blendMode), c.setScrollFactor(f * h, p * l), c.setAlpha(d * a), c.renderCanvas(t, c, i, r), c.setAlpha(d), c.setScrollFactor(f, p) } } e.mask && e.mask.postRenderCanvas(t) } } }, 77143: (t, e, i) => { const s = i(25305); const n = i(31559); const r = i(44603); const o = i(23568); const a = i(95540); r.register('container', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'x', 0); const r = o(t, 'y', 0); const h = a(t, 'children', null); const l = new n(this.scene, i, r, h); return void 0 !== e && (t.add = e), s(this.scene, l, t), l }) }, 24961: (t, e, i) => { const s = i(31559); i(39429).register('container', function (t, e, i) { return this.displayList.add(new s(this.scene, t, e, i)) }) }, 29959: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(72249), r = i(53584), t.exports = { renderWebGL: n, renderCanvas: r } }, 72249: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e); const n = e.list; const r = n.length; if (r !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), t.pipelines.preBatch(e); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e.alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < r; c++) { const d = n[c]; if (d.willRender(i)) { var f, p, v, g; if (void 0 !== d.alphaTopLeft) f = d.alphaTopLeft, p = d.alphaTopRight, v = d.alphaBottomLeft, g = d.alphaBottomRight; else { const m = d.alpha; f = m, p = m, v = m, g = m } const y = d.scrollFactorX; const x = d.scrollFactorY; a || d.blendMode === t.currentBlendMode || t.setBlendMode(d.blendMode); const T = d.mask; T && T.preRenderWebGL(t, d, i); const w = d.type; w !== t.currentType && (t.newType = !0, t.currentType = w), t.nextTypeMatch = c < r - 1 && n[c + 1].type === t.currentType, d.setScrollFactor(y * l, x * u), d.setAlpha(f * h, p * h, v * h, g * h), d.renderWebGL(t, d, i, o, e), d.setAlpha(f, p, v, g), d.setScrollFactor(y, x), T && T.postRenderWebGL(t, i), t.newType = !1 } } t.pipelines.postBatch(e) } } }, 47407: t => { t.exports = ['normal', 'multiply', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'] }, 3069: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(441); const o = i(95643); const a = i(41212); const h = i(35846); const l = i(44594); const u = i(61369); const c = new s({ Extends: o, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Origin, n.ScrollFactor, n.Transform, n.Visible, r], initialize: function (t, e, i, s, n, r) { o.call(this, t, 'DOMElement'), this.parent = t.sys.game.domContainer, this.cache = t.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new u(), this.rotate3dAngle = 'deg', this.pointerEvents = 'auto', this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(e, i), typeof s === 'string' ? s[0] === '#' ? this.setElement(s.substr(1), n, r) : this.createElement(s, n, r) : s && this.setElement(s, n, r), t.sys.events.on(l.SLEEP, this.handleSceneEvent, this), t.sys.events.on(l.WAKE, this.handleSceneEvent, this), t.sys.events.on(l.PRE_RENDER, this.preRender, this) }, handleSceneEvent: function (t) { const e = this.node; const i = e.style; e && (i.display = t.settings.visible ? 'block' : 'none') }, setSkew: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.skewX = t, this.skewY = e, this }, setPerspective: function (t) { return this.parent.style.perspective = t + 'px', this }, perspective: { get: function () { return parseFloat(this.parent.style.perspective) }, set: function (t) { this.parent.style.perspective = t + 'px' } }, addListener: function (t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.addEventListener(t[e], this.handler, !1) } return this }, removeListener: function (t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.removeEventListener(t[e], this.handler) } return this }, dispatchNativeEvent: function (t) { this.emit(t.type, t) }, createElement: function (t, e, i) { return this.setElement(document.createElement(t), e, i) }, setElement: function (t, e, i) { let s; if (this.removeElement(), typeof t === 'string' ? (t[0] === '#' && (t = t.substr(1)), s = document.getElementById(t)) : typeof t === 'object' && t.nodeType === 1 && (s = t), !s) return this; if (this.node = s, e && a(e)) for (const n in e) s.style[n] = e[n]; else typeof e === 'string' && (s.style = e); return s.style.zIndex = '0', s.style.display = 'inline', s.style.position = 'absolute', s.phaser = this, this.parent && this.parent.appendChild(s), i && (s.innerText = i), this.updateSize() }, createFromCache: function (t, e) { const i = this.cache.get(t); return i && this.createFromHTML(i, e), this }, createFromHTML: function (t, e) { void 0 === e && (e = 'div'), this.removeElement(); const i = document.createElement(e); return this.node = i, i.style.zIndex = '0', i.style.display = 'inline', i.style.position = 'absolute', i.phaser = this, this.parent && this.parent.appendChild(i), i.innerHTML = t, this.updateSize() }, removeElement: function () { return this.node && (h(this.node), this.node = null), this }, updateSize: function () { const t = this.node; const e = t.getBoundingClientRect(); return this.width = t.clientWidth, this.height = t.clientHeight, this.displayWidth = e.width || 0, this.displayHeight = e.height || 0, this }, getChildByProperty: function (t, e) { if (this.node) for (let i = this.node.querySelectorAll('*'), s = 0; s < i.length; s++) if (i[s][t] === e) return i[s]; return null }, getChildByID: function (t) { return this.getChildByProperty('id', t) }, getChildByName: function (t) { return this.getChildByProperty('name', t) }, setClassName: function (t) { return this.node && (this.node.className = t, this.updateSize()), this }, setText: function (t) { return this.node && (this.node.innerText = t, this.updateSize()), this }, setHTML: function (t) { return this.node && (this.node.innerHTML = t, this.updateSize()), this }, preRender: function () { const t = this.parentContainer; const e = this.node; e && t && !t.willRender() && (e.style.display = 'none') }, willRender: function () { return !0 }, preDestroy: function () { this.removeElement(), this.scene.sys.events.off(l.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(l.WAKE, this.handleSceneEvent, this), this.scene.sys.events.off(l.PRE_RENDER, this.preRender, this) } }); t.exports = c }, 49381: (t, e, i) => { const s = i(47407); const n = i(95643); const r = i(61340); const o = new r(); const a = new r(); const h = new r(); t.exports = function (t, e, i, r) { if (e.node) { const l = e.node.style; const u = e.scene.sys.settings; if (!l || !u.visible || n.RENDER_MASK !== e.renderFlags || e.cameraFilter !== 0 && e.cameraFilter & i.id || e.parentContainer && !e.parentContainer.willRender()) l.display = 'none'; else { const c = e.parentContainer; let d = i.alpha * e.alpha; c && (d *= c.alpha); const f = o; const p = a; const v = h; let g = 0; let m = 0; let y = '0%'; let x = '0%'; r ? (g = e.width * e.scaleX * e.originX, m = e.height * e.scaleY * e.originY, p.applyITRS(e.x - g, e.y - m, e.rotation, e.scaleX, e.scaleY), f.copyFrom(i.matrix), f.multiplyWithOffset(r, -i.scrollX * e.scrollFactorX, -i.scrollY * e.scrollFactorY), p.e = e.x - g, p.f = e.y - m, f.multiply(p, v)) : (g = e.width * e.originX, m = e.height * e.originY, p.applyITRS(e.x - g, e.y - m, e.rotation, e.scaleX, e.scaleY), f.copyFrom(i.matrix), y = 100 * e.originX + '%', x = 100 * e.originY + '%', p.e -= i.scrollX * e.scrollFactorX, p.f -= i.scrollY * e.scrollFactorY, f.multiply(p, v)), e.transformOnly || (l.display = 'block', l.opacity = d, l.zIndex = e._depth, l.pointerEvents = e.pointerEvents, l.mixBlendMode = s[e._blendMode]), l.transform = v.getCSSMatrix() + ' skew(' + e.skewX + 'rad, ' + e.skewY + 'rad) rotate3d(' + e.rotate3d.x + ',' + e.rotate3d.y + ',' + e.rotate3d.z + ',' + e.rotate3d.w + e.rotate3dAngle + ')', l.transformOrigin = y + ' ' + x } } } }, 2611: (t, e, i) => { const s = i(3069); i(39429).register('dom', function (t, e, i, n, r) { const o = new s(this.scene, t, e, i, n, r); return this.displayList.add(o), o }) }, 441: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(49381), r = i(49381), t.exports = { renderWebGL: n, renderCanvas: r } }, 62980: t => { t.exports = 'addedtoscene' }, 41337: t => { t.exports = 'destroy' }, 44947: t => { t.exports = 'removedfromscene' }, 49358: t => { t.exports = 'complete' }, 35163: t => { t.exports = 'created' }, 97249: t => { t.exports = 'error' }, 19483: t => { t.exports = 'locked' }, 56059: t => { t.exports = 'loop' }, 26772: t => { t.exports = 'metadata' }, 64437: t => { t.exports = 'playing' }, 83411: t => { t.exports = 'play' }, 75780: t => { t.exports = 'seeked' }, 67799: t => { t.exports = 'seeking' }, 63500: t => { t.exports = 'stalled' }, 55541: t => { t.exports = 'stop' }, 53208: t => { t.exports = 'textureready' }, 4992: t => { t.exports = 'unlocked' }, 12: t => { t.exports = 'unsupported' }, 51708: (t, e, i) => { t.exports = { ADDED_TO_SCENE: i(62980), DESTROY: i(41337), REMOVED_FROM_SCENE: i(44947), VIDEO_COMPLETE: i(49358), VIDEO_CREATED: i(35163), VIDEO_ERROR: i(97249), VIDEO_LOCKED: i(19483), VIDEO_LOOP: i(56059), VIDEO_METADATA: i(26772), VIDEO_PLAY: i(83411), VIDEO_PLAYING: i(64437), VIDEO_SEEKED: i(75780), VIDEO_SEEKING: i(67799), VIDEO_STALLED: i(63500), VIDEO_STOP: i(55541), VIDEO_TEXTURE: i(53208), VIDEO_UNLOCKED: i(4992), VIDEO_UNSUPPORTED: i(12) } }, 42421: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(64993); const a = new s({ Extends: r, Mixins: [n.Alpha, n.BlendMode, n.Depth, n.Flip, n.Origin, n.ScrollFactor, n.Size, n.Texture, n.Tint, n.Transform, n.Visible, o], initialize: function (t) { r.call(this, t, 'Extern') }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function () { }, render: function () { } }); t.exports = a }, 70217: () => { }, 56315: (t, e, i) => { const s = i(42421); i(39429).register('extern', function () { const t = new s(this.scene); return this.displayList.add(t), t }) }, 64993: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(80287), r = i(70217), t.exports = { renderWebGL: n, renderCanvas: r } }, 80287: (t, e, i) => { const s = i(91296); t.exports = function (t, e, i, n) { t.pipelines.clear(); const r = s(e, i, n).calc; e.render.call(e, t, i, r), t.pipelines.rebind() } }, 85592: t => { t.exports = { ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22 } }, 43831: (t, e, i) => { const s = i(71911); const n = i(83419); const r = i(85592); const o = i(31401); const a = i(8497); const h = i(95643); const l = i(95540); const u = i(35154); const c = i(36383); const d = i(84503); var f = new n({ Extends: h, Mixins: [o.AlphaSingle, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.PostPipeline, o.Transform, o.Visible, o.ScrollFactor, d], initialize: function (t, e) { const i = u(e, 'x', 0); const s = u(e, 'y', 0); h.call(this, t, 'Graphics'), this.setPosition(i, s), this.initPipeline(), this.initPostPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this.lineStyle(1, 0, 0), this.fillStyle(0, 0), this.setDefaultStyles(e) }, setDefaultStyles: function (t) { return u(t, 'lineStyle', null) && (this.defaultStrokeWidth = u(t, 'lineStyle.width', 1), this.defaultStrokeColor = u(t, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = u(t, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), u(t, 'fillStyle', null) && (this.defaultFillColor = u(t, 'fillStyle.color', 16777215), this.defaultFillAlpha = u(t, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this }, lineStyle: function (t, e, i) { return void 0 === i && (i = 1), this.commandBuffer.push(r.LINE_STYLE, t, e, i), this._lineWidth = t, this }, fillStyle: function (t, e) { return void 0 === e && (e = 1), this.commandBuffer.push(r.FILL_STYLE, t, e), this }, fillGradientStyle: function (t, e, i, s, n, o, a, h) { return void 0 === n && (n = 1), void 0 === o && (o = n), void 0 === a && (a = n), void 0 === h && (h = n), this.commandBuffer.push(r.GRADIENT_FILL_STYLE, n, o, a, h, t, e, i, s), this }, lineGradientStyle: function (t, e, i, s, n, o) { return void 0 === o && (o = 1), this.commandBuffer.push(r.GRADIENT_LINE_STYLE, t, o, e, i, s, n), this }, beginPath: function () { return this.commandBuffer.push(r.BEGIN_PATH), this }, closePath: function () { return this.commandBuffer.push(r.CLOSE_PATH), this }, fillPath: function () { return this.commandBuffer.push(r.FILL_PATH), this }, fill: function () { return this.commandBuffer.push(r.FILL_PATH), this }, strokePath: function () { return this.commandBuffer.push(r.STROKE_PATH), this }, stroke: function () { return this.commandBuffer.push(r.STROKE_PATH), this }, fillCircleShape: function (t) { return this.fillCircle(t.x, t.y, t.radius) }, strokeCircleShape: function (t) { return this.strokeCircle(t.x, t.y, t.radius) }, fillCircle: function (t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, c.PI2), this.fillPath(), this }, strokeCircle: function (t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, c.PI2), this.strokePath(), this }, fillRectShape: function (t) { return this.fillRect(t.x, t.y, t.width, t.height) }, strokeRectShape: function (t) { return this.strokeRect(t.x, t.y, t.width, t.height) }, fillRect: function (t, e, i, s) { return this.commandBuffer.push(r.FILL_RECT, t, e, i, s), this }, strokeRect: function (t, e, i, s) { const n = this._lineWidth / 2; const r = t - n; const o = t + n; return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + s), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + s), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + s), this.lineTo(o + i, e + s), this.strokePath(), this }, fillRoundedRect: function (t, e, i, s, n) { void 0 === n && (n = 20); let r = n; let o = n; let a = n; let h = n; typeof n !== 'number' && (r = l(n, 'tl', 20), o = l(n, 'tr', 20), a = l(n, 'bl', 20), h = l(n, 'br', 20)); const u = r >= 0; const d = o >= 0; const f = a >= 0; const p = h >= 0; return r = Math.abs(r), o = Math.abs(o), a = Math.abs(a), h = Math.abs(h), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), d ? this.arc(t + i - o, e + o, o, -c.TAU, 0) : this.arc(t + i, e, o, Math.PI, c.TAU, !0), this.lineTo(t + i, e + s - h), p ? this.arc(t + i - h, e + s - h, h, 0, c.TAU) : this.arc(t + i, e + s, h, -c.TAU, Math.PI, !0), this.lineTo(t + a, e + s), f ? this.arc(t + a, e + s - a, a, c.TAU, Math.PI) : this.arc(t, e + s, a, 0, -c.TAU, !0), this.lineTo(t, e + r), u ? this.arc(t + r, e + r, r, -Math.PI, -c.TAU) : this.arc(t, e, r, c.TAU, 0, !0), this.fillPath(), this }, strokeRoundedRect: function (t, e, i, s, n) { void 0 === n && (n = 20); let r = n; let o = n; let a = n; let h = n; const u = Math.min(i, s) / 2; typeof n !== 'number' && (r = l(n, 'tl', 20), o = l(n, 'tr', 20), a = l(n, 'bl', 20), h = l(n, 'br', 20)); const d = r >= 0; const f = o >= 0; const p = a >= 0; const v = h >= 0; return r = Math.min(Math.abs(r), u), o = Math.min(Math.abs(o), u), a = Math.min(Math.abs(a), u), h = Math.min(Math.abs(h), u), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.moveTo(t + i - o, e), f ? this.arc(t + i - o, e + o, o, -c.TAU, 0) : this.arc(t + i, e, o, Math.PI, c.TAU, !0), this.lineTo(t + i, e + s - h), this.moveTo(t + i, e + s - h), v ? this.arc(t + i - h, e + s - h, h, 0, c.TAU) : this.arc(t + i, e + s, h, -c.TAU, Math.PI, !0), this.lineTo(t + a, e + s), this.moveTo(t + a, e + s), p ? this.arc(t + a, e + s - a, a, c.TAU, Math.PI) : this.arc(t, e + s, a, 0, -c.TAU, !0), this.lineTo(t, e + r), this.moveTo(t, e + r), d ? this.arc(t + r, e + r, r, -Math.PI, -c.TAU) : this.arc(t, e, r, c.TAU, 0, !0), this.strokePath(), this }, fillPointShape: function (t, e) { return this.fillPoint(t.x, t.y, e) }, fillPoint: function (t, e, i) { return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(r.FILL_RECT, t, e, i, i), this }, fillTriangleShape: function (t) { return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3) }, strokeTriangleShape: function (t) { return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3) }, fillTriangle: function (t, e, i, s, n, o) { return this.commandBuffer.push(r.FILL_TRIANGLE, t, e, i, s, n, o), this }, strokeTriangle: function (t, e, i, s, n, o) { return this.commandBuffer.push(r.STROKE_TRIANGLE, t, e, i, s, n, o), this }, strokeLineShape: function (t) { return this.lineBetween(t.x1, t.y1, t.x2, t.y2) }, lineBetween: function (t, e, i, s) { return this.beginPath(), this.moveTo(t, e), this.lineTo(i, s), this.strokePath(), this }, lineTo: function (t, e) { return this.commandBuffer.push(r.LINE_TO, t, e), this }, moveTo: function (t, e) { return this.commandBuffer.push(r.MOVE_TO, t, e), this }, strokePoints: function (t, e, i, s) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < s; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.strokePath(), this }, fillPoints: function (t, e, i, s) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let n = 1; n < s; n++) this.lineTo(t[n].x, t[n].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.fillPath(), this }, strokeEllipseShape: function (t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.strokePoints(i, !0) }, strokeEllipse: function (t, e, i, s, n) { void 0 === n && (n = 32); const r = new a(t, e, i, s).getPoints(n); return this.strokePoints(r, !0) }, fillEllipseShape: function (t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.fillPoints(i, !0) }, fillEllipse: function (t, e, i, s, n) { void 0 === n && (n = 32); const r = new a(t, e, i, s).getPoints(n); return this.fillPoints(r, !0) }, arc: function (t, e, i, s, n, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.ARC, t, e, i, s, n, o, a), this }, slice: function (t, e, i, s, n, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.BEGIN_PATH), this.commandBuffer.push(r.MOVE_TO, t, e), this.commandBuffer.push(r.ARC, t, e, i, s, n, o, a), this.commandBuffer.push(r.CLOSE_PATH), this }, save: function () { return this.commandBuffer.push(r.SAVE), this }, restore: function () { return this.commandBuffer.push(r.RESTORE), this }, translateCanvas: function (t, e) { return this.commandBuffer.push(r.TRANSLATE, t, e), this }, scaleCanvas: function (t, e) { return this.commandBuffer.push(r.SCALE, t, e), this }, rotateCanvas: function (t) { return this.commandBuffer.push(r.ROTATE, t), this }, clear: function () { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this }, generateTexture: function (t, e, i) { let s; let n; const r = this.scene.sys; const o = r.game.renderer; void 0 === e && (e = r.scale.width), void 0 === i && (i = r.scale.height), f.TargetCamera.setScene(this.scene), f.TargetCamera.setViewport(0, 0, e, i), f.TargetCamera.scrollX = this.x, f.TargetCamera.scrollY = this.y; const a = { willReadFrequently: !0 }; if (typeof t === 'string') if (r.textures.exists(t)) { const h = (s = r.textures.get(t)).getSourceImage(); h instanceof HTMLCanvasElement && (n = h.getContext('2d', a)) } else n = (s = r.textures.createCanvas(t, e, i)).getSourceImage().getContext('2d', a); else t instanceof HTMLCanvasElement && (n = t.getContext('2d', a)); return n && (this.renderCanvas(o, this, f.TargetCamera, null, n, !1), s && s.refresh()), this }, preDestroy: function () { this.commandBuffer = [] } }); f.TargetCamera = new s(), t.exports = f }, 32768: (t, e, i) => { const s = i(85592); const n = i(20926); t.exports = function (t, e, i, r, o, a) { const h = e.commandBuffer; const l = h.length; const u = o || t.currentContext; if (l !== 0 && n(t, u, e, i, r)) { i.addToRenderList(e); let c = 1; let d = 1; let f = 0; let p = 0; let v = 1; let g = 0; let m = 0; let y = 0; u.beginPath(); for (let x = 0; x < l; ++x) { switch (h[x]) { case s.ARC: u.arc(h[x + 1], h[x + 2], h[x + 3], h[x + 4], h[x + 5], h[x + 6]), x += 7; break; case s.LINE_STYLE: v = h[x + 1], f = h[x + 2], c = h[x + 3], g = (16711680 & f) >>> 16, m = (65280 & f) >>> 8, y = 255 & f, u.strokeStyle = 'rgba(' + g + ',' + m + ',' + y + ',' + c + ')', u.lineWidth = v, x += 3; break; case s.FILL_STYLE: p = h[x + 1], d = h[x + 2], g = (16711680 & p) >>> 16, m = (65280 & p) >>> 8, y = 255 & p, u.fillStyle = 'rgba(' + g + ',' + m + ',' + y + ',' + d + ')', x += 2; break; case s.BEGIN_PATH: u.beginPath(); break; case s.CLOSE_PATH: u.closePath(); break; case s.FILL_PATH: a || u.fill(); break; case s.STROKE_PATH: a || u.stroke(); break; case s.FILL_RECT: a ? u.rect(h[x + 1], h[x + 2], h[x + 3], h[x + 4]) : u.fillRect(h[x + 1], h[x + 2], h[x + 3], h[x + 4]), x += 4; break; case s.FILL_TRIANGLE: u.beginPath(), u.moveTo(h[x + 1], h[x + 2]), u.lineTo(h[x + 3], h[x + 4]), u.lineTo(h[x + 5], h[x + 6]), u.closePath(), a || u.fill(), x += 6; break; case s.STROKE_TRIANGLE: u.beginPath(), u.moveTo(h[x + 1], h[x + 2]), u.lineTo(h[x + 3], h[x + 4]), u.lineTo(h[x + 5], h[x + 6]), u.closePath(), a || u.stroke(), x += 6; break; case s.LINE_TO: u.lineTo(h[x + 1], h[x + 2]), x += 2; break; case s.MOVE_TO: u.moveTo(h[x + 1], h[x + 2]), x += 2; break; case s.LINE_FX_TO: u.lineTo(h[x + 1], h[x + 2]), x += 5; break; case s.MOVE_FX_TO: u.moveTo(h[x + 1], h[x + 2]), x += 5; break; case s.SAVE: u.save(); break; case s.RESTORE: u.restore(); break; case s.TRANSLATE: u.translate(h[x + 1], h[x + 2]), x += 2; break; case s.SCALE: u.scale(h[x + 1], h[x + 2]), x += 2; break; case s.ROTATE: u.rotate(h[x + 1]), x += 1; break; case s.GRADIENT_FILL_STYLE: x += 5; break; case s.GRADIENT_LINE_STYLE: x += 6 } } u.restore() } } }, 87079: (t, e, i) => { const s = i(44603); const n = i(43831); s.register('graphics', function (t, e) { void 0 === t && (t = {}), void 0 !== e && (t.add = e); const i = new n(this.scene, t); return t.add && this.scene.sys.displayList.add(i), i }) }, 1201: (t, e, i) => { const s = i(43831); i(39429).register('graphics', function (t) { return this.displayList.add(new s(this.scene, t)) }) }, 84503: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(77545), r = i(32768), r = i(32768), t.exports = { renderWebGL: n, renderCanvas: r } }, 77545: (t, e, i) => { const s = i(85592); const n = i(91296); const r = i(61340); const o = i(70554); const a = function (t, e, i) { this.x = t, this.y = e, this.width = i }; const h = function (t, e, i) { this.points = [], this.pointsLength = 1, this.points[0] = new a(t, e, i) }; const l = []; const u = new r(); t.exports = function (t, e, i, r) { if (e.commandBuffer.length !== 0) { i.addToRenderList(e); const c = t.pipelines.set(e.pipeline, e); t.pipelines.preBatch(e); for (let d = n(e, i, r).calc, f = u.loadIdentity(), p = e.commandBuffer, v = i.alpha * e.alpha, g = 1, m = c.fillTint, y = c.strokeTint, x = 0, T = 0, w = 0, b = 2 * Math.PI, S = [], E = 0, A = !0, C = null, _ = o.getTintAppendFloatAlpha, M = 0; M < p.length; M++) switch (p[M]) { case s.BEGIN_PATH: S.length = 0, C = null, A = !0; break; case s.CLOSE_PATH: A = !1, C && C.points.length && C.points.push(C.points[0]); break; case s.FILL_PATH: for (E = 0; E < S.length; E++)c.batchFillPath(S[E].points, f, d); break; case s.STROKE_PATH: for (E = 0; E < S.length; E++)c.batchStrokePath(S[E].points, g, A, f, d); break; case s.LINE_STYLE: g = p[++M]; var P = _(p[++M], p[++M] * v); y.TL = P, y.TR = P, y.BL = P, y.BR = P; break; case s.FILL_STYLE: var R = _(p[++M], p[++M] * v); m.TL = R, m.TR = R, m.BL = R, m.BR = R; break; case s.GRADIENT_FILL_STYLE: var L = p[++M] * v; var O = p[++M] * v; var F = p[++M] * v; var D = p[++M] * v; m.TL = _(p[++M], L), m.TR = _(p[++M], O), m.BL = _(p[++M], F), m.BR = _(p[++M], D); break; case s.GRADIENT_LINE_STYLE: g = p[++M]; var k = p[++M] * v; y.TL = _(p[++M], k), y.TR = _(p[++M], k), y.BL = _(p[++M], k), y.BR = _(p[++M], k); break; case s.ARC: var I = 0; var B = p[++M]; var N = p[++M]; var U = p[++M]; var X = p[++M]; var Y = p[++M]; var z = p[++M]; var G = p[++M]; for (Y -= X, z ? Y < -b ? Y = -b : Y > 0 && (Y = Y % b - b) : Y > b ? Y = b : Y < 0 && (Y = b + Y % b), C === null && (C = new h(B + Math.cos(X) * U, N + Math.sin(X) * U, g), S.push(C), I += 0.01); I < 1 + G;)w = Y * I + X, x = B + Math.cos(w) * U, T = N + Math.sin(w) * U, C.points.push(new a(x, T, g)), I += 0.01; w = Y + X, x = B + Math.cos(w) * U, T = N + Math.sin(w) * U, C.points.push(new a(x, T, g)); break; case s.FILL_RECT: c.batchFillRect(p[++M], p[++M], p[++M], p[++M], f, d); break; case s.FILL_TRIANGLE: c.batchFillTriangle(p[++M], p[++M], p[++M], p[++M], p[++M], p[++M], f, d); break; case s.STROKE_TRIANGLE: c.batchStrokeTriangle(p[++M], p[++M], p[++M], p[++M], p[++M], p[++M], g, f, d); break; case s.LINE_TO: C !== null ? C.points.push(new a(p[++M], p[++M], g)) : (C = new h(p[++M], p[++M], g), S.push(C)); break; case s.MOVE_TO: C = new h(p[++M], p[++M], g), S.push(C); break; case s.SAVE: l.push(f.copyToArray()); break; case s.RESTORE: f.copyFromArray(l.pop()); break; case s.TRANSLATE: B = p[++M], N = p[++M], f.translate(B, N); break; case s.SCALE: B = p[++M], N = p[++M], f.scale(B, N); break; case s.ROTATE: f.rotate(p[++M]) }t.pipelines.postBatch(e) } } }, 26479: (t, e, i) => { const s = i(61061); const n = i(83419); const r = i(51708); const o = i(50792); const a = i(46710); const h = i(95540); const l = i(35154); const u = i(97022); const c = i(41212); const d = i(88492); const f = i(35072); const p = i(68287); const v = new n({ Extends: o, initialize: function (t, e, i) { o.call(this), i ? e && !Array.isArray(e) && (e = [e]) : Array.isArray(e) ? c(e[0]) && (i = e, e = null) : c(e) && (i = e, e = null), this.scene = t, this.children = new f(), this.isParent = !0, this.type = 'Group', this.classType = h(i, 'classType', p), this.name = h(i, 'name', ''), this.active = h(i, 'active', !0), this.maxSize = h(i, 'maxSize', -1), this.defaultKey = h(i, 'defaultKey', null), this.defaultFrame = h(i, 'defaultFrame', null), this.runChildUpdate = h(i, 'runChildUpdate', !1), this.createCallback = h(i, 'createCallback', null), this.removeCallback = h(i, 'removeCallback', null), this.createMultipleCallback = h(i, 'createMultipleCallback', null), this.internalCreateCallback = h(i, 'internalCreateCallback', null), this.internalRemoveCallback = h(i, 'internalRemoveCallback', null), e && this.addMultiple(e), i && this.createMultiple(i), this.on(r.ADDED_TO_SCENE, this.addedToScene, this), this.on(r.REMOVED_FROM_SCENE, this.removedFromScene, this) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, create: function (t, e, i, s, n, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === s && (s = this.defaultFrame), void 0 === n && (n = !0), void 0 === r && (r = !0), this.isFull()) return null; const o = new this.classType(this.scene, t, e, i, s); return o.addToDisplayList(this.scene.sys.displayList), o.addToUpdateList(), o.visible = n, o.setActive(r), this.add(o), o }, createMultiple: function (t) { if (this.isFull()) return []; Array.isArray(t) || (t = [t]); let e = []; if (t[0].key) for (let i = 0; i < t.length; i++) { const s = this.createFromConfig(t[i]); e = e.concat(s) } return e }, createFromConfig: function (t) { if (this.isFull()) return []; this.classType = h(t, 'classType', this.classType); let e = h(t, 'key', void 0); let i = h(t, 'frame', null); const n = h(t, 'visible', !0); const r = h(t, 'active', !0); const o = []; if (void 0 === e) return o; Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); const a = h(t, 'repeat', 0); const c = h(t, 'randomKey', !1); const f = h(t, 'randomFrame', !1); const p = h(t, 'yoyo', !1); const v = h(t, 'quantity', !1); const g = h(t, 'frameQuantity', 1); const m = h(t, 'max', 0); const y = d(e, i, { max: m, qty: v || g, random: c, randomB: f, repeat: a, yoyo: p }); t.createCallback && (this.createCallback = t.createCallback), t.removeCallback && (this.removeCallback = t.removeCallback), t.internalCreateCallback && (this.internalCreateCallback = t.internalCreateCallback), t.internalRemoveCallback && (this.internalRemoveCallback = t.internalRemoveCallback); for (let x = 0; x < y.length; x++) { const T = this.create(0, 0, y[x].a, y[x].b, n, r); if (!T) break; o.push(T) } if (u(t, 'setXY')) { const w = l(t, 'setXY.x', 0); const b = l(t, 'setXY.y', 0); const S = l(t, 'setXY.stepX', 0); const E = l(t, 'setXY.stepY', 0); s.SetXY(o, w, b, S, E) } if (u(t, 'setRotation')) { const A = l(t, 'setRotation.value', 0); const C = l(t, 'setRotation.step', 0); s.SetRotation(o, A, C) } if (u(t, 'setScale')) { const _ = l(t, 'setScale.x', 1); const M = l(t, 'setScale.y', _); const P = l(t, 'setScale.stepX', 0); const R = l(t, 'setScale.stepY', 0); s.SetScale(o, _, M, P, R) } if (u(t, 'setOrigin')) { const L = l(t, 'setOrigin.x', 0.5); const O = l(t, 'setOrigin.y', L); const F = l(t, 'setOrigin.stepX', 0); const D = l(t, 'setOrigin.stepY', 0); s.SetOrigin(o, L, O, F, D) } if (u(t, 'setAlpha')) { const k = l(t, 'setAlpha.value', 1); const I = l(t, 'setAlpha.step', 0); s.SetAlpha(o, k, I) } if (u(t, 'setDepth')) { const B = l(t, 'setDepth.value', 0); const N = l(t, 'setDepth.step', 0); s.SetDepth(o, B, N) } if (u(t, 'setScrollFactor')) { const U = l(t, 'setScrollFactor.x', 1); const X = l(t, 'setScrollFactor.y', U); const Y = l(t, 'setScrollFactor.stepX', 0); const z = l(t, 'setScrollFactor.stepY', 0); s.SetScrollFactor(o, U, X, Y, z) } const G = h(t, 'hitArea', null); const V = h(t, 'hitAreaCallback', null); G && s.SetHitArea(o, G, V); const W = h(t, 'gridAlign', !1); return W && s.GridAlign(o, W), this.createMultipleCallback && this.createMultipleCallback.call(this, o), o }, preUpdate: function (t, e) { if (this.runChildUpdate && this.children.size !== 0) for (let i = this.children.entries.slice(), s = 0; s < i.length; s++) { const n = i[s]; n.active && n.update(t, e) } }, add: function (t, e) { return void 0 === e && (e = !1), this.isFull() || (this.children.set(t), this.internalCreateCallback && this.internalCreateCallback.call(this, t), this.createCallback && this.createCallback.call(this, t), e && (t.addToDisplayList(this.scene.sys.displayList), t.addToUpdateList()), t.on(r.DESTROY, this.remove, this)), this }, addMultiple: function (t, e) { if (void 0 === e && (e = !1), Array.isArray(t)) for (let i = 0; i < t.length; i++) this.add(t[i], e); return this }, remove: function (t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) ? (this.children.delete(t), this.internalRemoveCallback && this.internalRemoveCallback.call(this, t), this.removeCallback && this.removeCallback.call(this, t), t.off(r.DESTROY, this.remove, this), i ? t.destroy() : e && (t.removeFromDisplayList(), t.removeFromUpdateList()), this) : this }, clear: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.children, s = 0; s < i.size; s++) { const n = i.entries[s]; n.off(r.DESTROY, this.remove, this), e ? n.destroy() : t && (n.removeFromDisplayList(), n.removeFromUpdateList()) } return this.children.clear(), this }, contains: function (t) { return this.children.contains(t) }, getChildren: function () { return this.children.entries }, getLength: function () { return this.children.size }, getMatching: function (t, e, i, s) { return a(this.children.entries, t, e, i, s) }, getFirst: function (t, e, i, s, n, r, o) { return this.getHandler(!0, 1, t, e, i, s, n, r, o) }, getFirstNth: function (t, e, i, s, n, r, o, a) { return this.getHandler(!0, t, e, i, s, n, r, o, a) }, getLast: function (t, e, i, s, n, r, o) { return this.getHandler(!1, 1, t, e, i, s, n, r, o) }, getLastNth: function (t, e, i, s, n, r, o, a) { return this.getHandler(!1, t, e, i, s, n, r, o, a) }, getHandler: function (t, e, i, s, n, r, o, a, h) { let l, u; void 0 === i && (i = !1), void 0 === s && (s = !1); let c = 0; const d = this.children.entries; if (t) for (u = 0; u < d.length; u++) if ((l = d[u]).active === i) { if (++c === e) break } else l = null; else for (u = d.length - 1; u >= 0; u--) if ((l = d[u]).active === i) { if (++c === e) break } else l = null; return l ? (typeof n === 'number' && (l.x = n), typeof r === 'number' && (l.y = r), l) : s ? this.create(n, r, o, a, h) : null }, get: function (t, e, i, s, n) { return this.getFirst(!1, !0, t, e, i, s, n) }, getFirstAlive: function (t, e, i, s, n, r) { return this.getFirst(!0, t, e, i, s, n, r) }, getFirstDead: function (t, e, i, s, n, r) { return this.getFirst(!1, t, e, i, s, n, r) }, playAnimation: function (t, e) { return s.PlayAnimation(this.children.entries, t, e), this }, isFull: function () { return this.maxSize !== -1 && this.children.size >= this.maxSize }, countActive: function (t) { void 0 === t && (t = !0); for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++; return e }, getTotalUsed: function () { return this.countActive() }, getTotalFree: function () { const t = this.getTotalUsed(); return (this.maxSize === -1 ? 999999999999 : this.maxSize) - t }, setActive: function (t) { return this.active = t, this }, setName: function (t) { return this.name = t, this }, propertyValueSet: function (t, e, i, n, r) { return s.PropertyValueSet(this.children.entries, t, e, i, n, r), this }, propertyValueInc: function (t, e, i, n, r) { return s.PropertyValueInc(this.children.entries, t, e, i, n, r), this }, setX: function (t, e) { return s.SetX(this.children.entries, t, e), this }, setY: function (t, e) { return s.SetY(this.children.entries, t, e), this }, setXY: function (t, e, i, n) { return s.SetXY(this.children.entries, t, e, i, n), this }, incX: function (t, e) { return s.IncX(this.children.entries, t, e), this }, incY: function (t, e) { return s.IncY(this.children.entries, t, e), this }, incXY: function (t, e, i, n) { return s.IncXY(this.children.entries, t, e, i, n), this }, shiftPosition: function (t, e, i) { return s.ShiftPosition(this.children.entries, t, e, i), this }, angle: function (t, e) { return s.Angle(this.children.entries, t, e), this }, rotate: function (t, e) { return s.Rotate(this.children.entries, t, e), this }, rotateAround: function (t, e) { return s.RotateAround(this.children.entries, t, e), this }, rotateAroundDistance: function (t, e, i) { return s.RotateAroundDistance(this.children.entries, t, e, i), this }, setAlpha: function (t, e) { return s.SetAlpha(this.children.entries, t, e), this }, setTint: function (t, e, i, n) { return s.SetTint(this.children.entries, t, e, i, n), this }, setOrigin: function (t, e, i, n) { return s.SetOrigin(this.children.entries, t, e, i, n), this }, scaleX: function (t, e) { return s.ScaleX(this.children.entries, t, e), this }, scaleY: function (t, e) { return s.ScaleY(this.children.entries, t, e), this }, scaleXY: function (t, e, i, n) { return s.ScaleXY(this.children.entries, t, e, i, n), this }, setDepth: function (t, e) { return s.SetDepth(this.children.entries, t, e), this }, setBlendMode: function (t) { return s.SetBlendMode(this.children.entries, t), this }, setHitArea: function (t, e) { return s.SetHitArea(this.children.entries, t, e), this }, shuffle: function () { return s.Shuffle(this.children.entries), this }, kill: function (t) { this.children.contains(t) && t.setActive(!1) }, killAndHide: function (t) { this.children.contains(t) && (t.setActive(!1), t.setVisible(!1)) }, setVisible: function (t, e, i) { return s.SetVisible(this.children.entries, t, e, i), this }, toggleVisible: function () { return s.ToggleVisible(this.children.entries), this }, destroy: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1), this.scene && !this.ignoreDestroy && (this.emit(r.DESTROY, this), this.removeAllListeners(), this.scene.sys.updateList.remove(this), this.clear(e, t), this.scene = void 0, this.children = void 0) } }); t.exports = v }, 94975: (t, e, i) => { const s = i(44603); const n = i(26479); s.register('group', function (t) { return new n(this.scene, null, t) }) }, 3385: (t, e, i) => { const s = i(26479); i(39429).register('group', function (t, e) { return this.updateList.add(new s(this.scene, t, e)) }) }, 88571: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(59819); const a = new s({ Extends: r, Mixins: [n.Alpha, n.BlendMode, n.Depth, n.Flip, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Size, n.TextureCrop, n.Tint, n.Transform, n.Visible, o], initialize: function (t, e, i, s, n) { r.call(this, t, 'Image'), this._crop = this.resetCropObject(), this.setTexture(s, n), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(!0) } }); t.exports = a }, 40652: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e), t.batchSprite(e, e.frame, i, s) } }, 82459: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(88571); n.register('image', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = r(t, 'frame', null); const a = new o(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), s(this.scene, a, t), a }) }, 2117: (t, e, i) => { const s = i(88571); i(39429).register('image', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)) }) }, 59819: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(99517), r = i(40652), t.exports = { renderWebGL: n, renderCanvas: r } }, 99517: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e), this.pipeline.batchSprite(e, i, s) } }, 77856: (t, e, i) => { const s = { Events: i(51708), DisplayList: i(8050), GameObjectCreator: i(44603), GameObjectFactory: i(39429), UpdateList: i(45027), Components: i(31401), GetCalcMatrix: i(91296), BuildGameObject: i(25305), BuildGameObjectAnimation: i(13059), GameObject: i(95643), BitmapText: i(22186), Blitter: i(6107), Bob: i(46590), Container: i(31559), DOMElement: i(3069), DynamicBitmapText: i(2638), Extern: i(42421), Graphics: i(43831), Group: i(26479), Image: i(88571), Layer: i(93595), Particles: i(18404), PathFollower: i(1159), RenderTexture: i(591), RetroFont: i(196), Rope: i(77757), Sprite: i(68287), Text: i(50171), GetTextSize: i(14220), MeasureText: i(79557), TextStyle: i(35762), TileSprite: i(20839), Zone: i(41481), Video: i(18471), Shape: i(17803), Arc: i(23629), Curve: i(89), Ellipse: i(19921), Grid: i(30479), IsoBox: i(61475), IsoTriangle: i(16933), Line: i(57847), Polygon: i(24949), Rectangle: i(74561), Star: i(55911), Triangle: i(36931), Factories: { Blitter: i(12709), Container: i(24961), DOMElement: i(2611), DynamicBitmapText: i(72566), Extern: i(56315), Graphics: i(1201), Group: i(3385), Image: i(2117), Layer: i(20005), Particles: i(676), PathFollower: i(90145), RenderTexture: i(60505), Rope: i(96819), Sprite: i(46409), StaticBitmapText: i(34914), Text: i(68005), TileSprite: i(91681), Zone: i(84175), Video: i(89025), Arc: i(42563), Curve: i(40511), Ellipse: i(1543), Grid: i(34137), IsoBox: i(3933), IsoTriangle: i(49803), Line: i(2481), Polygon: i(64827), Rectangle: i(87959), Star: i(93697), Triangle: i(45245) }, Creators: { Blitter: i(9403), Container: i(77143), DynamicBitmapText: i(11164), Graphics: i(87079), Group: i(94975), Image: i(82459), Layer: i(25179), Particles: i(92730), RenderTexture: i(34495), Rope: i(26209), Sprite: i(15567), StaticBitmapText: i(57336), Text: i(71259), TileSprite: i(14167), Zone: i(95261), Video: i(11511) } }; s.Shader = i(20071), s.Mesh = i(4703), s.NineSlice = i(28103), s.PointLight = i(80321), s.Plane = i(33663), s.Factories.Shader = i(74177), s.Factories.Mesh = i(9225), s.Factories.NineSlice = i(47521), s.Factories.PointLight = i(71255), s.Factories.Plane = i(30985), s.Creators.Shader = i(54935), s.Creators.Mesh = i(20527), s.Creators.NineSlice = i(28279), s.Creators.PointLight = i(39829), s.Creators.Plane = i(56015), s.Light = i(41432), s.LightsManager = i(61356), s.LightsPlugin = i(88992), t.exports = s }, 93595: (t, e, i) => { const s = i(10312); const n = i(83419); const r = i(31401); const o = i(53774); const a = i(45893); const h = i(50792); const l = i(51708); const u = i(73162); const c = i(33963); const d = i(44594); const f = i(19186); const p = new n({ Extends: u, Mixins: [r.AlphaSingle, r.BlendMode, r.Depth, r.Mask, r.PostPipeline, r.Visible, h, c], initialize: function (t, e) { u.call(this, t), h.call(this), this.scene = t, this.displayList = null, this.type = 'Layer', this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, this.systems = t.sys, this.events = t.sys.events, this.sortChildrenFlag = !1, this.addCallback = this.addChildCallback, this.removeCallback = this.removeChildCallback, this.initPostPipeline(), this.clearAlpha(), this.setBlendMode(s.SKIP_CHECK), e && this.add(e), t.sys.queueDepthSort() }, setActive: function (t) { return this.active = t, this }, setName: function (t) { return this.name = t, this }, setState: function (t) { return this.state = t, this }, setDataEnabled: function () { return this.data || (this.data = new a(this)), this }, setData: function (t, e) { return this.data || (this.data = new a(this)), this.data.set(t, e), this }, incData: function (t, e) { return this.data || (this.data = new a(this)), this.data.inc(t, e), this }, toggleData: function (t) { return this.data || (this.data = new a(this)), this.data.toggle(t), this }, getData: function (t) { return this.data || (this.data = new a(this)), this.data.get(t) }, setInteractive: function () { return this }, disableInteractive: function () { return this }, removeInteractive: function () { return this }, addedToScene: function () { }, removedFromScene: function () { }, update: function () { }, toJSON: function () { return o(this) }, willRender: function (t) { return !(this.renderFlags !== 15 || this.list.length === 0 || this.cameraFilter !== 0 && this.cameraFilter & t.id) }, getIndexList: function () { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), t = e, e.parentContainer);)e = e.parentContainer; return i.unshift(this.displayList.getIndex(t)), i }, addChildCallback: function (t) { const e = t.displayList; e && e !== this && t.removeFromDisplayList(), t.displayList || (this.queueDepthSort(), t.displayList = this, t.emit(l.ADDED_TO_SCENE, t, this.scene), this.events.emit(d.ADDED_TO_SCENE, t, this.scene)) }, removeChildCallback: function (t) { this.queueDepthSort(), t.displayList = null, t.emit(l.REMOVED_FROM_SCENE, t, this.scene), this.events.emit(d.REMOVED_FROM_SCENE, t, this.scene) }, queueDepthSort: function () { this.sortChildrenFlag = !0 }, depthSort: function () { this.sortChildrenFlag && (f(this.list, this.sortByDepth), this.sortChildrenFlag = !1) }, sortByDepth: function (t, e) { return t._depth - e._depth }, getChildren: function () { return this.list }, addToDisplayList: function (t) { return void 0 === t && (t = this.scene.sys.displayList), this.displayList && this.displayList !== t && this.removeFromDisplayList(), t.exists(this) || (this.displayList = t, t.add(this, !0), t.queueDepthSort(), this.emit(l.ADDED_TO_SCENE, this, this.scene), t.events.emit(d.ADDED_TO_SCENE, this, this.scene)), this }, removeFromDisplayList: function () { const t = this.displayList || this.scene.sys.displayList; return t.exists(this) && (t.remove(this, !0), t.queueDepthSort(), this.displayList = null, this.emit(l.REMOVED_FROM_SCENE, this, this.scene), t.events.emit(d.REMOVED_FROM_SCENE, this, this.scene)), this }, destroy: function (t) { if (this.scene && !this.ignoreDestroy) { this.emit(l.DESTROY, this); for (let e = this.list; e.length;)e[0].destroy(t); this.removeAllListeners(), this.resetPostPipeline(!0), this.displayList && (this.displayList.remove(this, !0, !1), this.displayList.queueDepthSort()), this.data && (this.data.destroy(), this.data = void 0), this.active = !1, this.visible = !1, this.list = void 0, this.scene = void 0, this.displayList = void 0, this.systems = void 0, this.events = void 0 } } }); t.exports = p }, 2956: t => { t.exports = function (t, e, i) { const s = e.list; if (s.length !== 0) { e.depthSort(); const n = e.blendMode !== -1; n || t.setBlendMode(0); const r = e._alpha; e.mask && e.mask.preRenderCanvas(t, null, i); for (let o = 0; o < s.length; o++) { const a = s[o]; if (a.willRender(i)) { const h = a.alpha; n || a.blendMode === t.currentBlendMode || t.setBlendMode(a.blendMode), a.setAlpha(h * r), a.renderCanvas(t, a, i), a.setAlpha(h) } } e.mask && e.mask.postRenderCanvas(t) } } }, 25179: (t, e, i) => { const s = i(25305); const n = i(93595); const r = i(44603); const o = i(23568); r.register('layer', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'children', null); const r = new n(this.scene, i); return void 0 !== e && (t.add = e), s(this.scene, r, t), r }) }, 20005: (t, e, i) => { const s = i(93595); i(39429).register('layer', function (t) { return this.displayList.add(new s(this.scene, t)) }) }, 33963: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(15869), r = i(2956), t.exports = { renderWebGL: n, renderCanvas: r } }, 15869: t => { t.exports = function (t, e, i) { const s = e.list; const n = s.length; if (n !== 0) { e.depthSort(), t.pipelines.preBatch(e); const r = e.blendMode !== -1; r || t.setBlendMode(0); for (let o = e.alpha, a = 0; a < n; a++) { const h = s[a]; if (h.willRender(i)) { var l, u, c, d; if (void 0 !== h.alphaTopLeft) l = h.alphaTopLeft, u = h.alphaTopRight, c = h.alphaBottomLeft, d = h.alphaBottomRight; else { const f = h.alpha; l = f, u = f, c = f, d = f } r || h.blendMode === t.currentBlendMode || t.setBlendMode(h.blendMode); const p = h.mask; p && p.preRenderWebGL(t, h, i); const v = h.type; v !== t.currentType && (t.newType = !0, t.currentType = v), t.nextTypeMatch = a < n - 1 && s[a + 1].type === t.currentType, h.setAlpha(l * o, u * o, c * o, d * o), h.renderWebGL(t, h, i), h.setAlpha(l, u, c, d), p && p.postRenderWebGL(t, i), t.newType = !1 } } t.pipelines.postBatch(e) } } }, 41432: (t, e, i) => { const s = i(96503); const n = i(83419); const r = i(31401); const o = i(51767); const a = i(70554); var h = new n({ Extends: s, Mixins: [r.Origin, r.ScrollFactor, r.Visible], initialize: function (t, e, i, n, r, a, h) { s.call(this, t, e, i), this.color = new o(n, r, a), this.intensity = h, this.renderFlags = 15, this.cameraFilter = 0, this.setScrollFactor(1, 1), this.setOrigin(), this.setDisplayOrigin(i) }, displayWidth: { get: function () { return this.diameter }, set: function (t) { this.diameter = t } }, displayHeight: { get: function () { return this.diameter }, set: function (t) { this.diameter = t } }, width: { get: function () { return this.diameter }, set: function (t) { this.diameter = t } }, height: { get: function () { return this.diameter }, set: function (t) { this.diameter = t } }, willRender: function (t) { return !(h.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id) }, setColor: function (t) { const e = a.getFloatsFromUintRGB(t); return this.color.set(e[0], e[1], e[2]), this }, setIntensity: function (t) { return this.intensity = t, this }, setRadius: function (t) { return this.radius = t, this } }); h.RENDER_MASK = 15, t.exports = h }, 61356: (t, e, i) => { const s = i(81491); const n = i(83419); const r = i(20339); const o = i(41432); const a = i(80321); const h = i(51767); const l = i(19133); const u = i(19186); const c = i(70554); const d = new n({ initialize: function () { this.lights = [], this.ambientColor = new h(0.1, 0.1, 0.1), this.active = !1, this.maxLights = -1, this.visibleLights = 0 }, addPointLight: function (t, e, i, s, n, r) { return this.systems.displayList.add(new a(this.scene, t, e, i, s, n, r)) }, enable: function () { return this.maxLights === -1 && (this.maxLights = this.systems.renderer.config.maxLights), this.active = !0, this }, disable: function () { return this.active = !1, this }, getLights: function (t) { for (var e = this.lights, i = t.worldView, n = [], o = 0; o < e.length; o++) { const a = e[o]; a.willRender(t) && s(a, i) && n.push({ light: a, distance: r(a.x, a.y, i.centerX, i.centerY) }) } return n.length > this.maxLights && (u(n, this.sortByDistance), n = n.slice(0, this.maxLights)), this.visibleLights = n.length, n }, sortByDistance: function (t, e) { return t.distance >= e.distance }, setAmbientColor: function (t) { const e = c.getFloatsFromUintRGB(t); return this.ambientColor.set(e[0], e[1], e[2]), this }, getMaxVisibleLights: function () { return this.maxLights }, getLightCount: function () { return this.lights.length }, addLight: function (t, e, i, s, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 128), void 0 === s && (s = 16777215), void 0 === n && (n = 1); const r = c.getFloatsFromUintRGB(s); const a = new o(t, e, i, r[0], r[1], r[2], n); return this.lights.push(a), a }, removeLight: function (t) { const e = this.lights.indexOf(t); return e >= 0 && l(this.lights, e), this }, shutdown: function () { this.lights.length = 0 }, destroy: function () { this.shutdown() } }); t.exports = d }, 88992: (t, e, i) => { const s = i(83419); const n = i(61356); const r = i(37277); const o = i(44594); const a = new s({ Extends: n, initialize: function (t) { this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once(o.BOOT, this.boot, this), n.call(this) }, boot: function () { const t = this.systems.events; t.on(o.SHUTDOWN, this.shutdown, this), t.on(o.DESTROY, this.destroy, this) }, destroy: function () { this.shutdown(), this.scene = void 0, this.systems = void 0 } }); r.register('LightsPlugin', a, 'lights'), t.exports = a }, 4703: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(39506); const o = i(83997); const a = i(95643); const h = i(34684); const l = i(92515); const u = i(91296); const c = i(37867); const d = i(29807); const f = i(43396); const p = i(19186); const v = i(25836); const g = i(39318); const m = new s({ Extends: a, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Mask, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Size, n.Texture, n.Transform, n.Visible, d], initialize: function (t, e, i, s, n, r, o, h, l, u, d, f) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = '__WHITE'), a.call(this, t, 'Mesh'), this.faces = [], this.vertices = [], this.tintFill = !1, this.debugCallback = null, this.debugGraphic = null, this.hideCCW = !0, this.modelPosition = new v(), this.modelScale = new v(1, 1, 1), this.modelRotation = new v(), this.dirtyCache = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.transformMatrix = new c(), this.viewPosition = new v(), this.viewMatrix = new c(), this.projectionMatrix = new c(), this.totalRendered = 0, this.totalFrame = 0, this.ignoreDirtyCache = !1, this.fov, this.displayOriginX = 0, this.displayOriginY = 0; const p = t.sys.renderer; this.setPosition(e, i), this.setTexture(s, n), this.setSize(p.width, p.height), this.initPipeline(), this.initPostPipeline(), this.setPerspective(p.width, p.height), r && this.addVertices(r, o, h, l, u, d, f) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, panX: function (t) { return this.viewPosition.addScale(v.LEFT, t), this.dirtyCache[10] = 1, this }, panY: function (t) { return this.viewPosition.y += v.DOWN.y * t, this.dirtyCache[10] = 1, this }, panZ: function (t) { return this.viewPosition.z += t, this.dirtyCache[10] = 1, this }, setPerspective: function (t, e, i, s, n) { return void 0 === i && (i = 45), void 0 === s && (s = 0.01), void 0 === n && (n = 1e3), this.fov = i, this.projectionMatrix.perspective(r(i), t / e, s, n), this.dirtyCache[10] = 1, this.dirtyCache[11] = 0, this }, setOrtho: function (t, e, i, s) { return void 0 === t && (t = this.scene.sys.renderer.getAspectRatio()), void 0 === e && (e = 1), void 0 === i && (i = -1e3), void 0 === s && (s = 1e3), this.fov = 0, this.projectionMatrix.ortho(-t, t, -e, e, i, s), this.dirtyCache[10] = 1, this.dirtyCache[11] = 1, this }, clear: function () { return this.faces.forEach(function (t) { t.destroy() }), this.faces = [], this.vertices = [], this }, addVerticesFromObj: function (t, e, i, s, n, r, o, a, l) { let u; const c = this.scene.sys.cache.obj.get(t); return c && (u = h(c, this, e, i, s, n, r, o, a, l)), u && u.verts.length !== 0 || console.warn('Mesh.addVerticesFromObj data empty:', t), this }, sortByDepth: function (t, e) { return t.depth - e.depth }, depthSort: function () { return p(this.faces, this.sortByDepth), this }, addVertex: function (t, e, i, s, n, r, o) { const a = new g(t, e, i, s, n, r, o); return this.vertices.push(a), a }, addFace: function (t, e, i) { const s = new o(t, e, i); return this.faces.push(s), this.dirtyCache[9] = -1, s }, addVertices: function (t, e, i, s, n, r, o) { const a = l(t, e, i, s, n, r, o); return a ? (this.faces = this.faces.concat(a.faces), this.vertices = this.vertices.concat(a.vertices)) : console.warn('Mesh.addVertices data empty or invalid'), this.dirtyCache[9] = -1, this }, getFaceCount: function () { return this.faces.length }, getVertexCount: function () { return this.vertices.length }, getFace: function (t) { return this.faces[t] }, hasFaceAt: function (t, e, i) { void 0 === i && (i = this.scene.sys.cameras.main); for (let s = u(this, i).calc, n = this.faces, r = 0; r < n.length; r++) { if (n[r].contains(t, e, s)) return !0 } return !1 }, getFaceAt: function (t, e, i) { void 0 === i && (i = this.scene.sys.cameras.main); for (var s = u(this, i).calc, n = this.faces, r = [], o = 0; o < n.length; o++) { const a = n[o]; a.contains(t, e, s) && r.push(a) } return p(r, this.sortByDepth) }, setDebug: function (t, e) { return this.debugGraphic = t, this.debugCallback = t || e ? e || this.renderDebug : null, this }, isDirty: function () { const t = this.modelPosition; const e = this.modelRotation; const i = this.modelScale; const s = this.dirtyCache; const n = t.x; const r = t.y; const o = t.z; const a = e.x; const h = e.y; const l = e.z; const u = i.x; const c = i.y; const d = i.z; const f = this.getFaceCount(); const p = s[0]; const v = s[1]; const g = s[2]; const m = s[3]; const y = s[4]; const x = s[5]; const T = s[6]; const w = s[7]; const b = s[8]; const S = s[9]; return s[0] = n, s[1] = r, s[2] = o, s[3] = a, s[4] = h, s[5] = l, s[6] = u, s[7] = c, s[8] = d, s[9] = f, p !== n || v !== r || g !== o || m !== a || y !== h || x !== l || T !== u || w !== c || b !== d || S !== f }, preUpdate: function () { this.totalRendered = this.totalFrame, this.totalFrame = 0; const t = this.dirtyCache; if (this.ignoreDirtyCache || t[10] || this.isDirty()) { const e = this.width; const i = this.height; const s = this.viewMatrix; const n = this.viewPosition; t[10] && (s.identity(), s.translate(n), s.invert(), t[10] = 0); const r = this.transformMatrix; r.setWorldMatrix(this.modelRotation, this.modelPosition, this.modelScale, this.viewMatrix, this.projectionMatrix); for (let o = n.z, a = this.faces, h = 0; h < a.length; h++)a[h].transformCoordinatesLocal(r, e, i, o); this.depthSort() } }, renderDebug: function (t, e) { for (let i = t.debugGraphic, s = 0; s < e.length; s++) { const n = e[s]; const r = n.vertex1.tx; const o = n.vertex1.ty; const a = n.vertex2.tx; const h = n.vertex2.ty; const l = n.vertex3.tx; const u = n.vertex3.ty; i.strokeTriangle(r, o, a, h, l, u) } }, preDestroy: function () { this.clear(), this.debugCallback = null, this.debugGraphic = null }, clearTint: function () { return this.setTint() }, setInteractive: function (t) { void 0 === t && (t = {}); const e = function (t, e, i) { for (let s = this.faces, n = 0; n < s.length; n++) { if (s[n].contains(e, i)) return !0 } return !1 }.bind(this); return this.scene.sys.input.enable(this, t, e), this }, setTint: function (t) { void 0 === t && (t = 16777215); for (let e = this.vertices, i = 0; i < e.length; i++)e[i].color = t; return this }, uvScroll: function (t, e) { for (let i = this.faces, s = 0; s < i.length; s++)i[s].scrollUV(t, e); return this }, uvScale: function (t, e) { for (let i = this.faces, s = 0; s < i.length; s++)i[s].scaleUV(t, e); return this }, tint: { set: function (t) { this.setTint(t) } }, rotateX: { get: function () { return f(this.modelRotation.x) }, set: function (t) { this.modelRotation.x = r(t) } }, rotateY: { get: function () { return f(this.modelRotation.y) }, set: function (t) { this.modelRotation.y = r(t) } }, rotateZ: { get: function () { return f(this.modelRotation.z) }, set: function (t) { this.modelRotation.z = r(t) } } }); t.exports = m }, 36488: t => { t.exports = function () { } }, 20527: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(35154); const a = i(4703); n.register('mesh', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = r(t, 'frame', null); const h = o(t, 'vertices', []); const l = o(t, 'uvs', []); const u = o(t, 'indicies', []); const c = o(t, 'containsZ', !1); const d = o(t, 'normals', []); const f = o(t, 'colors', 16777215); const p = o(t, 'alphas', 1); const v = new a(this.scene, 0, 0, i, n, h, l, u, c, d, f, p); return void 0 !== e && (t.add = e), s(this.scene, v, t), v }) }, 9225: (t, e, i) => { const s = i(4703); i(39429).register('mesh', function (t, e, i, n, r, o, a, h, l, u, c) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u, c)) }) }, 29807: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(48833), r = i(36488), t.exports = { renderWebGL: n, renderCanvas: r } }, 48833: (t, e, i) => { const s = i(91296); t.exports = function (t, e, i, n) { const r = e.faces; const o = r.length; if (o !== 0) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline, e); const h = s(e, i, n).calc; t.pipelines.preBatch(e); for (var l = a.setGameObject(e), u = a.vertexViewF32, c = a.vertexViewU32, d = a.vertexCount * a.currentShader.vertexComponentCount - 1, f = e.tintFill, p = [], v = e.debugCallback, g = h.a, m = h.b, y = h.c, x = h.d, T = h.e, w = h.f, b = e.viewPosition.z, S = e.hideCCW, E = i.roundPixels, A = i.alpha * e.alpha, C = 0, _ = 0; _ < o; _++) { const M = r[_]; M.isInView(i, S, b, A, g, m, y, x, T, w, E) && (a.shouldFlush(3) && (a.flush(), l = a.setGameObject(e), d = 0), d = M.load(u, c, d, l, f), C++, a.vertexCount += 3, a.currentBatch.count = a.vertexCount - a.currentBatch.start, v && p.push(M)) } e.totalFrame += C, v && v.call(e, e, p), t.pipelines.postBatch(e) } } }, 28103: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(78023); const a = i(39318); const h = new s({ Extends: r, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Texture, n.Transform, n.Visible, o], initialize: function (t, e, i, s, n, o, h, l, u, c, d) { r.call(this, t, 'NineSlice'), this._width, this._height, this._originX = 0.5, this._originY = 0.5, this._sizeComponent = !0, this.vertices = [], this.leftWidth, this.rightWidth, this.topHeight, this.bottomHeight, this.tint = 16777215, this.tintFill = !1; const f = t.textures.getFrame(s, n); this.is3Slice = !c && !d, f.scale9 && (this.is3Slice = f.is3Slice); for (let p = this.is3Slice ? 18 : 54, v = 0; v < p; v++) this.vertices.push(new a()); this.setPosition(e, i), this.setTexture(s, n), this.setSlices(o, h, l, u, c, d, !1), this.updateDisplayOrigin(), this.initPipeline(), this.initPostPipeline() }, setSlices: function (t, e, i, s, n, r, o) { void 0 === i && (i = 10), void 0 === s && (s = 10), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = !1); const a = this.frame; let h = !1; if (this.is3Slice && o && n !== 0 && r !== 0 && (h = !0), h) console.warn('Cannot change 9 slice to 3 slice'); else { if (a.scale9 && !o) { const l = a.data.scale9Borders; const u = l.x; const c = l.y; i = u, s = a.width - l.w - u, n = c, r = a.height - l.h - c, void 0 === t && (t = a.width), void 0 === e && (e = a.height) } else void 0 === t && (t = 256), void 0 === e && (e = 256); this._width = t, this._height = e, this.leftWidth = i, this.rightWidth = s, this.topHeight = n, this.bottomHeight = r, this.is3Slice && (e = a.height, this._height = e, this.topHeight = e, this.bottomHeight = 0), this.updateVertices(), this.updateUVs() } return this }, updateUVs: function () { const t = this.leftWidth; const e = this.rightWidth; const i = this.topHeight; const s = this.bottomHeight; const n = this.frame.width; const r = this.frame.height; this.updateQuadUVs(0, 0, 0, t / n, i / r), this.updateQuadUVs(6, t / n, 0, 1 - e / n, i / r), this.updateQuadUVs(12, 1 - e / n, 0, 1, i / r), this.is3Slice || (this.updateQuadUVs(18, 0, i / r, t / n, 1 - s / r), this.updateQuadUVs(24, t / n, i / r, 1 - e / n, 1 - s / r), this.updateQuadUVs(30, 1 - e / n, i / r, 1, 1 - s / r), this.updateQuadUVs(36, 0, 1 - s / r, t / n, 1), this.updateQuadUVs(42, t / n, 1 - s / r, 1 - e / n, 1), this.updateQuadUVs(48, 1 - e / n, 1 - s / r, 1, 1)) }, updateVertices: function () { const t = this.leftWidth; const e = this.rightWidth; const i = this.topHeight; const s = this.bottomHeight; const n = this.width; const r = this.height; this.updateQuad(0, -0.5, 0.5, t / n - 0.5, 0.5 - i / r), this.updateQuad(6, t / n - 0.5, 0.5, 0.5 - e / n, 0.5 - i / r), this.updateQuad(12, 0.5 - e / n, 0.5, 0.5, 0.5 - i / r), this.is3Slice || (this.updateQuad(18, -0.5, 0.5 - i / r, t / n - 0.5, s / r - 0.5), this.updateQuad(24, t / n - 0.5, 0.5 - i / r, 0.5 - e / n, s / r - 0.5), this.updateQuad(30, 0.5 - e / n, 0.5 - i / r, 0.5, s / r - 0.5), this.updateQuad(36, -0.5, s / r - 0.5, t / n - 0.5, -0.5), this.updateQuad(42, t / n - 0.5, s / r - 0.5, 0.5 - e / n, -0.5), this.updateQuad(48, 0.5 - e / n, s / r - 0.5, 0.5, -0.5)) }, updateQuad: function (t, e, i, s, n) { const r = this.width; const o = this.height; const a = this.originX; const h = this.originY; const l = this.vertices; l[t + 0].resize(e, i, r, o, a, h), l[t + 1].resize(e, n, r, o, a, h), l[t + 2].resize(s, i, r, o, a, h), l[t + 3].resize(e, n, r, o, a, h), l[t + 4].resize(s, n, r, o, a, h), l[t + 5].resize(s, i, r, o, a, h) }, updateQuadUVs: function (t, e, i, s, n) { const r = this.vertices; const o = this.frame; const a = o.u0; const h = o.v0; const l = o.u1; const u = o.v1; if (a !== 0 || l !== 1) { const c = l - a; e = a + e * c, s = a + s * c } if (h !== 0 || u !== 1) { const d = u - h; i = h + i * d, n = h + n * d } r[t + 0].setUVs(e, i), r[t + 1].setUVs(e, n), r[t + 2].setUVs(s, i), r[t + 3].setUVs(e, n), r[t + 4].setUVs(s, n), r[t + 5].setUVs(s, i) }, clearTint: function () { return this.setTint(16777215), this }, setTint: function (t) { return void 0 === t && (t = 16777215), this.tint = t, this.tintFill = !1, this }, setTintFill: function (t) { return this.setTint(t), this.tintFill = !0, this }, isTinted: { get: function () { return this.tint !== 16777215 } }, width: { get: function () { return this._width }, set: function (t) { this._width = Math.max(t, this.leftWidth + this.rightWidth), this.updateVertices() } }, height: { get: function () { return this._height }, set: function (t) { this.is3Slice || (this._height = Math.max(t, this.topHeight + this.bottomHeight), this.updateVertices()) } }, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (t) { this.scaleX = t / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (t) { this.scaleY = t / this.height } }, setSize: function (t, e) { this.width = t, this.height = e, this.updateDisplayOrigin(); const i = this.input; return i && !i.customHitArea && (i.hitArea.width = this.width, i.hitArea.height = this.height), this }, setDisplaySize: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this }, originX: { get: function () { return this._originX }, set: function (t) { this._originX = t, this.updateVertices() } }, originY: { get: function () { return this._originY }, set: function (t) { this._originY = t, this.updateVertices() } }, setOrigin: function (t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this._originX = t, this._originY = e, this.updateVertices(), this.updateDisplayOrigin() }, setSizeToFrame: function () { if (this.is3Slice) { const t = this.frame.height; this._height = t, this.topHeight = t, this.bottomHeight = 0 } return this.updateUVs(), this }, preDestroy: function () { this.vertices = [] } }); t.exports = h }, 28279: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(35154); const a = i(28103); n.register('nineslice', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = r(t, 'frame', null); const h = o(t, 'width', 256); const l = o(t, 'height', 256); const u = o(t, 'leftWidth', 10); const c = o(t, 'rightWidth', 10); const d = o(t, 'topHeight', 0); const f = o(t, 'bottomHeight', 0); const p = new a(this.scene, 0, 0, i, n, h, l, u, c, d, f); return void 0 !== e && (t.add = e), s(this.scene, p, t), p }) }, 47521: (t, e, i) => { const s = i(28103); i(39429).register('nineslice', function (t, e, i, n, r, o, a, h, l, u) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u)) }) }, 78023: (t, e, i) => { const s = i(29747); let n = s; const r = s; n = i(52230), t.exports = { renderWebGL: n, renderCanvas: r } }, 52230: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { const o = e.vertices; const a = o.length; if (a !== 0) { i.addToRenderList(e); const h = t.pipelines.set(e.pipeline, e); const l = s(e, i, r, !1).calc; t.pipelines.preBatch(e); let u = h.setGameObject(e); const c = h.vertexViewF32; const d = h.vertexViewU32; let f = h.vertexCount * h.currentShader.vertexComponentCount - 1; const p = i.roundPixels; const v = e.tintFill; const g = i.alpha * e.alpha; const m = n.getTintAppendFloatAlpha(e.tint, g); const y = h.vertexAvailable(); let x = -1; y < a && (x = y); for (let T = 0; T < a; T++) { const w = o[T]; T === x && (h.flush(), u = h.setGameObject(e), f = 0), c[++f] = l.getXRound(w.vx, w.vy, p), c[++f] = l.getYRound(w.vx, w.vy, p), c[++f] = w.u, c[++f] = w.v, c[++f] = u, c[++f] = v, d[++f] = m, h.vertexCount++, h.currentBatch.count = h.vertexCount - h.currentBatch.start } t.pipelines.postBatch(e) } } }, 76472: (t, e, i) => { const s = i(83419); const n = i(44777); const r = i(37589); const o = i(6113); const a = i(91389); const h = i(90664); const l = new s({ Extends: n, initialize: function (t) { n.call(this, t, null, !1), this.active = !1, this.easeName = 'Linear', this.r = [], this.g = [], this.b = [] }, getMethod: function () { return this.propertyValue === null ? 0 : 9 }, setMethods: function () { const t = this.propertyValue; let e = t; let i = this.defaultEmit; let s = this.defaultUpdate; if (this.method === 9) { this.start = t[0], this.ease = o('Linear'), this.interpolation = a('linear'), i = this.easedValueEmit, s = this.easeValueUpdate, e = t[0], this.active = !0; for (let n = 0; n < t.length; n++) { const r = h(t[n]); this.r.push(r.r), this.g.push(r.g), this.b.push(r.b) } } return this.onEmit = i, this.onUpdate = s, this.current = e, this }, setEase: function (t) { this.easeName = t, this.ease = o(t) }, easedValueEmit: function () { return this.current = this.start, this.start }, easeValueUpdate: function (t, e, i) { const s = this.ease(i); const n = this.interpolation(this.r, s); const o = this.interpolation(this.g, s); const a = this.interpolation(this.b, s); const h = r(n, o, a); return this.current = h, h } }); t.exports = l }, 44777: (t, e, i) => { const s = i(30976); const n = i(45319); const r = i(83419); const o = i(99472); const a = i(6113); const h = i(95540); const l = i(91389); const u = i(77720); const c = i(15994); const d = new r({ initialize: function (t, e, i) { void 0 === i && (i = !1), this.propertyKey = t, this.propertyValue = e, this.defaultValue = e, this.steps = 0, this.counter = 0, this.yoyo = !1, this.direction = 0, this.start = 0, this.current = 0, this.end = 0, this.ease = null, this.interpolation = null, this.emitOnly = i, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.active = !0, this.method = 0, this._onEmit, this._onUpdate }, loadConfig: function (t, e) { void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = h(t, this.propertyKey, this.defaultValue), this.method = this.getMethod(), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate) }, toJSON: function () { return JSON.stringify(this.propertyValue) }, onChange: function (t) { let e; switch (this.method) { case 1: case 3: case 8: e = t; break; case 2: this.propertyValue.indexOf(t) >= 0 && (e = t); break; case 4: var i = (this.end - this.start) / this.steps; e = u(t, i), this.counter = e; break; case 5: case 6: case 7: e = n(t, this.start, this.end); break; case 9: e = this.start[0] } return this.current = e, this }, getMethod: function () { const t = this.propertyValue; if (t === null) return 0; const e = typeof t; if (e === 'number') return 1; if (Array.isArray(t)) return 2; if (e === 'function') return 3; if (e === 'object') { if (this.hasBoth(t, 'start', 'end')) return this.has(t, 'steps') ? 4 : 5; if (this.hasBoth(t, 'min', 'max')) return 6; if (this.has(t, 'random')) return 7; if (this.hasEither(t, 'onEmit', 'onUpdate')) return 8; if (this.hasEither(t, 'values', 'interpolation')) return 9 } return 0 }, setMethods: function () { const t = this.propertyValue; let e = t; let i = this.defaultEmit; let s = this.defaultUpdate; switch (this.method) { case 1: i = this.staticValueEmit; break; case 2: i = this.randomStaticValueEmit, e = t[0]; break; case 3: this._onEmit = t, i = this.proxyEmit; break; case 4: this.start = t.start, this.end = t.end, this.steps = t.steps, this.counter = this.start, this.yoyo = !!this.has(t, 'yoyo') && t.yoyo, this.direction = 0, i = this.steppedEmit, e = this.start; break; case 5: this.start = t.start, this.end = t.end; var n = this.has(t, 'ease') ? t.ease : 'Linear'; this.ease = a(n, t.easeParams), i = this.has(t, 'random') && t.random ? this.randomRangedValueEmit : this.easedValueEmit, s = this.easeValueUpdate, e = this.start; break; case 6: this.start = t.min, this.end = t.max, i = this.has(t, 'int') && t.int ? this.randomRangedIntEmit : this.randomRangedValueEmit, e = this.start; break; case 7: var r = t.random; Array.isArray(r) && (this.start = r[0], this.end = r[1]), i = this.randomRangedIntEmit, e = this.start; break; case 8: this._onEmit = this.has(t, 'onEmit') ? t.onEmit : this.defaultEmit, this._onUpdate = this.has(t, 'onUpdate') ? t.onUpdate : this.defaultUpdate, i = this.proxyEmit, s = this.proxyUpdate; break; case 9: this.start = t.values; var o = this.has(t, 'ease') ? t.ease : 'Linear'; this.ease = a(o, t.easeParams), this.interpolation = l(t.interpolation), i = this.easedValueEmit, s = this.easeValueUpdate, e = this.start[0] } return this.onEmit = i, this.onUpdate = s, this.current = e, this }, has: function (t, e) { return t.hasOwnProperty(e) }, hasBoth: function (t, e, i) { return t.hasOwnProperty(e) && t.hasOwnProperty(i) }, hasEither: function (t, e, i) { return t.hasOwnProperty(e) || t.hasOwnProperty(i) }, defaultEmit: function (t, e, i) { return i }, defaultUpdate: function (t, e, i, s) { return s }, proxyEmit: function (t, e, i) { const s = this._onEmit(t, e, i); return this.current = s, s }, proxyUpdate: function (t, e, i, s) { const n = this._onUpdate(t, e, i, s); return this.current = n, n }, staticValueEmit: function () { return this.current }, staticValueUpdate: function () { return this.current }, randomStaticValueEmit: function () { const t = Math.floor(Math.random() * this.propertyValue.length); return this.current = this.propertyValue[t], this.current }, randomRangedValueEmit: function (t, e) { const i = o(this.start, this.end); return t && t.data[e] && (t.data[e].min = i, t.data[e].max = this.end), this.current = i, i }, randomRangedIntEmit: function (t, e) { const i = s(this.start, this.end); return t && t.data[e] && (t.data[e].min = i, t.data[e].max = this.end), this.current = i, i }, steppedEmit: function () { let t; const e = this.counter; let i = e; const s = (this.end - this.start) / this.steps; this.yoyo ? (this.direction === 0 ? (i += s) >= this.end && (t = i - this.end, i = this.end - t, this.direction = 1) : (i -= s) <= this.start && (t = this.start - i, i = this.start + t, this.direction = 0), this.counter = i) : this.counter = c(i + s, this.start, this.end); return this.current = e, e }, easedValueEmit: function (t, e) { if (t && t.data[e]) { const i = t.data[e]; i.min = this.start, i.max = this.end } return this.current = this.start, this.start }, easeValueUpdate: function (t, e, i) { let s; const n = t.data[e]; const r = this.ease(i); return s = this.interpolation ? this.interpolation(this.start, r) : (n.max - n.min) * r + n.min, this.current = s, s }, destroy: function () { this.propertyValue = null, this.defaultValue = null, this.ease = null, this.interpolation = null, this._onEmit = null, this._onUpdate = null } }); t.exports = d }, 24502: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(20286); const o = new s({ Extends: r, initialize: function (t, e, i, s, o) { if (typeof t === 'object') { const a = t; t = n(a, 'x', 0), e = n(a, 'y', 0), i = n(a, 'power', 0), s = n(a, 'epsilon', 100), o = n(a, 'gravity', 50) } else void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 100), void 0 === o && (o = 50); r.call(this, t, e, !0), this._gravity = o, this._power = i * o, this._epsilon = s * s }, update: function (t, e) { const i = this.x - t.x; const s = this.y - t.y; let n = i * i + s * s; if (n !== 0) { const r = Math.sqrt(n); n < this._epsilon && (n = this._epsilon); const o = this._power * e / (n * r) * 100; t.velocityX += i * o, t.velocityY += s * o } }, epsilon: { get: function () { return Math.sqrt(this._epsilon) }, set: function (t) { this._epsilon = t * t } }, power: { get: function () { return this._power / this._gravity }, set: function (t) { this._power = t * this._gravity } }, gravity: { get: function () { return this._gravity }, set: function (t) { const e = this.power; this._gravity = t, this.power = e } } }); t.exports = o }, 56480: (t, e, i) => { const s = i(9674); const n = i(45319); const r = i(83419); const o = i(39506); const a = i(87841); const h = i(11520); const l = i(26099); const u = new r({ initialize: function (t) { this.emitter = t, this.texture = null, this.frame = null, this.x = 0, this.y = 0, this.worldPosition = new l(), this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.holdCurrent = 0, this.lifeT = 0, this.data = { tint: { min: 16777215, max: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 }, x: { min: 0, max: 0 }, y: { min: 0, max: 0 }, accelerationX: { min: 0, max: 0 }, accelerationY: { min: 0, max: 0 }, maxVelocityX: { min: 0, max: 0 }, maxVelocityY: { min: 0, max: 0 }, moveToX: { min: 0, max: 0 }, moveToY: { min: 0, max: 0 }, bounce: { min: 0, max: 0 } }, this.isCropped = !1, this.scene = t.scene, this.anims = new s(this), this.bounds = new a() }, emit: function (t, e, i, s, n, r) { return this.emitter.emit(t, e, i, s, n, r) }, isAlive: function () { return this.lifeCurrent > 0 }, kill: function () { this.lifeCurrent = 0 }, setPosition: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e }, fire: function (t, e) { const i = this.emitter; const s = i.ops; const n = i.getAnim(); if (n ? this.anims.play(n) : (this.frame = i.getFrame(), this.texture = this.frame.texture), !this.frame) throw new Error('Particle has no texture frame'); if (i.getEmitZone(this), void 0 === t ? this.x += s.x.onEmit(this, 'x') : s.x.steps > 0 ? this.x += t + s.x.onEmit(this, 'x') : this.x += t, void 0 === e ? this.y += s.y.onEmit(this, 'y') : s.y.steps > 0 ? this.y += e + s.y.onEmit(this, 'y') : this.y += e, this.life = s.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0, this.delayCurrent = s.delay.onEmit(this, 'delay'), this.holdCurrent = s.hold.onEmit(this, 'hold'), this.scaleX = s.scaleX.onEmit(this, 'scaleX'), this.scaleY = s.scaleY.active ? s.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = s.rotate.onEmit(this, 'rotate'), this.rotation = o(this.angle), i.worldMatrix.transformPoint(this.x, this.y, this.worldPosition), this.delayCurrent === 0 && i.getDeathZone(this)) return this.lifeCurrent = 0, !1; const r = s.speedX.onEmit(this, 'speedX'); const a = s.speedY.active ? s.speedY.onEmit(this, 'speedY') : r; if (i.radial) { const h = o(s.angle.onEmit(this, 'angle')); this.velocityX = Math.cos(h) * Math.abs(r), this.velocityY = Math.sin(h) * Math.abs(a) } else if (i.moveTo) { const l = s.moveToX.onEmit(this, 'moveToX'); const u = s.moveToY.onEmit(this, 'moveToY'); const c = this.life / 1e3; this.velocityX = (l - this.x) / c, this.velocityY = (u - this.y) / c } else this.velocityX = r, this.velocityY = a; return i.acceleration && (this.accelerationX = s.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = s.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = s.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = s.maxVelocityY.onEmit(this, 'maxVelocityY'), this.bounce = s.bounce.onEmit(this, 'bounce'), this.alpha = s.alpha.onEmit(this, 'alpha'), s.color.active ? this.tint = s.color.onEmit(this, 'tint') : this.tint = s.tint.onEmit(this, 'tint'), !0 }, update: function (t, e, i) { if (this.lifeCurrent <= 0) return !(this.holdCurrent > 0) || (this.holdCurrent -= t, this.holdCurrent <= 0); if (this.delayCurrent > 0) return this.delayCurrent -= t, !1; this.anims.update(0, t); const s = this.emitter; const r = s.ops; const a = 1 - this.lifeCurrent / this.life; if (this.lifeT = a, this.x = r.x.onUpdate(this, 'x', a, this.x), this.y = r.y.onUpdate(this, 'y', a, this.y), s.moveTo) { const h = r.moveToX.onUpdate(this, 'moveToX', a, s.moveToX); const l = r.moveToY.onUpdate(this, 'moveToY', a, s.moveToY); const u = this.lifeCurrent / 1e3; this.velocityX = (h - this.x) / u, this.velocityY = (l - this.y) / u } return this.computeVelocity(s, t, e, i, a), this.scaleX = r.scaleX.onUpdate(this, 'scaleX', a, this.scaleX), r.scaleY.active ? this.scaleY = r.scaleY.onUpdate(this, 'scaleY', a, this.scaleY) : this.scaleY = this.scaleX, this.angle = r.rotate.onUpdate(this, 'rotate', a, this.angle), this.rotation = o(this.angle), s.getDeathZone(this) ? (this.lifeCurrent = 0, !0) : (this.alpha = n(r.alpha.onUpdate(this, 'alpha', a, this.alpha), 0, 1), r.color.active ? this.tint = r.color.onUpdate(this, 'color', a, this.tint) : this.tint = r.tint.onUpdate(this, 'tint', a, this.tint), this.lifeCurrent -= t, this.lifeCurrent <= 0 && this.holdCurrent <= 0) }, computeVelocity: function (t, e, i, s, r) { const o = t.ops; let a = this.velocityX; let h = this.velocityY; const l = o.accelerationX.onUpdate(this, 'accelerationX', r, this.accelerationX); const u = o.accelerationY.onUpdate(this, 'accelerationY', r, this.accelerationY); const c = o.maxVelocityX.onUpdate(this, 'maxVelocityX', r, this.maxVelocityX); const d = o.maxVelocityY.onUpdate(this, 'maxVelocityY', r, this.maxVelocityY); this.bounce = o.bounce.onUpdate(this, 'bounce', r, this.bounce), a += t.gravityX * i + l * i, h += t.gravityY * i + u * i, a = n(a, -c, c), h = n(h, -d, d), this.velocityX = a, this.velocityY = h, this.x += a * i, this.y += h * i, t.worldMatrix.transformPoint(this.x, this.y, this.worldPosition); for (let f = 0; f < s.length; f++) { const p = s[f]; p.active && p.update(this, e, i, r) } }, setSizeToFrame: function () { }, getBounds: function (t) { void 0 === t && (t = this.emitter.getWorldTransformMatrix()); const e = Math.abs(t.scaleX) * this.scaleX; const i = Math.abs(t.scaleY) * this.scaleY; const s = this.x; const n = this.y; const r = this.rotation; const o = this.frame.width * e / 2; const a = this.frame.height * i / 2; const u = this.bounds; const c = new l(s - o, n - a); const d = new l(s + o, n - a); const f = new l(s - o, n + a); const p = new l(s + o, n + a); return r !== 0 && (h(c, s, n, r), h(d, s, n, r), h(f, s, n, r), h(p, s, n, r)), t.transformPoint(c.x, c.y, c), t.transformPoint(d.x, d.y, d), t.transformPoint(f.x, f.y, f), t.transformPoint(p.x, p.y, p), u.x = Math.min(c.x, d.x, f.x, p.x), u.y = Math.min(c.y, d.y, f.y, p.y), u.width = Math.max(c.x, d.x, f.x, p.x) - u.x, u.height = Math.max(c.y, d.y, f.y, p.y) - u.y, u }, destroy: function () { this.anims.destroy(), this.anims = null, this.emitter = null, this.texture = null, this.frame = null, this.scene = null } }); t.exports = u }, 69601: (t, e, i) => { const s = i(83419); const n = i(20286); const r = i(87841); const o = new s({ Extends: n, initialize: function (t, e, i, s, o, a, h, l) { void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), void 0 === l && (l = !0), n.call(this, t, e, !0), this.bounds = new r(t, e, i, s), this.collideLeft = o, this.collideRight = a, this.collideTop = h, this.collideBottom = l }, update: function (t) { const e = this.bounds; const i = -t.bounce; const s = t.worldPosition; s.x < e.x && this.collideLeft ? (t.x += e.x - s.x, t.velocityX *= i) : s.x > e.right && this.collideRight && (t.x -= s.x - e.right, t.velocityX *= i), s.y < e.y && this.collideTop ? (t.y += e.y - s.y, t.velocityY *= i) : s.y > e.bottom && this.collideBottom && (t.y -= s.y - e.bottom, t.velocityY *= i) } }); t.exports = o }, 31600: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(53774); const o = i(43459); const a = i(26388); const h = i(19909); const l = i(76472); const u = i(44777); const c = i(20696); const d = i(95643); const f = i(95540); const p = i(26546); const v = i(24502); const g = i(1985); const m = i(97022); const y = i(86091); const x = i(73162); const T = i(20074); const w = i(56480); const b = i(68875); const S = i(87841); const E = i(59996); const A = i(72905); const C = i(90668); const _ = i(19186); const M = i(61340); const P = i(26099); const R = i(15994); const L = i(69601); const O = ['active', 'advance', 'blendMode', 'colorEase', 'deathCallback', 'deathCallbackScope', 'duration', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxAliveParticles', 'maxParticles', 'name', 'emitting', 'particleBringToTop', 'particleClass', 'radial', 'sortCallback', 'sortOrderAsc', 'sortProperty', 'stopAfter', 'tintFill', 'timeScale', 'trackVisible', 'visible']; const F = ['accelerationX', 'accelerationY', 'alpha', 'angle', 'bounce', 'color', 'delay', 'hold', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y']; const D = new s({ Extends: d, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Mask, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Texture, n.Transform, n.Visible, C], initialize: function (t, e, i, s, n) { d.call(this, t, 'ParticleEmitter'), this.particleClass = w, this.ops = { accelerationX: new u('accelerationX', 0), accelerationY: new u('accelerationY', 0), alpha: new u('alpha', 1), angle: new u('angle', { min: 0, max: 360 }, !0), bounce: new u('bounce', 0), color: new l('color'), delay: new u('delay', 0, !0), hold: new u('hold', 0, !0), lifespan: new u('lifespan', 1e3, !0), maxVelocityX: new u('maxVelocityX', 1e4), maxVelocityY: new u('maxVelocityY', 1e4), moveToX: new u('moveToX', 0), moveToY: new u('moveToY', 0), quantity: new u('quantity', 1, !0), rotate: new u('rotate', 0), scaleX: new u('scaleX', 1), scaleY: new u('scaleY', 1), speedX: new u('speedX', 0, !0), speedY: new u('speedY', 0, !0), tint: new u('tint', 16777215), x: new u('x', 0), y: new u('y', 0) }, this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.moveTo = !1, this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.maxAliveParticles = 0, this.stopAfter = 0, this.duration = 0, this.frequency = 0, this.emitting = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZones = [], this.deathZones = [], this.viewBounds = null, this.follow = null, this.followOffset = new P(), this.trackVisible = !1, this.frames = [], this.randomFrame = !0, this.frameQuantity = 1, this.anims = [], this.randomAnim = !0, this.animQuantity = 1, this.dead = [], this.alive = [], this.counters = new Float32Array(10), this.skipping = !1, this.worldMatrix = new M(), this.sortProperty = '', this.sortOrderAsc = !0, this.sortCallback = this.depthSortCallback, this.processors = new x(this), this.tintFill = !1, this.initPipeline(), this.initPostPipeline(), this.setPosition(e, i), this.setTexture(s), n && this.setConfig(n) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, setConfig: function (t) { if (!t) return this; let e = 0; let i = ''; const s = this.ops; for (e = 0; e < F.length; e++)s[i = F[e]].loadConfig(t); for (e = 0; e < O.length; e++)m(t, i = O[e]) && (this[i] = f(t, i)); if (this.acceleration = this.accelerationX !== 0 || this.accelerationY !== 0, this.moveTo = this.moveToX !== 0 && this.moveToY !== 0, m(t, 'speed') && (s.speedX.loadConfig(t, 'speed'), s.speedY.active = !1), (g(t, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), m(t, 'scale') && (s.scaleX.loadConfig(t, 'scale'), s.scaleY.active = !1), m(t, 'callbackScope')) { const n = f(t, 'callbackScope', null); this.emitCallbackScope = n, this.deathCallbackScope = n } if (m(t, 'emitZone') && this.addEmitZone(t.emitZone), m(t, 'deathZone') && this.addDeathZone(t.deathZone), m(t, 'bounds')) { const r = this.addParticleBounds(t.bounds); r.collideLeft = f(t, 'collideLeft', !0), r.collideRight = f(t, 'collideRight', !0), r.collideTop = f(t, 'collideTop', !0), r.collideBottom = f(t, 'collideBottom', !0) } return m(t, 'followOffset') && this.followOffset.setFromObject(f(t, 'followOffset', 0)), m(t, 'texture') && this.setTexture(t.texture), m(t, 'frame') ? this.setEmitterFrame(t.frame) : m(t, 'anim') && this.setAnim(t.anim), m(t, 'reserve') && this.reserve(t.reserve), m(t, 'advance') && this.fastForward(t.advance), this.resetCounters(this.frequency, this.emitting), this.emitting && this.emit(c.START, this), this }, toJSON: function () { const t = r(this); let e = 0; let i = ''; for (e = 0; e < O.length; e++)t[i = O[e]] = this[i]; const s = this.ops; for (e = 0; e < F.length; e++)s[i = F[e]] && (t[i] = s[i].toJSON()); return s.speedY.active || (delete t.speedX, t.speed = s.speedX.toJSON()), this.scaleX === this.scaleY && (delete t.scaleX, delete t.scaleY, t.scale = s.scaleX.toJSON()), t }, resetCounters: function (t, e) { const i = this.counters; i.fill(0), i[0] = t, e && (i[5] = 1) }, startFollow: function (t, e, i, s) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = s, this }, stopFollow: function () { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this }, getFrame: function () { let t; const e = this.frames; const i = e.length; return i === 1 ? t = e[0] : this.randomFrame ? t = p(e) : (t = e[this.currentFrame], this.frameCounter++, this.frameCounter === this.frameQuantity && (this.frameCounter = 0, this.currentFrame++, this.currentFrame === i && (this.currentFrame = 0))), this.texture.get(t) }, setEmitterFrame: function (t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0; const s = typeof t; if (this.frames.length = 0, Array.isArray(t)) this.frames = this.frames.concat(t); else if (s === 'string' || s === 'number') this.frames.push(t); else if (s === 'object') { const n = t; (t = f(n, 'frames', null)) && (this.frames = this.frames.concat(t)); const r = f(n, 'cycle', !1); this.randomFrame = !r, this.frameQuantity = f(n, 'quantity', i) } return this.frames.length === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this }, getAnim: function () { const t = this.anims; const e = t.length; if (e === 0) return null; if (e === 1) return t[0]; if (this.randomAnim) return p(t); const i = t[this.currentAnim]; return this.animCounter++, this.animCounter >= this.animQuantity && (this.animCounter = 0, this.currentAnim = R(this.currentAnim + 1, 0, e)), i }, setAnim: function (t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomAnim = e, this.animQuantity = i, this.currentAnim = 0; const s = typeof t; if (this.anims.length = 0, Array.isArray(t)) this.anims = this.anims.concat(t); else if (s === 'string') this.anims.push(t); else if (s === 'object') { const n = t; (t = f(n, 'anims', null)) && (this.anims = this.anims.concat(t)); const r = f(n, 'cycle', !1); this.randomAnim = !r, this.animQuantity = f(n, 'quantity', i) } return this.anims.length === 1 && (this.animQuantity = 1, this.randomAnim = !1), this }, setRadial: function (t) { return void 0 === t && (t = !0), this.radial = t, this }, addParticleBounds: function (t, e, i, s, n, r, o, a) { if (typeof t === 'object') { const h = t; t = h.x, e = h.y, i = m(h, 'w') ? h.w : h.width, s = m(h, 'h') ? h.h : h.height } return this.addParticleProcessor(new L(t, e, i, s, n, r, o, a)) }, setParticleSpeed: function (t, e) { return void 0 === e && (e = t), this.ops.speedX.onChange(t), t === e ? this.ops.speedY.active = !1 : this.ops.speedY.onChange(e), this.radial = !0, this }, setParticleScale: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.ops.scaleX.onChange(t), this.ops.scaleY.onChange(e), this }, setParticleGravity: function (t, e) { return this.gravityX = t, this.gravityY = e, this }, setParticleAlpha: function (t) { return this.ops.alpha.onChange(t), this }, setParticleTint: function (t) { return this.ops.tint.onChange(t), this }, setEmitterAngle: function (t) { return this.ops.angle.onChange(t), this }, setParticleLifespan: function (t) { return this.ops.lifespan.onChange(t), this }, setQuantity: function (t) { return this.quantity = t, this }, setFrequency: function (t, e) { return this.frequency = t, this.flowCounter = t > 0 ? t : 0, e && (this.quantity = e), this }, addDeathZone: function (t) { let e; Array.isArray(t) || (t = [t]); for (var i = [], s = 0; s < t.length; s++) if ((e = t[s]) instanceof a) i.push(e); else if (typeof e.contains === 'function') e = new a(e, !0), i.push(e); else { const n = f(e, 'type', 'onEnter'); const r = f(e, 'source', null); if (r && typeof r.contains === 'function') e = new a(r, n === 'onEnter'), i.push(e) } return this.deathZones = this.deathZones.concat(i), i }, removeDeathZone: function (t) { return A(this.deathZones, t), this }, clearDeathZones: function () { return this.deathZones.length = 0, this }, addEmitZone: function (t) { let e; Array.isArray(t) || (t = [t]); for (var i = [], s = 0; s < t.length; s++) if ((e = t[s]) instanceof b || e instanceof h) i.push(e); else { const n = f(e, 'source', null); if (n) { const r = f(e, 'type', 'random'); if (r === 'random' && typeof n.getRandomPoint === 'function') e = new b(n), i.push(e); else if (r === 'edge' && typeof n.getPoints === 'function') { const o = f(e, 'quantity', 1); const a = f(e, 'stepRate', 0); const l = f(e, 'yoyo', !1); const u = f(e, 'seamless', !0); const c = f(e, 'total', -1); e = new h(n, o, a, l, u, c), i.push(e) } } } return this.emitZones = this.emitZones.concat(i), i }, removeEmitZone: function (t) { return A(this.emitZones, t), this.zoneIndex = 0, this }, clearEmitZones: function () { return this.emitZones.length = 0, this.zoneIndex = 0, this }, getEmitZone: function (t) { const e = this.emitZones; const i = e.length; if (i !== 0) { const s = e[this.zoneIndex]; s.getPoint(t), s.total > -1 && (this.zoneTotal++, this.zoneTotal === s.total && (this.zoneTotal = 0, this.zoneIndex++, this.zoneIndex === i && (this.zoneIndex = 0))) } }, getDeathZone: function (t) { for (let e = this.deathZones, i = 0; i < e.length; i++) { const s = e[i]; if (s.willKill(t)) return this.emit(c.DEATH_ZONE, this, t, s), !0 } return !1 }, setEmitZone: function (t) { let e; return (e = isFinite(t) ? t : this.emitZones.indexOf(t)) >= 0 && (this.zoneIndex = e), this }, addParticleProcessor: function (t) { return this.processors.exists(t) || (t.emitter && t.emitter.removeParticleProcessor(t), this.processors.add(t), t.emitter = this), t }, removeParticleProcessor: function (t) { return this.processors.exists(t) && (this.processors.remove(t, !0), t.emitter = null), t }, getProcessors: function () { return this.processors.getAll('active', !0) }, createGravityWell: function (t) { return this.addParticleProcessor(new v(t)) }, reserve: function (t) { const e = this.dead; if (this.maxParticles > 0) { const i = this.getParticleCount(); i + t > this.maxParticles && (t = this.maxParticles - (i + t)) } for (let s = 0; s < t; s++)e.push(new this.particleClass(this)); return this }, getAliveParticleCount: function () { return this.alive.length }, getDeadParticleCount: function () { return this.dead.length }, getParticleCount: function () { return this.getAliveParticleCount() + this.getDeadParticleCount() }, atLimit: function () { return this.maxParticles > 0 && this.getParticleCount() >= this.maxParticles || this.maxAliveParticles > 0 && this.getAliveParticleCount() >= this.maxAliveParticles }, onParticleEmit: function (t, e) { return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof t === 'function' && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this }, onParticleDeath: function (t, e) { return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof t === 'function' && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this }, killAll: function () { for (let t = this.dead, e = this.alive; e.length > 0;)t.push(e.pop()); return this }, forEachAlive: function (t, e) { for (let i = this.alive, s = i.length, n = 0; n < s; n++)t.call(e, i[n], this); return this }, forEachDead: function (t, e) { for (let i = this.dead, s = i.length, n = 0; n < s; n++)t.call(e, i[n], this); return this }, start: function (t, e) { return void 0 === t && (t = 0), this.emitting || (t > 0 && this.fastForward(t), this.emitting = !0, this.resetCounters(this.frequency, !0), void 0 !== e && (this.duration = Math.abs(e)), this.emit(c.START, this)), this }, stop: function (t) { return void 0 === t && (t = !1), this.emitting && (this.emitting = !1, t && this.killAll(), this.emit(c.STOP, this)), this }, pause: function () { return this.active = !1, this }, resume: function () { return this.active = !0, this }, setSortProperty: function (t, e) { return void 0 === t && (t = ''), void 0 === e && (e = this.true), this.sortProperty = t, this.sortOrderAsc = e, this.sortCallback = this.depthSortCallback, this }, setSortCallback: function (t) { return t = this.sortProperty !== '' ? this.depthSortCallback : null, this.sortCallback = t, this }, depthSort: function () { return _(this.alive, this.sortCallback.bind(this)), this }, depthSortCallback: function (t, e) { const i = this.sortProperty; return this.sortOrderAsc ? t[i] - e[i] : e[i] - t[i] }, flow: function (t, e, i) { return void 0 === e && (e = 1), this.emitting = !1, this.frequency = t, this.quantity = e, void 0 !== i && (this.stopAfter = i), this.start() }, explode: function (t, e, i) { this.frequency = -1, this.resetCounters(-1, !0); const s = this.emitParticle(t, e, i); return this.emit(c.EXPLODE, this, s), s }, emitParticleAt: function (t, e, i) { return this.emitParticle(i, t, e) }, emitParticle: function (t, e, i) { if (!this.atLimit()) { void 0 === t && (t = this.ops.quantity.onEmit()); for (let s = this.dead, n = this.stopAfter, r = this.follow ? this.follow.x + this.followOffset.x : e, o = this.follow ? this.follow.y + this.followOffset.y : i, a = 0; a < t; a++) { var h = s.pop(); if (h || (h = new this.particleClass(this)), h.fire(r, o) ? (this.particleBringToTop ? this.alive.push(h) : this.alive.unshift(h), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, h, this)) : this.dead.push(h), n > 0 && (this.stopCounter++, this.stopCounter >= n)) break; if (this.atLimit()) break } return h } }, fastForward: function (t, e) { void 0 === e && (e = 1e3 / 60); let i = 0; for (this.skipping = !0; i < Math.abs(t);) this.preUpdate(0, e), i += e; return this.skipping = !1, this }, preUpdate: function (t, e) { const i = (e *= this.timeScale) / 1e3; this.trackVisible && (this.visible = this.follow.visible), this.getWorldTransformMatrix(this.worldMatrix); const s = this.getProcessors(); const n = this.alive; const r = this.dead; let o = 0; const a = []; let h = n.length; for (o = 0; o < h; o++) { const l = n[o]; l.update(e, i, s) && a.push({ index: o, particle: l }) } if ((h = a.length) > 0) { const u = this.deathCallback; const d = this.deathCallbackScope; for (o = h - 1; o >= 0; o--) { const f = a[o]; n.splice(f.index, 1), r.push(f.particle), u && u.call(d, f.particle), f.particle.setPosition() } } if (this.emitting || this.skipping) { if (this.frequency === 0) this.emitParticle(); else if (this.frequency > 0) for (this.flowCounter -= e; this.flowCounter <= 0;) this.emitParticle(), this.flowCounter += this.frequency; this.skipping || (this.duration > 0 && (this.elapsed += e, this.elapsed >= this.duration && this.stop()), this.stopAfter > 0 && this.stopCounter >= this.stopAfter && this.stop()) } else this.completeFlag === 1 && n.length === 0 && (this.completeFlag = 0, this.emit(c.COMPLETE, this)) }, overlap: function (t) { for (var e = this.getWorldTransformMatrix(), i = this.alive, s = i.length, n = [], r = 0; r < s; r++) { const o = i[r]; E(t, o.getBounds(e)) && n.push(o) } return n }, getBounds: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 1e3 / 60), void 0 === s && (s = new S()); let n; let r; const a = this.getWorldTransformMatrix(); const h = this.alive; let l = !1; if (s.setTo(0, 0, 0, 0), e > 0) { let u = 0; for (this.skipping = !0; u < Math.abs(e);) { for (this.preUpdate(0, i), n = 0; n < h.length; n++)r = h[n].getBounds(a), l ? T(s, r) : (l = !0, o(r, s)); u += i } this.skipping = !1 } else for (n = 0; n < h.length; n++)r = h[n].getBounds(a), l ? T(s, r) : (l = !0, o(r, s)); return t > 0 && y(s, t, t), s }, createEmitter: function () { throw new Error('createEmitter removed. See ParticleEmitter docs for info') }, particleX: { get: function () { return this.ops.x.current }, set: function (t) { this.ops.x.onChange(t) } }, particleY: { get: function () { return this.ops.y.current }, set: function (t) { this.ops.y.onChange(t) } }, accelerationX: { get: function () { return this.ops.accelerationX.current }, set: function (t) { this.ops.accelerationX.onChange(t) } }, accelerationY: { get: function () { return this.ops.accelerationY.current }, set: function (t) { this.ops.accelerationY.onChange(t) } }, maxVelocityX: { get: function () { return this.ops.maxVelocityX.current }, set: function (t) { this.ops.maxVelocityX.onChange(t) } }, maxVelocityY: { get: function () { return this.ops.maxVelocityY.current }, set: function (t) { this.ops.maxVelocityY.onChange(t) } }, speed: { get: function () { return this.ops.speedX.current }, set: function (t) { this.ops.speedX.onChange(t), this.ops.speedY.onChange(t) } }, speedX: { get: function () { return this.ops.speedX.current }, set: function (t) { this.ops.speedX.onChange(t) } }, speedY: { get: function () { return this.ops.speedY.current }, set: function (t) { this.ops.speedY.onChange(t) } }, moveToX: { get: function () { return this.ops.moveToX.current }, set: function (t) { this.ops.moveToX.onChange(t) } }, moveToY: { get: function () { return this.ops.moveToY.current }, set: function (t) { this.ops.moveToY.onChange(t) } }, bounce: { get: function () { return this.ops.bounce.current }, set: function (t) { this.ops.bounce.onChange(t) } }, particleScaleX: { get: function () { return this.ops.scaleX.current }, set: function (t) { this.ops.scaleX.onChange(t) } }, particleScaleY: { get: function () { return this.ops.scaleY.current }, set: function (t) { this.ops.scaleY.onChange(t) } }, particleColor: { get: function () { return this.ops.color.current }, set: function (t) { this.ops.color.onChange(t) } }, colorEase: { get: function () { return this.ops.color.easeName }, set: function (t) { this.ops.color.setEase(t) } }, particleTint: { get: function () { return this.ops.tint.current }, set: function (t) { this.ops.tint.onChange(t) } }, particleAlpha: { get: function () { return this.ops.alpha.current }, set: function (t) { this.ops.alpha.onChange(t) } }, lifespan: { get: function () { return this.ops.lifespan.current }, set: function (t) { this.ops.lifespan.onChange(t) } }, particleAngle: { get: function () { return this.ops.angle.current }, set: function (t) { this.ops.angle.onChange(t) } }, particleRotate: { get: function () { return this.ops.rotate.current }, set: function (t) { this.ops.rotate.onChange(t) } }, quantity: { get: function () { return this.ops.quantity.current }, set: function (t) { this.ops.quantity.onChange(t) } }, delay: { get: function () { return this.ops.delay.current }, set: function (t) { this.ops.delay.onChange(t) } }, hold: { get: function () { return this.ops.hold.current }, set: function (t) { this.ops.hold.onChange(t) } }, flowCounter: { get: function () { return this.counters[0] }, set: function (t) { this.counters[0] = t } }, frameCounter: { get: function () { return this.counters[1] }, set: function (t) { this.counters[1] = t } }, animCounter: { get: function () { return this.counters[2] }, set: function (t) { this.counters[2] = t } }, elapsed: { get: function () { return this.counters[3] }, set: function (t) { this.counters[3] = t } }, stopCounter: { get: function () { return this.counters[4] }, set: function (t) { this.counters[4] = t } }, completeFlag: { get: function () { return this.counters[5] }, set: function (t) { this.counters[5] = t } }, zoneIndex: { get: function () { return this.counters[6] }, set: function (t) { this.counters[6] = t } }, zoneTotal: { get: function () { return this.counters[7] }, set: function (t) { this.counters[7] = t } }, currentFrame: { get: function () { return this.counters[8] }, set: function (t) { this.counters[8] = t } }, currentAnim: { get: function () { return this.counters[9] }, set: function (t) { this.counters[9] = t } }, preDestroy: function () { let t; this.texture = null, this.frames = null, this.anims = null, this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.emitZones = null, this.deathZones = null, this.bounds = null, this.follow = null, this.counters = null; const e = this.ops; for (t = 0; t < F.length; t++) { e[F[t]].destroy() } for (t = 0; t < this.alive.length; t++) this.alive[t].destroy(); for (t = 0; t < this.dead.length; t++) this.dead[t].destroy(); this.ops = null, this.alive = [], this.dead = [], this.worldMatrix.destroy() } }); t.exports = D }, 9871: (t, e, i) => { const s = i(59996); const n = i(61340); const r = new n(); const o = new n(); const a = new n(); const h = new n(); t.exports = function (t, e, i, n) { const l = r; const u = o; const c = a; const d = h; n ? (d.loadIdentity(), d.multiply(n), d.translate(e.x, e.y), d.rotate(e.rotation), d.scale(e.scaleX, e.scaleY)) : d.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const f = t.currentContext; const p = i.roundPixels; const v = i.alpha; const g = e.alpha; const m = e.alive; const y = m.length; const x = e.viewBounds; if (e.visible && y !== 0 && (!x || s(x, i.worldView))) { e.sortCallback && e.depthSort(), i.addToRenderList(e); const T = e.scrollFactorX; const w = e.scrollFactorY; f.save(), f.globalCompositeOperation = t.blendModes[e.blendMode]; for (let b = 0; b < y; b++) { const S = m[b]; const E = S.alpha * g * v; if (!(E <= 0 || S.scaleX === 0 || S.scaleY === 0)) { c.applyITRS(S.x, S.y, S.rotation, S.scaleX, S.scaleY), l.copyFrom(i.matrix), l.multiplyWithOffset(d, -i.scrollX * T, -i.scrollY * w), c.e = S.x, c.f = S.y, l.multiply(c, u); const A = S.frame; const C = A.canvasData; if (C.width > 0 && C.height > 0) { let _ = -A.halfWidth; let M = -A.halfHeight; f.globalAlpha = E, f.save(), u.setToContext(f), p && (_ = Math.round(_), M = Math.round(M)), f.imageSmoothingEnabled = !A.source.scaleMode, f.drawImage(A.source.image, C.x, C.y, C.width, C.height, _, M, C.width, C.height), f.restore() } } } f.restore() } } }, 92730: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(95540); const a = i(31600); n.register('particles', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = o(t, 'config', null); const h = new a(this.scene, 0, 0, i); return void 0 !== e && (t.add = e), s(this.scene, h, t), n && h.setConfig(n), h }) }, 676: (t, e, i) => { const s = i(39429); const n = i(31600); s.register('particles', function (t, e, i, s) { return void 0 !== t && typeof t === 'string' && console.warn('ParticleEmitterManager was removed in Phaser 3.60. See documentation for details'), this.displayList.add(new n(this.scene, t, e, i, s)) }) }, 90668: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(21188), r = i(9871), t.exports = { renderWebGL: n, renderCanvas: r } }, 21188: (t, e, i) => { const s = i(59996); const n = i(61340); const r = i(70554); const o = new n(); const a = new n(); const h = new n(); const l = new n(); t.exports = function (t, e, i, n) { const u = t.pipelines.set(e.pipeline); const c = o; const d = a; const f = h; const p = l; n ? (p.loadIdentity(), p.multiply(n), p.translate(e.x, e.y), p.rotate(e.rotation), p.scale(e.scaleX, e.scaleY)) : p.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const v = r.getTintAppendFloatAlpha; const g = i.alpha; const m = e.alpha; t.pipelines.preBatch(e); const y = e.alive; const x = y.length; const T = e.viewBounds; if (x !== 0 && (!T || s(T, i.worldView))) { e.sortCallback && e.depthSort(), i.addToRenderList(e), c.copyFrom(i.matrix), c.multiplyWithOffset(p, -i.scrollX * e.scrollFactorX, -i.scrollY * e.scrollFactorY), t.setBlendMode(e.blendMode), e.mask && (e.mask.preRenderWebGL(t, e, i), t.pipelines.set(e.pipeline)); for (var w, b, S = e.tintFill, E = 0; E < x; E++) { const A = y[E]; const C = A.alpha * m * g; if (!(C <= 0 || A.scaleX === 0 || A.scaleY === 0)) { f.applyITRS(A.x, A.y, A.rotation, A.scaleX, A.scaleY), f.e = A.x, f.f = A.y, c.multiply(f, d); const _ = A.frame; _.glTexture !== b && (b = _.glTexture, w = u.setGameObject(e, _)); const M = -_.halfWidth; const P = -_.halfHeight; const R = d.setQuad(M, P, M + _.width, P + _.height); const L = v(A.tint, C); u.shouldFlush(6) && (u.flush(), w = u.setGameObject(e, _)), u.batchQuad(e, R[0], R[1], R[2], R[3], R[4], R[5], R[6], R[7], _.u0, _.v0, _.u1, _.v1, L, L, L, L, S, b, w) } } e.mask && e.mask.postRenderWebGL(t, i), t.pipelines.postBatch(e) } } }, 20286: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = !0), this.emitter, this.x = t, this.y = e, this.active = i }, update: function () { }, destroy: function () { this.emitter = null } }); t.exports = s }, 9774: t => { t.exports = 'complete' }, 812: t => { t.exports = 'deathzone' }, 30522: t => { t.exports = 'explode' }, 96695: t => { t.exports = 'start' }, 18677: t => { t.exports = 'stop' }, 20696: (t, e, i) => { t.exports = { COMPLETE: i(9774), DEATH_ZONE: i(812), EXPLODE: i(30522), START: i(96695), STOP: i(18677) } }, 18404: (t, e, i) => { t.exports = { EmitterColorOp: i(76472), EmitterOp: i(44777), Events: i(20696), GravityWell: i(24502), Particle: i(56480), ParticleBounds: i(69601), ParticleEmitter: i(31600), ParticleProcessor: i(20286), Zones: i(21024) } }, 26388: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e) { this.source = t, this.killOnEnter = e }, willKill: function (t) { const e = t.worldPosition; const i = this.source.contains(e.x, e.y); return i && this.killOnEnter || !i && !this.killOnEnter } }); t.exports = s }, 19909: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s, n, r) { void 0 === s && (s = !1), void 0 === n && (n = !0), void 0 === r && (r = -1), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = s, this.counter = -1, this.seamless = n, this._length = 0, this._direction = 0, this.total = r, this.updateSource() }, updateSource: function () { if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) { const t = this.points[0]; const e = this.points[this.points.length - 1]; t.x === e.x && t.y === e.y && this.points.pop() } const i = this._length; return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this }, changeSource: function (t) { return this.source = t, this.updateSource() }, getPoint: function (t) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const e = this.points[this.counter]; e && (t.x = e.x, t.y = e.y) } }); t.exports = s }, 68875: (t, e, i) => { const s = i(83419); const n = i(26099); const r = new s({ initialize: function (t) { this.source = t, this._tempVec = new n(), this.total = -1 }, getPoint: function (t) { const e = this._tempVec; this.source.getRandomPoint(e), t.x = e.x, t.y = e.y } }); t.exports = r }, 21024: (t, e, i) => { t.exports = { DeathZone: i(26388), EdgeZone: i(19909), RandomZone: i(68875) } }, 1159: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(68287); const o = new s({ Extends: r, Mixins: [n.PathFollower], initialize: function (t, e, i, s, n, o) { r.call(this, t, i, s, n, o), this.path = e }, preUpdate: function (t, e) { this.anims.update(t, e), this.pathUpdate(t) } }); t.exports = o }, 90145: (t, e, i) => { const s = i(39429); const n = i(1159); s.register('follower', function (t, e, i, s, r) { const o = new n(this.scene, t, e, i, s, r); return this.displayList.add(o), this.updateList.add(o), o }) }, 33663: (t, e, i) => { const s = i(9674); const n = i(83419); const r = i(48803); const o = i(90664); const a = i(4703); const h = i(45650); const l = new n({ Extends: a, initialize: function (t, e, i, n, r, o, h, l) { n || (n = '__DEFAULT'), a.call(this, t, e, i, n, r), this.type = 'Plane', this.anims = new s(this), this.gridWidth, this.gridHeight, this.isTiled, this._checkerboard = null, this.hideCCW = !1, this.setGridSize(o, h, l), this.setSizeToFrame(!1), this.setViewHeight() }, originX: { get: function () { return 0.5 } }, originY: { get: function () { return 0.5 } }, setGridSize: function (t, e, i) { void 0 === t && (t = 8), void 0 === e && (e = 8), void 0 === i && (i = !1); let s = !1; return i && (s = !0), this.gridWidth = t, this.gridHeight = e, this.isTiled = i, this.clear(), r({ mesh: this, widthSegments: t, heightSegments: e, isOrtho: !1, tile: i, flipY: s }), this }, setSizeToFrame: function (t) { void 0 === t && (t = !0); const e = this.frame; if (this.setPerspective(this.width / e.width, this.height / e.height), this._checkerboard && this._checkerboard !== this.texture && this.removeCheckerboard(), !t) return this; let i; let s; const n = this.gridWidth; const r = this.gridHeight; const o = this.vertices; const a = e.u0; const h = e.u1; let l = e.v0; let u = e.v1; let c = 0; if (this.isTiled) for (l = e.v1, u = e.v0, s = 0; s < r; s++) for (i = 0; i < n; i++)o[c++].setUVs(a, u), o[c++].setUVs(a, l), o[c++].setUVs(h, u), o[c++].setUVs(a, l), o[c++].setUVs(h, l), o[c++].setUVs(h, u); else { const d = n + 1; const f = r + 1; const p = h - a; const v = u - l; const g = []; for (s = 0; s < f; s++) for (i = 0; i < d; i++) { const m = a + p * (i / n); const y = l + v * (s / r); g.push(m, y) } for (s = 0; s < r; s++) for (i = 0; i < n; i++) { const x = 2 * (i + d * s); const T = 2 * (i + d * (s + 1)); const w = 2 * (i + 1 + d * (s + 1)); const b = 2 * (i + 1 + d * s); o[c++].setUVs(g[x], g[x + 1]), o[c++].setUVs(g[T], g[T + 1]), o[c++].setUVs(g[b], g[b + 1]), o[c++].setUVs(g[T], g[T + 1]), o[c++].setUVs(g[w], g[w + 1]), o[c++].setUVs(g[b], g[b + 1]) } } return this }, setViewHeight: function (t) { void 0 === t && (t = this.frame.height); const e = this.fov * (Math.PI / 180); this.viewPosition.z = this.height / t / Math.tan(e / 2), this.dirtyCache[10] = 1 }, createCheckerboard: function (t, e, i, s, n) { void 0 === t && (t = 16777215), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === s && (s = 255), void 0 === n && (n = 128); for (var r = o(t), a = o(e), l = [], u = 0; u < 16; u++) for (let c = 0; c < 16; c++)u < 8 && c < 8 || u > 7 && c > 7 ? l.push(r.r, r.g, r.b, i) : l.push(a.r, a.g, a.b, s); const d = this.scene.sys.textures.addUint8Array(h(), new Uint8Array(l), 16, 16); return this.removeCheckerboard(), this.setTexture(d), this.setSizeToFrame(), this.setViewHeight(n), this }, removeCheckerboard: function () { this._checkerboard && (this._checkerboard.destroy(), this._checkerboard = null) }, play: function (t, e) { return this.anims.play(t, e) }, playReverse: function (t, e) { return this.anims.playReverse(t, e) }, playAfterDelay: function (t, e) { return this.anims.playAfterDelay(t, e) }, playAfterRepeat: function (t, e) { return this.anims.playAfterRepeat(t, e) }, stop: function () { return this.anims.stop() }, stopAfterDelay: function (t) { return this.anims.stopAfterDelay(t) }, stopAfterRepeat: function (t) { return this.anims.stopAfterRepeat(t) }, stopOnFrame: function (t) { return this.anims.stopOnFrame(t) }, preUpdate: function (t, e) { a.prototype.preUpdate.call(this, t, e), this.anims.update(t, e) }, preDestroy: function () { this.clear(), this.removeCheckerboard(), this.anims.destroy(), this.anims = void 0, this.debugCallback = null, this.debugGraphic = null } }); t.exports = l }, 56015: (t, e, i) => { const s = i(25305); const n = i(13059); const r = i(44603); const o = i(23568); const a = i(35154); const h = i(33663); r.register('plane', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const l = a(t, 'width', 8); const u = a(t, 'height', 8); const c = a(t, 'tile', !1); const d = new h(this.scene, 0, 0, i, r, l, u, c); void 0 !== e && (t.add = e); const f = a(t, 'checkerboard', null); if (f) { const p = a(f, 'color1', 16777215); const v = a(f, 'color2', 255); const g = a(f, 'alpha1', 255); const m = a(f, 'alpha2', 255); const y = a(f, 'height', 128); d.createCheckerboard(p, v, g, m, y) } return s(this.scene, d, t), n(d, t), d }) }, 30985: (t, e, i) => { const s = i(33663); i(39429).register('plane', function (t, e, i, n, r, o, a) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a)) }) }, 80321: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(30100); const a = i(36060); const h = i(67277); const l = new s({ Extends: r, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.Mask, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Transform, n.Visible, h], initialize: function (t, e, i, s, n, h, l) { void 0 === s && (s = 16777215), void 0 === n && (n = 128), void 0 === h && (h = 1), void 0 === l && (l = 0.1), r.call(this, t, 'PointLight'), this.initPipeline(a.POINTLIGHT_PIPELINE), this.initPostPipeline(), this.setPosition(e, i), this.color = o(s), this.intensity = h, this.attenuation = l, this.width = 2 * n, this.height = 2 * n, this._radius = n }, radius: { get: function () { return this._radius }, set: function (t) { this._radius = t, this.width = 2 * t, this.height = 2 * t } }, originX: { get: function () { return 0.5 } }, originY: { get: function () { return 0.5 } }, displayOriginX: { get: function () { return this._radius } }, displayOriginY: { get: function () { return this._radius } } }); t.exports = l }, 39829: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(80321); n.register('pointlight', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'color', 16777215); const n = r(t, 'radius', 128); const a = r(t, 'intensity', 1); const h = r(t, 'attenuation', 0.1); const l = new o(this.scene, 0, 0, i, n, a, h); return void 0 !== e && (t.add = e), s(this.scene, l, t), l }) }, 71255: (t, e, i) => { const s = i(39429); const n = i(80321); s.register('pointlight', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)) }) }, 67277: (t, e, i) => { const s = i(29747); let n = s; const r = s; n = i(57787), t.exports = { renderWebGL: n, renderCanvas: r } }, 57787: (t, e, i) => { const s = i(91296); t.exports = function (t, e, i, n) { i.addToRenderList(e); const r = t.pipelines.set(e.pipeline); const o = s(e, i, n).calc; const a = e.width; const h = e.height; const l = -e._radius; const u = -e._radius; const c = l + a; const d = u + h; const f = o.getX(0, 0); const p = o.getY(0, 0); const v = o.getX(l, u); const g = o.getY(l, u); const m = o.getX(l, d); const y = o.getY(l, d); const x = o.getX(c, d); const T = o.getY(c, d); const w = o.getX(c, u); const b = o.getY(c, u); t.pipelines.preBatch(e), r.batchPointLight(e, i, v, g, m, y, x, T, w, b, f, p), t.pipelines.postBatch(e) } }, 591: (t, e, i) => { const s = i(83419); const n = i(81320); const r = i(88571); const o = new s({ Extends: r, initialize: function (t, e, i, s, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 32), void 0 === o && (o = 32); const a = new n(t.sys.textures, '', s, o); r.call(this, t, e, i, a), this.type = 'RenderTexture', this.camera = this.texture.camera, this._saved = !1 }, setSize: function (t, e) { this.width = t, this.height = e, this.texture.setSize(t, e), this.updateDisplayOrigin(); const i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this }, resize: function (t, e) { return this.setSize(t, e), this }, saveTexture: function (t) { const e = this.texture; return e.key = t, e.manager.addDynamicTexture(e) && (this._saved = !0), e }, fill: function (t, e, i, s, n, r) { return this.texture.fill(t, e, i, s, n, r), this }, clear: function () { return this.texture.clear(), this }, stamp: function (t, e, i, s, n) { return this.texture.stamp(t, e, i, s, n), this }, erase: function (t, e, i) { return this.texture.erase(t, e, i), this }, draw: function (t, e, i, s, n) { return this.texture.draw(t, e, i, s, n), this }, drawFrame: function (t, e, i, s, n, r) { return this.texture.drawFrame(t, e, i, s, n, r), this }, repeat: function (t, e, i, s, n, r, o, a, h) { return this.texture.repeat(t, e, i, s, n, r, o, a, h), this }, beginDraw: function () { return this.texture.beginDraw(), this }, batchDraw: function (t, e, i, s, n) { return this.texture.batchDraw(t, e, i, s, n), this }, batchDrawFrame: function (t, e, i, s, n, r) { return this.texture.batchDrawFrame(t, e, i, s, n, r), this }, endDraw: function (t) { return this.texture.endDraw(t), this }, snapshotArea: function (t, e, i, s, n, r, o) { return this.texture.snapshotArea(t, e, i, s, n, r, o), this }, snapshot: function (t, e, i) { return this.snapshotArea(0, 0, this.width, this.height, t, e, i) }, snapshotPixel: function (t, e, i) { return this.snapshotArea(t, e, 1, 1, i, 'pixel') }, preDestroy: function () { this.camera = null, this._saved || this.texture.destroy() } }); t.exports = o }, 34495: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(591); n.register('renderTexture', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const n = r(t, 'y', 0); const a = r(t, 'width', 32); const h = r(t, 'height', 32); const l = new o(this.scene, i, n, a, h); return void 0 !== e && (t.add = e), s(this.scene, l, t), l }) }, 60505: (t, e, i) => { const s = i(39429); const n = i(591); s.register('renderTexture', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)) }) }, 77757: (t, e, i) => { const s = i(9674); const n = i(83419); const r = i(31401); const o = i(95643); const a = i(36060); const h = i(38745); const l = i(26099); const u = new n({ Extends: o, Mixins: [r.AlphaSingle, r.BlendMode, r.Depth, r.Flip, r.Mask, r.Pipeline, r.PostPipeline, r.Size, r.Texture, r.Transform, r.Visible, r.ScrollFactor, h], initialize: function (t, e, i, n, r, h, u, c, d) { void 0 === n && (n = '__DEFAULT'), void 0 === h && (h = 2), void 0 === u && (u = !0), o.call(this, t, 'Rope'), this.anims = new s(this), this.points = h, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = n === '__DEFAULT', this.dirty = !1, this.horizontal = u, this._flipX = !1, this._flipY = !1, this._perp = new l(), this.debugCallback = null, this.debugGraphic = null, this.setTexture(n, r), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline(a.ROPE_PIPELINE), this.initPostPipeline(), Array.isArray(h) && this.resizeArrays(h.length), this.setPoints(h, c, d), this.updateVertices() }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function (t, e) { const i = this.anims.currentFrame; this.anims.update(t, e), this.anims.currentFrame !== i && (this.updateUVs(), this.updateVertices()) }, play: function (t, e, i) { return this.anims.play(t, e, i), this }, setDirty: function () { return this.dirty = !0, this }, setHorizontal: function (t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(t, e, i)) }, setVertical: function (t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(t, e, i)) : this }, setTintFill: function (t) { return void 0 === t && (t = !1), this.tintFill = t, this }, setAlphas: function (t, e) { const i = this.points.length; if (i < 1) return this; let s; const n = this.alphas; void 0 === t ? t = [1] : Array.isArray(t) || void 0 !== e || (t = [t]); let r = 0; if (void 0 !== e) for (s = 0; s < i; s++)n[r = 2 * s] = t, n[r + 1] = e; else if (t.length === i) for (s = 0; s < i; s++)n[r = 2 * s] = t[s], n[r + 1] = t[s]; else { let o = t[0]; for (s = 0; s < i; s++)r = 2 * s, t.length > r && (o = t[r]), n[r] = o, t.length > r + 1 && (o = t[r + 1]), n[r + 1] = o } return this }, setColors: function (t) { const e = this.points.length; if (e < 1) return this; let i; const s = this.colors; void 0 === t ? t = [16777215] : Array.isArray(t) || (t = [t]); let n = 0; if (t.length === e) for (i = 0; i < e; i++)s[n = 2 * i] = t[i], s[n + 1] = t[i]; else { let r = t[0]; for (i = 0; i < e; i++)n = 2 * i, t.length > n && (r = t[n]), s[n] = r, t.length > n + 1 && (r = t[n + 1]), s[n + 1] = r } return this }, setPoints: function (t, e, i) { if (void 0 === t && (t = 2), typeof t === 'number') { let s; let n; let r; let o = t; if (o < 2 && (o = 2), t = [], this.horizontal) for (r = -this.frame.halfWidth, n = this.frame.width / (o - 1), s = 0; s < o; s++)t.push({ x: r + s * n, y: 0 }); else for (r = -this.frame.halfHeight, n = this.frame.height / (o - 1), s = 0; s < o; s++)t.push({ x: 0, y: r + s * n }) } let a = t.length; const h = this.points.length; return a < 1 ? (console.warn('Rope: Not enough points given'), this) : (a === 1 && (t.unshift({ x: 0, y: 0 }), a++), h !== a && this.resizeArrays(a), this.dirty = !0, this.points = t, this.updateUVs(), e != null && this.setColors(e), i != null && this.setAlphas(i), this) }, updateUVs: function () { for (let t = this.uv, e = this.points.length, i = this.frame.u0, s = this.frame.v0, n = this.frame.u1, r = this.frame.v1, o = (n - i) / (e - 1), a = (r - s) / (e - 1), h = 0; h < e; h++) { var l; var u; var c; var d; const f = 4 * h; this.horizontal ? (this._flipX ? (l = n - h * o, c = n - h * o) : (l = i + h * o, c = i + h * o), this._flipY ? (u = r, d = s) : (u = s, d = r)) : (this._flipX ? (l = i, c = n) : (l = n, c = i), this._flipY ? (u = r - h * a, d = r - h * a) : (u = s + h * a, d = s + h * a)), t[f + 0] = l, t[f + 1] = u, t[f + 2] = c, t[f + 3] = d } return this }, resizeArrays: function (t) { let e = this.colors; let i = this.alphas; this.vertices = new Float32Array(4 * t), this.uv = new Float32Array(4 * t), e = new Uint32Array(2 * t), i = new Float32Array(2 * t); for (let s = 0; s < 2 * t; s++)e[s] = 16777215, i[s] = 1; return this.colors = e, this.alphas = i, this.dirty = !0, this }, updateVertices: function () { const t = this._perp; const e = this.points; const i = this.vertices; const s = e.length; if (this.dirty = !1, !(s < 1)) { for (var n, r = e[0], o = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, a = 0; a < s; a++) { const h = e[a]; const l = 4 * a; n = a < s - 1 ? e[a + 1] : h, t.x = n.y - r.y, t.y = -(n.x - r.x); const u = t.length(); t.x /= u, t.y /= u, t.x *= o, t.y *= o, i[l] = h.x + t.x, i[l + 1] = h.y + t.y, i[l + 2] = h.x - t.x, i[l + 3] = h.y - t.y, r = h } return this } }, setDebug: function (t, e) { return this.debugGraphic = t, this.debugCallback = t || e ? e || this.renderDebugVerts : null, this }, renderDebugVerts: function (t, e, i) { const s = t.debugGraphic; let n = i[0]; let r = i[1]; let o = i[2]; let a = i[3]; s.lineBetween(n, r, o, a); for (let h = 4; h < e; h += 4) { const l = i[h + 0]; const u = i[h + 1]; const c = i[h + 2]; const d = i[h + 3]; s.lineBetween(n, r, l, u), s.lineBetween(o, a, c, d), s.lineBetween(o, a, l, u), s.lineBetween(l, u, c, d), n = l, r = u, o = c, a = d } }, preDestroy: function () { this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null }, flipX: { get: function () { return this._flipX }, set: function (t) { return this._flipX = t, this.updateUVs() } }, flipY: { get: function () { return this._flipY }, set: function (t) { return this._flipY = t, this.updateUVs() } } }); t.exports = u }, 95262: t => { t.exports = function () { } }, 26209: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(35154); const a = i(77757); n.register('rope', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = r(t, 'frame', null); const h = r(t, 'horizontal', !0); const l = o(t, 'points', void 0); const u = o(t, 'colors', void 0); const c = o(t, 'alphas', void 0); const d = new a(this.scene, 0, 0, i, n, l, h, u, c); return void 0 !== e && (t.add = e), s(this.scene, d, t), d }) }, 96819: (t, e, i) => { const s = i(77757); i(39429).register('rope', function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)) }) }, 38745: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(20439), r = i(95262), t.exports = { renderWebGL: n, renderCanvas: r } }, 20439: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.pipelines.set(e.pipeline, e); const a = s(e, i, r).calc; const h = e.vertices; const l = e.uv; const u = e.colors; const c = e.alphas; const d = e.alpha; const f = n.getTintAppendFloatAlpha; const p = i.roundPixels; const v = h.length; const g = Math.floor(0.5 * v); o.flush(), t.pipelines.preBatch(e); const m = o.setGameObject(e); const y = o.vertexViewF32; const x = o.vertexViewU32; let T = o.vertexCount * o.currentShader.vertexComponentCount - 1; let w = 0; const b = e.tintFill; e.dirty && e.updateVertices(); for (var S = e.debugCallback, E = [], A = 0; A < v; A += 2) { const C = h[A + 0]; const _ = h[A + 1]; let M = C * a.a + _ * a.c + a.e; let P = C * a.b + _ * a.d + a.f; p && (M = Math.round(M), P = Math.round(P)), y[++T] = M, y[++T] = P, y[++T] = l[A + 0], y[++T] = l[A + 1], y[++T] = m, y[++T] = b, x[++T] = f(u[w], i.alpha * (c[w] * d)), w++, S && (E[A + 0] = M, E[A + 1] = P) } S && S.call(e, e, v, E), o.vertexCount += g, o.currentBatch.count = o.vertexCount - o.currentBatch.start, t.pipelines.postBatch(e) } }, 20071: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(95540); const a = i(79291); const h = i(61622); const l = i(25479); const u = i(61340); const c = i(95428); const d = i(92503); const f = new s({ Extends: r, Mixins: [n.ComputedSize, n.Depth, n.GetBounds, n.Mask, n.Origin, n.ScrollFactor, n.Transform, n.Visible, l], initialize: function (t, e, i, s, n, o, a, h) { void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 128), void 0 === o && (o = 128), r.call(this, t, 'Shader'), this.blendMode = -1, this.shader; const l = t.sys.renderer; this.renderer = l, this.gl = l.gl, this.vertexData = new ArrayBuffer(2 * Float32Array.BYTES_PER_ELEMENT * 6), this.vertexBuffer = l.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this._deferSetShader = null, this._deferProjOrtho = null, this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new u(), this._tempMatrix2 = new u(), this._tempMatrix3 = new u(), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = l.width, this._rendererHeight = l.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(i, s), this.setSize(n, o), this.setOrigin(0.5, 0.5), this.setShader(e, a, h), this.renderer.on(d.RESTORE_WEBGL, this.onContextRestored, this) }, willRender: function (t) { return !!this.renderToTexture || !(r.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id) }, setRenderToTexture: function (t, e) { if (void 0 === e && (e = !1), !this.renderToTexture) { const i = this.width; const s = this.height; var n = this.renderer; this.glTexture = n.createTextureFromSource(null, i, s, 0), this.framebuffer = n.createFramebuffer(i, s, this.glTexture, !1), this._rendererWidth = i, this._rendererHeight = s, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), t && (this.texture = this.scene.sys.textures.addGLTexture(t, this.glTexture)) } return this.shader && (n.pipelines.clear(), this.load(), this.flush(), n.pipelines.rebind()), this }, setShader: function (t, e, i) { if (this.renderer.contextLost) return this._deferSetShader = { key: t, textures: e, textureData: i }, this; if (void 0 === e && (e = []), typeof t === 'string') { const s = this.scene.sys.cache.shader; if (!s.has(t)) return console.warn('Shader missing: ' + t), this; this.shader = s.get(t) } else this.shader = t; const n = this.gl; const r = this.renderer; this.program && r.deleteProgram(this.program); const o = r.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc); n.uniformMatrix4fv(n.getUniformLocation(o.webGLProgram, 'uViewMatrix'), !1, this.viewMatrix), n.uniformMatrix4fv(n.getUniformLocation(o.webGLProgram, 'uProjectionMatrix'), !1, this.projectionMatrix), n.uniform2f(n.getUniformLocation(o.webGLProgram, 'uResolution'), this.width, this.height), this.program = o; const h = new Date(); const l = { resolution: { type: '2f', value: { x: this.width, y: this.height } }, time: { type: '1f', value: 0 }, mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } }, date: { type: '4fv', value: [h.getFullYear(), h.getMonth(), h.getDate(), 60 * h.getHours() * 60 + 60 * h.getMinutes() + h.getSeconds()] }, sampleRate: { type: '1f', value: 44100 }, iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: !0 } } }; this.shader.uniforms ? this.uniforms = a(!0, {}, this.shader.uniforms, l) : this.uniforms = l; for (let u = 0; u < 4; u++)e[u] && this.setSampler2D('iChannel' + u, e[u], u, i); return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this }, setPointer: function (t) { return this.pointer = t, this }, projOrtho: function (t, e, i, s) { if (this.renderer.contextLost) this._deferProjOrtho = { left: t, right: e, bottom: i, top: s }; else { const n = 1 / (t - e); const r = 1 / (i - s); const o = this.projectionMatrix; o[0] = -2 * n, o[5] = -2 * r, o[10] = -0.001, o[12] = (t + e) * n, o[13] = (s + i) * r, o[14] = -0; const a = this.program; const h = this.gl; this.renderer.setProgram(a), h.uniformMatrix4fv(h.getUniformLocation(a.webGLProgram, 'uProjectionMatrix'), !1, this.projectionMatrix), this._rendererWidth = e, this._rendererHeight = i } }, initUniforms: function () { const t = this.renderer.glFuncMap; const e = this.program; for (const i in this._textureCount = 0, this.uniforms) { const s = this.uniforms[i]; const n = s.type; const r = t[n]; s.uniformLocation = this.renderer.createUniformLocation(e, i), n !== 'sampler2D' && (s.glMatrix = r.matrix, s.glValueLength = r.length, s.glFunc = r.func) } }, setSampler2DBuffer: function (t, e, i, s, n, r) { void 0 === n && (n = 0), void 0 === r && (r = {}); const o = this.uniforms[t]; return o.value = e, r.width = i, r.height = s, o.textureData = r, this._textureCount = n, this.initSampler2D(o), this }, setSampler2D: function (t, e, i, s) { void 0 === i && (i = 0); const n = this.scene.sys.textures; if (n.exists(e)) { const r = n.getFrame(e); if (r.glTexture && r.glTexture.isRenderTexture) return this.setSampler2DBuffer(t, r.glTexture, r.width, r.height, i, s); const o = this.uniforms[t]; const a = r.source; o.textureKey = e, o.source = a.image, o.value = r.glTexture, a.isGLTexture && (s || (s = {}), s.width = a.width, s.height = a.height), s && (o.textureData = s), this._textureCount = i, this.initSampler2D(o) } return this }, setUniform: function (t, e) { return h(this.uniforms, t, e), this }, getUniform: function (t) { return o(this.uniforms, t, null) }, setChannel0: function (t, e) { return this.setSampler2D('iChannel0', t, 0, e) }, setChannel1: function (t, e) { return this.setSampler2D('iChannel1', t, 1, e) }, setChannel2: function (t, e) { return this.setSampler2D('iChannel2', t, 2, e) }, setChannel3: function (t, e) { return this.setSampler2D('iChannel3', t, 3, e) }, initSampler2D: function (t) { if (t.value) { const e = t.textureData; if (e && !t.value.isRenderTexture) { const i = this.gl; const s = t.value; const n = i[o(e, 'magFilter', 'linear').toUpperCase()]; const r = i[o(e, 'minFilter', 'linear').toUpperCase()]; let a = i[o(e, 'wrapS', 'repeat').toUpperCase()]; let h = i[o(e, 'wrapT', 'repeat').toUpperCase()]; const l = i[o(e, 'format', 'rgba').toUpperCase()]; const u = o(e, 'flipY', !1); const c = o(e, 'width', s.width); const d = o(e, 'height', s.height); let f = o(e, 'source', s.pixels); e.repeat && (a = i.REPEAT, h = i.REPEAT), e.width && (f = null), s.update(f, c, d, u, a, h, r, n, l) } this.renderer.setProgram(this.program), this._textureCount++ } }, syncUniforms: function () { let t; let e; let i; let s; let n; const r = this.gl; const o = this.uniforms; let a = 0; for (const h in o) i = (t = o[h]).glFunc, e = t.glValueLength, s = t.uniformLocation, (n = t.value) !== null && (e === 1 ? t.glMatrix ? i.call(r, s.webGLUniformLocation, t.transpose, n) : i.call(r, s.webGLUniformLocation, n) : e === 2 ? i.call(r, s.webGLUniformLocation, n.x, n.y) : e === 3 ? i.call(r, s.webGLUniformLocation, n.x, n.y, n.z) : e === 4 ? i.call(r, s.webGLUniformLocation, n.x, n.y, n.z, n.w) : t.type === 'sampler2D' && (r.activeTexture(r.TEXTURE0 + a), r.bindTexture(r.TEXTURE_2D, n.webGLTexture), r.uniform1i(s.webGLUniformLocation, a), a++)) }, load: function (t) { const e = this.gl; const i = this.width; const s = this.height; const n = this.renderer; const r = this.program; const o = this.viewMatrix; if (!this.renderToTexture) { const a = -this._displayOriginX; const h = -this._displayOriginY; o[0] = t[0], o[1] = t[1], o[4] = t[2], o[5] = t[3], o[8] = t[4], o[9] = t[5], o[12] = o[0] * a + o[4] * h, o[13] = o[1] * a + o[5] * h } e.useProgram(r.webGLProgram), e.uniformMatrix4fv(e.getUniformLocation(r.webGLProgram, 'uViewMatrix'), !1, o), e.uniformMatrix4fv(e.getUniformLocation(r.webGLProgram, 'uProjectionMatrix'), !1, this.projectionMatrix), e.uniform2f(e.getUniformLocation(r.webGLProgram, 'uResolution'), this.width, this.height); const l = this.uniforms; const u = l.resolution; u.value.x = i, u.value.y = s, l.time.value = n.game.loop.getDuration(); const c = this.pointer; if (c) { const d = l.mouse; const f = c.x / i; const p = 1 - c.y / s; d.value.x = f.toFixed(2), d.value.y = p.toFixed(2) } this.syncUniforms() }, flush: function () { const t = this.width; const e = this.height; const i = this.program; const s = this.gl; const n = this.vertexBuffer; const r = this.renderer; const o = 2 * Float32Array.BYTES_PER_ELEMENT; this.renderToTexture && (r.setFramebuffer(this.framebuffer), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT)), s.bindBuffer(s.ARRAY_BUFFER, n.webGLBuffer); const a = s.getAttribLocation(i.webGLProgram, 'inPosition'); a !== -1 && (s.enableVertexAttribArray(a), s.vertexAttribPointer(a, 2, s.FLOAT, !1, o, 0)); const h = this.vertexViewF32; h[3] = e, h[4] = t, h[5] = e, h[8] = t, h[9] = e, h[10] = t; s.bufferSubData(s.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * o)), s.drawArrays(s.TRIANGLES, 0, 6), this.renderToTexture && r.setFramebuffer(null, !1) }, setAlpha: function () { }, setBlendMode: function () { }, onContextRestored: function () { if (this._deferSetShader !== null) { const t = this._deferSetShader.key; const e = this._deferSetShader.textures; const i = this._deferSetShader.textureData; this._deferSetShader = null, this.setShader(t, e, i) } if (this._deferProjOrtho !== null) { const s = this._deferProjOrtho.left; const n = this._deferProjOrtho.right; const r = this._deferProjOrtho.bottom; const o = this._deferProjOrtho.top; this._deferProjOrtho = null, this.projOrtho(s, n, r, o) } }, preDestroy: function () { const t = this.renderer; t.off(d.RESTORE_WEBGL, this.onContextRestored, this), t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), this.renderToTexture && (t.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null), c(this.uniforms, function (e) { t.deleteUniformLocation(e.uniformLocation), e.uniformLocation = null }) } }); t.exports = f }, 80464: t => { t.exports = function () { } }, 54935: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(20071); n.register('shader', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = r(t, 'x', 0); const a = r(t, 'y', 0); const h = r(t, 'width', 128); const l = r(t, 'height', 128); const u = new o(this.scene, i, n, a, h, l); return void 0 !== e && (t.add = e), s(this.scene, u, t), u }) }, 74177: (t, e, i) => { const s = i(20071); i(39429).register('shader', function (t, e, i, n, r, o, a) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a)) }) }, 25479: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(19257), r = i(80464), t.exports = { renderWebGL: n, renderCanvas: r } }, 19257: (t, e, i) => { const s = i(91296); t.exports = function (t, e, i, n) { if (e.shader) { if (i.addToRenderList(e), t.pipelines.clear(), e.renderToTexture) e.load(), e.flush(); else { const r = s(e, i, n).calc; t.width === e._rendererWidth && t.height === e._rendererHeight || e.projOrtho(0, t.width, t.height, 0), e.load(r.matrix), e.flush() } t.pipelines.rebind() } } }, 10441: (t, e, i) => { const s = i(70554); t.exports = function (t, e, i, n, r, o) { for (let a = s.getTintAppendFloatAlpha(i.fillColor, i.fillAlpha * n), h = i.pathData, l = i.pathIndexes, u = 0; u < l.length; u += 3) { const c = 2 * l[u]; const d = 2 * l[u + 1]; const f = 2 * l[u + 2]; const p = h[c + 0] - r; const v = h[c + 1] - o; const g = h[d + 0] - r; const m = h[d + 1] - o; const y = h[f + 0] - r; const x = h[f + 1] - o; const T = e.getX(p, v); const w = e.getY(p, v); const b = e.getX(g, m); const S = e.getY(g, m); const E = e.getX(y, x); const A = e.getY(y, x); t.batchTri(i, T, w, b, S, E, A, 0, 0, 1, 1, a, a, a, 2) } } }, 65960: t => { t.exports = function (t, e, i, s) { const n = i || e.fillColor; const r = s || e.fillAlpha; const o = (16711680 & n) >>> 16; const a = (65280 & n) >>> 8; const h = 255 & n; t.fillStyle = 'rgba(' + o + ',' + a + ',' + h + ',' + r + ')' } }, 75177: t => { t.exports = function (t, e, i, s) { const n = i || e.strokeColor; const r = s || e.strokeAlpha; const o = (16711680 & n) >>> 16; const a = (65280 & n) >>> 8; const h = 255 & n; t.strokeStyle = 'rgba(' + o + ',' + a + ',' + h + ',' + r + ')', t.lineWidth = e.lineWidth } }, 17803: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(95643); const o = i(23031); const a = new s({ Extends: r, Mixins: [n.AlphaSingle, n.BlendMode, n.Depth, n.GetBounds, n.Mask, n.Origin, n.Pipeline, n.PostPipeline, n.ScrollFactor, n.Transform, n.Visible], initialize: function (t, e, i) { void 0 === e && (e = 'Shape'), r.call(this, t, e), this.geom = i, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o(), this.width = 0, this.height = 0, this.initPipeline(), this.initPostPipeline() }, setFillStyle: function (t, e) { return void 0 === e && (e = 1), void 0 === t ? this.isFilled = !1 : (this.fillColor = t, this.fillAlpha = e, this.isFilled = !0), this }, setStrokeStyle: function (t, e, i) { return void 0 === i && (i = 1), void 0 === t ? this.isStroked = !1 : (this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i, this.isStroked = !0), this }, setClosePath: function (t) { return this.closePath = t, this }, setSize: function (t, e) { return this.width = t, this.height = e, this }, setDisplaySize: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this }, preDestroy: function () { this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = [] }, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (t) { this.scaleX = t / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (t) { this.scaleY = t / this.height } } }); t.exports = a }, 34682: (t, e, i) => { const s = i(70554); t.exports = function (t, e, i, n, r) { const o = t.strokeTint; const a = s.getTintAppendFloatAlpha(e.strokeColor, e.strokeAlpha * i); o.TL = a, o.TR = a, o.BL = a, o.BR = a; const h = e.pathData; let l = h.length - 1; const u = e.lineWidth; const c = u / 2; let d = h[0] - n; let f = h[1] - r; e.closePath || (l -= 2); for (let p = 2; p < l; p += 2) { const v = h[p] - n; const g = h[p + 1] - r; t.batchLine(d, f, v, g, c, c, u, p - 2, !!e.closePath && p === l - 1), d = v, f = g } } }, 23629: (t, e, i) => { const s = i(13609); const n = i(83419); const r = i(39506); const o = i(94811); const a = i(96503); const h = i(36383); const l = i(17803); const u = new n({ Extends: l, Mixins: [s], initialize: function (t, e, i, s, n, r, o, h, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 128), void 0 === n && (n = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), l.call(this, t, 'Arc', new a(0, 0, s)), this._startAngle = n, this._endAngle = r, this._anticlockwise = o, this._iterations = 0.01, this.setPosition(e, i); const c = 2 * this.geom.radius; this.setSize(c, c), void 0 !== h && this.setFillStyle(h, u), this.updateDisplayOrigin(), this.updateData() }, iterations: { get: function () { return this._iterations }, set: function (t) { this._iterations = t, this.updateData() } }, radius: { get: function () { return this.geom.radius }, set: function (t) { this.geom.radius = t; const e = 2 * t; this.setSize(e, e), this.updateDisplayOrigin(), this.updateData() } }, startAngle: { get: function () { return this._startAngle }, set: function (t) { this._startAngle = t, this.updateData() } }, endAngle: { get: function () { return this._endAngle }, set: function (t) { this._endAngle = t, this.updateData() } }, anticlockwise: { get: function () { return this._anticlockwise }, set: function (t) { this._anticlockwise = t, this.updateData() } }, setRadius: function (t) { return this.radius = t, this }, setIterations: function (t) { return void 0 === t && (t = 0.01), this.iterations = t, this }, setStartAngle: function (t, e) { return this._startAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData() }, setEndAngle: function (t, e) { return this._endAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData() }, updateData: function () { const t = this._iterations; let e = t; const i = this.geom.radius; const s = r(this._startAngle); let n = r(this._endAngle); const a = i; const l = i; n -= s, this._anticlockwise ? n < -h.PI2 ? n = -h.PI2 : n > 0 && (n = -h.PI2 + n % h.PI2) : n > h.PI2 ? n = h.PI2 : n < 0 && (n = h.PI2 + n % h.PI2); for (var u, c = [a + Math.cos(s) * i, l + Math.sin(s) * i]; e < 1;)u = n * e + s, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), e += t; return u = n + s, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), c.push(a + Math.cos(s) * i, l + Math.sin(s) * i), this.pathIndexes = o(c), this.pathData = c, this } }); t.exports = u }, 42542: (t, e, i) => { const s = i(39506); const n = i(65960); const r = i(75177); const o = i(20926); t.exports = function (t, e, i, a) { i.addToRenderList(e); const h = t.currentContext; if (o(t, h, e, i, a)) { const l = e.radius; h.beginPath(), h.arc(l - e.originX * (2 * l), l - e.originY * (2 * l), l, s(e._startAngle), s(e._endAngle), e.anticlockwise), e.closePath && h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (r(h, e), h.stroke()), h.restore() } } }, 42563: (t, e, i) => { const s = i(23629); const n = i(39429); n.register('arc', function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)) }), n.register('circle', function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, 0, 360, !1, n, r)) }) }, 13609: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(41447), r = i(42542), t.exports = { renderWebGL: n, renderCanvas: r } }, 41447: (t, e, i) => { const s = i(91296); const n = i(10441); const r = i(34682); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = s(e, i, o); const l = a.calcMatrix.copyFrom(h.calc); const u = e._displayOriginX; const c = e._displayOriginY; const d = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && n(a, l, e, d, u, c), e.isStroked && r(a, e, d, u, c), t.pipelines.postBatch(e) } }, 89: (t, e, i) => { const s = i(83419); const n = i(33141); const r = i(94811); const o = i(87841); const a = i(17803); const h = new s({ Extends: a, Mixins: [n], initialize: function (t, e, i, s, n, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, 'Curve', s), this._smoothness = 32, this._curveBounds = new o(), this.closePath = !1, this.setPosition(e, i), void 0 !== n && this.setFillStyle(n, r), this.updateData() }, smoothness: { get: function () { return this._smoothness }, set: function (t) { this._smoothness = t, this.updateData() } }, setSmoothness: function (t) { return this._smoothness = t, this.updateData() }, updateData: function () { const t = this._curveBounds; const e = this._smoothness; this.geom.getBounds(t, e), this.setSize(t.width, t.height), this.updateDisplayOrigin(); for (var i = [], s = this.geom.getPoints(e), n = 0; n < s.length; n++)i.push(s[n].x, s[n].y); return i.push(s[0].x, s[0].y), this.pathIndexes = r(i), this.pathData = i, this } }); t.exports = h }, 3170: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX + e._curveBounds.x; const l = e._displayOriginY + e._curveBounds.y; const u = e.pathData; let c = u.length - 1; const d = u[0] - h; const f = u[1] - l; a.beginPath(), a.moveTo(d, f), e.closePath || (c -= 2); for (let p = 2; p < c; p += 2) { const v = u[p] - h; const g = u[p + 1] - l; a.lineTo(v, g) } e.closePath && a.closePath(), e.isFilled && (s(a, e), a.fill()), e.isStroked && (n(a, e), a.stroke()), a.restore() } } }, 40511: (t, e, i) => { const s = i(39429); const n = i(89); s.register('curve', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)) }) }, 33141: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(53987), r = i(3170), t.exports = { renderWebGL: n, renderCanvas: r } }, 53987: (t, e, i) => { const s = i(10441); const n = i(91296); const r = i(34682); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = n(e, i, o); const l = a.calcMatrix.copyFrom(h.calc); const u = e._displayOriginX + e._curveBounds.x; const c = e._displayOriginY + e._curveBounds.y; const d = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && s(a, l, e, d, u, c), e.isStroked && r(a, e, d, u, c), t.pipelines.postBatch(e) } }, 19921: (t, e, i) => { const s = i(83419); const n = i(94811); const r = i(54205); const o = i(8497); const a = i(17803); const h = new s({ Extends: a, Mixins: [r], initialize: function (t, e, i, s, n, r, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 128), void 0 === n && (n = 128), a.call(this, t, 'Ellipse', new o(s / 2, n / 2, s, n)), this._smoothness = 64, this.setPosition(e, i), this.width = s, this.height = n, void 0 !== r && this.setFillStyle(r, h), this.updateDisplayOrigin(), this.updateData() }, smoothness: { get: function () { return this._smoothness }, set: function (t) { this._smoothness = t, this.updateData() } }, setSize: function (t, e) { return this.width = t, this.height = e, this.geom.setPosition(t / 2, e / 2), this.geom.setSize(t, e), this.updateData() }, setSmoothness: function (t) { return this._smoothness = t, this.updateData() }, updateData: function () { for (var t = [], e = this.geom.getPoints(this._smoothness), i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = n(t), this.pathData = t, this } }); t.exports = h }, 7930: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX; const l = e._displayOriginY; const u = e.pathData; let c = u.length - 1; const d = u[0] - h; const f = u[1] - l; a.beginPath(), a.moveTo(d, f), e.closePath || (c -= 2); for (let p = 2; p < c; p += 2) { const v = u[p] - h; const g = u[p + 1] - l; a.lineTo(v, g) } a.closePath(), e.isFilled && (s(a, e), a.fill()), e.isStroked && (n(a, e), a.stroke()), a.restore() } } }, 1543: (t, e, i) => { const s = i(19921); i(39429).register('ellipse', function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)) }) }, 54205: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(19467), r = i(7930), t.exports = { renderWebGL: n, renderCanvas: r } }, 19467: (t, e, i) => { const s = i(10441); const n = i(91296); const r = i(34682); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = n(e, i, o); const l = a.calcMatrix.copyFrom(h.calc); const u = e._displayOriginX; const c = e._displayOriginY; const d = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && s(a, l, e, d, u, c), e.isStroked && r(a, e, d, u, c), t.pipelines.postBatch(e) } }, 30479: (t, e, i) => { const s = i(83419); const n = i(17803); const r = i(26015); const o = new s({ Extends: n, Mixins: [r], initialize: function (t, e, i, s, r, o, a, h, l, u, c) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 128), void 0 === r && (r = 128), void 0 === o && (o = 32), void 0 === a && (a = 32), n.call(this, t, 'Grid', null), this.cellWidth = o, this.cellHeight = a, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(e, i), this.setSize(s, r), this.setFillStyle(h, l), void 0 !== u && this.setOutlineStyle(u, c), this.updateDisplayOrigin() }, setFillStyle: function (t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showCells = !1 : (this.fillColor = t, this.fillAlpha = e, this.showCells = !0), this }, setAltFillStyle: function (t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showAltCells = !1 : (this.altFillColor = t, this.altFillAlpha = e, this.showAltCells = !0), this }, setOutlineStyle: function (t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showOutline = !1 : (this.outlineFillColor = t, this.outlineFillAlpha = e, this.showOutline = !0), this } }); t.exports = o }, 49912: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = -e._displayOriginX; const l = -e._displayOriginY; const u = i.alpha * e.alpha; const c = e.width; const d = e.height; const f = e.cellWidth; const p = e.cellHeight; const v = Math.ceil(c / f); const g = Math.ceil(d / p); let m = f; let y = p; let x = f - (v * f - c); let T = p - (g * p - d); const w = e.showCells; const b = e.showAltCells; const S = e.showOutline; let E = 0; let A = 0; let C = 0; let _ = 0; let M = 0; if (S && (m--, y--, x === f && x--, T === p && T--), w && e.fillAlpha > 0) for (s(a, e), A = 0; A < g; A++) for (b && (C = A % 2), E = 0; E < v; E++)b && C ? C = 0 : (C++, _ = E < v - 1 ? m : x, M = A < g - 1 ? y : T, a.fillRect(h + E * f, l + A * p, _, M)); if (b && e.altFillAlpha > 0) for (s(a, e, e.altFillColor, e.altFillAlpha * u), A = 0; A < g; A++) for (b && (C = A % 2), E = 0; E < v; E++)!b || C ? (C = 0, _ = E < v - 1 ? m : x, M = A < g - 1 ? y : T, a.fillRect(h + E * f, l + A * p, _, M)) : C = 1; if (S && e.outlineFillAlpha > 0) { for (n(a, e, e.outlineFillColor, e.outlineFillAlpha * u), E = 1; E < v; E++) { const P = E * f; a.beginPath(), a.moveTo(P + h, l), a.lineTo(P + h, d + l), a.stroke() } for (A = 1; A < g; A++) { const R = A * p; a.beginPath(), a.moveTo(h, R + l), a.lineTo(h + c, R + l), a.stroke() } } a.restore() } } }, 34137: (t, e, i) => { const s = i(39429); const n = i(30479); s.register('grid', function (t, e, i, s, r, o, a, h, l, u) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h, l, u)) }) }, 26015: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(46161), r = i(49912), t.exports = { renderWebGL: n, renderCanvas: r } }, 46161: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.pipelines.set(e.pipeline); const a = s(e, i, r); o.calcMatrix.copyFrom(a.calc).translate(-e._displayOriginX, -e._displayOriginY); let h; let l; const u = i.alpha * e.alpha; const c = e.width; const d = e.height; const f = e.cellWidth; const p = e.cellHeight; const v = Math.ceil(c / f); const g = Math.ceil(d / p); let m = f; let y = p; let x = f - (v * f - c); let T = p - (g * p - d); const w = e.showCells; const b = e.showAltCells; const S = e.showOutline; let E = 0; let A = 0; let C = 0; let _ = 0; let M = 0; if (S && (m--, y--, x === f && x--, T === p && T--), t.pipelines.preBatch(e), w && e.fillAlpha > 0) for (h = o.fillTint, l = n.getTintAppendFloatAlpha(e.fillColor, e.fillAlpha * u), h.TL = l, h.TR = l, h.BL = l, h.BR = l, A = 0; A < g; A++) for (b && (C = A % 2), E = 0; E < v; E++)b && C ? C = 0 : (C++, _ = E < v - 1 ? m : x, M = A < g - 1 ? y : T, o.batchFillRect(E * f, A * p, _, M)); if (b && e.altFillAlpha > 0) for (h = o.fillTint, l = n.getTintAppendFloatAlpha(e.altFillColor, e.altFillAlpha * u), h.TL = l, h.TR = l, h.BL = l, h.BR = l, A = 0; A < g; A++) for (b && (C = A % 2), E = 0; E < v; E++)!b || C ? (C = 0, _ = E < v - 1 ? m : x, M = A < g - 1 ? y : T, o.batchFillRect(E * f, A * p, _, M)) : C = 1; if (S && e.outlineFillAlpha > 0) { const P = o.strokeTint; const R = n.getTintAppendFloatAlpha(e.outlineFillColor, e.outlineFillAlpha * u); for (P.TL = R, P.TR = R, P.BL = R, P.BR = R, E = 1; E < v; E++) { const L = E * f; o.batchLine(L, 0, L, d, 1, 1, 1, 0, !1) } for (A = 1; A < g; A++) { const O = A * p; o.batchLine(0, O, c, O, 1, 1, 1, 0, !1) } } t.pipelines.postBatch(e) } }, 61475: (t, e, i) => { const s = i(99651); const n = i(83419); const r = i(17803); const o = new n({ Extends: r, Mixins: [s], initialize: function (t, e, i, s, n, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 48), void 0 === n && (n = 32), void 0 === o && (o = 15658734), void 0 === a && (a = 10066329), void 0 === h && (h = 13421772), r.call(this, t, 'IsoBox', null), this.projection = 4, this.fillTop = o, this.fillLeft = a, this.fillRight = h, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(e, i), this.setSize(s, n), this.updateDisplayOrigin() }, setProjection: function (t) { return this.projection = t, this }, setFaces: function (t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this }, setFillStyle: function (t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this } }); t.exports = o }, 11508: (t, e, i) => { const s = i(65960); const n = i(20926); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.currentContext; if (n(t, o, e, i, r) && e.isFilled) { const a = e.width; const h = e.height; const l = a / 2; const u = a / e.projection; e.showTop && (s(o, e, e.fillTop), o.beginPath(), o.moveTo(-l, -h), o.lineTo(0, -u - h), o.lineTo(l, -h), o.lineTo(l, -1), o.lineTo(0, u - 1), o.lineTo(-l, -1), o.lineTo(-l, -h), o.fill()), e.showLeft && (s(o, e, e.fillLeft), o.beginPath(), o.moveTo(-l, 0), o.lineTo(0, u), o.lineTo(0, u - h), o.lineTo(-l, -h), o.lineTo(-l, 0), o.fill()), e.showRight && (s(o, e, e.fillRight), o.beginPath(), o.moveTo(l, 0), o.lineTo(0, u), o.lineTo(0, u - h), o.lineTo(l, -h), o.lineTo(l, 0), o.fill()), o.restore() } } }, 3933: (t, e, i) => { const s = i(39429); const n = i(61475); s.register('isobox', function (t, e, i, s, r, o, a) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a)) }) }, 99651: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(68149), r = i(11508), t.exports = { renderWebGL: n, renderCanvas: r } }, 68149: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { i.addToRenderList(e); let o; let a; let h; let l; let u; let c; let d; let f; let p; const v = t.pipelines.set(e.pipeline); const g = s(e, i, r); const m = v.calcMatrix.copyFrom(g.calc); const y = e.width; const x = e.height; const T = y / 2; const w = y / e.projection; const b = i.alpha * e.alpha; e.isFilled && (t.pipelines.preBatch(e), e.showTop && (o = n.getTintAppendFloatAlpha(e.fillTop, b), a = m.getX(-T, -x), h = m.getY(-T, -x), l = m.getX(0, -w - x), u = m.getY(0, -w - x), c = m.getX(T, -x), d = m.getY(T, -x), f = m.getX(0, w - x), p = m.getY(0, w - x), v.batchQuad(e, a, h, l, u, c, d, f, p, 0, 0, 1, 1, o, o, o, o, 2)), e.showLeft && (o = n.getTintAppendFloatAlpha(e.fillLeft, b), a = m.getX(-T, 0), h = m.getY(-T, 0), l = m.getX(0, w), u = m.getY(0, w), c = m.getX(0, w - x), d = m.getY(0, w - x), f = m.getX(-T, -x), p = m.getY(-T, -x), v.batchQuad(e, a, h, l, u, c, d, f, p, 0, 0, 1, 1, o, o, o, o, 2)), e.showRight && (o = n.getTintAppendFloatAlpha(e.fillRight, b), a = m.getX(T, 0), h = m.getY(T, 0), l = m.getX(0, w), u = m.getY(0, w), c = m.getX(0, w - x), d = m.getY(0, w - x), f = m.getX(T, -x), p = m.getY(T, -x), v.batchQuad(e, a, h, l, u, c, d, f, p, 0, 0, 1, 1, o, o, o, o, 2)), t.pipelines.postBatch(e)) } }, 16933: (t, e, i) => { const s = i(83419); const n = i(60561); const r = i(17803); const o = new s({ Extends: r, Mixins: [n], initialize: function (t, e, i, s, n, o, a, h, l) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 48), void 0 === n && (n = 32), void 0 === o && (o = !1), void 0 === a && (a = 15658734), void 0 === h && (h = 10066329), void 0 === l && (l = 13421772), r.call(this, t, 'IsoTriangle', null), this.projection = 4, this.fillTop = a, this.fillLeft = h, this.fillRight = l, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = o, this.isFilled = !0, this.setPosition(e, i), this.setSize(s, n), this.updateDisplayOrigin() }, setProjection: function (t) { return this.projection = t, this }, setReversed: function (t) { return this.isReversed = t, this }, setFaces: function (t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this }, setFillStyle: function (t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this } }); t.exports = o }, 79590: (t, e, i) => { const s = i(65960); const n = i(20926); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.currentContext; if (n(t, o, e, i, r) && e.isFilled) { const a = e.width; const h = e.height; const l = a / 2; const u = a / e.projection; const c = e.isReversed; e.showTop && c && (s(o, e, e.fillTop), o.beginPath(), o.moveTo(-l, -h), o.lineTo(0, -u - h), o.lineTo(l, -h), o.lineTo(0, u - h), o.fill()), e.showLeft && (s(o, e, e.fillLeft), o.beginPath(), c ? (o.moveTo(-l, -h), o.lineTo(0, u), o.lineTo(0, u - h)) : (o.moveTo(-l, 0), o.lineTo(0, u), o.lineTo(0, u - h)), o.fill()), e.showRight && (s(o, e, e.fillRight), o.beginPath(), c ? (o.moveTo(l, -h), o.lineTo(0, u), o.lineTo(0, u - h)) : (o.moveTo(l, 0), o.lineTo(0, u), o.lineTo(0, u - h)), o.fill()), o.restore() } } }, 49803: (t, e, i) => { const s = i(39429); const n = i(16933); s.register('isotriangle', function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)) }) }, 60561: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(51503), r = i(79590), t.exports = { renderWebGL: n, renderCanvas: r } }, 51503: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.pipelines.set(e.pipeline); const a = s(e, i, r); const h = o.calcMatrix.copyFrom(a.calc); const l = e.width; const u = e.height; const c = l / 2; const d = l / e.projection; const f = e.isReversed; const p = i.alpha * e.alpha; if (e.isFilled) { let v, g, m, y, x, T, w; if (t.pipelines.preBatch(e), e.showTop && f) { v = n.getTintAppendFloatAlpha(e.fillTop, p), g = h.getX(-c, -u), m = h.getY(-c, -u), y = h.getX(0, -d - u), x = h.getY(0, -d - u), T = h.getX(c, -u), w = h.getY(c, -u); const b = h.getX(0, d - u); const S = h.getY(0, d - u); o.batchQuad(e, g, m, y, x, T, w, b, S, 0, 0, 1, 1, v, v, v, v, 2) } e.showLeft && (v = n.getTintAppendFloatAlpha(e.fillLeft, p), f ? (g = h.getX(-c, -u), m = h.getY(-c, -u), y = h.getX(0, d), x = h.getY(0, d), T = h.getX(0, d - u), w = h.getY(0, d - u)) : (g = h.getX(-c, 0), m = h.getY(-c, 0), y = h.getX(0, d), x = h.getY(0, d), T = h.getX(0, d - u), w = h.getY(0, d - u)), o.batchTri(e, g, m, y, x, T, w, 0, 0, 1, 1, v, v, v, 2)), e.showRight && (v = n.getTintAppendFloatAlpha(e.fillRight, p), f ? (g = h.getX(c, -u), m = h.getY(c, -u), y = h.getX(0, d), x = h.getY(0, d), T = h.getX(0, d - u), w = h.getY(0, d - u)) : (g = h.getX(c, 0), m = h.getY(c, 0), y = h.getX(0, d), x = h.getY(0, d), T = h.getX(0, d - u), w = h.getY(0, d - u)), o.batchTri(e, g, m, y, x, T, w, 0, 0, 1, 1, v, v, v, 2)), t.pipelines.postBatch(e) } } }, 57847: (t, e, i) => { const s = i(83419); const n = i(17803); const r = i(23031); const o = i(36823); const a = new s({ Extends: n, Mixins: [o], initialize: function (t, e, i, s, o, a, h, l, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === o && (o = 0), void 0 === a && (a = 128), void 0 === h && (h = 0), n.call(this, t, 'Line', new r(s, o, a, h)); const c = Math.max(1, this.geom.right - this.geom.left); const d = Math.max(1, this.geom.bottom - this.geom.top); this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(e, i), this.setSize(c, d), void 0 !== l && this.setStrokeStyle(1, l, u), this.updateDisplayOrigin() }, setLineWidth: function (t, e) { return void 0 === e && (e = t), this._startWidth = t, this._endWidth = e, this.lineWidth = t, this }, setTo: function (t, e, i, s) { return this.geom.setTo(t, e, i, s), this } }); t.exports = a }, 17440: (t, e, i) => { const s = i(75177); const n = i(20926); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.currentContext; if (n(t, o, e, i, r)) { const a = e._displayOriginX; const h = e._displayOriginY; e.isStroked && (s(o, e), o.beginPath(), o.moveTo(e.geom.x1 - a, e.geom.y1 - h), o.lineTo(e.geom.x2 - a, e.geom.y2 - h), o.stroke()), o.restore() } } }, 2481: (t, e, i) => { const s = i(39429); const n = i(57847); s.register('line', function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)) }) }, 36823: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(77385), r = i(17440), t.exports = { renderWebGL: n, renderCanvas: r } }, 77385: (t, e, i) => { const s = i(91296); const n = i(70554); t.exports = function (t, e, i, r) { i.addToRenderList(e); const o = t.pipelines.set(e.pipeline); const a = s(e, i, r); o.calcMatrix.copyFrom(a.calc); const h = e._displayOriginX; const l = e._displayOriginY; const u = i.alpha * e.alpha; if (t.pipelines.preBatch(e), e.isStroked) { const c = o.strokeTint; const d = n.getTintAppendFloatAlpha(e.strokeColor, e.strokeAlpha * u); c.TL = d, c.TR = d, c.BL = d, c.BR = d, o.batchLine(e.geom.x1 - h, e.geom.y1 - l, e.geom.x2 - h, e.geom.y2 - l, e._startWidth / 2, e._endWidth / 2, 1, 0, !1, a.sprite, a.camera) } t.pipelines.postBatch(e) } }, 24949: (t, e, i) => { const s = i(90273); const n = i(83419); const r = i(94811); const o = i(13829); const a = i(25717); const h = i(17803); const l = i(5469); const u = new n({ Extends: h, Mixins: [s], initialize: function (t, e, i, s, n, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Polygon', new a(s)); const l = o(this.geom); this.setPosition(e, i), this.setSize(l.width, l.height), void 0 !== n && this.setFillStyle(n, r), this.updateDisplayOrigin(), this.updateData() }, smooth: function (t) { void 0 === t && (t = 1); for (let e = 0; e < t; e++)l(this.geom); return this.updateData() }, setTo: function (t) { this.geom.setTo(t); const e = o(this.geom); return this.setSize(e.width, e.height), this.updateDisplayOrigin(), this.updateData() }, updateData: function () { for (var t = [], e = this.geom.points, i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = r(t), this.pathData = t, this } }); t.exports = u }, 38710: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX; const l = e._displayOriginY; const u = e.pathData; let c = u.length - 1; const d = u[0] - h; const f = u[1] - l; a.beginPath(), a.moveTo(d, f), e.closePath || (c -= 2); for (let p = 2; p < c; p += 2) { const v = u[p] - h; const g = u[p + 1] - l; a.lineTo(v, g) } e.closePath && a.closePath(), e.isFilled && (s(a, e), a.fill()), e.isStroked && (n(a, e), a.stroke()), a.restore() } } }, 64827: (t, e, i) => { const s = i(39429); const n = i(24949); s.register('polygon', function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)) }) }, 90273: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(73695), r = i(38710), t.exports = { renderWebGL: n, renderCanvas: r } }, 73695: (t, e, i) => { const s = i(10441); const n = i(91296); const r = i(34682); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = n(e, i, o); const l = a.calcMatrix.copyFrom(h.calc); const u = e._displayOriginX; const c = e._displayOriginY; const d = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && s(a, l, e, d, u, c), e.isStroked && r(a, e, d, u, c), t.pipelines.postBatch(e) } }, 74561: (t, e, i) => { const s = i(83419); const n = i(87841); const r = i(17803); const o = i(95597); const a = new s({ Extends: r, Mixins: [o], initialize: function (t, e, i, s, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 128), void 0 === o && (o = 128), r.call(this, t, 'Rectangle', new n(0, 0, s, o)), this.setPosition(e, i), this.setSize(s, o), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData() }, setSize: function (t, e) { this.width = t, this.height = e, this.geom.setSize(t, e), this.updateData(), this.updateDisplayOrigin(); const i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this }, updateData: function () { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), e.getLineD(i), t.push(i.x2, i.y2), this.pathData = t, this } }); t.exports = a }, 48682: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX; const l = e._displayOriginY; e.isFilled && (s(a, e), a.fillRect(-h, -l, e.width, e.height)), e.isStroked && (n(a, e), a.beginPath(), a.rect(-h, -l, e.width, e.height), a.stroke()), a.restore() } } }, 87959: (t, e, i) => { const s = i(39429); const n = i(74561); s.register('rectangle', function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)) }) }, 95597: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(52059), r = i(48682), t.exports = { renderWebGL: n, renderCanvas: r } }, 52059: (t, e, i) => { const s = i(91296); const n = i(34682); const r = i(70554); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = s(e, i, o); a.calcMatrix.copyFrom(h.calc); const l = e._displayOriginX; const u = e._displayOriginY; const c = i.alpha * e.alpha; if (t.pipelines.preBatch(e), e.isFilled) { const d = a.fillTint; const f = r.getTintAppendFloatAlpha(e.fillColor, e.fillAlpha * c); d.TL = f, d.TR = f, d.BL = f, d.BR = f, a.batchFillRect(-l, -u, e.width, e.height) } e.isStroked && n(a, e, c, l, u), t.pipelines.postBatch(e) } }, 55911: (t, e, i) => { const s = i(81991); const n = i(83419); const r = i(94811); const o = i(17803); const a = new n({ Extends: o, Mixins: [s], initialize: function (t, e, i, s, n, r, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 5), void 0 === n && (n = 32), void 0 === r && (r = 64), o.call(this, t, 'Star', null), this._points = s, this._innerRadius = n, this._outerRadius = r, this.setPosition(e, i), this.setSize(2 * r, 2 * r), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData() }, setPoints: function (t) { return this._points = t, this.updateData() }, setInnerRadius: function (t) { return this._innerRadius = t, this.updateData() }, setOuterRadius: function (t) { return this._outerRadius = t, this.updateData() }, points: { get: function () { return this._points }, set: function (t) { this._points = t, this.updateData() } }, innerRadius: { get: function () { return this._innerRadius }, set: function (t) { this._innerRadius = t, this.updateData() } }, outerRadius: { get: function () { return this._outerRadius }, set: function (t) { this._outerRadius = t, this.updateData() } }, updateData: function () { const t = []; const e = this._points; const i = this._innerRadius; const s = this._outerRadius; let n = Math.PI / 2 * 3; const o = Math.PI / e; const a = s; const h = s; t.push(a, h + -s); for (let l = 0; l < e; l++)t.push(a + Math.cos(n) * s, h + Math.sin(n) * s), n += o, t.push(a + Math.cos(n) * i, h + Math.sin(n) * i), n += o; return t.push(a, h + -s), this.pathIndexes = r(t), this.pathData = t, this } }); t.exports = a }, 64272: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX; const l = e._displayOriginY; const u = e.pathData; let c = u.length - 1; const d = u[0] - h; const f = u[1] - l; a.beginPath(), a.moveTo(d, f), e.closePath || (c -= 2); for (let p = 2; p < c; p += 2) { const v = u[p] - h; const g = u[p + 1] - l; a.lineTo(v, g) } a.closePath(), e.isFilled && (s(a, e), a.fill()), e.isStroked && (n(a, e), a.stroke()), a.restore() } } }, 93697: (t, e, i) => { const s = i(55911); i(39429).register('star', function (t, e, i, n, r, o, a) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a)) }) }, 81991: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(57017), r = i(64272), t.exports = { renderWebGL: n, renderCanvas: r } }, 57017: (t, e, i) => { const s = i(10441); const n = i(91296); const r = i(34682); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = n(e, i, o); const l = a.calcMatrix.copyFrom(h.calc); const u = e._displayOriginX; const c = e._displayOriginY; const d = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && s(a, l, e, d, u, c), e.isStroked && r(a, e, d, u, c), t.pipelines.postBatch(e) } }, 36931: (t, e, i) => { const s = i(83419); const n = i(17803); const r = i(16483); const o = i(96195); const a = new s({ Extends: n, Mixins: [o], initialize: function (t, e, i, s, o, a, h, l, u, c, d) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === o && (o = 128), void 0 === a && (a = 64), void 0 === h && (h = 0), void 0 === l && (l = 128), void 0 === u && (u = 128), n.call(this, t, 'Triangle', new r(s, o, a, h, l, u)); const f = this.geom.right - this.geom.left; const p = this.geom.bottom - this.geom.top; this.setPosition(e, i), this.setSize(f, p), void 0 !== c && this.setFillStyle(c, d), this.updateDisplayOrigin(), this.updateData() }, setTo: function (t, e, i, s, n, r) { return this.geom.setTo(t, e, i, s, n, r), this.updateData() }, updateData: function () { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), this.pathData = t, this } }); t.exports = a }, 85172: (t, e, i) => { const s = i(65960); const n = i(75177); const r = i(20926); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.currentContext; if (r(t, a, e, i, o)) { const h = e._displayOriginX; const l = e._displayOriginY; const u = e.geom.x1 - h; const c = e.geom.y1 - l; const d = e.geom.x2 - h; const f = e.geom.y2 - l; const p = e.geom.x3 - h; const v = e.geom.y3 - l; a.beginPath(), a.moveTo(u, c), a.lineTo(d, f), a.lineTo(p, v), a.closePath(), e.isFilled && (s(a, e), a.fill()), e.isStroked && (n(a, e), a.stroke()), a.restore() } } }, 45245: (t, e, i) => { const s = i(39429); const n = i(36931); s.register('triangle', function (t, e, i, s, r, o, a, h, l, u) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h, l, u)) }) }, 96195: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(83253), r = i(85172), t.exports = { renderWebGL: n, renderCanvas: r } }, 83253: (t, e, i) => { const s = i(91296); const n = i(34682); const r = i(70554); t.exports = function (t, e, i, o) { i.addToRenderList(e); const a = t.pipelines.set(e.pipeline); const h = s(e, i, o); a.calcMatrix.copyFrom(h.calc); const l = e._displayOriginX; const u = e._displayOriginY; const c = i.alpha * e.alpha; if (t.pipelines.preBatch(e), e.isFilled) { const d = a.fillTint; const f = r.getTintAppendFloatAlpha(e.fillColor, e.fillAlpha * c); d.TL = f, d.TR = f, d.BL = f, d.BR = f; const p = e.geom.x1 - l; const v = e.geom.y1 - u; const g = e.geom.x2 - l; const m = e.geom.y2 - u; const y = e.geom.x3 - l; const x = e.geom.y3 - u; a.batchFillTriangle(p, v, g, m, y, x, h.sprite, h.camera) } e.isStroked && n(a, e, c, l, u), t.pipelines.postBatch(e) } }, 68287: (t, e, i) => { const s = i(9674); const n = i(83419); const r = i(31401); const o = i(95643); const a = i(92751); const h = new n({ Extends: o, Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.PostPipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, a], initialize: function (t, e, i, n, r) { o.call(this, t, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new s(this), this.setTexture(n, r), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(!0) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, preUpdate: function (t, e) { this.anims.update(t, e) }, play: function (t, e) { return this.anims.play(t, e) }, playReverse: function (t, e) { return this.anims.playReverse(t, e) }, playAfterDelay: function (t, e) { return this.anims.playAfterDelay(t, e) }, playAfterRepeat: function (t, e) { return this.anims.playAfterRepeat(t, e) }, chain: function (t) { return this.anims.chain(t) }, stop: function () { return this.anims.stop() }, stopAfterDelay: function (t) { return this.anims.stopAfterDelay(t) }, stopAfterRepeat: function (t) { return this.anims.stopAfterRepeat(t) }, stopOnFrame: function (t) { return this.anims.stopOnFrame(t) }, toJSON: function () { return r.ToJSON(this) }, preDestroy: function () { this.anims.destroy(), this.anims = void 0 } }); t.exports = h }, 76552: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e), t.batchSprite(e, e.frame, i, s) } }, 15567: (t, e, i) => { const s = i(25305); const n = i(13059); const r = i(44603); const o = i(23568); const a = i(68287); r.register('sprite', function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), s(this.scene, h, t), n(h, t), h }) }, 46409: (t, e, i) => { const s = i(39429); const n = i(68287); s.register('sprite', function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)) }) }, 92751: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(9409), r = i(76552), t.exports = { renderWebGL: n, renderCanvas: r } }, 9409: t => { t.exports = function (t, e, i, s) { i.addToRenderList(e), e.pipeline.batchSprite(e, i, s) } }, 14220: t => { t.exports = function (t, e, i) { const s = t.canvas; const n = t.context; const r = t.style; const o = []; let a = 0; let h = i.length; r.maxLines > 0 && r.maxLines < i.length && (h = r.maxLines), r.syncFont(s, n); for (let l = 0; l < h; l++) { let u = r.strokeThickness; u += n.measureText(i[l]).width, i[l].length > 1 && (u += t.letterSpacing * (i[l].length - 1)), r.wordWrap && (u -= n.measureText(' ').width), o[l] = Math.ceil(u), a = Math.max(a, o[l]) } const c = e.fontSize + r.strokeThickness; let d = c * h; const f = t.lineSpacing; return h > 1 && (d += f * (h - 1)), { width: a, height: d, lines: h, lineWidths: o, lineSpacing: f, lineHeight: c } } }, 79557: (t, e, i) => { const s = i(27919); t.exports = function (t) { const e = s.create(this); const i = e.getContext('2d', { willReadFrequently: !0 }); t.syncFont(e, i); const n = i.measureText(t.testString); if ('actualBoundingBoxAscent' in n) { const r = n.actualBoundingBoxAscent; const o = n.actualBoundingBoxDescent; return s.remove(e), { ascent: r, descent: o, fontSize: r + o } } const a = Math.ceil(n.width * t.baselineX); let h = a; const l = 2 * h; h = h * t.baselineY | 0, e.width = a, e.height = l, i.fillStyle = '#f00', i.fillRect(0, 0, a, l), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, h); const u = { ascent: 0, descent: 0, fontSize: 0 }; const c = i.getImageData(0, 0, a, l); if (!c) return u.ascent = h, u.descent = h + 6, u.fontSize = u.ascent + u.descent, s.remove(e), u; let d; let f; const p = c.data; const v = p.length; const g = 4 * a; let m = 0; let y = !1; for (d = 0; d < h; d++) { for (f = 0; f < g; f += 4) if (p[m + f] !== 255) { y = !0; break } if (y) break; m += g } for (u.ascent = h - d, m = v - g, y = !1, d = l; d > h; d--) { for (f = 0; f < g; f += 4) if (p[m + f] !== 255) { y = !0; break } if (y) break; m -= g } return u.descent = d - h, u.fontSize = u.ascent + u.descent, s.remove(e), u } }, 50171: (t, e, i) => { const s = i(40366); const n = i(27919); const r = i(83419); const o = i(31401); const a = i(95643); const h = i(14220); const l = i(35154); const u = i(35846); const c = i(61771); const d = i(35762); const f = i(45650); const p = new r({ Extends: a, Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.PostPipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, c], initialize: function (t, e, i, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, 'Text'), this.renderer = t.sys.renderer, this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.initPostPipeline(!0), this.canvas = n.create(this), this.context, this.style = new d(this, r), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = { left: 0, right: 0, top: 0, bottom: 0 }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.letterSpacing = 0, this.style.resolution === 0 && (this.style.resolution = 1), this._crop = this.resetCropObject(), this._textureKey = f(), this.texture = t.sys.textures.addCanvas(this._textureKey, this.canvas), this.context = this.texture.context, this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(s), r && r.padding && this.setPadding(r.padding), r && r.lineSpacing && this.setLineSpacing(r.lineSpacing) }, initRTL: function () { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', s(this.canvas, this.scene.sys.canvas), this.originX = 1) }, runWordWrap: function (t) { const e = this.style; if (e.wordWrapCallback) { let i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this); return Array.isArray(i) && (i = i.join('\n')), i } return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t }, advancedWordWrap: function (t, e, i) { for (var s = '', n = t.replace(/ +/gi, ' ').split(this.splitRegExp), r = n.length, o = 0; o < r; o++) { let a = n[o]; let h = ''; if (a = a.replace(/^ *|\s*$/gi, ''), e.measureText(a).width < i) s += a + '\n'; else { for (let l = i, u = a.split(' '), c = 0; c < u.length; c++) { const d = u[c]; const f = d + ' '; let p = e.measureText(f).width; if (p > l) { if (c === 0) { for (var v = f; v.length && (v = v.slice(0, -1), !((p = e.measureText(v).width) <= l));); if (!v.length) throw new Error('wordWrapWidth < a single character'); const g = d.substr(v.length); u[c] = g, h += v } const m = u[c].length ? c : c + 1; const y = u.slice(m).join(' ').replace(/[ \n]*$/gi, ''); n.splice(o + 1, 0, y), r = n.length; break } h += f, l -= p } s += h.replace(/[ \n]*$/gi, '') + '\n' } } return s = s.replace(/[\s|\n]*$/gi, '') }, basicWordWrap: function (t, e, i) { for (var s = '', n = t.split(this.splitRegExp), r = n.length - 1, o = e.measureText(' ').width, a = 0; a <= r; a++) { for (let h = i, l = n[a].split(' '), u = l.length - 1, c = 0; c <= u; c++) { const d = l[c]; const f = e.measureText(d).width; let p = f; c < u && (p += o), p > h && c > 0 && (s += '\n', h = i), s += d, c < u ? (s += ' ', h -= p) : h -= f } a < r && (s += '\n') } return s }, getWrappedText: function (t) { return void 0 === t && (t = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp) }, setText: function (t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this._text && (this._text = t.toString(), this.updateText()), this }, appendText: function (t, e) { void 0 === e && (e = !0), t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t = t.toString(); const i = this._text.concat(e ? '\n' + t : t); return i !== this._text && (this._text = i, this.updateText()), this }, setStyle: function (t) { return this.style.setStyle(t) }, setFont: function (t) { return this.style.setFont(t) }, setFontFamily: function (t) { return this.style.setFontFamily(t) }, setFontSize: function (t) { return this.style.setFontSize(t) }, setFontStyle: function (t) { return this.style.setFontStyle(t) }, setFixedSize: function (t, e) { return this.style.setFixedSize(t, e) }, setBackgroundColor: function (t) { return this.style.setBackgroundColor(t) }, setFill: function (t) { return this.style.setFill(t) }, setColor: function (t) { return this.style.setColor(t) }, setStroke: function (t, e) { return this.style.setStroke(t, e) }, setShadow: function (t, e, i, s, n, r) { return this.style.setShadow(t, e, i, s, n, r) }, setShadowOffset: function (t, e) { return this.style.setShadowOffset(t, e) }, setShadowColor: function (t) { return this.style.setShadowColor(t) }, setShadowBlur: function (t) { return this.style.setShadowBlur(t) }, setShadowStroke: function (t) { return this.style.setShadowStroke(t) }, setShadowFill: function (t) { return this.style.setShadowFill(t) }, setWordWrapWidth: function (t, e) { return this.style.setWordWrapWidth(t, e) }, setWordWrapCallback: function (t, e) { return this.style.setWordWrapCallback(t, e) }, setAlign: function (t) { return this.style.setAlign(t) }, setResolution: function (t) { return this.style.setResolution(t) }, setLineSpacing: function (t) { return this.lineSpacing = t, this.updateText() }, setLetterSpacing: function (t) { return this.letterSpacing = t, this.updateText() }, setPadding: function (t, e, i, s) { if (typeof t === 'object') { const n = t; const r = l(n, 'x', null); r !== null ? (t = r, i = r) : (t = l(n, 'left', 0), i = l(n, 'right', t)); const o = l(n, 'y', null); o !== null ? (e = o, s = o) : (e = l(n, 'top', 0), s = l(n, 'bottom', e)) } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === s && (s = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = s, this.updateText() }, setMaxLines: function (t) { return this.style.setMaxLines(t) }, setRTL: function (t) { void 0 === t && (t = !0); const e = this.style; return e.rtl === t || (e.rtl = t, t ? (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', s(this.canvas, this.scene.sys.canvas)) : (this.canvas.dir = 'ltr', this.context.direction = 'ltr'), e.align === 'left' ? e.align = 'right' : e.align === 'right' && (e.align = 'left')), this }, updateText: function () { const t = this.canvas; const e = this.context; const i = this.style; const s = i.resolution; const n = i.metrics; i.syncFont(t, e); let r = this._text; (i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this._text)); let o; const a = r.split(this.splitRegExp); const l = h(this, n, a); const u = this.padding; i.fixedWidth === 0 ? (this.width = l.width + u.left + u.right, o = l.width) : (this.width = i.fixedWidth, (o = this.width - u.left - u.right) < l.width && (o = l.width)), i.fixedHeight === 0 ? this.height = l.height + u.top + u.bottom : this.height = i.fixedHeight; let c; let d; let f = this.width; let p = this.height; this.updateDisplayOrigin(), f *= s, p *= s, f = Math.max(f, 1), p = Math.max(p, 1), t.width !== f || t.height !== p ? (t.width = f, t.height = p, this.frame.setSize(f, p), i.syncFont(t, e), i.rtl && (e.direction = 'rtl')) : e.clearRect(0, 0, f, p), e.save(), e.scale(s, s), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, f, p)), i.syncStyle(t, e), e.translate(u.left, u.top); for (let v = 0; v < l.lines; v++) { if (c = i.strokeThickness / 2, d = i.strokeThickness / 2 + v * l.lineHeight + n.ascent, v > 0 && (d += l.lineSpacing * v), i.rtl) c = f - c - u.left - u.right; else if (i.align === 'right') c += o - l.lineWidths[v]; else if (i.align === 'center') c += (o - l.lineWidths[v]) / 2; else if (i.align === 'justify') { if (l.lineWidths[v] / l.width >= 0.85) { let g = l.width - l.lineWidths[v]; const m = e.measureText(' ').width; const y = a[v].trim(); const x = y.split(' '); g += (a[v].length - y.length) * m; for (let T = Math.floor(g / m), w = 0; T > 0;)x[w] += ' ', w = (w + 1) % (x.length - 1 || 1), --T; a[v] = x.join(' ') } } if (this.autoRound && (c = Math.round(c), d = Math.round(d)), i.strokeThickness && (i.syncShadow(e, i.shadowStroke), e.strokeText(a[v], c, d)), i.color) { i.syncShadow(e, i.shadowFill); const b = this.letterSpacing; if (b !== 0) for (let S = 0, E = a[v].split(''), A = 0; A < E.length; A++)e.fillText(E[A], c + S, d), S += e.measureText(E[A]).width + b; else e.fillText(a[v], c, d) } } e.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(t, this.frame.source.glTexture, !0)); const C = this.input; return C && !C.customHitArea && (C.hitArea.width = this.width, C.hitArea.height = this.height), this }, getTextMetrics: function () { return this.style.getTextMetrics() }, text: { get: function () { return this._text }, set: function (t) { this.setText(t) } }, toJSON: function () { const t = o.ToJSON(this); const e = { autoRound: this.autoRound, text: this._text, style: this.style.toJSON(), padding: { left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom } }; return t.data = e, t }, preDestroy: function () { u(this.canvas), n.remove(this.canvas); const t = this.texture; t && t.destroy() } }); t.exports = p }, 79724: t => { t.exports = function (t, e, i, s) { e.width !== 0 && e.height !== 0 && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, s)) } }, 71259: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(50171); n.register('text', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'text', ''); const n = r(t, 'style', null); const a = r(t, 'padding', null); a !== null && (n.padding = a); const h = new o(this.scene, 0, 0, i, n); return void 0 !== e && (t.add = e), s(this.scene, h, t), h.autoRound = r(t, 'autoRound', !0), h.resolution = r(t, 'resolution', 1), h }) }, 68005: (t, e, i) => { const s = i(50171); i(39429).register('text', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)) }) }, 61771: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(34397), r = i(79724), t.exports = { renderWebGL: n, renderCanvas: r } }, 35762: (t, e, i) => { const s = i(83419); const n = i(23568); const r = i(35154); const o = i(79557); const a = { fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], rtl: ['rtl', !1], testString: ['testString', '|Mqgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1] }; const h = new s({ initialize: function (t, e) { this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this.wordWrapWidth, this.wordWrapCallback, this.wordWrapCallbackScope, this.wordWrapUseAdvanced, this._font, this.setStyle(e, !1, !0) }, setStyle: function (t, e, i) { for (const s in void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = t.fontSize.toString() + 'px'), a) { const h = i ? a[s][1] : this[s]; this[s] = s === 'wordWrapCallback' || s === 'wordWrapCallbackScope' ? r(t, a[s][0], h) : n(t, a[s][0], h) } const l = r(t, 'font', null); l !== null && this.setFont(l, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(); const u = r(t, 'fill', null); u !== null && (this.color = u); const c = r(t, 'metrics', !1); return c ? this.metrics = { ascent: r(c, 'ascent', 0), descent: r(c, 'descent', 0), fontSize: r(c, 'fontSize', 0) } : !e && this.metrics || (this.metrics = o(this)), e ? this.parent.updateText() : this.parent }, syncFont: function (t, e) { e.font = this._font }, syncStyle: function (t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round' }, syncShadow: function (t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0) }, update: function (t) { return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(), this.metrics = o(this)), this.parent.updateText() }, setFont: function (t, e) { void 0 === e && (e = !0); let i = t; let s = ''; let n = ''; if (typeof t !== 'string') i = r(t, 'fontFamily', 'Courier'), s = r(t, 'fontSize', '16px'), n = r(t, 'fontStyle', ''); else { const o = t.split(' '); let a = 0; n = o.length > 2 ? o[a++] : '', s = o[a++] || '16px', i = o[a++] || 'Courier' } return i === this.fontFamily && s === this.fontSize && n === this.fontStyle || (this.fontFamily = i, this.fontSize = s, this.fontStyle = n, e && this.update(!0)), this.parent }, setFontFamily: function (t) { return this.fontFamily !== t && (this.fontFamily = t, this.update(!0)), this.parent }, setFontStyle: function (t) { return this.fontStyle !== t && (this.fontStyle = t, this.update(!0)), this.parent }, setFontSize: function (t) { return typeof t === 'number' && (t = t.toString() + 'px'), this.fontSize !== t && (this.fontSize = t, this.update(!0)), this.parent }, setTestString: function (t) { return this.testString = t, this.update(!0) }, setFixedSize: function (t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1) }, setBackgroundColor: function (t) { return this.backgroundColor = t, this.update(!1) }, setFill: function (t) { return this.color = t, this.update(!1) }, setColor: function (t) { return this.color = t, this.update(!1) }, setResolution: function (t) { return this.resolution = t, this.update(!1) }, setStroke: function (t, e) { return void 0 === e && (e = this.strokeThickness), void 0 === t && this.strokeThickness !== 0 ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === t && this.strokeThickness === e || (this.stroke = t, this.strokeThickness = e, this.update(!0)), this.parent }, setShadow: function (t, e, i, s, n, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === s && (s = 0), void 0 === n && (n = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = s, this.shadowStroke = n, this.shadowFill = r, this.update(!1) }, setShadowOffset: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1) }, setShadowColor: function (t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1) }, setShadowBlur: function (t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1) }, setShadowStroke: function (t) { return this.shadowStroke = t, this.update(!1) }, setShadowFill: function (t) { return this.shadowFill = t, this.update(!1) }, setWordWrapWidth: function (t, e) { return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1) }, setWordWrapCallback: function (t, e) { return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1) }, setAlign: function (t) { return void 0 === t && (t = 'left'), this.align = t, this.update(!1) }, setMaxLines: function (t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1) }, getTextMetrics: function () { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize } }, toJSON: function () { const t = {}; for (const e in a) t[e] = this[e]; return t.metrics = this.getTextMetrics(), t }, destroy: function () { this.parent = void 0 } }); t.exports = h }, 34397: (t, e, i) => { const s = i(70554); t.exports = function (t, e, i, n) { if (e.width !== 0 && e.height !== 0) { i.addToRenderList(e); const r = e.frame; const o = r.width; const a = r.height; const h = s.getTintAppendFloatAlpha; const l = t.pipelines.set(e.pipeline, e); const u = l.setTexture2D(r.glTexture, e); l.batchTexture(e, r.glTexture, o, a, e.x, e.y, o / e.style.resolution, a / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, o, a, h(e.tintTopLeft, i.alpha * e._alphaTL), h(e.tintTopRight, i.alpha * e._alphaTR), h(e.tintBottomLeft, i.alpha * e._alphaBL), h(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, 0, 0, i, n, !1, u) } } }, 20839: (t, e, i) => { const s = i(27919); const n = i(83419); const r = i(31401); const o = i(95643); const a = i(98439); const h = i(68703); const l = i(56295); const u = i(45650); const c = i(26099); const d = new n({ Extends: o, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.PostPipeline, r.ScrollFactor, r.Tint, r.Transform, r.Visible, l], initialize: function (t, e, i, n, r, h, l) { const d = t.sys.renderer; o.call(this, t, 'TileSprite'); let f = t.sys.textures.get(h); let p = f.get(l); p.source.compressionAlgorithm && (console.warn('TileSprite cannot use compressed texture'), p = (f = t.sys.textures.get('__MISSING')).get()), f.type === 'DynamicTexture' && (console.warn('TileSprite cannot use Dynamic Texture'), p = (f = t.sys.textures.get('__MISSING')).get()), n && r ? (n = Math.floor(n), r = Math.floor(r)) : (n = p.width, r = p.height), this._tilePosition = new c(), this._tileScale = new c(1, 1), this.dirty = !1, this.renderer = d, this.canvas = s.create(this, n, r), this.context = this.canvas.getContext('2d', { willReadFrequently: !1 }), this.displayTexture = f, this.displayFrame = p, this._crop = this.resetCropObject(), this._textureKey = u(), this.texture = t.sys.textures.addCanvas(this._textureKey, this.canvas), this.frame = this.texture.get(), this.potWidth = a(p.width), this.potHeight = a(p.height), this.fillCanvas = s.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext('2d', { willReadFrequently: !1 }), this.fillPattern = null, this.setPosition(e, i), this.setSize(n, r), this.setFrame(l), this.setOriginFromFrame(), this.initPipeline(), this.initPostPipeline(!0) }, setTexture: function (t, e) { return this.displayTexture = this.scene.sys.textures.get(t), this.setFrame(e) }, setFrame: function (t) { const e = this.displayTexture.get(t); return this.potWidth = a(e.width), this.potHeight = a(e.height), this.canvas.width = 0, e.cutWidth && e.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.displayFrame = e, this.dirty = !0, this.updateTileTexture(), this }, setTilePosition: function (t, e) { return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this }, setTileScale: function (t, e) { return void 0 === t && (t = this.tileScaleX), void 0 === e && (e = t), this.tileScaleX = t, this.tileScaleY = e, this }, updateTileTexture: function () { if (this.dirty && this.renderer) { const t = this.displayFrame; if (t.source.isRenderTexture || t.source.isGLTexture) return console.warn('TileSprites can only use Image or Canvas based textures'), void (this.dirty = !1); const e = this.fillContext; const i = this.fillCanvas; let s = this.potWidth; let n = this.potHeight; this.renderer && this.renderer.gl || (s = t.cutWidth, n = t.cutHeight), e.clearRect(0, 0, s, n), i.width = s, i.height = n, e.drawImage(t.source.image, t.cutX, t.cutY, t.cutWidth, t.cutHeight, 0, 0, s, n), this.renderer && this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(i, this.fillPattern) : this.fillPattern = e.createPattern(i, 'repeat'), this.updateCanvas(), this.dirty = !1 } }, updateCanvas: function () { const t = this.canvas; if (t.width === this.width && t.height === this.height || (t.width = this.width, t.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl) this.dirty = !1; else { const e = this.context; this.scene.sys.game.config.antialias || h.disable(e); const i = this._tileScale.x; const s = this._tileScale.y; const n = this._tilePosition.x; const r = this._tilePosition.y; e.clearRect(0, 0, this.width, this.height), e.save(), e.scale(i, s), e.translate(-n, -r), e.fillStyle = this.fillPattern, e.fillRect(n, r, this.width / i, this.height / s), e.restore(), this.dirty = !1 } }, preDestroy: function () { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), s.remove(this.canvas), s.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null; const t = this.texture; t && t.destroy(), this.renderer = null }, tilePositionX: { get: function () { return this._tilePosition.x }, set: function (t) { this._tilePosition.x = t, this.dirty = !0 } }, tilePositionY: { get: function () { return this._tilePosition.y }, set: function (t) { this._tilePosition.y = t, this.dirty = !0 } }, tileScaleX: { get: function () { return this._tileScale.x }, set: function (t) { this._tileScale.x = t, this.dirty = !0 } }, tileScaleY: { get: function () { return this._tileScale.y }, set: function (t) { this._tileScale.y = t, this.dirty = !0 } } }); t.exports = d }, 46992: t => { t.exports = function (t, e, i, s) { e.updateCanvas(), i.addToRenderList(e), t.batchSprite(e, e.frame, i, s) } }, 14167: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(20839); n.register('tileSprite', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const n = r(t, 'y', 0); const a = r(t, 'width', 512); const h = r(t, 'height', 512); const l = r(t, 'key', ''); const u = r(t, 'frame', ''); const c = new o(this.scene, i, n, a, h, l, u); return void 0 !== e && (t.add = e), s(this.scene, c, t), c }) }, 91681: (t, e, i) => { const s = i(20839); i(39429).register('tileSprite', function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)) }) }, 56295: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(18553), r = i(46992), t.exports = { renderWebGL: n, renderCanvas: r } }, 18553: (t, e, i) => { const s = i(70554); t.exports = function (t, e, i, n) { e.updateCanvas(); const r = e.width; const o = e.height; if (r !== 0 && o !== 0) { i.addToRenderList(e); const a = s.getTintAppendFloatAlpha; const h = t.pipelines.set(e.pipeline, e); const l = h.setTexture2D(e.fillPattern, e); h.batchTexture(e, e.fillPattern, e.displayFrame.width * e.tileScaleX, e.displayFrame.height * e.tileScaleY, e.x, e.y, r, o, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.originX * r, e.originY * o, 0, 0, r, o, a(e.tintTopLeft, i.alpha * e._alphaTL), a(e.tintTopRight, i.alpha * e._alphaTR), a(e.tintBottomLeft, i.alpha * e._alphaBL), a(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, e.tilePositionX % e.displayFrame.width / e.displayFrame.width, e.tilePositionY % e.displayFrame.height / e.displayFrame.height, i, n, !1, l) } } }, 18471: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(31401); const o = i(51708); const a = i(8443); const h = i(95643); const l = i(36383); const u = i(14463); const c = i(45650); const d = i(10247); const f = new n({ Extends: h, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.PostPipeline, r.ScrollFactor, r.TextureCrop, r.Tint, r.Transform, r.Visible, d], initialize: function (t, e, i, s) { h.call(this, t, 'Video'), this.video, this.videoTexture, this.videoTextureSource, this.snapshotTexture, this.flipY = !1, this._key = c(), this.touchLocked = !1, this.playWhenUnlocked = !1, this.frameReady = !1, this.isStalled = !1, this.failedPlayAttempts = 0, this.metadata, this.retry = 0, this.retryInterval = 500, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = { ended: this.completeHandler.bind(this), legacy: this.legacyPlayHandler.bind(this), playing: this.playingHandler.bind(this), seeked: this.seekedHandler.bind(this), seeking: this.seekingHandler.bind(this), stalled: this.stalledHandler.bind(this), suspend: this.stalledHandler.bind(this), waiting: this.stalledHandler.bind(this) }, this._loadCallbackHandler = this.loadErrorHandler.bind(this), this._metadataCallbackHandler = this.metadataHandler.bind(this), this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = 0, this._markerOut = 0, this._playingMarker = !1, this._lastUpdate = 0, this.cacheKey = '', this.isSeeking = !1, this._playCalled = !1, this._rfvCallbackId = 0; const n = t.sys.game; this._device = n.device.video, this.setPosition(e, i), this.setSize(256, 256), this.initPipeline(), this.initPostPipeline(!0), n.events.on(a.PAUSE, this.globalPause, this), n.events.on(a.RESUME, this.globalResume, this); const r = t.sys.sound; r && r.on(u.GLOBAL_MUTE, this.globalMute, this), s && this.load(s) }, addedToScene: function () { this.scene.sys.updateList.add(this) }, removedFromScene: function () { this.scene.sys.updateList.remove(this) }, load: function (t) { const e = this.scene.sys.cache.video.get(t); return e ? (this.cacheKey = t, this.loadHandler(e.url, e.noAudio, e.crossOrigin)) : console.warn('No video in cache for key: ' + t), this }, changeSource: function (t, e, i, s, n) { void 0 === e && (e = !0), void 0 === i && (i = !1), this.cacheKey !== t && (this.load(t), e && this.play(i, s, n)) }, getVideoKey: function () { return this.cacheKey }, loadURL: function (t, e, i) { void 0 === e && (e = !1); const s = this._device.getVideoURL(t); return s ? (this.cacheKey = '', this.loadHandler(s.url, e, i)) : console.warn('No supported video format found for ' + t), this }, loadMediaStream: function (t, e, i) { return this.loadHandler(null, e, i, t) }, loadHandler: function (t, e, i, s) { e || (e = !1); let n = this.video; if (n ? (this.removeLoadEventHandlers(), this.stop()) : ((n = document.createElement('video')).controls = !1, n.setAttribute('playsinline', 'playsinline'), n.setAttribute('preload', 'auto'), n.setAttribute('disablePictureInPicture', 'true')), e ? (n.muted = !0, n.defaultMuted = !0, n.setAttribute('autoplay', 'autoplay')) : (n.muted = !1, n.defaultMuted = !1, n.removeAttribute('autoplay')), i ? n.setAttribute('crossorigin', i) : n.removeAttribute('crossorigin'), s) if ('srcObject' in n) try { n.srcObject = s } catch (t) { if (t.name !== 'TypeError') throw t; n.src = URL.createObjectURL(s) } else n.src = URL.createObjectURL(s); else n.src = t; this.retry = 0, this.video = n, this._playCalled = !1, n.load(), this.addLoadEventHandlers(); const r = this.scene.sys.textures.get(this._key); return this.setTexture(r), this }, requestVideoFrame: function (t, e) { const i = this.video; if (i) { const s = e.width; const n = e.height; let r = this.videoTexture; const a = this.videoTextureSource; const h = !r || a.source !== i; h ? (this._codePaused = i.paused, this._codeMuted = i.muted, r ? (a.source = i, a.width = s, a.height = n, r.get().setSize(s, n)) : ((r = this.scene.sys.textures.create(this._key, i, s, n)).add('__BASE', 0, 0, 0, s, n), this.setTexture(r), this.videoTexture = r, this.videoTextureSource = r.source[0], this.videoTextureSource.setFlipY(this.flipY), this.emit(o.VIDEO_TEXTURE, this, r)), this.setSizeToFrame(), this.updateDisplayOrigin()) : a.update(), this.isStalled = !1, this.metadata = e; const l = e.mediaTime; h && (this._lastUpdate = l, this.emit(o.VIDEO_CREATED, this, s, n), this.frameReady || (this.frameReady = !0, this.emit(o.VIDEO_PLAY, this))), this._playingMarker ? l >= this._markerOut && (i.loop ? (i.currentTime = this._markerIn, this.emit(o.VIDEO_LOOP, this)) : (this.stop(!1), this.emit(o.VIDEO_COMPLETE, this))) : l < this._lastUpdate && this.emit(o.VIDEO_LOOP, this), this._lastUpdate = l, this._rfvCallbackId = this.video.requestVideoFrameCallback(this.requestVideoFrame.bind(this)) } }, play: function (t, e, i) { void 0 === e && (e = -1), void 0 === i && (i = l.MAX_SAFE_INTEGER); const s = this.video; return !s || this.isPlaying() ? (s || console.warn('Video not loaded'), this) : (void 0 === t && (t = s.loop), s.loop = t, this._markerIn = e, this._markerOut = i, this._playingMarker = e > -1 && i > e && i < l.MAX_SAFE_INTEGER, this._playCalled || (this._rfvCallbackId = s.requestVideoFrameCallback(this.requestVideoFrame.bind(this)), this._playCalled = !0, this.createPlayPromise()), this) }, addLoadEventHandlers: function () { const t = this.video; t && (t.addEventListener('error', this._loadCallbackHandler), t.addEventListener('abort', this._loadCallbackHandler), t.addEventListener('loadedmetadata', this._metadataCallbackHandler)) }, removeLoadEventHandlers: function () { const t = this.video; t && (t.removeEventListener('error', this._loadCallbackHandler), t.removeEventListener('abort', this._loadCallbackHandler)) }, addEventHandlers: function () { const t = this.video; if (t) { const e = this._callbacks; for (const i in e) t.addEventListener(i, e[i]) } }, removeEventHandlers: function () { const t = this.video; if (t) { const e = this._callbacks; for (const i in e) t.removeEventListener(i, e[i]) } }, createPlayPromise: function (t) { void 0 === t && (t = !0); const e = this.video; const i = e.play(); if (void 0 !== i) { const s = this.playSuccess.bind(this); let n = this.playError.bind(this); if (!t) { const r = this; n = function () { r.failedPlayAttempts++ } } i.then(s).catch(n) } else e.addEventListener('playing', this._callbacks.legacy), t || this.failedPlayAttempts++ }, addMarker: function (t, e, i) { return !isNaN(e) && e >= 0 && !isNaN(i) && i > e && (this.markers[t] = [e, i]), this }, playMarker: function (t, e) { const i = this.markers[t]; return i && this.play(e, i[0], i[1]), this }, removeMarker: function (t) { return delete this.markers[t], this }, snapshot: function (t, e) { return void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.snapshotArea(0, 0, this.width, this.height, t, e) }, snapshotArea: function (t, e, i, s, n, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), void 0 === n && (n = i), void 0 === r && (r = s); const o = this.video; let a = this.snapshotTexture; return a ? (a.setSize(n, r), o && a.context.drawImage(o, t, e, i, s, 0, 0, n, r)) : (a = this.scene.sys.textures.createCanvas(c(), n, r), this.snapshotTexture = a, o && a.context.drawImage(o, t, e, i, s, 0, 0, n, r)), a.update() }, saveSnapshotTexture: function (t) { return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, t) : this.snapshotTexture = this.scene.sys.textures.createCanvas(t, this.width, this.height), this.snapshotTexture }, playSuccess: function () { if (this._playCalled) { this.addEventHandlers(), this._codePaused = !1, this.touchLocked && (this.touchLocked = !1, this.emit(o.VIDEO_UNLOCKED, this)); const t = this.scene.sys.sound; t && t.mute && this.setMute(!0), this._markerIn > -1 && (this.video.currentTime = this._markerIn) } }, playError: function (t) { const e = t.name; e === 'NotAllowedError' ? (this.touchLocked = !0, this.playWhenUnlocked = !0, this.failedPlayAttempts = 1, this.emit(o.VIDEO_LOCKED, this)) : e === 'NotSupportedError' ? (this.stop(!1), this.emit(o.VIDEO_UNSUPPORTED, this, t)) : (this.stop(!1), this.emit(o.VIDEO_ERROR, this, t)) }, legacyPlayHandler: function () { const t = this.video; t && (this.playSuccess(), t.removeEventListener('playing', this._callbacks.legacy)) }, playingHandler: function () { this.isStalled = !1, this.emit(o.VIDEO_PLAYING, this) }, loadErrorHandler: function (t) { this.stop(!1), this.emit(o.VIDEO_ERROR, this, t) }, metadataHandler: function (t) { this.emit(o.VIDEO_METADATA, this, t) }, setSizeToFrame: function (t) { t || (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this.scaleX !== 1 && (this.scaleX = this.displayWidth / this.width), this.scaleY !== 1 && (this.scaleY = this.displayHeight / this.height); const e = this.input; return e && !e.customHitArea && (e.hitArea.width = this.width, e.hitArea.height = this.height), this }, stalledHandler: function (t) { this.isStalled = !0, this.emit(o.VIDEO_STALLED, this, t) }, completeHandler: function () { this._playCalled = !1, this.emit(o.VIDEO_COMPLETE, this) }, preUpdate: function (t, e) { this.video && this._playCalled && this.touchLocked && this.playWhenUnlocked && (this.retry += e, this.retry >= this.retryInterval && (this.createPlayPromise(!1), this.retry = 0)) }, seekTo: function (t) { const e = this.video; if (e) { const i = e.duration; if (i !== 1 / 0 && !isNaN(i)) { const s = i * t; this.setCurrentTime(s) } } return this }, getCurrentTime: function () { return this.video ? this.video.currentTime : 0 }, setCurrentTime: function (t) { const e = this.video; if (e) { if (typeof t === 'string') { const i = t[0]; const s = parseFloat(t.substr(1)); i === '+' ? t = e.currentTime + s : i === '-' && (t = e.currentTime - s) } e.currentTime = t } return this }, seekingHandler: function () { this.isSeeking = !0, this.emit(o.VIDEO_SEEKING, this) }, seekedHandler: function () { this.isSeeking = !1, this.emit(o.VIDEO_SEEKED, this) }, getProgress: function () { const t = this.video; if (t) { const e = t.duration; if (e !== 1 / 0 && !isNaN(e)) return t.currentTime / e } return -1 }, getDuration: function () { return this.video ? this.video.duration : 0 }, setMute: function (t) { void 0 === t && (t = !0), this._codeMuted = t; const e = this.video; return e && (e.muted = !!this._systemMuted || t), this }, isMuted: function () { return this._codeMuted }, globalMute: function (t, e) { this._systemMuted = e; const i = this.video; i && (i.muted = !!this._codeMuted || e) }, globalPause: function () { this._systemPaused = !0, this.video && !this.video.ended && (this.removeEventHandlers(), this.video.pause()) }, globalResume: function () { this._systemPaused = !1, !this.video || this._codePaused || this.video.ended || this.createPlayPromise() }, setPaused: function (t) { void 0 === t && (t = !0); const e = this.video; return this._codePaused = t, e && !e.ended && (t ? e.paused || (this.removeEventHandlers(), e.pause()) : t || (this._playCalled ? e.paused && !this._systemPaused && this.createPlayPromise() : this.play())), this }, pause: function () { return this.setPaused(!0) }, resume: function () { return this.setPaused(!1) }, getVolume: function () { return this.video ? this.video.volume : 1 }, setVolume: function (t) { return void 0 === t && (t = 1), this.video && (this.video.volume = s(t, 0, 1)), this }, getPlaybackRate: function () { return this.video ? this.video.playbackRate : 1 }, setPlaybackRate: function (t) { return this.video && (this.video.playbackRate = t), this }, getLoop: function () { return !!this.video && this.video.loop }, setLoop: function (t) { return void 0 === t && (t = !0), this.video && (this.video.loop = t), this }, isPlaying: function () { return !!this.video && !(this.video.paused || this.video.ended) }, isPaused: function () { return this.video && this._playCalled && this.video.paused || this._codePaused || this._systemPaused }, saveTexture: function (t, e) { return void 0 === e && (e = !1), this.videoTexture && (this.scene.sys.textures.renameTexture(this._key, t), this.videoTextureSource.setFlipY(e)), this._key = t, this.flipY = e, !!this.videoTexture }, stop: function (t) { void 0 === t && (t = !0); const e = this.video; return e && (this.removeEventHandlers(), e.cancelVideoFrameCallback(this._rfvCallbackId), e.pause()), this.retry = 0, this._playCalled = !1, t && this.emit(o.VIDEO_STOP, this), this }, removeVideoElement: function () { const t = this.video; if (t) { for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();)t.removeChild(t.firstChild); t.removeAttribute('autoplay'), t.removeAttribute('src'), this.video = null } }, preDestroy: function () { this.stop(!1), this.removeLoadEventHandlers(), this.removeVideoElement(); const t = this.scene.sys.game.events; t.off(a.PAUSE, this.globalPause, this), t.off(a.RESUME, this.globalResume, this); const e = this.scene.sys.sound; e && e.off(u.GLOBAL_MUTE, this.globalMute, this) } }); t.exports = f }, 58352: t => { t.exports = function (t, e, i, s) { e.videoTexture && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, s)) } }, 11511: (t, e, i) => { const s = i(25305); const n = i(44603); const r = i(23568); const o = i(18471); n.register('video', function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const n = new o(this.scene, 0, 0, i); return void 0 !== e && (t.add = e), s(this.scene, n, t), n }) }, 89025: (t, e, i) => { const s = i(18471); i(39429).register('video', function (t, e, i) { return this.displayList.add(new s(this.scene, t, e, i)) }) }, 10247: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(29849), r = i(58352), t.exports = { renderWebGL: n, renderCanvas: r } }, 29849: t => { t.exports = function (t, e, i, s) { e.videoTexture && (i.addToRenderList(e), e.pipeline.batchSprite(e, i, s)) } }, 41481: (t, e, i) => { const s = i(10312); const n = i(96503); const r = i(87902); const o = i(83419); const a = i(31401); const h = i(95643); const l = i(87841); const u = i(37303); const c = new o({ Extends: h, Mixins: [a.Depth, a.GetBounds, a.Origin, a.Transform, a.ScrollFactor, a.Visible], initialize: function (t, e, i, n, r) { void 0 === n && (n = 1), void 0 === r && (r = n), h.call(this, t, 'Zone'), this.setPosition(e, i), this.width = n, this.height = r, this.blendMode = s.NORMAL, this.updateDisplayOrigin() }, displayWidth: { get: function () { return this.scaleX * this.width }, set: function (t) { this.scaleX = t / this.width } }, displayHeight: { get: function () { return this.scaleY * this.height }, set: function (t) { this.scaleY = t / this.height } }, setSize: function (t, e, i) { void 0 === i && (i = !0), this.width = t, this.height = e, this.updateDisplayOrigin(); const s = this.input; return i && s && !s.customHitArea && (s.hitArea.width = t, s.hitArea.height = e), this }, setDisplaySize: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this }, setCircleDropZone: function (t) { return this.setDropZone(new n(0, 0, t), r) }, setRectangleDropZone: function (t, e) { return this.setDropZone(new l(0, 0, t, e), u) }, setDropZone: function (t, e) { return this.input || this.setInteractive(t, e, !0), this }, setAlpha: function () { }, setBlendMode: function () { }, renderCanvas: function (t, e, i) { i.addToRenderList(e) }, renderWebGL: function (t, e, i) { i.addToRenderList(e) } }); t.exports = c }, 95261: (t, e, i) => { const s = i(44603); const n = i(23568); const r = i(41481); s.register('zone', function (t) { const e = n(t, 'x', 0); const i = n(t, 'y', 0); const s = n(t, 'width', 1); const o = n(t, 'height', s); return new r(this.scene, e, i, s, o) }) }, 84175: (t, e, i) => { const s = i(41481); i(39429).register('zone', function (t, e, i, n) { return this.displayList.add(new s(this.scene, t, e, i, n)) }) }, 95166: t => { t.exports = function (t) { return t.radius > 0 ? Math.PI * t.radius * t.radius : 0 } }, 96503: (t, e, i) => { const s = i(83419); const n = i(87902); const r = i(26241); const o = i(79124); const a = i(23777); const h = i(28176); const l = new s({ initialize: function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = a.CIRCLE, this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i }, contains: function (t, e) { return n(this, t, e) }, getPoint: function (t, e) { return r(this, t, e) }, getPoints: function (t, e, i) { return o(this, t, e, i) }, getRandomPoint: function (t) { return h(this, t) }, setTo: function (t, e, i) { return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this }, setEmpty: function () { return this._radius = 0, this._diameter = 0, this }, setPosition: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this }, isEmpty: function () { return this._radius <= 0 }, radius: { get: function () { return this._radius }, set: function (t) { this._radius = t, this._diameter = 2 * t } }, diameter: { get: function () { return this._diameter }, set: function (t) { this._diameter = t, this._radius = 0.5 * t } }, left: { get: function () { return this.x - this._radius }, set: function (t) { this.x = t + this._radius } }, right: { get: function () { return this.x + this._radius }, set: function (t) { this.x = t - this._radius } }, top: { get: function () { return this.y - this._radius }, set: function (t) { this.y = t + this._radius } }, bottom: { get: function () { return this.y + this._radius }, set: function (t) { this.y = t - this._radius } } }); t.exports = l }, 71562: t => { t.exports = function (t) { return Math.PI * t.radius * 2 } }, 92110: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i) { return void 0 === i && (i = new s()), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i } }, 42250: (t, e, i) => { const s = i(96503); t.exports = function (t) { return new s(t.x, t.y, t.radius) } }, 87902: t => { t.exports = function (t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius } }, 5698: (t, e, i) => { const s = i(87902); t.exports = function (t, e) { return s(t, e.x, e.y) } }, 70588: (t, e, i) => { const s = i(87902); t.exports = function (t, e) { return s(t, e.x, e.y) && s(t, e.right, e.y) && s(t, e.x, e.bottom) && s(t, e.right, e.bottom) } }, 26394: t => { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.radius) } }, 76278: t => { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.radius === e.radius } }, 2074: (t, e, i) => { const s = i(87841); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e } }, 26241: (t, e, i) => { const s = i(92110); const n = i(62945); const r = i(36383); const o = i(2141); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = n(e, 0, r.PI2); return s(t, a, i) } }, 79124: (t, e, i) => { const s = i(71562); const n = i(92110); const r = i(62945); const o = i(36383); t.exports = function (t, e, i, a) { void 0 === a && (a = []), !e && i > 0 && (e = s(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(n(t, l)) } return a } }, 50884: t => { t.exports = function (t, e, i) { return t.x += e, t.y += i, t } }, 39212: t => { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t } }, 28176: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { void 0 === e && (e = new s()); const i = 2 * Math.PI * Math.random(); const n = Math.random() + Math.random(); const r = n > 1 ? 2 - n : n; const o = r * Math.cos(i); const a = r * Math.sin(i); return e.x = t.x + o * t.radius, e.y = t.y + a * t.radius, e } }, 88911: (t, e, i) => { const s = i(96503); s.Area = i(95166), s.Circumference = i(71562), s.CircumferencePoint = i(92110), s.Clone = i(42250), s.Contains = i(87902), s.ContainsPoint = i(5698), s.ContainsRect = i(70588), s.CopyFrom = i(26394), s.Equals = i(76278), s.GetBounds = i(2074), s.GetPoint = i(26241), s.GetPoints = i(79124), s.Offset = i(50884), s.OffsetPoint = i(39212), s.Random = i(28176), t.exports = s }, 23777: t => { t.exports = { CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6 } }, 78874: t => { t.exports = function (t) { return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI } }, 92990: t => { t.exports = function (t) { const e = t.width / 2; const i = t.height / 2; const s = Math.pow(e - i, 2) / Math.pow(e + i, 2); return Math.PI * (e + i) * (1 + 3 * s / (10 + Math.sqrt(4 - 3 * s))) } }, 79522: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = t.width / 2; const r = t.height / 2; return i.x = t.x + n * Math.cos(e), i.y = t.y + r * Math.sin(e), i } }, 58102: (t, e, i) => { const s = i(8497); t.exports = function (t) { return new s(t.x, t.y, t.width, t.height) } }, 81154: t => { t.exports = function (t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; let s = (e - t.x) / t.width; let n = (i - t.y) / t.height; return (s *= s) + (n *= n) < 0.25 } }, 46662: (t, e, i) => { const s = i(81154); t.exports = function (t, e) { return s(t, e.x, e.y) } }, 1632: (t, e, i) => { const s = i(81154); t.exports = function (t, e) { return s(t, e.x, e.y) && s(t, e.right, e.y) && s(t, e.x, e.bottom) && s(t, e.right, e.bottom) } }, 65534: t => { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height) } }, 8497: (t, e, i) => { const s = i(83419); const n = i(81154); const r = i(90549); const o = i(48320); const a = i(23777); const h = i(24820); const l = new s({ initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.type = a.ELLIPSE, this.x = t, this.y = e, this.width = i, this.height = s }, contains: function (t, e) { return n(this, t, e) }, getPoint: function (t, e) { return r(this, t, e) }, getPoints: function (t, e, i) { return o(this, t, e, i) }, getRandomPoint: function (t) { return h(this, t) }, setTo: function (t, e, i, s) { return this.x = t, this.y = e, this.width = i, this.height = s, this }, setEmpty: function () { return this.width = 0, this.height = 0, this }, setPosition: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this }, setSize: function (t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this }, isEmpty: function () { return this.width <= 0 || this.height <= 0 }, getMinorRadius: function () { return Math.min(this.width, this.height) / 2 }, getMajorRadius: function () { return Math.max(this.width, this.height) / 2 }, left: { get: function () { return this.x - this.width / 2 }, set: function (t) { this.x = t + this.width / 2 } }, right: { get: function () { return this.x + this.width / 2 }, set: function (t) { this.x = t - this.width / 2 } }, top: { get: function () { return this.y - this.height / 2 }, set: function (t) { this.y = t + this.height / 2 } }, bottom: { get: function () { return this.y + this.height / 2 }, set: function (t) { this.y = t - this.height / 2 } } }); t.exports = l }, 36146: t => { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height } }, 23694: (t, e, i) => { const s = i(87841); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e } }, 90549: (t, e, i) => { const s = i(79522); const n = i(62945); const r = i(36383); const o = i(2141); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = n(e, 0, r.PI2); return s(t, a, i) } }, 48320: (t, e, i) => { const s = i(92990); const n = i(79522); const r = i(62945); const o = i(36383); t.exports = function (t, e, i, a) { void 0 === a && (a = []), !e && i > 0 && (e = s(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(n(t, l)) } return a } }, 73424: t => { t.exports = function (t, e, i) { return t.x += e, t.y += i, t } }, 44808: t => { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t } }, 24820: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { void 0 === e && (e = new s()); const i = Math.random() * Math.PI * 2; const n = Math.sqrt(Math.random()); return e.x = t.x + n * Math.cos(i) * t.width / 2, e.y = t.y + n * Math.sin(i) * t.height / 2, e } }, 49203: (t, e, i) => { const s = i(8497); s.Area = i(78874), s.Circumference = i(92990), s.CircumferencePoint = i(79522), s.Clone = i(58102), s.Contains = i(81154), s.ContainsPoint = i(46662), s.ContainsRect = i(1632), s.CopyFrom = i(65534), s.Equals = i(36146), s.GetBounds = i(23694), s.GetPoint = i(90549), s.GetPoints = i(48320), s.Offset = i(73424), s.OffsetPoint = i(44808), s.Random = i(24820), t.exports = s }, 55738: (t, e, i) => { const s = i(23777); const n = i(79291); let r = { Circle: i(88911), Ellipse: i(49203), Intersects: i(91865), Line: i(2529), Mesh: i(73090), Point: i(43711), Polygon: i(58423), Rectangle: i(93232), Triangle: i(84435) }; r = n(!1, r, s), t.exports = r }, 2044: (t, e, i) => { const s = i(20339); t.exports = function (t, e) { return s(t.x, t.y, e.x, e.y) <= t.radius + e.radius } }, 81491: t => { t.exports = function (t, e) { const i = e.width / 2; const s = e.height / 2; const n = Math.abs(t.x - e.x - i); const r = Math.abs(t.y - e.y - s); const o = i + t.radius; const a = s + t.radius; if (n > o || r > a) return !1; if (n <= i || r <= s) return !0; const h = n - i; const l = r - s; return h * h + l * l <= t.radius * t.radius } }, 63376: (t, e, i) => { const s = i(2141); const n = i(2044); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { let r; let o; let a; let h; const l = t.x; const u = t.y; const c = t.radius; const d = e.x; const f = e.y; const p = e.radius; if (u === f) (a = (o = -2 * f) * o - 4 * (r = 1) * (d * d + (h = (p * p - c * c - d * d + l * l) / (2 * (l - d))) * h - 2 * d * h + f * f - p * p)) === 0 ? i.push(new s(h, -o / (2 * r))) : a > 0 && (i.push(new s(h, (-o + Math.sqrt(a)) / (2 * r))), i.push(new s(h, (-o - Math.sqrt(a)) / (2 * r)))); else { const v = (l - d) / (u - f); const g = (p * p - c * c - d * d + l * l - f * f + u * u) / (2 * (u - f)); (a = (o = 2 * u * v - 2 * g * v - 2 * l) * o - 4 * (r = v * v + 1) * (l * l + u * u + g * g - c * c - 2 * u * g)) === 0 ? (h = -o / (2 * r), i.push(new s(h, g - h * v))) : a > 0 && (h = (-o + Math.sqrt(a)) / (2 * r), i.push(new s(h, g - h * v)), h = (-o - Math.sqrt(a)) / (2 * r), i.push(new s(h, g - h * v))) } } return i } }, 97439: (t, e, i) => { const s = i(4042); const n = i(81491); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); const h = e.getLineD(); s(r, t, i), s(o, t, i), s(a, t, i), s(h, t, i) } return i } }, 4042: (t, e, i) => { const s = i(2141); const n = i(80462); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { let r; let o; const a = t.x1; const h = t.y1; const l = t.x2; const u = t.y2; const c = e.x; const d = e.y; const f = e.radius; const p = l - a; const v = u - h; const g = a - c; const m = h - d; const y = p * p + v * v; const x = 2 * (p * g + v * m); const T = x * x - 4 * y * (g * g + m * m - f * f); if (T === 0) { const w = -x / (2 * y); r = a + w * p, o = h + w * v, w >= 0 && w <= 1 && i.push(new s(r, o)) } else if (T > 0) { const b = (-x - Math.sqrt(T)) / (2 * y); r = a + b * p, o = h + b * v, b >= 0 && b <= 1 && i.push(new s(r, o)); const S = (-x + Math.sqrt(T)) / (2 * y); r = a + S * p, o = h + S * v, S >= 0 && S <= 1 && i.push(new s(r, o)) } } return i } }, 36100: (t, e, i) => { const s = i(25836); t.exports = function (t, e, i, n) { void 0 === i && (i = !1); let r; let o; let a; const h = t.x1; const l = t.y1; const u = t.x2; const c = t.y2; const d = e.x1; const f = e.y1; const p = u - h; const v = c - l; const g = e.x2 - d; const m = e.y2 - f; const y = p * m - v * g; if (y === 0) return null; if (i) { if ((o = (d + g * (r = (p * (f - l) + v * (h - d)) / (g * v - m * p)) - h) / p) < 0 || r < 0 || r > 1) return null; a = o } else { if (o = ((l - f) * p - (h - d) * v) / y, (r = ((d - h) * m - (f - l) * g) / y) < 0 || r > 1 || o < 0 || o > 1) return null; a = r } return void 0 === n && (n = new s()), n.set(h + p * a, l + v * a, a) } }, 3073: (t, e, i) => { const s = i(36100); const n = i(23031); const r = i(25836); const o = new n(); const a = new r(); t.exports = function (t, e, i, n) { void 0 === i && (i = !1), void 0 === n && (n = new r()); let h = !1; n.set(), a.set(); for (let l = e[e.length - 1], u = 0; u < e.length; u++) { const c = e[u]; o.setTo(l.x, l.y, c.x, c.y), l = c, s(t, o, i, a) && (!h || a.z < n.z) && (n.copy(a), h = !0) } return h ? n : null } }, 56362: (t, e, i) => { const s = i(25836); const n = i(61369); const r = i(3073); const o = new s(); t.exports = function (t, e, i, s) { void 0 === s && (s = new n()), Array.isArray(e) || (e = [e]); let a = !1; s.set(), o.set(); for (let h = 0; h < e.length; h++)r(t, e[h].points, i, o) && (!a || o.z < s.z) && (s.set(o.x, o.y, o.z, h), a = !0); return a ? s : null } }, 60646: (t, e, i) => { const s = i(2141); const n = i(76112); const r = i(92773); t.exports = function (t, e, i) { if (void 0 === i && (i = []), r(t, e)) for (let o = e.getLineA(), a = e.getLineB(), h = e.getLineC(), l = e.getLineD(), u = [new s(), new s(), new s(), new s()], c = [n(o, t, u[0]), n(a, t, u[1]), n(h, t, u[2]), n(l, t, u[3])], d = 0; d < 4; d++)c[d] && i.push(u[d]); return i } }, 71147: (t, e, i) => { const s = i(61369); const n = i(56362); const r = new (i(23031))(); function o (t, e, i, o, a) { const h = Math.cos(t); const l = Math.sin(t); r.setTo(e, i, e + h, i + l); const u = n(r, o, !0); u && a.push(new s(u.x, u.y, t, u.w)) } function a (t, e) { return t.z - e.z } t.exports = function (t, e, i) { Array.isArray(i) || (i = [i]); for (var s = [], n = [], r = 0; r < i.length; r++) for (let h = i[r].points, l = 0; l < h.length; l++) { const u = Math.atan2(h[l].y - e, h[l].x - t); n.indexOf(u) === -1 && (o(u, t, e, i, s), o(u - 1e-5, t, e, i, s), o(u + 1e-5, t, e, i, s), n.push(u)) } return s.sort(a) } }, 68389: (t, e, i) => { const s = i(87841); const n = i(59996); t.exports = function (t, e, i) { return void 0 === i && (i = new s()), n(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i } }, 52784: (t, e, i) => { const s = i(60646); const n = i(59996); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = t.getLineD(); s(r, e, i), s(o, e, i), s(a, e, i), s(h, e, i) } return i } }, 26341: (t, e, i) => { const s = i(89265); const n = i(60646); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); n(r, t, i), n(o, t, i), n(a, t, i) } return i } }, 38720: (t, e, i) => { const s = i(4042); const n = i(67636); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); s(r, e, i), s(o, e, i), s(a, e, i) } return i } }, 13882: (t, e, i) => { const s = i(2141); const n = i(2822); const r = i(76112); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) for (let o = t.getLineA(), a = t.getLineB(), h = t.getLineC(), l = [new s(), new s(), new s()], u = [r(o, e, l[0]), r(a, e, l[1]), r(h, e, l[2])], c = 0; c < 3; c++)u[c] && i.push(l[c]); return i } }, 75636: (t, e, i) => { const s = i(82944); const n = i(13882); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); n(t, r, i), n(t, o, i), n(t, a, i) } return i } }, 80462: (t, e, i) => { const s = i(87902); const n = new (i(2141))(); t.exports = function (t, e, i) { if (void 0 === i && (i = n), s(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0; if (s(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e.x - t.x1; const h = e.y - t.y1; const l = r * r + o * o; let u = r; let c = o; if (l > 0) { const d = (a * r + h * o) / l; u *= d, c *= d } return i.x = t.x1 + u, i.y = t.y1 + c, u * u + c * c <= l && u * r + c * o >= 0 && s(e, i.x, i.y) } }, 76112: t => { t.exports = function (t, e, i) { const s = t.x1; const n = t.y1; const r = t.x2; const o = t.y2; const a = e.x1; const h = e.y1; const l = e.x2; const u = e.y2; if (s === r && n === o || a === l && h === u) return !1; const c = (u - h) * (r - s) - (l - a) * (o - n); if (c === 0) return !1; const d = ((l - a) * (n - h) - (u - h) * (s - a)) / c; const f = ((r - s) * (n - h) - (o - n) * (s - a)) / c; return !(d < 0 || d > 1 || f < 0 || f > 1) && (i && (i.x = s + d * (r - s), i.y = n + d * (o - n)), !0) } }, 92773: t => { t.exports = function (t, e) { const i = t.x1; const s = t.y1; const n = t.x2; const r = t.y2; const o = e.x; const a = e.y; const h = e.right; const l = e.bottom; let u = 0; if (i >= o && i <= h && s >= a && s <= l || n >= o && n <= h && r >= a && r <= l) return !0; if (i < o && n >= o) { if ((u = s + (r - s) * (o - i) / (n - i)) > a && u <= l) return !0 } else if (i > h && n <= h && (u = s + (r - s) * (h - i) / (n - i)) >= a && u <= l) return !0; if (s < a && r >= a) { if ((u = i + (n - i) * (a - s) / (r - s)) >= o && u <= h) return !0 } else if (s > l && r <= l && (u = i + (n - i) * (l - s) / (r - s)) >= o && u <= h) return !0; return !1 } }, 16204: t => { t.exports = function (t, e, i) { void 0 === i && (i = 1); const s = e.x1; const n = e.y1; const r = e.x2; const o = e.y2; const a = t.x; const h = t.y; const l = (r - s) * (r - s) + (o - n) * (o - n); if (l === 0) return !1; const u = ((a - s) * (r - s) + (h - n) * (o - n)) / l; if (u < 0) return Math.sqrt((s - a) * (s - a) + (n - h) * (n - h)) <= i; if (u >= 0 && u <= 1) { const c = ((n - h) * (r - s) - (s - a) * (o - n)) / l; return Math.abs(c) * Math.sqrt(l) <= i } return Math.sqrt((r - a) * (r - a) + (o - h) * (o - h)) <= i } }, 14199: (t, e, i) => { const s = i(16204); t.exports = function (t, e) { if (!s(t, e)) return !1; const i = Math.min(e.x1, e.x2); const n = Math.max(e.x1, e.x2); const r = Math.min(e.y1, e.y2); const o = Math.max(e.y1, e.y2); return t.x >= i && t.x <= n && t.y >= r && t.y <= o } }, 59996: t => { t.exports = function (t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom) } }, 89265: (t, e, i) => { const s = i(76112); const n = i(37303); const r = i(48653); const o = i(77493); t.exports = function (t, e) { if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1; const i = e.getLineA(); const a = e.getLineB(); const h = e.getLineC(); if (n(t, i.x1, i.y1) || n(t, i.x2, i.y2)) return !0; if (n(t, a.x1, a.y1) || n(t, a.x2, a.y2)) return !0; if (n(t, h.x1, h.y1) || n(t, h.x2, h.y2)) return !0; const l = t.getLineA(); const u = t.getLineB(); const c = t.getLineC(); const d = t.getLineD(); if (s(i, l) || s(i, u) || s(i, c) || s(i, d)) return !0; if (s(a, l) || s(a, u) || s(a, c) || s(a, d)) return !0; if (s(h, l) || s(h, u) || s(h, c) || s(h, d)) return !0; const f = o(t); return r(e, f, !0).length > 0 } }, 84411: t => { t.exports = function (t, e, i, s, n, r) { return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || s > t.bottom + r || n < t.top - r) } }, 67636: (t, e, i) => { const s = i(80462); const n = i(10690); t.exports = function (t, e) { return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) && (!!n(t, e.x, e.y) || (!!s(t.getLineA(), e) || (!!s(t.getLineB(), e) || !!s(t.getLineC(), e)))) } }, 2822: (t, e, i) => { const s = i(76112); t.exports = function (t, e) { return !(!t.contains(e.x1, e.y1) && !t.contains(e.x2, e.y2)) || (!!s(t.getLineA(), e) || (!!s(t.getLineB(), e) || !!s(t.getLineC(), e))) } }, 82944: (t, e, i) => { const s = i(48653); const n = i(71694); const r = i(76112); t.exports = function (t, e) { if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1; const i = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = e.getLineA(); const l = e.getLineB(); const u = e.getLineC(); if (r(i, h) || r(i, l) || r(i, u)) return !0; if (r(o, h) || r(o, l) || r(o, u)) return !0; if (r(a, h) || r(a, l) || r(a, u)) return !0; let c = n(t); let d = s(e, c, !0); return d.length > 0 || (c = n(e), (d = s(t, c, !0)).length > 0) } }, 91865: (t, e, i) => { t.exports = { CircleToCircle: i(2044), CircleToRectangle: i(81491), GetCircleToCircle: i(63376), GetCircleToRectangle: i(97439), GetLineToCircle: i(4042), GetLineToLine: i(36100), GetLineToPoints: i(3073), GetLineToPolygon: i(56362), GetLineToRectangle: i(60646), GetRaysFromPointToPolygon: i(71147), GetRectangleIntersection: i(68389), GetRectangleToRectangle: i(52784), GetRectangleToTriangle: i(26341), GetTriangleToCircle: i(38720), GetTriangleToLine: i(13882), GetTriangleToTriangle: i(75636), LineToCircle: i(80462), LineToLine: i(76112), LineToRectangle: i(92773), PointToLine: i(16204), PointToLineSegment: i(14199), RectangleToRectangle: i(59996), RectangleToTriangle: i(89265), RectangleToValues: i(84411), TriangleToCircle: i(67636), TriangleToLine: i(2822), TriangleToTriangle: i(82944) } }, 91938: t => { t.exports = function (t) { return Math.atan2(t.y2 - t.y1, t.x2 - t.x1) } }, 84993: t => { t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = []); let s = Math.round(t.x1); let n = Math.round(t.y1); const r = Math.round(t.x2); const o = Math.round(t.y2); const a = Math.abs(r - s); const h = Math.abs(o - n); const l = s < r ? 1 : -1; const u = n < o ? 1 : -1; let c = a - h; i.push({ x: s, y: n }); for (let d = 1; s !== r || n !== o;) { const f = c << 1; f > -h && (c -= h, s += l), f < a && (c += a, n += u), d % e == 0 && i.push({ x: s, y: n }), d++ } return i } }, 36469: t => { t.exports = function (t, e, i) { const s = e - (t.x1 + t.x2) / 2; const n = i - (t.y1 + t.y2) / 2; return t.x1 += s, t.y1 += n, t.x2 += s, t.y2 += n, t } }, 31116: (t, e, i) => { const s = i(23031); t.exports = function (t) { return new s(t.x1, t.y1, t.x2, t.y2) } }, 59944: t => { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2) } }, 59220: t => { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 } }, 78177: (t, e, i) => { const s = i(35001); t.exports = function (t, e, i) { void 0 === i && (i = e); const n = s(t); const r = t.x2 - t.x1; const o = t.y2 - t.y1; return e && (t.x1 = t.x1 - r / n * e, t.y1 = t.y1 - o / n * e), i && (t.x2 = t.x2 + r / n * i, t.y2 = t.y2 + o / n * i), t } }, 26708: (t, e, i) => { const s = i(52816); const n = i(6113); const r = i(2141); t.exports = function (t, e, i, o, a) { void 0 === o && (o = 0), void 0 === a && (a = []); let h; let l; const u = []; const c = t.x1; const d = t.y1; const f = t.x2 - c; const p = t.y2 - d; const v = n(e, a); const g = i - 1; for (h = 0; h < g; h++)l = v(h / g), u.push(new r(c + f * l, d + p * l)); if (l = v(1), u.push(new r(c + f * l, d + p * l)), o > 0) { let m = u[0]; const y = [m]; for (h = 1; h < u.length - 1; h++) { const x = u[h]; s(m, x) >= o && (y.push(x), m = x) } const T = u[u.length - 1]; return s(m, T) < o && y.pop(), y.push(T), y } return u } }, 32125: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e } }, 99569: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = (o - n) * (o - n) + (a - r) * (a - r); if (h === 0) return i; const l = ((e.x - n) * (o - n) + (e.y - r) * (a - r)) / h; return i.x = n + l * (o - n), i.y = r + l * (a - r), i } }, 34638: (t, e, i) => { const s = i(36383); const n = i(91938); const r = i(2141); t.exports = function (t, e) { void 0 === e && (e = new r()); const i = n(t) - s.TAU; return e.x = Math.cos(i), e.y = Math.sin(i), e } }, 13151: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i) { return void 0 === i && (i = new s()), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i } }, 15258: (t, e, i) => { const s = i(35001); const n = i(2141); t.exports = function (t, e, i, r) { void 0 === r && (r = []), !e && i > 0 && (e = s(t) / i); for (let o = t.x1, a = t.y1, h = t.x2, l = t.y2, u = 0; u < e; u++) { const c = u / e; const d = o + (h - o) * c; const f = a + (l - a) * c; r.push(new n(d, f)) } return r } }, 26408: t => { t.exports = function (t, e) { const i = t.x1; const s = t.y1; const n = t.x2; const r = t.y2; const o = (n - i) * (n - i) + (r - s) * (r - s); if (o === 0) return !1; const a = ((s - e.y) * (n - i) - (i - e.x) * (r - s)) / o; return Math.abs(a) * Math.sqrt(o) } }, 98770: t => { t.exports = function (t) { return Math.abs(t.y1 - t.y2) } }, 35001: t => { t.exports = function (t) { return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1)) } }, 23031: (t, e, i) => { const s = i(83419); const n = i(13151); const r = i(15258); const o = i(23777); const a = i(65822); const h = i(26099); const l = new s({ initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.type = o.LINE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s }, getPoint: function (t, e) { return n(this, t, e) }, getPoints: function (t, e, i) { return r(this, t, e, i) }, getRandomPoint: function (t) { return a(this, t) }, setTo: function (t, e, i, s) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s, this }, setFromObjects: function (t, e) { return this.x1 = t.x, this.y1 = t.y, this.x2 = e.x, this.y2 = e.y, this }, getPointA: function (t) { return void 0 === t && (t = new h()), t.set(this.x1, this.y1), t }, getPointB: function (t) { return void 0 === t && (t = new h()), t.set(this.x2, this.y2), t }, left: { get: function () { return Math.min(this.x1, this.x2) }, set: function (t) { this.x1 <= this.x2 ? this.x1 = t : this.x2 = t } }, right: { get: function () { return Math.max(this.x1, this.x2) }, set: function (t) { this.x1 > this.x2 ? this.x1 = t : this.x2 = t } }, top: { get: function () { return Math.min(this.y1, this.y2) }, set: function (t) { this.y1 <= this.y2 ? this.y1 = t : this.y2 = t } }, bottom: { get: function () { return Math.max(this.y1, this.y2) }, set: function (t) { this.y1 > this.y2 ? this.y1 = t : this.y2 = t } } }); t.exports = l }, 64795: (t, e, i) => { const s = i(36383); const n = i(15994); const r = i(91938); t.exports = function (t) { const e = r(t) - s.TAU; return n(e, -Math.PI, Math.PI) } }, 52616: (t, e, i) => { const s = i(36383); const n = i(91938); t.exports = function (t) { return Math.cos(n(t) - s.TAU) } }, 87231: (t, e, i) => { const s = i(36383); const n = i(91938); t.exports = function (t) { return Math.sin(n(t) - s.TAU) } }, 89662: t => { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t } }, 71165: t => { t.exports = function (t) { return -(t.x2 - t.x1) / (t.y2 - t.y1) } }, 65822: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { void 0 === e && (e = new s()); const i = Math.random(); return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e } }, 69777: (t, e, i) => { const s = i(91938); const n = i(64795); t.exports = function (t, e) { return 2 * n(e) - Math.PI - s(t) } }, 39706: (t, e, i) => { const s = i(64400); t.exports = function (t, e) { const i = (t.x1 + t.x2) / 2; const n = (t.y1 + t.y2) / 2; return s(t, i, n, e) } }, 82585: (t, e, i) => { const s = i(64400); t.exports = function (t, e, i) { return s(t, e.x, e.y, i) } }, 64400: t => { t.exports = function (t, e, i, s) { const n = Math.cos(s); const r = Math.sin(s); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * n - a * r + e, t.y1 = o * r + a * n + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * n - a * r + e, t.y2 = o * r + a * n + i, t } }, 62377: t => { t.exports = function (t, e, i, s, n) { return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(s) * n, t.y2 = i + Math.sin(s) * n, t } }, 71366: t => { t.exports = function (t) { return (t.y2 - t.y1) / (t.x2 - t.x1) } }, 10809: t => { t.exports = function (t) { return Math.abs(t.x1 - t.x2) } }, 2529: (t, e, i) => { const s = i(23031); s.Angle = i(91938), s.BresenhamPoints = i(84993), s.CenterOn = i(36469), s.Clone = i(31116), s.CopyFrom = i(59944), s.Equals = i(59220), s.Extend = i(78177), s.GetEasedPoints = i(26708), s.GetMidPoint = i(32125), s.GetNearestPoint = i(99569), s.GetNormal = i(34638), s.GetPoint = i(13151), s.GetPoints = i(15258), s.GetShortestDistance = i(26408), s.Height = i(98770), s.Length = i(35001), s.NormalAngle = i(64795), s.NormalX = i(52616), s.NormalY = i(87231), s.Offset = i(89662), s.PerpSlope = i(71165), s.Random = i(65822), s.ReflectAngle = i(69777), s.Rotate = i(39706), s.RotateAroundPoint = i(82585), s.RotateAroundXY = i(64400), s.SetToAngle = i(62377), s.Slope = i(71366), s.Width = i(10809), t.exports = s }, 83997: (t, e, i) => { const s = i(83419); const n = i(87841); const r = i(26099); function o (t, e, i, s) { const n = t - i; const r = e - s; const o = n * n + r * r; return Math.sqrt(o) } const a = new s({ initialize: function (t, e, i) { this.vertex1 = t, this.vertex2 = e, this.vertex3 = i, this.bounds = new n(), this._inCenter = new r() }, getInCenter: function (t) { void 0 === t && (t = !0); let e; let i; let s; let n; let r; let a; const h = this.vertex1; const l = this.vertex2; const u = this.vertex3; t ? (e = h.x, i = h.y, s = l.x, n = l.y, r = u.x, a = u.y) : (e = h.vx, i = h.vy, s = l.vx, n = l.vy, r = u.vx, a = u.vy); const c = o(r, a, s, n); const d = o(e, i, r, a); const f = o(s, n, e, i); const p = c + d + f; return this._inCenter.set((e * c + s * d + r * f) / p, (i * c + n * d + a * f) / p) }, contains: function (t, e, i) { const s = this.vertex1; const n = this.vertex2; const r = this.vertex3; let o = s.vx; let a = s.vy; let h = n.vx; let l = n.vy; let u = r.vx; let c = r.vy; if (i) { const d = i.a; const f = i.b; const p = i.c; const v = i.d; const g = i.e; const m = i.f; o = s.vx * d + s.vy * p + g, a = s.vx * f + s.vy * v + m, h = n.vx * d + n.vy * p + g, l = n.vx * f + n.vy * v + m, u = r.vx * d + r.vy * p + g, c = r.vx * f + r.vy * v + m } const y = u - o; const x = c - a; const T = h - o; const w = l - a; const b = t - o; const S = e - a; const E = y * y + x * x; const A = y * T + x * w; const C = y * b + x * S; const _ = T * T + w * w; const M = T * b + w * S; const P = E * _ - A * A; const R = P === 0 ? 0 : 1 / P; const L = (_ * C - A * M) * R; const O = (E * M - A * C) * R; return L >= 0 && O >= 0 && L + O < 1 }, isCounterClockwise: function (t) { const e = this.vertex1; const i = this.vertex2; const s = this.vertex3; const n = (i.vx - e.vx) * (s.vy - e.vy) - (i.vy - e.vy) * (s.vx - e.vx); return t <= 0 ? n >= 0 : n < 0 }, load: function (t, e, i, s, n) { return i = this.vertex1.load(t, e, i, s, n), i = this.vertex2.load(t, e, i, s, n), i = this.vertex3.load(t, e, i, s, n) }, transformCoordinatesLocal: function (t, e, i, s) { return this.vertex1.transformCoordinatesLocal(t, e, i, s), this.vertex2.transformCoordinatesLocal(t, e, i, s), this.vertex3.transformCoordinatesLocal(t, e, i, s), this }, updateBounds: function () { const t = this.vertex1; const e = this.vertex2; const i = this.vertex3; const s = this.bounds; return s.x = Math.min(t.vx, e.vx, i.vx), s.y = Math.min(t.vy, e.vy, i.vy), s.width = Math.max(t.vx, e.vx, i.vx) - s.x, s.height = Math.max(t.vy, e.vy, i.vy) - s.y, this }, isInView: function (t, e, i, s, n, r, o, a, h, l, u) { this.update(s, n, r, o, a, h, l, u); const c = this.vertex1; const d = this.vertex2; const f = this.vertex3; if (c.ta <= 0 && d.ta <= 0 && f.ta <= 0) return !1; if (e && !this.isCounterClockwise(i)) return !1; const p = this.bounds; p.x = Math.min(c.tx, d.tx, f.tx), p.y = Math.min(c.ty, d.ty, f.ty), p.width = Math.max(c.tx, d.tx, f.tx) - p.x, p.height = Math.max(c.ty, d.ty, f.ty) - p.y; const v = t.x + t.width; const g = t.y + t.height; return !(p.width <= 0 || p.height <= 0 || t.width <= 0 || t.height <= 0) && !(p.right < t.x || p.bottom < t.y || p.x > v || p.y > g) }, scrollUV: function (t, e) { return this.vertex1.scrollUV(t, e), this.vertex2.scrollUV(t, e), this.vertex3.scrollUV(t, e), this }, scaleUV: function (t, e) { return this.vertex1.scaleUV(t, e), this.vertex2.scaleUV(t, e), this.vertex3.scaleUV(t, e), this }, setColor: function (t) { return this.vertex1.color = t, this.vertex2.color = t, this.vertex3.color = t, this }, update: function (t, e, i, s, n, r, o, a) { return this.vertex1.update(e, i, s, n, r, o, a, t), this.vertex2.update(e, i, s, n, r, o, a, t), this.vertex3.update(e, i, s, n, r, o, a, t), this }, translate: function (t, e) { void 0 === e && (e = 0); const i = this.vertex1; const s = this.vertex2; const n = this.vertex3; return i.x += t, i.y += e, s.x += t, s.y += e, n.x += t, n.y += e, this }, x: { get: function () { return this.getInCenter().x }, set: function (t) { const e = this.getInCenter(); this.translate(t - e.x, 0) } }, y: { get: function () { return this.getInCenter().y }, set: function (t) { const e = this.getInCenter(); this.translate(0, t - e.y) } }, alpha: { get: function () { const t = this.vertex1; const e = this.vertex2; const i = this.vertex3; return (t.alpha + e.alpha + i.alpha) / 3 }, set: function (t) { this.vertex1.alpha = t, this.vertex2.alpha = t, this.vertex3.alpha = t } }, depth: { get: function () { const t = this.vertex1; const e = this.vertex2; const i = this.vertex3; return (t.vz + e.vz + i.vz) / 3 } }, destroy: function () { this.vertex1 = null, this.vertex2 = null, this.vertex3 = null } }); t.exports = a }, 48803: (t, e, i) => { const s = i(83997); const n = i(95540); const r = i(37867); const o = i(25836); const a = i(39318); const h = new o(); const l = new o(); const u = new r(); t.exports = function (t) { let e; const i = n(t, 'mesh'); let r = n(t, 'texture', null); const o = n(t, 'frame'); let c = n(t, 'width', 1); let d = n(t, 'height', c); const f = n(t, 'widthSegments', 1); const p = n(t, 'heightSegments', f); const v = n(t, 'x', 0); const g = n(t, 'y', 0); const m = n(t, 'z', 0); const y = n(t, 'rotateX', 0); const x = n(t, 'rotateY', 0); const T = n(t, 'rotateZ', 0); const w = n(t, 'zIsUp', !0); const b = n(t, 'isOrtho', !!i && i.dirtyCache[11]); let S = n(t, 'colors', [16777215]); let E = n(t, 'alphas', [1]); const A = n(t, 'tile', !1); const C = n(t, 'flipY', !1); const _ = n(t, 'width', null); const M = { faces: [], verts: [] }; if (h.set(v, g, m), l.set(y, x, T), u.fromRotationXYTranslation(l, h, w), !r && i) r = i.texture, o || (e = i.frame); else if (i && typeof r === 'string') r = i.scene.sys.textures.get(r); else if (!r) return M; e || (e = r.get(o)), !_ && b && r && i && (c = e.width / i.height, d = e.height / i.height); let P; let R; const L = c / 2; const O = d / 2; const F = Math.floor(f); const D = Math.floor(p); const k = F + 1; const I = D + 1; const B = c / F; const N = d / D; const U = []; const X = []; let Y = 0; let z = 1; let G = 0; let V = 1; e && (Y = e.u0, z = e.u1, C ? (G = e.v1, V = e.v0) : (G = e.v0, V = e.v1)); const W = z - Y; const H = V - G; for (R = 0; R < I; R++) { const j = R * N - O; for (P = 0; P < k; P++) { const q = P * B - L; X.push(q, -j); const K = Y + W * (P / F); const Z = G + H * (R / D); U.push(K, Z) } } Array.isArray(S) || (S = [S]), Array.isArray(E) || (E = [E]); let J = 0; let Q = 0; for (R = 0; R < D; R++) for (P = 0; P < F; P++) { const $ = 2 * (P + k * R); const tt = 2 * (P + k * (R + 1)); const et = 2 * (P + 1 + k * (R + 1)); const it = 2 * (P + 1 + k * R); const st = S[Q]; const nt = E[J]; const rt = new a(X[$], X[$ + 1], 0, U[$], U[$ + 1], st, nt).transformMat4(u); const ot = new a(X[tt], X[tt + 1], 0, U[tt], U[tt + 1], st, nt).transformMat4(u); const at = new a(X[it], X[it + 1], 0, U[it], U[it + 1], st, nt).transformMat4(u); const ht = new a(X[tt], X[tt + 1], 0, U[tt], U[tt + 1], st, nt).transformMat4(u); const lt = new a(X[et], X[et + 1], 0, U[et], U[et + 1], st, nt).transformMat4(u); const ut = new a(X[it], X[it + 1], 0, U[it], U[it + 1], st, nt).transformMat4(u); A && (rt.setUVs(Y, V), ot.setUVs(Y, G), at.setUVs(z, V), ht.setUVs(Y, G), lt.setUVs(z, G), ut.setUVs(z, V)), ++Q === S.length && (Q = 0), ++J === E.length && (J = 0), M.verts.push(rt, ot, at, ht, lt, ut), M.faces.push(new s(rt, ot, at), new s(ht, lt, ut)) } return i && (i.faces = i.faces.concat(M.faces), i.vertices = i.vertices.concat(M.verts)), M } }, 34684: (t, e, i) => { const s = i(83997); const n = i(37867); const r = i(25836); const o = i(39318); const a = new r(); const h = new r(); const l = new n(); t.exports = function (t, e, i, n, r, u, c, d, f, p) { void 0 === i && (i = 1), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === u && (u = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === f && (f = 0), void 0 === p && (p = !0); const v = { faces: [], verts: [] }; const g = t.materials; a.set(n, r, u), h.set(c, d, f), l.fromRotationXYTranslation(h, a, p); for (let m = 0; m < t.models.length; m++) for (let y = t.models[m], x = y.vertices, T = y.textureCoords, w = y.faces, b = 0; b < w.length; b++) { const S = w[b]; const E = S.vertices[0]; const A = S.vertices[1]; const C = S.vertices[2]; const _ = x[E.vertexIndex]; const M = x[A.vertexIndex]; const P = x[C.vertexIndex]; const R = E.textureCoordsIndex; const L = A.textureCoordsIndex; const O = C.textureCoordsIndex; const F = R === -1 ? { u: 0, v: 1 } : T[R]; const D = L === -1 ? { u: 0, v: 0 } : T[L]; const k = O === -1 ? { u: 1, v: 1 } : T[O]; let I = 16777215; S.material !== '' && g[S.material] && (I = g[S.material]); const B = new o(_.x * i, _.y * i, _.z * i, F.u, F.v, I).transformMat4(l); const N = new o(M.x * i, M.y * i, M.z * i, D.u, D.v, I).transformMat4(l); const U = new o(P.x * i, P.y * i, P.z * i, k.u, k.v, I).transformMat4(l); v.verts.push(B, N, U), v.faces.push(new s(B, N, U)) } return e && (e.faces = e.faces.concat(v.faces), e.vertices = e.vertices.concat(v.verts)), v } }, 92515: (t, e, i) => { const s = i(83997); const n = i(39318); t.exports = function (t, e, i, r, o, a, h, l) { if (void 0 === r && (r = !1), void 0 === a && (a = 16777215), void 0 === h && (h = 1), void 0 === l && (l = !1), t.length === e.length || r) { let u; let c; let d; let f; let p; let v; let g; let m; let y; let x; let T; const w = { faces: [], vertices: [] }; const b = r ? 3 : 2; const S = Array.isArray(a); const E = Array.isArray(h); if (Array.isArray(i) && i.length > 0) for (u = 0; u < i.length; u++) { const A = i[u]; const C = 2 * i[u]; const _ = i[u] * b; c = t[_], d = t[_ + 1], f = r ? t[_ + 2] : 0, p = e[C], v = e[C + 1], l && (v = 1 - v), g = S ? a[A] : a, m = E ? h[A] : h, y = 0, x = 0, T = 0, o && (y = o[_], x = o[_ + 1], T = r ? o[_ + 2] : 0), w.vertices.push(new n(c, d, f, p, v, g, m, y, x, T)) } else { let M = 0; let P = 0; for (u = 0; u < t.length; u += b)c = t[u], d = t[u + 1], f = r ? t[u + 2] : 0, p = e[M], v = e[M + 1], g = S ? a[P] : a, m = E ? h[P] : h, y = 0, x = 0, T = 0, o && (y = o[u], x = o[u + 1], T = r ? o[u + 2] : 0), w.vertices.push(new n(c, d, f, p, v, g, m, y, x, T)), M += 2, P++ } for (u = 0; u < w.vertices.length; u += 3) { const R = w.vertices[u]; const L = w.vertices[u + 1]; const O = w.vertices[u + 2]; w.faces.push(new s(R, L, O)) } return w } console.warn('GenerateVerts: vertices and uvs count not equal') } }, 85048: t => { let e = !0; const i = 'untitled'; let s = ''; let n = ''; function r (t) { const e = t.indexOf('#'); return e > -1 ? t.substring(0, e) : t } function o (t) { return t.models.length === 0 && t.models.push({ faces: [], name: i, textureCoords: [], vertexNormals: [], vertices: [] }), s = '', t.models[t.models.length - 1] } function a (t, e) { const n = t.length >= 2 ? t[1] : i; e.models.push({ faces: [], name: n, textureCoords: [], vertexNormals: [], vertices: [] }), s = '' } function h (t) { t.length === 2 && (s = t[1]) } function l (t, e) { const i = t.length; const s = i >= 2 ? parseFloat(t[1]) : 0; const n = i >= 3 ? parseFloat(t[2]) : 0; const r = i >= 4 ? parseFloat(t[3]) : 0; o(e).vertices.push({ x: s, y: n, z: r }) } function u (t, i) { const s = t.length; let n = s >= 2 ? parseFloat(t[1]) : 0; let r = s >= 3 ? parseFloat(t[2]) : 0; let a = s >= 4 ? parseFloat(t[3]) : 0; isNaN(n) && (n = 0), isNaN(r) && (r = 0), isNaN(a) && (a = 0), e && (r = 1 - r), o(i).textureCoords.push({ u: n, v: r, w: a }) } function c (t, e) { const i = t.length; const s = i >= 2 ? parseFloat(t[1]) : 0; const n = i >= 3 ? parseFloat(t[2]) : 0; const r = i >= 4 ? parseFloat(t[3]) : 0; o(e).vertexNormals.push({ x: s, y: n, z: r }) } function d (t, e) { const i = t.length - 1; if (!(i < 3)) { for (var r = { group: s, material: n, vertices: [] }, a = 0; a < i; a++) { const h = t[a + 1].split('/'); const l = h.length; if (!(l < 1 || l > 3)) { let u = 0; let c = 0; let d = 0; u = parseInt(h[0], 10), l > 1 && h[1] !== '' && (c = parseInt(h[1], 10)), l > 2 && (d = parseInt(h[2], 10)), u !== 0 && (u < 0 && (u = o(e).vertices.length + 1 + u), c -= 1, u -= 1, d -= 1, r.vertices.push({ textureCoordsIndex: c, vertexIndex: u, vertexNormalIndex: d })) } } o(e).faces.push(r) } } function f (t, e) { t.length >= 2 && e.materialLibraries.push(t[1]) } function p (t) { t.length >= 2 && (n = t[1]) } t.exports = function (t, i) { void 0 === i && (i = !0), e = i; const o = { materials: {}, materialLibraries: [], models: [] }; s = '', n = ''; for (let v = t.split('\n'), g = 0; g < v.length; g++) { const m = r(v[g]).replace(/\s\s+/g, ' ').trim().split(' '); switch (m[0].toLowerCase()) { case 'o': a(m, o); break; case 'g': h(m); break; case 'v': l(m, o); break; case 'vt': u(m, o); break; case 'vn': c(m, o); break; case 'f': d(m, o); break; case 'mtllib': f(m, o); break; case 'usemtl': p(m) } } return o } }, 61485: (t, e, i) => { const s = i(37589); t.exports = function (t) { for (var e = {}, i = t.split('\n'), n = '', r = 0; r < i.length; r++) { const o = i[r].trim(); if (o.indexOf('#') !== 0 && o !== '') { const a = o.replace(/\s\s+/g, ' ').trim().split(' '); switch (a[0].toLowerCase()) { case 'newmtl': n = a[1]; break; case 'kd': var h = Math.floor(255 * a[1]); var l = a.length >= 2 ? Math.floor(255 * a[2]) : h; var u = a.length >= 3 ? Math.floor(255 * a[3]) : h; e[n] = s(h, l, u) } } } return e } }, 92570: t => { t.exports = function (t, e, i, s) { let n, r; if (void 0 === i && void 0 === s) { const o = t.getInCenter(); n = o.x, r = o.y } const a = Math.cos(e); const h = Math.sin(e); const l = t.vertex1; const u = t.vertex2; const c = t.vertex3; let d = l.x - n; let f = l.y - r; l.set(d * a - f * h + n, d * h + f * a + r), d = u.x - n, f = u.y - r, u.set(d * a - f * h + n, d * h + f * a + r), d = c.x - n, f = c.y - r, c.set(d * a - f * h + n, d * h + f * a + r) } }, 39318: (t, e, i) => { const s = i(83419); const n = i(70554); const r = i(25836); const o = new s({ Extends: r, initialize: function (t, e, i, s, n, o, a, h, l, u) { void 0 === o && (o = 16777215), void 0 === a && (a = 1), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === u && (u = 0), r.call(this, t, e, i), this.vx = 0, this.vy = 0, this.vz = 0, this.nx = h, this.ny = l, this.nz = u, this.u = s, this.v = n, this.color = o, this.alpha = a, this.tx = 0, this.ty = 0, this.ta = 0, this.tu = s, this.tv = n }, setUVs: function (t, e) { return this.u = t, this.v = e, this.tu = t, this.tv = e, this }, scrollUV: function (t, e) { return this.tu += t, this.tv += e, this }, scaleUV: function (t, e) { return this.tu = this.u * t, this.tv = this.v * e, this }, transformCoordinatesLocal: function (t, e, i, s) { const n = this.x; const r = this.y; const o = this.z; const a = t.val; const h = n * a[0] + r * a[4] + o * a[8] + a[12]; const l = n * a[1] + r * a[5] + o * a[9] + a[13]; const u = n * a[2] + r * a[6] + o * a[10] + a[14]; const c = n * a[3] + r * a[7] + o * a[11] + a[15]; this.vx = h / c * e, this.vy = -l / c * i, this.vz = s <= 0 ? u / c : -u / c }, resize: function (t, e, i, s, n, r) { return this.x = t, this.y = e, this.vx = this.x * i, this.vy = -this.y * s, this.vz = 0, n < 0.5 ? this.vx += i * (0.5 - n) : n > 0.5 && (this.vx -= i * (n - 0.5)), r < 0.5 ? this.vy += s * (0.5 - r) : r > 0.5 && (this.vy -= s * (r - 0.5)), this }, update: function (t, e, i, s, n, r, o, a) { let h = this.vx * t + this.vy * i + n; let l = this.vx * e + this.vy * s + r; return o && (h = Math.round(h), l = Math.round(l)), this.tx = h, this.ty = l, this.ta = this.alpha * a, this }, load: function (t, e, i, s, r) { return t[++i] = this.tx, t[++i] = this.ty, t[++i] = this.tu, t[++i] = this.tv, t[++i] = s, t[++i] = r, e[++i] = n.getTintAppendFloatAlpha(this.color, this.ta), i } }); t.exports = o }, 73090: (t, e, i) => { const s = { Face: i(83997), GenerateGridVerts: i(48803), GenerateObjVerts: i(34684), GenerateVerts: i(92515), ParseObj: i(85048), ParseObjMaterial: i(61485), RotateFace: i(92570), Vertex: i(39318) }; t.exports = s }, 96550: t => { t.exports = function (t) { return t.setTo(Math.ceil(t.x), Math.ceil(t.y)) } }, 99706: (t, e, i) => { const s = i(2141); t.exports = function (t) { return new s(t.x, t.y) } }, 68010: t => { t.exports = function (t, e) { return e.setTo(t.x, t.y) } }, 27814: t => { t.exports = function (t, e) { return t.x === e.x && t.y === e.y } }, 73565: t => { t.exports = function (t) { return t.setTo(Math.floor(t.x), Math.floor(t.y)) } }, 87555: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { if (void 0 === e && (e = new s()), !Array.isArray(t)) throw new Error('GetCentroid points argument must be an array'); const i = t.length; if (i < 1) throw new Error('GetCentroid points array must not be empty'); if (i === 1) e.x = t[0].x, e.y = t[0].y; else { for (let n = 0; n < i; n++)e.x += t[n].x, e.y += t[n].y; e.x /= i, e.y /= i } return e } }, 28793: t => { t.exports = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y) } }, 44405: t => { t.exports = function (t) { return t.x * t.x + t.y * t.y } }, 20873: (t, e, i) => { const s = i(87841); t.exports = function (t, e) { void 0 === e && (e = new s()); for (var i = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = 0; a < t.length; a++) { const h = t[a]; h.x > i && (i = h.x), h.x < n && (n = h.x), h.y > r && (r = h.y), h.y < o && (o = h.y) } return e.x = n, e.y = o, e.width = i - n, e.height = r - o, e } }, 26152: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = new s()), n.x = t.x + (e.x - t.x) * i, n.y = t.y + (e.y - t.y) * i, n } }, 55767: t => { t.exports = function (t) { return t.setTo(t.y, t.x) } }, 79432: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.setTo(-t.x, -t.y) } }, 2141: (t, e, i) => { const s = i(83419); const n = i(23777); const r = new s({ initialize: function (t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.type = n.POINT, this.x = t, this.y = e }, setTo: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this } }); t.exports = r }, 72930: (t, e, i) => { const s = i(2141); const n = i(44405); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const r = (t.x * e.x + t.y * e.y) / n(e); return r !== 0 && (i.x = r * e.x, i.y = r * e.y), i } }, 62880: (t, e, i) => { const s = i(2141); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = t.x * e.x + t.y * e.y; return n !== 0 && (i.x = n * e.x, i.y = n * e.y), i } }, 15093: (t, e, i) => { const s = i(28793); t.exports = function (t, e) { if (t.x !== 0 || t.y !== 0) { const i = s(t); t.x /= i, t.y /= i } return t.x *= e, t.y *= e, t } }, 43711: (t, e, i) => { const s = i(2141); s.Ceil = i(96550), s.Clone = i(99706), s.CopyFrom = i(68010), s.Equals = i(27814), s.Floor = i(73565), s.GetCentroid = i(87555), s.GetMagnitude = i(28793), s.GetMagnitudeSq = i(44405), s.GetRectangleFromPoints = i(20873), s.Interpolate = i(26152), s.Invert = i(55767), s.Negative = i(79432), s.Project = i(72930), s.ProjectUnit = i(62880), s.SetMagnitude = i(15093), t.exports = s }, 12306: (t, e, i) => { const s = i(25717); t.exports = function (t) { return new s(t.points) } }, 63814: t => { t.exports = function (t, e, i) { for (var s = !1, n = -1, r = t.points.length - 1; ++n < t.points.length; r = n) { const o = t.points[n].x; const a = t.points[n].y; const h = t.points[r].x; const l = t.points[r].y; (a <= i && i < l || l <= i && i < a) && e < (h - o) * (i - a) / (l - a) + o && (s = !s) } return s } }, 99338: (t, e, i) => { const s = i(63814); t.exports = function (t, e) { return s(t, e.x, e.y) } }, 94811: t => { 'use strict'; function e (t, e, s) { s = s || 2; let r; let o; let a; let h; let c; let d; let p; const v = e && e.length; const g = v ? e[0] * s : t.length; let m = i(t, 0, g, s, !0); const y = []; if (!m || m.next === m.prev) return y; if (v && (m = (function (t, e, s, n) { let r; let o; let a; const h = []; for (r = 0, o = e.length; r < o; r++)(a = i(t, e[r] * n, r < o - 1 ? e[r + 1] * n : t.length, n, !1)) === a.next && (a.steiner = !0), h.push(f(a)); for (h.sort(l), r = 0; r < h.length; r++)s = u(h[r], s); return s }(t, e, m, s))), t.length > 80 * s) { r = a = t[0], o = h = t[1]; for (let x = s; x < g; x += s)(c = t[x]) < r && (r = c), (d = t[x + 1]) < o && (o = d), c > a && (a = c), d > h && (h = d); p = (p = Math.max(a - r, h - o)) !== 0 ? 32767 / p : 0 } return n(m, y, s, r, o, p, 0), y } function i (t, e, i, s, n) { let r, o; if (n === C(t, e, i, s) > 0) for (r = e; r < i; r += s)o = S(r, t[r], t[r + 1], o); else for (r = i - s; r >= e; r -= s)o = S(r, t[r], t[r + 1], o); return o && m(o, o.next) && (E(o), o = o.next), o } function s (t, e) { if (!t) return t; e || (e = t); let i; let s = t; do { if (i = !1, s.steiner || !m(s, s.next) && g(s.prev, s, s.next) !== 0) s = s.next; else { if (E(s), (s = e = s.prev) === s.next) break; i = !0 } } while (i || s !== e); return e } function n (t, e, i, l, u, c, f) { if (t) { !f && c && (function (t, e, i, s) { let n = t; do { n.z === 0 && (n.z = d(n.x, n.y, e, i, s)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t); n.prevZ.nextZ = null, n.prevZ = null, (function (t) { let e; let i; let s; let n; let r; let o; let a; let h; let l = 1; do { for (i = t, t = null, r = null, o = 0; i;) { for (o++, s = i, a = 0, e = 0; e < l && (a++, s = s.nextZ); e++); for (h = l; a > 0 || h > 0 && s;)a !== 0 && (h === 0 || !s || i.z <= s.z) ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, h--), r ? r.nextZ = n : t = n, n.prevZ = r, r = n; i = s } r.nextZ = null, l *= 2 } while (o > 1) }(n)) }(t, l, u, c)); for (var p, v, g = t; t.prev !== t.next;) if (p = t.prev, v = t.next, c ? o(t, l, u, c) : r(t)) e.push(p.i / i | 0), e.push(t.i / i | 0), e.push(v.i / i | 0), E(t), t = v.next, g = v.next; else if ((t = v) === g) { f ? f === 1 ? n(t = a(s(t), e, i), e, i, l, u, c, 2) : f === 2 && h(t, e, i, l, u, c) : n(s(t), e, i, l, u, c, 1); break } } } function r (t) { const e = t.prev; const i = t; const s = t.next; if (g(e, i, s) >= 0) return !1; for (let n = e.x, r = i.x, o = s.x, a = e.y, h = i.y, l = s.y, u = n < r ? n < o ? n : o : r < o ? r : o, c = a < h ? a < l ? a : l : h < l ? h : l, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > h ? a > l ? a : l : h > l ? h : l, v = s.next; v !== e;) { if (v.x >= u && v.x <= d && v.y >= c && v.y <= f && p(n, a, r, h, o, l, v.x, v.y) && g(v.prev, v, v.next) >= 0) return !1; v = v.next } return !0 } function o (t, e, i, s) { const n = t.prev; const r = t; const o = t.next; if (g(n, r, o) >= 0) return !1; for (var a = n.x, h = r.x, l = o.x, u = n.y, c = r.y, f = o.y, v = a < h ? a < l ? a : l : h < l ? h : l, m = u < c ? u < f ? u : f : c < f ? c : f, y = a > h ? a > l ? a : l : h > l ? h : l, x = u > c ? u > f ? u : f : c > f ? c : f, T = d(v, m, e, i, s), w = d(y, x, e, i, s), b = t.prevZ, S = t.nextZ; b && b.z >= T && S && S.z <= w;) { if (b.x >= v && b.x <= y && b.y >= m && b.y <= x && b !== n && b !== o && p(a, u, h, c, l, f, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1; if (b = b.prevZ, S.x >= v && S.x <= y && S.y >= m && S.y <= x && S !== n && S !== o && p(a, u, h, c, l, f, S.x, S.y) && g(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } for (; b && b.z >= T;) { if (b.x >= v && b.x <= y && b.y >= m && b.y <= x && b !== n && b !== o && p(a, u, h, c, l, f, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1; b = b.prevZ } for (; S && S.z <= w;) { if (S.x >= v && S.x <= y && S.y >= m && S.y <= x && S !== n && S !== o && p(a, u, h, c, l, f, S.x, S.y) && g(S.prev, S, S.next) >= 0) return !1; S = S.nextZ } return !0 } function a (t, e, i) { let n = t; do { const r = n.prev; const o = n.next.next; !m(r, o) && y(r, n, n.next, o) && w(r, o) && w(o, r) && (e.push(r.i / i | 0), e.push(n.i / i | 0), e.push(o.i / i | 0), E(n), E(n.next), n = t = o), n = n.next } while (n !== t); return s(n) } function h (t, e, i, r, o, a) { let h = t; do { for (let l = h.next.next; l !== h.prev;) { if (h.i !== l.i && v(h, l)) { let u = b(h, l); return h = s(h, h.next), u = s(u, u.next), n(h, e, i, r, o, a, 0), void n(u, e, i, r, o, a, 0) } l = l.next } h = h.next } while (h !== t) } function l (t, e) { return t.x - e.x } function u (t, e) { const i = (function (t, e) { let i; let s = e; const n = t.x; const r = t.y; let o = -1 / 0; do { if (r <= s.y && r >= s.next.y && s.next.y !== s.y) { const a = s.x + (r - s.y) * (s.next.x - s.x) / (s.next.y - s.y); if (a <= n && a > o && (o = a, i = s.x < s.next.x ? s : s.next, a === n)) return i } s = s.next } while (s !== e); if (!i) return null; let h; const l = i; const u = i.x; const d = i.y; let f = 1 / 0; s = i; do { n >= s.x && s.x >= u && n !== s.x && p(r < d ? n : o, r, u, d, r < d ? o : n, r, s.x, s.y) && (h = Math.abs(r - s.y) / (n - s.x), w(s, t) && (h < f || h === f && (s.x > i.x || s.x === i.x && c(i, s))) && (i = s, f = h)), s = s.next } while (s !== l); return i }(t, e)); if (!i) return e; const n = b(i, t); return s(n, n.next), s(i, i.next) } function c (t, e) { return g(t.prev, t, e.prev) < 0 && g(e.next, t, t.next) < 0 } function d (t, e, i, s, n) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * n | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - s) * n | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function f (t) { let e = t; let i = t; do { (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next } while (e !== t); return i } function p (t, e, i, s, n, r, o, a) { return (n - o) * (e - a) >= (t - o) * (r - a) && (t - o) * (s - a) >= (i - o) * (e - a) && (i - o) * (r - a) >= (n - o) * (s - a) } function v (t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && y(i, i.next, t, e)) return !0; i = i.next } while (i !== t); return !1 }(t, e)) && (w(t, e) && w(e, t) && (function (t, e) { let i = t; let s = !1; const n = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; do { i.y > r != i.next.y > r && i.next.y !== i.y && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next } while (i !== t); return s }(t, e)) && (g(t.prev, t, e.prev) || g(t, e.prev, e)) || m(t, e) && g(t.prev, t, t.next) > 0 && g(e.prev, e, e.next) > 0) } function g (t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) } function m (t, e) { return t.x === e.x && t.y === e.y } function y (t, e, i, s) { const n = T(g(t, e, i)); const r = T(g(t, e, s)); const o = T(g(i, s, t)); const a = T(g(i, s, e)); return n !== r && o !== a || (!(n !== 0 || !x(t, i, e)) || (!(r !== 0 || !x(t, s, e)) || (!(o !== 0 || !x(i, t, s)) || !(a !== 0 || !x(i, e, s))))) } function x (t, e, i) { return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y) } function T (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function w (t, e) { return g(t.prev, t, t.next) < 0 ? g(t, e, t.next) >= 0 && g(t, t.prev, e) >= 0 : g(t, e, t.prev) < 0 || g(t, t.next, e) < 0 } function b (t, e) { const i = new A(t.i, t.x, t.y); const s = new A(e.i, e.x, e.y); const n = t.next; const r = e.prev; return t.next = e, e.prev = t, i.next = n, n.prev = i, s.next = i, i.prev = s, r.next = s, s.prev = r, s } function S (t, e, i, s) { const n = new A(t, e, i); return s ? (n.next = s.next, n.prev = s, s.next.prev = n, s.next = n) : (n.prev = n, n.next = n), n } function E (t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function A (t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function C (t, e, i, s) { for (var n = 0, r = e, o = i - s; r < i; r += s)n += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return n } e.deviation = function (t, e, i, s) { const n = e && e.length; const r = n ? e[0] * i : t.length; let o = Math.abs(C(t, 0, r, i)); if (n) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(C(t, l, u, i)) } let c = 0; for (a = 0; a < s.length; a += 3) { const d = s[a] * i; const f = s[a + 1] * i; const p = s[a + 2] * i; c += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1])) } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o) }, e.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, s = 0, n = 0; n < t.length; n++) { for (let r = 0; r < t[n].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[n][r][o]); n > 0 && (s += t[n - 1].length, i.holes.push(s)) } return i }, t.exports = e }, 13829: (t, e, i) => { const s = i(87841); t.exports = function (t, e) { void 0 === e && (e = new s()); for (var i, n = 1 / 0, r = 1 / 0, o = -n, a = -r, h = 0; h < t.points.length; h++)i = t.points[h], n = Math.min(n, i.x), r = Math.min(r, i.y), o = Math.max(o, i.x), a = Math.max(a, i.y); return e.x = n, e.y = r, e.width = o - n, e.height = a - r, e } }, 26173: t => { t.exports = function (t, e) { void 0 === e && (e = []); for (let i = 0; i < t.points.length; i++)e.push(t.points[i].x), e.push(t.points[i].y); return e } }, 9564: (t, e, i) => { const s = i(35001); const n = i(23031); const r = i(30052); t.exports = function (t, e, i, o) { void 0 === o && (o = []); const a = t.points; const h = r(t); !e && i > 0 && (e = h / i); for (let l = 0; l < e; l++) for (let u = h * (l / e), c = 0, d = 0; d < a.length; d++) { const f = a[d]; const p = a[(d + 1) % a.length]; const v = new n(f.x, f.y, p.x, p.y); const g = s(v); if (!(u < c || u > c + g)) { const m = v.getPoint((u - c) / g); o.push(m); break } c += g } return o } }, 30052: (t, e, i) => { const s = i(35001); const n = i(23031); t.exports = function (t) { for (var e = t.points, i = 0, r = 0; r < e.length; r++) { const o = e[r]; const a = e[(r + 1) % e.length]; const h = new n(o.x, o.y, a.x, a.y); i += s(h) } return i } }, 25717: (t, e, i) => { const s = i(83419); const n = i(63814); const r = i(9564); const o = i(23777); const a = new s({ initialize: function (t) { this.type = o.POLYGON, this.area = 0, this.points = [], t && this.setTo(t) }, contains: function (t, e) { return n(this, t, e) }, setTo: function (t) { if (this.area = 0, this.points = [], typeof t === 'string' && (t = t.split(' ')), !Array.isArray(t)) return this; for (var e, i = 0; i < t.length; i++)e = { x: 0, y: 0 }, typeof t[i] === 'number' || typeof t[i] === 'string' ? (e.x = parseFloat(t[i]), e.y = parseFloat(t[i + 1]), i++) : Array.isArray(t[i]) ? (e.x = t[i][0], e.y = t[i][1]) : (e.x = t[i].x, e.y = t[i].y), this.points.push(e); return this.calculateArea(), this }, calculateArea: function () { if (this.points.length < 3) return this.area = 0, this.area; for (var t, e, i = 0, s = 0; s < this.points.length - 1; s++)t = this.points[s], i += ((e = this.points[s + 1]).x - t.x) * (t.y + e.y); return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = 0.5 * -i, this.area }, getPoints: function (t, e, i) { return r(this, t, e, i) } }); t.exports = a }, 8133: t => { t.exports = function (t) { return t.points.reverse(), t } }, 29524: t => { function e (t, e, i) { let s = e.x; let n = e.y; let r = i.x - s; let o = i.y - n; if (r !== 0 || o !== 0) { const a = ((t.x - s) * r + (t.y - n) * o) / (r * r + o * o); a > 1 ? (s = i.x, n = i.y) : a > 0 && (s += r * a, n += o * a) } return (r = t.x - s) * r + (o = t.y - n) * o } function i (t, s, n, r, o) { for (var a, h = r, l = s + 1; l < n; l++) { const u = e(t[l], t[s], t[n]); u > h && (a = l, h = u) } h > r && (a - s > 1 && i(t, s, a, r, o), o.push(t[a]), n - a > 1 && i(t, a, n, r, o)) } function s (t, e) { const s = t.length - 1; const n = [t[0]]; return i(t, 0, s, e, n), n.push(t[s]), n } t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = !1); let n = t.points; if (n.length > 2) { const r = e * e; i || (n = (function (t, e) { for (var i, s, n, r, o, a = t[0], h = [a], l = 1, u = t.length; l < u; l++)i = t[l], n = a, r = void 0, o = void 0, r = (s = i).x - n.x, o = s.y - n.y, r * r + o * o > e && (h.push(i), a = i); return a !== i && h.push(i), h }(n, r))), t.setTo(s(n, r)) } return t } }, 5469: t => { const e = function (t, e) { return t[0] = e[0], t[1] = e[1], t }; t.exports = function (t) { let i; const s = []; const n = t.points; for (i = 0; i < n.length; i++)s.push([n[i].x, n[i].y]); const r = []; for (s.length > 0 && r.push(e([0, 0], s[0])), i = 0; i < s.length - 1; i++) { const o = s[i]; const a = s[i + 1]; const h = o[0]; const l = o[1]; const u = a[0]; const c = a[1]; r.push([0.85 * h + 0.15 * u, 0.85 * l + 0.15 * c]), r.push([0.15 * h + 0.85 * u, 0.15 * l + 0.85 * c]) } return s.length > 1 && r.push(e([0, 0], s[s.length - 1])), t.setTo(r) } }, 24709: t => { t.exports = function (t, e, i) { for (let s = t.points, n = 0; n < s.length; n++)s[n].x += e, s[n].y += i; return t } }, 58423: (t, e, i) => { const s = i(25717); s.Clone = i(12306), s.Contains = i(63814), s.ContainsPoint = i(99338), s.Earcut = i(94811), s.GetAABB = i(13829), s.GetNumberArray = i(26173), s.GetPoints = i(9564), s.Perimeter = i(30052), s.Reverse = i(8133), s.Simplify = i(29524), s.Smooth = i(5469), s.Translate = i(24709), t.exports = s }, 62224: t => { t.exports = function (t) { return t.width * t.height } }, 98615: t => { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t } }, 31688: t => { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t } }, 67502: t => { t.exports = function (t, e, i) { return t.x = e - t.width / 2, t.y = i - t.height / 2, t } }, 65085: (t, e, i) => { const s = i(87841); t.exports = function (t) { return new s(t.x, t.y, t.width, t.height) } }, 37303: t => { t.exports = function (t, e, i) { return !(t.width <= 0 || t.height <= 0) && (t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i) } }, 96553: (t, e, i) => { const s = i(37303); t.exports = function (t, e) { return s(t, e.x, e.y) } }, 70273: t => { t.exports = function (t, e) { return !(e.width * e.height > t.width * t.height) && (e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom) } }, 43459: t => { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height) } }, 77493: t => { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x, y: t.y }), e.push({ x: t.right, y: t.y }), e.push({ x: t.right, y: t.bottom }), e.push({ x: t.x, y: t.bottom }), e } }, 9219: t => { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height } }, 53751: (t, e, i) => { const s = i(8249); t.exports = function (t, e) { const i = s(t); return i < s(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2) } }, 16088: (t, e, i) => { const s = i(8249); t.exports = function (t, e) { const i = s(t); return i > s(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2) } }, 80774: t => { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t } }, 83859: t => { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t } }, 19217: (t, e, i) => { const s = i(87841); const n = i(36383); t.exports = function (t, e) { if (void 0 === e && (e = new s()), t.length === 0) return e; for (var i, r, o, a = Number.MAX_VALUE, h = Number.MAX_VALUE, l = n.MIN_SAFE_INTEGER, u = n.MIN_SAFE_INTEGER, c = 0; c < t.length; c++)i = t[c], Array.isArray(i) ? (r = i[0], o = i[1]) : (r = i.x, o = i.y), a = Math.min(a, r), h = Math.min(h, o), l = Math.max(l, r), u = Math.max(u, o); return e.x = a, e.y = h, e.width = l - a, e.height = u - h, e } }, 9477: (t, e, i) => { const s = i(87841); t.exports = function (t, e, i, n, r) { return void 0 === r && (r = new s()), r.setTo(Math.min(t, i), Math.min(e, n), Math.abs(t - i), Math.abs(e - n)) } }, 8249: t => { t.exports = function (t) { return t.height === 0 ? NaN : t.width / t.height } }, 27165: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = t.centerX, e.y = t.centerY, e } }, 20812: (t, e, i) => { const s = i(13019); const n = i(2141); t.exports = function (t, e, i) { if (void 0 === i && (i = new n()), e <= 0 || e >= 1) return i.x = t.x, i.y = t.y, i; let r = s(t) * e; return e > 0.5 ? (r -= t.width + t.height) <= t.width ? (i.x = t.right - r, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (r - t.width)) : r <= t.width ? (i.x = t.x + r, i.y = t.y) : (i.x = t.right, i.y = t.y + (r - t.width)), i } }, 34819: (t, e, i) => { const s = i(20812); const n = i(13019); t.exports = function (t, e, i, r) { void 0 === r && (r = []), !e && i > 0 && (e = n(t) / i); for (let o = 0; o < e; o++) { const a = o / e; r.push(s(t, a)) } return r } }, 51313: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = t.width, e.y = t.height, e } }, 86091: (t, e, i) => { const s = i(67502); t.exports = function (t, e, i) { const n = t.centerX; const r = t.centerY; return t.setSize(t.width + 2 * e, t.height + 2 * i), s(t, n, r) } }, 53951: (t, e, i) => { const s = i(87841); const n = i(59996); t.exports = function (t, e, i) { return void 0 === i && (i = new s()), n(t, e) ? (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y) : i.setEmpty(), i } }, 14649: (t, e, i) => { const s = i(13019); const n = i(2141); t.exports = function (t, e, i, r) { if (void 0 === r && (r = []), !e && !i) return r; e ? i = Math.round(s(t) / e) : e = s(t) / i; for (let o = t.x, a = t.y, h = 0, l = 0; l < i; l++) switch (r.push(new n(o, a)), h) { case 0: (o += e) >= t.right && (h = 1, a += o - t.right, o = t.right); break; case 1: (a += e) >= t.bottom && (h = 2, o -= a - t.bottom, a = t.bottom); break; case 2: (o -= e) <= t.left && (h = 3, a -= t.left - o, o = t.left); break; case 3: (a -= e) <= t.top && (h = 0, a = t.top) } return r } }, 33595: t => { t.exports = function (t, e) { for (var i = t.x, s = t.right, n = t.y, r = t.bottom, o = 0; o < e.length; o++)i = Math.min(i, e[o].x), s = Math.max(s, e[o].x), n = Math.min(n, e[o].y), r = Math.max(r, e[o].y); return t.x = i, t.y = n, t.width = s - i, t.height = r - n, t } }, 20074: t => { t.exports = function (t, e) { const i = Math.min(t.x, e.x); const s = Math.max(t.right, e.right); t.x = i, t.width = s - i; const n = Math.min(t.y, e.y); const r = Math.max(t.bottom, e.bottom); return t.y = n, t.height = r - n, t } }, 92171: t => { t.exports = function (t, e, i) { const s = Math.min(t.x, e); const n = Math.max(t.right, e); t.x = s, t.width = n - s; const r = Math.min(t.y, i); const o = Math.max(t.bottom, i); return t.y = r, t.height = o - r, t } }, 42981: t => { t.exports = function (t, e, i) { return t.x += e, t.y += i, t } }, 46907: t => { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t } }, 60170: t => { t.exports = function (t, e) { return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y } }, 13019: t => { t.exports = function (t) { return 2 * (t.width + t.height) } }, 85133: (t, e, i) => { const s = i(2141); const n = i(39506); t.exports = function (t, e, i) { void 0 === i && (i = new s()), e = n(e); const r = Math.sin(e); const o = Math.cos(e); let a = o > 0 ? t.width / 2 : t.width / -2; let h = r > 0 ? t.height / 2 : t.height / -2; return Math.abs(a * r) < Math.abs(h * o) ? h = a * r / o : a = h * o / r, i.x = a + t.centerX, i.y = h + t.centerY, i } }, 26597: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e } }, 86470: (t, e, i) => { const s = i(30976); const n = i(70273); const r = i(2141); t.exports = function (t, e, i) { if (void 0 === i && (i = new r()), n(t, e)) switch (s(0, 3)) { case 0: i.x = t.x + Math.random() * (e.right - t.x), i.y = t.y + Math.random() * (e.top - t.y); break; case 1: i.x = e.x + Math.random() * (t.right - e.x), i.y = e.bottom + Math.random() * (t.bottom - e.bottom); break; case 2: i.x = t.x + Math.random() * (e.x - t.x), i.y = e.y + Math.random() * (t.bottom - e.y); break; case 3: i.x = e.right + Math.random() * (t.right - e.right), i.y = t.y + Math.random() * (e.bottom - t.y) } return i } }, 87841: (t, e, i) => { const s = i(83419); const n = i(37303); const r = i(20812); const o = i(34819); const a = i(23777); const h = i(23031); const l = i(26597); const u = new s({ initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.type = a.RECTANGLE, this.x = t, this.y = e, this.width = i, this.height = s }, contains: function (t, e) { return n(this, t, e) }, getPoint: function (t, e) { return r(this, t, e) }, getPoints: function (t, e, i) { return o(this, t, e, i) }, getRandomPoint: function (t) { return l(this, t) }, setTo: function (t, e, i, s) { return this.x = t, this.y = e, this.width = i, this.height = s, this }, setEmpty: function () { return this.setTo(0, 0, 0, 0) }, setPosition: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this }, setSize: function (t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this }, isEmpty: function () { return this.width <= 0 || this.height <= 0 }, getLineA: function (t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.y, this.right, this.y), t }, getLineB: function (t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.y, this.right, this.bottom), t }, getLineC: function (t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.bottom, this.x, this.bottom), t }, getLineD: function (t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.bottom, this.x, this.y), t }, left: { get: function () { return this.x }, set: function (t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t } }, right: { get: function () { return this.x + this.width }, set: function (t) { t <= this.x ? this.width = 0 : this.width = t - this.x } }, top: { get: function () { return this.y }, set: function (t) { t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t } }, bottom: { get: function () { return this.y + this.height }, set: function (t) { t <= this.y ? this.height = 0 : this.height = t - this.y } }, centerX: { get: function () { return this.x + this.width / 2 }, set: function (t) { this.x = t - this.width / 2 } }, centerY: { get: function () { return this.y + this.height / 2 }, set: function (t) { this.y = t - this.height / 2 } } }); t.exports = u }, 94845: t => { t.exports = function (t, e) { return t.width === e.width && t.height === e.height } }, 31730: t => { t.exports = function (t, e, i) { return void 0 === i && (i = e), t.width *= e, t.height *= i, t } }, 36899: (t, e, i) => { const s = i(87841); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const n = Math.min(t.x, e.x); const r = Math.min(t.y, e.y); const o = Math.max(t.right, e.right) - n; const a = Math.max(t.bottom, e.bottom) - r; return i.setTo(n, r, o, a) } }, 93232: (t, e, i) => { const s = i(87841); s.Area = i(62224), s.Ceil = i(98615), s.CeilAll = i(31688), s.CenterOn = i(67502), s.Clone = i(65085), s.Contains = i(37303), s.ContainsPoint = i(96553), s.ContainsRect = i(70273), s.CopyFrom = i(43459), s.Decompose = i(77493), s.Equals = i(9219), s.FitInside = i(53751), s.FitOutside = i(16088), s.Floor = i(80774), s.FloorAll = i(83859), s.FromPoints = i(19217), s.FromXY = i(9477), s.GetAspectRatio = i(8249), s.GetCenter = i(27165), s.GetPoint = i(20812), s.GetPoints = i(34819), s.GetSize = i(51313), s.Inflate = i(86091), s.Intersection = i(53951), s.MarchingAnts = i(14649), s.MergePoints = i(33595), s.MergeRect = i(20074), s.MergeXY = i(92171), s.Offset = i(42981), s.OffsetPoint = i(46907), s.Overlaps = i(60170), s.Perimeter = i(13019), s.PerimeterPoint = i(85133), s.Random = i(26597), s.RandomOutside = i(86470), s.SameDimensions = i(94845), s.Scale = i(31730), s.Union = i(36899), t.exports = s }, 41658: t => { t.exports = function (t) { const e = t.x1; const i = t.y1; const s = t.x2; const n = t.y2; const r = t.x3; const o = t.y3; return Math.abs(((r - e) * (n - i) - (s - e) * (o - i)) / 2) } }, 39208: (t, e, i) => { const s = i(16483); t.exports = function (t, e, i) { const n = i * (Math.sqrt(3) / 2); return new s(t, e, t + i / 2, e + n, t - i / 2, e + n) } }, 39545: (t, e, i) => { const s = i(94811); const n = i(16483); t.exports = function (t, e, i, r, o) { void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = []); for (var a, h, l, u, c, d, f, p, v, g = s(t, e), m = 0; m < g.length; m += 3)a = g[m], h = g[m + 1], l = g[m + 2], u = t[2 * a] * i, c = t[2 * a + 1] * r, d = t[2 * h] * i, f = t[2 * h + 1] * r, p = t[2 * l] * i, v = t[2 * l + 1] * r, o.push(new n(u, c, d, f, p, v)); return o } }, 90301: (t, e, i) => { const s = i(16483); t.exports = function (t, e, i, n) { return void 0 === n && (n = i), new s(t, e, t, e - n, t + i, e) } }, 23707: (t, e, i) => { const s = i(97523); const n = i(13584); t.exports = function (t, e, i, r) { void 0 === r && (r = s); const o = r(t); const a = e - o.x; const h = i - o.y; return n(t, a, h) } }, 97523: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { return void 0 === e && (e = new s()), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e } }, 24951: (t, e, i) => { const s = i(26099); function n (t, e, i, s) { return t * s - e * i } t.exports = function (t, e) { void 0 === e && (e = new s()); const i = t.x3; const r = t.y3; const o = t.x1 - i; const a = t.y1 - r; const h = t.x2 - i; const l = t.y2 - r; const u = 2 * n(o, a, h, l); const c = n(a, o * o + a * a, l, h * h + l * l); const d = n(o, o * o + a * a, h, h * h + l * l); return e.x = i - c / u, e.y = r + d / u, e } }, 85614: (t, e, i) => { const s = i(96503); t.exports = function (t, e) { void 0 === e && (e = new s()); let i; let n; const r = t.x1; const o = t.y1; const a = t.x2; const h = t.y2; const l = t.x3; const u = t.y3; const c = a - r; const d = h - o; const f = l - r; const p = u - o; const v = c * (r + a) + d * (o + h); const g = f * (r + l) + p * (o + u); const m = 2 * (c * (u - h) - d * (l - a)); if (Math.abs(m) < 1e-6) { const y = Math.min(r, a, l); const x = Math.min(o, h, u); i = 0.5 * (Math.max(r, a, l) - y), n = 0.5 * (Math.max(o, h, u) - x), e.x = y + i, e.y = x + n, e.radius = Math.sqrt(i * i + n * n) } else e.x = (p * v - d * g) / m, e.y = (c * g - f * v) / m, i = e.x - r, n = e.y - o, e.radius = Math.sqrt(i * i + n * n); return e } }, 74422: (t, e, i) => { const s = i(16483); t.exports = function (t) { return new s(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3) } }, 10690: t => { t.exports = function (t, e, i) { const s = t.x3 - t.x1; const n = t.y3 - t.y1; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e - t.x1; const h = i - t.y1; const l = s * s + n * n; const u = s * r + n * o; const c = s * a + n * h; const d = r * r + o * o; const f = r * a + o * h; const p = l * d - u * u; const v = p === 0 ? 0 : 1 / p; const g = (d * c - u * f) * v; const m = (l * f - u * c) * v; return g >= 0 && m >= 0 && g + m < 1 } }, 48653: t => { t.exports = function (t, e, i, s) { void 0 === i && (i = !1), void 0 === s && (s = []); for (var n, r, o, a, h, l, u = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = u * u + c * c, v = u * d + c * f, g = d * d + f * f, m = p * g - v * v, y = m === 0 ? 0 : 1 / m, x = t.x1, T = t.y1, w = 0; w < e.length && (r = (p * (l = d * (o = e[w].x - x) + f * (a = e[w].y - T)) - v * (h = u * o + c * a)) * y, !((n = (g * h - v * l) * y) >= 0 && r >= 0 && n + r < 1 && (s.push({ x: e[w].x, y: e[w].y }), i))); w++); return s } }, 96006: (t, e, i) => { const s = i(10690); t.exports = function (t, e) { return s(t, e.x, e.y) } }, 71326: t => { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3) } }, 71694: t => { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x1, y: t.y1 }), e.push({ x: t.x2, y: t.y2 }), e.push({ x: t.x3, y: t.y3 }), e } }, 33522: t => { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3 } }, 20437: (t, e, i) => { const s = i(2141); const n = i(35001); t.exports = function (t, e, i) { void 0 === i && (i = new s()); const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); if (e <= 0 || e >= 1) return i.x = r.x1, i.y = r.y1, i; const h = n(r); const l = n(o); const u = n(a); let c = (h + l + u) * e; let d = 0; return c < h ? (d = c / h, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) : c > h + l ? (d = (c -= h + l) / u, i.x = a.x1 + (a.x2 - a.x1) * d, i.y = a.y1 + (a.y2 - a.y1) * d) : (d = (c -= h) / l, i.x = o.x1 + (o.x2 - o.x1) * d, i.y = o.y1 + (o.y2 - o.y1) * d), i } }, 80672: (t, e, i) => { const s = i(35001); const n = i(2141); t.exports = function (t, e, i, r) { void 0 === r && (r = []); const o = t.getLineA(); const a = t.getLineB(); const h = t.getLineC(); const l = s(o); const u = s(a); const c = s(h); const d = l + u + c; !e && i > 0 && (e = d / i); for (let f = 0; f < e; f++) { let p = d * (f / e); let v = 0; const g = new n(); p < l ? (v = p / l, g.x = o.x1 + (o.x2 - o.x1) * v, g.y = o.y1 + (o.y2 - o.y1) * v) : p > l + u ? (v = (p -= l + u) / c, g.x = h.x1 + (h.x2 - h.x1) * v, g.y = h.y1 + (h.y2 - h.y1) * v) : (v = (p -= l) / u, g.x = a.x1 + (a.x2 - a.x1) * v, g.y = a.y1 + (a.y2 - a.y1) * v), r.push(g) } return r } }, 39757: (t, e, i) => { const s = i(2141); function n (t, e, i, s) { const n = t - i; const r = e - s; const o = n * n + r * r; return Math.sqrt(o) } t.exports = function (t, e) { void 0 === e && (e = new s()); const i = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = t.x3; const l = t.y3; const u = n(h, l, o, a); const c = n(i, r, h, l); const d = n(o, a, i, r); const f = u + c + d; return e.x = (i * u + o * c + h * d) / f, e.y = (r * u + a * c + l * d) / f, e } }, 13584: t => { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t } }, 1376: (t, e, i) => { const s = i(35001); t.exports = function (t) { const e = t.getLineA(); const i = t.getLineB(); const n = t.getLineC(); return s(e) + s(i) + s(n) } }, 90260: (t, e, i) => { const s = i(2141); t.exports = function (t, e) { void 0 === e && (e = new s()); const i = t.x2 - t.x1; const n = t.y2 - t.y1; const r = t.x3 - t.x1; const o = t.y3 - t.y1; let a = Math.random(); let h = Math.random(); return a + h >= 1 && (a = 1 - a, h = 1 - h), e.x = t.x1 + (i * a + r * h), e.y = t.y1 + (n * a + o * h), e } }, 52172: (t, e, i) => { const s = i(99614); const n = i(39757); t.exports = function (t, e) { const i = n(t); return s(t, i.x, i.y, e) } }, 49907: (t, e, i) => { const s = i(99614); t.exports = function (t, e, i) { return s(t, e.x, e.y, i) } }, 99614: t => { t.exports = function (t, e, i, s) { const n = Math.cos(s); const r = Math.sin(s); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * n - a * r + e, t.y1 = o * r + a * n + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * n - a * r + e, t.y2 = o * r + a * n + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * n - a * r + e, t.y3 = o * r + a * n + i, t } }, 16483: (t, e, i) => { const s = i(83419); const n = i(10690); const r = i(20437); const o = i(80672); const a = i(23777); const h = i(23031); const l = i(90260); const u = new s({ initialize: function (t, e, i, s, n, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.type = a.TRIANGLE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s, this.x3 = n, this.y3 = r }, contains: function (t, e) { return n(this, t, e) }, getPoint: function (t, e) { return r(this, t, e) }, getPoints: function (t, e, i) { return o(this, t, e, i) }, getRandomPoint: function (t) { return l(this, t) }, setTo: function (t, e, i, s, n, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s, this.x3 = n, this.y3 = r, this }, getLineA: function (t) { return void 0 === t && (t = new h()), t.setTo(this.x1, this.y1, this.x2, this.y2), t }, getLineB: function (t) { return void 0 === t && (t = new h()), t.setTo(this.x2, this.y2, this.x3, this.y3), t }, getLineC: function (t) { return void 0 === t && (t = new h()), t.setTo(this.x3, this.y3, this.x1, this.y1), t }, left: { get: function () { return Math.min(this.x1, this.x2, this.x3) }, set: function (t) { let e = 0; e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e } }, right: { get: function () { return Math.max(this.x1, this.x2, this.x3) }, set: function (t) { let e = 0; e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e } }, top: { get: function () { return Math.min(this.y1, this.y2, this.y3) }, set: function (t) { let e = 0; e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e } }, bottom: { get: function () { return Math.max(this.y1, this.y2, this.y3) }, set: function (t) { let e = 0; e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e } } }); t.exports = u }, 84435: (t, e, i) => { const s = i(16483); s.Area = i(41658), s.BuildEquilateral = i(39208), s.BuildFromPolygon = i(39545), s.BuildRight = i(90301), s.CenterOn = i(23707), s.Centroid = i(97523), s.CircumCenter = i(24951), s.CircumCircle = i(85614), s.Clone = i(74422), s.Contains = i(10690), s.ContainsArray = i(48653), s.ContainsPoint = i(96006), s.CopyFrom = i(71326), s.Decompose = i(71694), s.Equals = i(33522), s.GetPoint = i(20437), s.GetPoints = i(80672), s.InCenter = i(39757), s.Perimeter = i(1376), s.Offset = i(13584), s.Random = i(90260), s.Rotate = i(52172), s.RotateAroundPoint = i(49907), s.RotateAroundXY = i(99614), t.exports = s }, 74457: t => { t.exports = function (t, e, i) { return { gameObject: t, enabled: !0, draggable: !1, dropZone: !1, cursor: !1, target: null, camera: null, hitArea: e, hitAreaCallback: i, hitAreaDebug: null, customHitArea: !1, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0, dragX: 0, dragY: 0 } } }, 84409: t => { t.exports = function (t, e) { return function (i, s, n, r) { const o = t.getPixelAlpha(s, n, r.texture.key, r.frame.name); return o && o >= e } } }, 7003: (t, e, i) => { const s = i(83419); const n = i(93301); const r = i(50792); const o = i(8214); const a = i(8443); const h = i(78970); const l = i(85098); const u = i(42515); const c = i(36210); const d = i(61340); const f = i(85955); const p = new s({ initialize: function (t, e) { this.game = t, this.scaleManager, this.canvas, this.config = e, this.enabled = !0, this.events = new r(), this.isOver = !0, this.defaultCursor = '', this.keyboard = e.inputKeyboard ? new h(this) : null, this.mouse = e.inputMouse ? new l(this) : null, this.touch = e.inputTouch ? new c(this) : null, this.pointers = [], this.pointersTotal = e.inputActivePointers, e.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2); for (let i = 0; i <= this.pointersTotal; i++) { const s = new u(this, i); s.smoothFactor = e.inputSmoothFactor, this.pointers.push(s) } this.mousePointer = e.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new d(), this._tempMatrix2 = new d(), this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], t.events.once(a.BOOT, this.boot, this) }, boot: function () { const t = this.game; const e = t.events; this.canvas = t.canvas, this.scaleManager = t.scale, this.events.emit(o.MANAGER_BOOT), e.on(a.PRE_RENDER, this.preRender, this), e.once(a.DESTROY, this.destroy, this) }, setCanvasOver: function (t) { this.isOver = !0, this.events.emit(o.GAME_OVER, t) }, setCanvasOut: function (t) { this.isOver = !1, this.events.emit(o.GAME_OUT, t) }, preRender: function () { const t = this.game.loop.now; const e = this.game.loop.delta; const i = this.game.scene.getScenes(!0, !0); this.time = t, this.events.emit(o.MANAGER_UPDATE); for (let s = 0; s < i.length; s++) { const n = i[s]; if (n.sys.input && n.sys.input.updatePoll(t, e) && this.globalTopOnly) return } }, setDefaultCursor: function (t) { this.defaultCursor = t, this.canvas.style.cursor !== t && (this.canvas.style.cursor = t) }, setCursor: function (t) { t.cursor && (this.canvas.style.cursor = t.cursor) }, resetCursor: function (t) { t.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor) }, addPointer: function (t) { void 0 === t && (t = 1); const e = []; this.pointersTotal + t > 10 && (t = 10 - this.pointersTotal); for (let i = 0; i < t; i++) { const s = this.pointers.length; const n = new u(this, s); n.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(n), this.pointersTotal++, e.push(n) } return e }, updateInputPlugins: function (t, e) { const i = this.game.scene.getScenes(!1, !0); this._tempSkip = !1; for (let s = 0; s < i.length; s++) { const n = i[s]; if (n.sys.input) if (n.sys.input.update(t, e) && this.globalTopOnly || this._tempSkip) return } }, onTouchStart: function (t) { for (var e = this.pointers, i = [], s = 0; s < t.changedTouches.length; s++) for (let r = t.changedTouches[s], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (!a.active) { a.touchstart(r, t), this.activePointer = a, i.push(a); break } } this.updateInputPlugins(n.TOUCH_START, i) }, onTouchMove: function (t) { for (var e = this.pointers, i = [], s = 0; s < t.changedTouches.length; s++) for (let r = t.changedTouches[s], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { const h = document.elementFromPoint(r.clientX, r.clientY) === this.canvas; !this.isOver && h ? this.setCanvasOver(t) : this.isOver && !h && this.setCanvasOut(t), this.isOver && (a.touchmove(r, t), this.activePointer = a, i.push(a)); break } } this.updateInputPlugins(n.TOUCH_MOVE, i) }, onTouchEnd: function (t) { for (var e = this.pointers, i = [], s = 0; s < t.changedTouches.length; s++) for (let r = t.changedTouches[s], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { a.touchend(r, t), i.push(a); break } } this.updateInputPlugins(n.TOUCH_END, i) }, onTouchCancel: function (t) { for (var e = this.pointers, i = [], s = 0; s < t.changedTouches.length; s++) for (let r = t.changedTouches[s], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { a.touchcancel(r, t), i.push(a); break } } this.updateInputPlugins(n.TOUCH_CANCEL, i) }, onMouseDown: function (t) { const e = this.mousePointer; e.down(t), e.updateMotion(), this.activePointer = e, this.updateInputPlugins(n.MOUSE_DOWN, this.mousePointerContainer) }, onMouseMove: function (t) { const e = this.mousePointer; e.move(t), e.updateMotion(), this.activePointer = e, this.updateInputPlugins(n.MOUSE_MOVE, this.mousePointerContainer) }, onMouseUp: function (t) { const e = this.mousePointer; e.up(t), e.updateMotion(), this.activePointer = e, this.updateInputPlugins(n.MOUSE_UP, this.mousePointerContainer) }, onMouseWheel: function (t) { const e = this.mousePointer; e.wheel(t), this.activePointer = e, this.updateInputPlugins(n.MOUSE_WHEEL, this.mousePointerContainer) }, onPointerLockChange: function (t) { const e = this.mouse.locked; this.mousePointer.locked = e, this.events.emit(o.POINTERLOCK_CHANGE, t, e) }, inputCandidate: function (t, e) { const i = t.input; if (!i || !i.enabled || !t.willRender(e)) return !1; let s = !0; let n = t.parentContainer; if (n) do { if (!n.willRender(e)) { s = !1; break } n = n.parentContainer } while (n); return s }, hitTest: function (t, e, i, s) { void 0 === s && (s = this._tempHitTest); const n = this._tempPoint; const r = i.scrollX; const o = i.scrollY; s.length = 0; const a = t.x; const h = t.y; i.getWorldPoint(a, h, n), t.worldX = n.x, t.worldY = n.y; for (let l = { x: 0, y: 0 }, u = this._tempMatrix, c = this._tempMatrix2, d = 0; d < e.length; d++) { const p = e[d]; if (this.inputCandidate(p, i)) { const v = n.x + r * p.scrollFactorX - r; const g = n.y + o * p.scrollFactorY - o; p.parentContainer ? (p.getWorldTransformMatrix(u, c), u.applyInverse(v, g, l)) : f(v, g, p.x, p.y, p.rotation, p.scaleX, p.scaleY, l), this.pointWithinHitArea(p, l.x, l.y) && s.push(p) } } return s }, pointWithinHitArea: function (t, e, i) { e += t.displayOriginX, i += t.displayOriginY; const s = t.input; return !(!s || !s.hitAreaCallback(s.hitArea, e, i, t)) && (s.localX = e, s.localY = i, !0) }, pointWithinInteractiveObject: function (t, e, i) { return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t)) }, transformPointer: function (t, e, i, s) { const n = t.position; const r = t.prevPosition; r.x = n.x, r.y = n.y; const o = this.scaleManager.transformX(e); const a = this.scaleManager.transformY(i); const h = t.smoothFactor; s && h !== 0 ? (n.x = o * h + r.x * (1 - h), n.y = a * h + r.y * (1 - h)) : (n.x = o, n.y = a) }, destroy: function () { this.events.removeAllListeners(), this.game.events.off(a.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy(); for (let t = 0; t < this.pointers.length; t++) this.pointers[t].destroy(); this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null } }); t.exports = p }, 48205: (t, e, i) => { const s = i(96503); const n = i(87902); const r = i(83419); const o = i(93301); const a = i(74457); const h = i(84409); const l = i(20339); const u = i(8497); const c = i(81154); const d = i(8214); const f = i(50792); const p = i(95540); const v = i(23777); const g = i(89639); const m = i(41212); const y = i(37277); const x = i(87841); const T = i(37303); const w = i(44594); const b = i(16483); const S = i(10690); const E = new r({ Extends: f, initialize: function (t) { f.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.pluginEvents = new f(), this.enabled = !0, this.displayList, this.cameras, g.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0; const e = { cancelled: !1 }; this._eventContainer = { stopPropagation: function () { e.cancelled = !0 } }, this._eventData = e, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._dragState = [], this._over = { 0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [] }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], this._updatedThisFrame = !1, t.sys.events.once(w.BOOT, this.boot, this), t.sys.events.on(w.START, this.start, this) }, boot: function () { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(w.DESTROY, this.destroy, this), this.pluginEvents.emit(d.BOOT) }, start: function () { const t = this.systems.events; t.on(w.TRANSITION_START, this.transitionIn, this), t.on(w.TRANSITION_OUT, this.transitionOut, this), t.on(w.TRANSITION_COMPLETE, this.transitionComplete, this), t.on(w.PRE_UPDATE, this.preUpdate, this), t.once(w.SHUTDOWN, this.shutdown, this), this.manager.events.on(d.GAME_OUT, this.onGameOut, this), this.manager.events.on(d.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(d.START) }, onGameOver: function (t) { this.isActive() && this.emit(d.GAME_OVER, t.timeStamp, t) }, onGameOut: function (t) { this.isActive() && this.emit(d.GAME_OUT, t.timeStamp, t) }, preUpdate: function () { this.pluginEvents.emit(d.PRE_UPDATE); const t = this._pendingRemoval; const e = this._pendingInsertion; const i = t.length; const s = e.length; if (i !== 0 || s !== 0) { for (var n = this._list, r = 0; r < i; r++) { const o = t[r]; const a = n.indexOf(o); a > -1 && (n.splice(a, 1), this.clear(o, !0)) } this._pendingRemoval.length = 0, this._list = n.concat(e.splice(0)) } }, isActive: function () { return this.enabled && this.scene.sys.canInput() }, updatePoll: function (t, e) { if (!this.isActive()) return !1; if (this.pluginEvents.emit(d.UPDATE, t, e), this._updatedThisFrame) return this._updatedThisFrame = !1, !1; let i; const s = this.manager; const n = s.pointers; const r = s.pointersTotal; for (i = 0; i < r; i++)n[i].updateMotion(); if (this._list.length === 0) return !1; const o = this.pollRate; if (o === -1) return !1; if (o > 0) { if (this._pollTimer -= e, !(this._pollTimer < 0)) return !1; this._pollTimer = this.pollRate } let a = !1; for (i = 0; i < r; i++) { let h = 0; const l = n[i]; this._tempZones = [], this._temp = this.hitTestPointer(l), this.sortGameObjects(this._temp, l), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), h += this.processOverOutEvents(l), this.getDragState(l) === 2 && this.processDragThresholdEvent(l, t), h > 0 && (a = !0) } return a }, update: function (t, e) { if (!this.isActive()) return !1; for (var i = e.length, s = !1, n = 0; n < i; n++) { let r = 0; const a = e[n]; switch (this._tempZones = [], this._temp = this.hitTestPointer(a), this.sortGameObjects(this._temp, a), this.sortDropZones(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), t) { case o.MOUSE_DOWN: r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverOutEvents(a); break; case o.MOUSE_UP: r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOverOutEvents(a); break; case o.TOUCH_START: r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverEvents(a); break; case o.TOUCH_END: case o.TOUCH_CANCEL: r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOutEvents(a); break; case o.MOUSE_MOVE: case o.TOUCH_MOVE: r += this.processDragMoveEvent(a), r += this.processMoveEvents(a), r += this.processOverOutEvents(a); break; case o.MOUSE_WHEEL: r += this.processWheelEvent(a) }r > 0 && (s = !0) } return this._updatedThisFrame = !0, s }, clear: function (t, e) { void 0 === e && (e = !1), this.disable(t); const i = t.input; i && (this.removeDebug(t), this.manager.resetCursor(i), i.gameObject = void 0, i.target = void 0, i.hitArea = void 0, i.hitAreaCallback = void 0, i.callbackContext = void 0, t.input = null), e || this.queueForRemoval(t); const s = this._draggable.indexOf(t); return s > -1 && this._draggable.splice(s, 1), t }, disable: function (t) { const e = t.input; e && (e.enabled = !1, e.dragState = 0); for (var i, s = this._drag, n = this._over, r = this.manager, o = 0; o < r.pointersTotal; o++)(i = s[o].indexOf(t)) > -1 && s[o].splice(i, 1), (i = n[o].indexOf(t)) > -1 && n[o].splice(i, 1); return this }, enable: function (t, e, i, s) { return void 0 === s && (s = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && s && !t.input.dropZone && (t.input.dropZone = s), this }, hitTestPointer: function (t) { for (var e = this.cameras.getCamerasBelowPointer(t), i = 0; i < e.length; i++) { for (var s = e[i], n = this.manager.hitTest(t, this._list, s), r = 0; r < n.length; r++) { const o = n[r]; o.input.dropZone && this._tempZones.push(o) } if (n.length > 0) return t.camera = s, n } return t.camera = e[0], [] }, processDownEvents: function (t) { let e = 0; const i = this._temp; const s = this._eventData; const n = this._eventContainer; s.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input && a.input.enabled) { if (e++, a.emit(d.GAMEOBJECT_POINTER_DOWN, t, a.input.localX, a.input.localY, n), s.cancelled || !a.input || !a.input.enabled) { r = !0; break } if (this.emit(d.GAMEOBJECT_DOWN, t, a, n), s.cancelled || !a.input) { r = !0; break } } } return !r && this.manager && (t.downElement === this.manager.game.canvas ? this.emit(d.POINTER_DOWN, t, i) : this.emit(d.POINTER_DOWN_OUTSIDE, t)), e }, getDragState: function (t) { return this._dragState[t.id] }, setDragState: function (t, e) { this._dragState[t.id] = e }, processDragThresholdEvent: function (t, e) { let i = !1; const s = this.dragTimeThreshold; const n = this.dragDistanceThreshold; if ((n > 0 && l(t.x, t.y, t.downX, t.downY) >= n || s > 0 && e >= t.downTime + s) && (i = !0), i) return this.setDragState(t, 3), this.processDragStartList(t) }, processDragStartList: function (t) { if (this.getDragState(t) !== 3) return 0; for (var e = this._drag[t.id], i = 0; i < e.length; i++) { const s = e[i]; const n = s.input; n.dragState = 2, n.dragStartX = s.x, n.dragStartY = s.y, n.dragStartXGlobal = t.worldX, n.dragStartYGlobal = t.worldY, n.dragX = n.dragStartXGlobal - n.dragStartX, n.dragY = n.dragStartYGlobal - n.dragStartY, s.emit(d.GAMEOBJECT_DRAG_START, t, n.dragX, n.dragY), this.emit(d.DRAG_START, t, s) } return this.setDragState(t, 4), e.length }, processDragDownEvent: function (t) { const e = this._temp; if (this._draggable.length === 0 || e.length === 0 || !t.primaryDown || this.getDragState(t) !== 0) return 0; this.setDragState(t, 1); for (var i = [], s = 0; s < e.length; s++) { const n = e[s]; n.input.draggable && n.input.dragState === 0 && i.push(n) } return i.length === 0 ? (this.setDragState(t, 0), 0) : (i.length > 1 && (this.sortGameObjects(i, t), this.topOnly && i.splice(1)), this._drag[t.id] = i, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? (this.setDragState(t, 3), this.processDragStartList(t)) : (this.setDragState(t, 2), 0)) }, processDragMoveEvent: function (t) { if (this.getDragState(t) === 2 && this.processDragThresholdEvent(t, this.manager.game.loop.now), this.getDragState(t) !== 4) return 0; for (var e = this._tempZones, i = this._drag[t.id], s = 0; s < i.length; s++) { var n; var r; const o = i[s]; const a = o.input; let h = a.target; if (h) { const l = e.indexOf(h); l === 0 ? (o.emit(d.GAMEOBJECT_DRAG_OVER, t, h), this.emit(d.DRAG_OVER, t, o, h)) : l > 0 ? (o.emit(d.GAMEOBJECT_DRAG_LEAVE, t, h), this.emit(d.DRAG_LEAVE, t, o, h), a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)) : (o.emit(d.GAMEOBJECT_DRAG_LEAVE, t, h), this.emit(d.DRAG_LEAVE, t, o, h), e[0] ? (a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)) : a.target = null) } else !h && e[0] && (a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)); if (o.parentContainer) { const u = t.worldX - a.dragStartXGlobal; const c = t.worldY - a.dragStartYGlobal; const f = o.getParentRotation(); let p = u * Math.cos(f) + c * Math.sin(f); let v = c * Math.cos(f) - u * Math.sin(f); p *= 1 / o.parentContainer.scaleX, v *= 1 / o.parentContainer.scaleY, n = p + a.dragStartX, r = v + a.dragStartY } else n = t.worldX - a.dragX, r = t.worldY - a.dragY; o.emit(d.GAMEOBJECT_DRAG, t, n, r), this.emit(d.DRAG, t, o, n, r) } return i.length }, processDragUpEvent: function (t) { for (var e = this._drag[t.id], i = 0; i < e.length; i++) { const s = e[i]; const n = s.input; if (n && n.dragState === 2) { n.dragState = 0, n.dragX = n.localX - s.displayOriginX, n.dragY = n.localY - s.displayOriginY; let r = !1; const o = n.target; o && (s.emit(d.GAMEOBJECT_DROP, t, o), this.emit(d.DROP, t, s, o), n.target = null, r = !0), s.input && s.input.enabled && (s.emit(d.GAMEOBJECT_DRAG_END, t, n.dragX, n.dragY, r), this.emit(d.DRAG_END, t, s, r)) } } return this.setDragState(t, 0), e.splice(0), 0 }, processMoveEvents: function (t) { let e = 0; const i = this._temp; const s = this._eventData; const n = this._eventContainer; s.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input && a.input.enabled) { if (e++, a.emit(d.GAMEOBJECT_POINTER_MOVE, t, a.input.localX, a.input.localY, n), s.cancelled || !a.input || !a.input.enabled) { r = !0; break } if (this.emit(d.GAMEOBJECT_MOVE, t, a, n), s.cancelled || !a.input || !a.input.enabled) { r = !0; break } if (this.topOnly) break } } return r || this.emit(d.POINTER_MOVE, t, i), e }, processWheelEvent: function (t) { let e = 0; const i = this._temp; const s = this._eventData; const n = this._eventContainer; s.cancelled = !1; for (var r = !1, o = t.deltaX, a = t.deltaY, h = t.deltaZ, l = 0; l < i.length; l++) { const u = i[l]; if (u.input && u.input.enabled) { if (e++, u.emit(d.GAMEOBJECT_POINTER_WHEEL, t, o, a, h, n), s.cancelled || !u.input || !u.input.enabled) { r = !0; break } if (this.emit(d.GAMEOBJECT_WHEEL, t, u, o, a, h, n), s.cancelled || !u.input || !u.input.enabled) { r = !0; break } } } return r || this.emit(d.POINTER_WHEEL, t, i, o, a, h), e }, processOverEvents: function (t) { const e = this._temp; let i = 0; const s = e.length; const n = []; if (s > 0) { const r = this.manager; const o = this._eventData; const a = this._eventContainer; o.cancelled = !1; for (var h = !1, l = 0; l < s; l++) { const u = e[l]; if (u.input && u.input.enabled) { if (n.push(u), r.setCursor(u.input), u.emit(d.GAMEOBJECT_POINTER_OVER, t, u.input.localX, u.input.localY, a), i++, o.cancelled || !u.input || !u.input.enabled) { h = !0; break } if (this.emit(d.GAMEOBJECT_OVER, t, u, a), o.cancelled || !u.input || !u.input.enabled) { h = !0; break } } } h || this.emit(d.POINTER_OVER, t, n) } return this._over[t.id] = n, i }, processOutEvents: function (t) { const e = this._over[t.id]; let i = 0; const s = e.length; if (s > 0) { const n = this.manager; const r = this._eventData; const o = this._eventContainer; r.cancelled = !1; let a = !1; this.sortGameObjects(e, t); for (let h = 0; h < s; h++) { let l = e[h]; if ((l = e[h]).input && l.input.enabled) { if (n.resetCursor(l.input), l.emit(d.GAMEOBJECT_POINTER_OUT, t, o), i++, r.cancelled || !l.input || !l.input.enabled) { a = !0; break } if (this.emit(d.GAMEOBJECT_OUT, t, l, o), r.cancelled || !l.input || !l.input.enabled) { a = !0; break } a || this.emit(d.POINTER_OUT, t, e) } } this._over[t.id] = [] } return i }, processOverOutEvents: function (t) { let e; let i; const s = this._temp; const n = []; const r = []; const o = []; let a = this._over[t.id]; const h = this._drag[t.id]; const l = this.manager; for (e = 0; e < a.length; e++)i = a[e], s.indexOf(i) === -1 && h.indexOf(i) === -1 ? n.push(i) : o.push(i); for (e = 0; e < s.length; e++)i = s[e], a.indexOf(i) === -1 && r.push(i); let u = n.length; let c = 0; const f = this._eventData; const p = this._eventContainer; f.cancelled = !1; let v = !1; if (u > 0) { for (this.sortGameObjects(n, t), e = 0; e < u; e++) if ((i = n[e]).input && i.input.enabled) { if (l.resetCursor(i.input), i.emit(d.GAMEOBJECT_POINTER_OUT, t, p), c++, f.cancelled || !i.input || !i.input.enabled) { v = !0; break } if (this.emit(d.GAMEOBJECT_OUT, t, i, p), f.cancelled || !i.input || !i.input.enabled) { v = !0; break } } v || this.emit(d.POINTER_OUT, t, n) } if (u = r.length, f.cancelled = !1, v = !1, u > 0) { for (this.sortGameObjects(r, t), e = 0; e < u; e++) if ((i = r[e]).input && i.input.enabled) { if (l.setCursor(i.input), i.emit(d.GAMEOBJECT_POINTER_OVER, t, i.input.localX, i.input.localY, p), c++, f.cancelled || !i.input || !i.input.enabled) { v = !0; break } if (this.emit(d.GAMEOBJECT_OVER, t, i, p), f.cancelled || !i.input || !i.input.enabled) { v = !0; break } } v || this.emit(d.POINTER_OVER, t, r) } return a = o.concat(r), this._over[t.id] = this.sortGameObjects(a, t), c }, processUpEvents: function (t) { const e = this._temp; const i = this._eventData; const s = this._eventContainer; i.cancelled = !1; for (var n = !1, r = 0; r < e.length; r++) { const o = e[r]; if (o.input && o.input.enabled) { if (o.emit(d.GAMEOBJECT_POINTER_UP, t, o.input.localX, o.input.localY, s), i.cancelled || !o.input || !o.input.enabled) { n = !0; break } if (this.emit(d.GAMEOBJECT_UP, t, o, s), i.cancelled || !o.input || !o.input.enabled) { n = !0; break } } } return !n && this.manager && (t.upElement === this.manager.game.canvas ? this.emit(d.POINTER_UP, t, e) : this.emit(d.POINTER_UP_OUTSIDE, t)), e.length }, queueForInsertion: function (t) { return this._pendingInsertion.indexOf(t) === -1 && this._list.indexOf(t) === -1 && this._pendingInsertion.push(t), this }, queueForRemoval: function (t) { return this._pendingRemoval.push(t), this }, setDraggable: function (t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; s.input.draggable = e; const n = this._draggable.indexOf(s); e && n === -1 ? this._draggable.push(s) : !e && n > -1 && this._draggable.splice(n, 1) } return this }, makePixelPerfect: function (t) { void 0 === t && (t = 1); const e = this.systems.textures; return h(e, t) }, setHitArea: function (t, e, i) { if (void 0 === e) return this.setHitAreaFromTexture(t); Array.isArray(t) || (t = [t]); let s = !1; let n = !1; let r = !1; let o = !1; let h = !1; let l = !0; if (m(e) && Object.keys(e).length) { const u = e; const c = t.some(function (t) { return t.hasOwnProperty('faces') }); if (!c) { e = p(u, 'hitArea', null), i = p(u, 'hitAreaCallback', null), h = p(u, 'pixelPerfect', !1); const d = p(u, 'alphaTolerance', 1); h && (e = {}, i = this.makePixelPerfect(d)) } s = p(u, 'draggable', !1), n = p(u, 'dropZone', !1), r = p(u, 'cursor', !1), o = p(u, 'useHandCursor', !1), e && i || (this.setHitAreaFromTexture(t), l = !1) } else typeof e !== 'function' || i || (i = e, e = {}); for (let f = 0; f < t.length; f++) { const v = t[f]; if (h && v.type === 'Container') console.warn('Cannot pixelPerfect test a Container. Use a custom callback.'); else { const g = v.input ? v.input : a(v, e, i); g.customHitArea = l, g.dropZone = n, g.cursor = o ? 'pointer' : r, v.input = g, s && this.setDraggable(v), this.queueForInsertion(v) } } return this }, setHitAreaCircle: function (t, e, i, r, o) { void 0 === o && (o = n); const a = new s(e, i, r); return this.setHitArea(t, a, o) }, setHitAreaEllipse: function (t, e, i, s, n, r) { void 0 === r && (r = c); const o = new u(e, i, s, n); return this.setHitArea(t, o, r) }, setHitAreaFromTexture: function (t, e) { void 0 === e && (e = T), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; const n = s.frame; let r = 0; let o = 0; s.width ? (r = s.width, o = s.height) : n && (r = n.realWidth, o = n.realHeight), s.type !== 'Container' || r !== 0 && o !== 0 ? r !== 0 && o !== 0 && (s.input = a(s, new x(0, 0, r, o), e), this.queueForInsertion(s)) : console.warn('Container.setInteractive must specify a Shape or call setSize() first') } return this }, setHitAreaRectangle: function (t, e, i, s, n, r) { void 0 === r && (r = T); const o = new x(e, i, s, n); return this.setHitArea(t, o, r) }, setHitAreaTriangle: function (t, e, i, s, n, r, o, a) { void 0 === a && (a = S); const h = new b(e, i, s, n, r, o); return this.setHitArea(t, h, a) }, enableDebug: function (t, e) { void 0 === e && (e = 65280); const i = t.input; if (!i || !i.hitArea) return this; const s = i.hitArea; const n = s.type; let r = i.hitAreaDebug; const o = this.systems.add; const a = this.systems.updateList; r && (a.remove(r), r.destroy(), r = null); let h = 0; let l = 0; switch (n) { case v.CIRCLE: r = o.arc(0, 0, s.radius), h = s.x - s.radius, l = s.y - s.radius; break; case v.ELLIPSE: r = o.ellipse(0, 0, s.width, s.height), h = s.x - s.width / 2, l = s.y - s.height / 2; break; case v.LINE: r = o.line(0, 0, s.x1, s.y1, s.x2, s.y2); break; case v.POLYGON: r = o.polygon(0, 0, s.points); break; case v.RECTANGLE: r = o.rectangle(0, 0, s.width, s.height), h = s.x, l = s.y; break; case v.TRIANGLE: r = o.triangle(0, 0, s.x1, s.y1, s.x2, s.y2, s.x3, s.y3) } return r && (r.isFilled = !1, r.strokeColor = e, r.preUpdate = function () { r.setVisible(t.visible), r.setStrokeStyle(1 / t.scale, r.strokeColor), r.setDisplayOrigin(t.displayOriginX, t.displayOriginY); let e = t.x; let i = t.y; let s = t.rotation; let n = t.scaleX; let o = t.scaleY; if (t.parentContainer) { const a = t.getWorldTransformMatrix(); e = a.tx, i = a.ty, s = a.rotation, n = a.scaleX, o = a.scaleY } r.setRotation(s), r.setScale(n, o), r.setPosition(e + h * n, i + l * o), r.setScrollFactor(t.scrollFactorX, t.scrollFactorY), r.setDepth(t.depth) }, a.add(r), i.hitAreaDebug = r), this }, removeDebug: function (t) { const e = t.input; e && e.hitAreaDebug && (e.hitAreaDebug.destroy(), e.hitAreaDebug = null); return this }, setPollAlways: function () { return this.setPollRate(0) }, setPollOnMove: function () { return this.setPollRate(-1) }, setPollRate: function (t) { return this.pollRate = t, this._pollTimer = 0, this }, setGlobalTopOnly: function (t) { return this.manager.globalTopOnly = t, this }, setTopOnly: function (t) { return this.topOnly = t, this }, sortGameObjects: function (t, e) { if (t.length < 2 || !e.camera) return t; const i = e.camera.renderList; return t.sort(function (t, e) { const s = Math.max(i.indexOf(t), 0); return Math.max(i.indexOf(e), 0) - s }) }, sortDropZones: function (t) { return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortDropZoneHandler.bind(this))) }, sortDropZoneHandler: function (t, e) { if (t.parentContainer || e.parentContainer) { if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t); if (t.parentContainer === e) return -1; if (e.parentContainer === t) return 1; for (var i = t.getIndexList(), s = e.getIndexList(), n = Math.min(i.length, s.length), r = 0; r < n; r++) { const o = i[r]; const a = s[r]; if (o !== a) return a - o } return s.length - i.length } return this.displayList.getIndex(e) - this.displayList.getIndex(t) }, stopPropagation: function () { return this.manager._tempSkip = !0, this }, addPointer: function (t) { return this.manager.addPointer(t) }, setDefaultCursor: function (t) { return this.manager.setDefaultCursor(t), this }, transitionIn: function () { this.enabled = this.settings.transitionAllowInput }, transitionComplete: function () { this.settings.transitionAllowInput || (this.enabled = !0) }, transitionOut: function () { this.enabled = this.settings.transitionAllowInput }, shutdown: function () { this.pluginEvents.emit(d.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0, this._dragState.length = 0; for (let t = 0; t < 10; t++) this._drag[t] = [], this._over[t] = []; this.removeAllListeners(); const e = this.manager; e.canvas.style.cursor = e.defaultCursor; const i = this.systems.events; i.off(w.TRANSITION_START, this.transitionIn, this), i.off(w.TRANSITION_OUT, this.transitionOut, this), i.off(w.TRANSITION_COMPLETE, this.transitionComplete, this), i.off(w.PRE_UPDATE, this.preUpdate, this), e.events.off(d.GAME_OUT, this.onGameOut, this), e.events.off(d.GAME_OVER, this.onGameOver, this), i.off(w.SHUTDOWN, this.shutdown, this) }, resetPointers: function () { for (let t = this.manager.pointers, e = 0; e < t.length; e++)t[e].reset() }, destroy: function () { this.shutdown(), this.pluginEvents.emit(d.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(w.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null }, x: { get: function () { return this.manager.activePointer.x } }, y: { get: function () { return this.manager.activePointer.y } }, isOver: { get: function () { return this.manager.isOver } }, mousePointer: { get: function () { return this.manager.mousePointer } }, activePointer: { get: function () { return this.manager.activePointer } }, pointer1: { get: function () { return this.manager.pointers[1] } }, pointer2: { get: function () { return this.manager.pointers[2] } }, pointer3: { get: function () { return this.manager.pointers[3] } }, pointer4: { get: function () { return this.manager.pointers[4] } }, pointer5: { get: function () { return this.manager.pointers[5] } }, pointer6: { get: function () { return this.manager.pointers[6] } }, pointer7: { get: function () { return this.manager.pointers[7] } }, pointer8: { get: function () { return this.manager.pointers[8] } }, pointer9: { get: function () { return this.manager.pointers[9] } }, pointer10: { get: function () { return this.manager.pointers[10] } } }); y.register('InputPlugin', E, 'input'), t.exports = E }, 89639: (t, e, i) => { const s = i(35154); const n = {}; const r = { register: function (t, e, i, s, r) { n[t] = { plugin: e, mapping: i, settingsKey: s, configKey: r } }, getPlugin: function (t) { return n[t] }, install: function (t) { const e = t.scene.sys; const i = e.settings.input; const r = e.game.config; for (const o in n) { const a = n[o].plugin; const h = n[o].mapping; const l = n[o].settingsKey; const u = n[o].configKey; s(i, l, r[u]) && (t[h] = new a(t)) } }, remove: function (t) { n.hasOwnProperty(t) && delete n[t] } }; t.exports = r }, 42515: (t, e, i) => { const s = i(31040); const n = i(83419); const r = i(20339); const o = i(43855); const a = i(47235); const h = i(26099); const l = i(25892); const u = new n({ initialize: function (t, e) { this.manager = t, this.id = e, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new h(), this.prevPosition = new h(), this.midPoint = new h(-1, -1), this.velocity = new h(), this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = e === 0, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0 }, updateWorldPoint: function (t) { const e = t.getWorldPoint(this.x, this.y); return this.worldX = e.x, this.worldY = e.y, this }, positionToCamera: function (t, e) { return t.getWorldPoint(this.x, this.y, e) }, updateMotion: function () { const t = this.position.x; const e = this.position.y; const i = this.midPoint.x; const n = this.midPoint.y; if (t !== i || e !== n) { let r = a(this.motionFactor, i, t); let h = a(this.motionFactor, n, e); o(r, t, 0.1) && (r = t), o(h, e, 0.1) && (h = e), this.midPoint.set(r, h); const l = t - r; const u = e - h; this.velocity.set(l, u), this.angle = s(r, h, t, e), this.distance = Math.sqrt(l * l + u * u) } }, up: function (t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y), this.buttons === 0 && (this.isDown = !1, this.upTime = t.timeStamp, this.wasTouch = !1) }, down: function (t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y), l.macOS && t.ctrlKey && (this.buttons = 2, this.primaryDown = !1), this.isDown || (this.isDown = !0, this.downTime = t.timeStamp), this.wasTouch = !1 }, move: function (t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.locked && (this.movementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.moveTime = t.timeStamp, this.wasTouch = !1 }, wheel: function (t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.deltaZ = t.deltaZ, this.wasTouch = !1 }, touchstart: function (t, e) { t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.active = !0, this.buttons = 1, this.event = e, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion() }, touchmove: function (t, e) { this.event = e, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.moveTime = e.timeStamp, this.wasTouch = !0, this.updateMotion() }, touchend: function (t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion() }, touchcancel: function (t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1 }, noButtonDown: function () { return this.buttons === 0 }, leftButtonDown: function () { return !!(1 & this.buttons) }, rightButtonDown: function () { return !!(2 & this.buttons) }, middleButtonDown: function () { return !!(4 & this.buttons) }, backButtonDown: function () { return !!(8 & this.buttons) }, forwardButtonDown: function () { return !!(16 & this.buttons) }, leftButtonReleased: function () { return this.button === 0 && !this.isDown }, rightButtonReleased: function () { return this.button === 2 && !this.isDown }, middleButtonReleased: function () { return this.button === 1 && !this.isDown }, backButtonReleased: function () { return this.button === 3 && !this.isDown }, forwardButtonReleased: function () { return this.button === 4 && !this.isDown }, getDistance: function () { return this.isDown ? r(this.downX, this.downY, this.x, this.y) : r(this.downX, this.downY, this.upX, this.upY) }, getDistanceX: function () { return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX) }, getDistanceY: function () { return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY) }, getDuration: function () { return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime }, getAngle: function () { return this.isDown ? s(this.downX, this.downY, this.x, this.y) : s(this.downX, this.downY, this.upX, this.upY) }, getInterpolatedPosition: function (t, e) { void 0 === t && (t = 10), void 0 === e && (e = []); for (let i = this.prevPosition.x, s = this.prevPosition.y, n = this.position.x, r = this.position.y, o = 0; o < t; o++) { const h = 1 / t * o; e[o] = { x: a(h, i, n), y: a(h, s, r) } } return e }, reset: function () { this.event = null, this.downElement = null, this.upElement = null, this.button = 0, this.buttons = 0, this.position.set(0, 0), this.prevPosition.set(0, 0), this.midPoint.set(-1, -1), this.velocity.set(0, 0), this.angle = 0, this.distance = 0, this.worldX = 0, this.worldY = 0, this.downX = 0, this.downY = 0, this.upX = 0, this.upY = 0, this.moveTime = 0, this.upTime = 0, this.downTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0, this.active = this.id === 0 }, destroy: function () { this.camera = null, this.manager = null, this.position = null }, x: { get: function () { return this.position.x }, set: function (t) { this.position.x = t } }, y: { get: function () { return this.position.y }, set: function (t) { this.position.y = t } }, time: { get: function () { return this.event ? this.event.timeStamp : 0 } } }); t.exports = u }, 93301: t => { t.exports = { MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8 } }, 7179: t => { t.exports = 'boot' }, 85375: t => { t.exports = 'destroy' }, 39843: t => { t.exports = 'dragend' }, 23388: t => { t.exports = 'dragenter' }, 16133: t => { t.exports = 'drag' }, 27829: t => { t.exports = 'dragleave' }, 53904: t => { t.exports = 'dragover' }, 56058: t => { t.exports = 'dragstart' }, 2642: t => { t.exports = 'drop' }, 88171: t => { t.exports = 'gameobjectdown' }, 36147: t => { t.exports = 'dragend' }, 71692: t => { t.exports = 'dragenter' }, 96149: t => { t.exports = 'drag' }, 81285: t => { t.exports = 'dragleave' }, 74048: t => { t.exports = 'dragover' }, 21322: t => { t.exports = 'dragstart' }, 49378: t => { t.exports = 'drop' }, 86754: t => { t.exports = 'gameobjectmove' }, 86433: t => { t.exports = 'gameobjectout' }, 60709: t => { t.exports = 'gameobjectover' }, 24081: t => { t.exports = 'pointerdown' }, 11172: t => { t.exports = 'pointermove' }, 18907: t => { t.exports = 'pointerout' }, 95579: t => { t.exports = 'pointerover' }, 35368: t => { t.exports = 'pointerup' }, 26972: t => { t.exports = 'wheel' }, 47078: t => { t.exports = 'gameobjectup' }, 73802: t => { t.exports = 'gameobjectwheel' }, 56718: t => { t.exports = 'gameout' }, 25936: t => { t.exports = 'gameover' }, 27503: t => { t.exports = 'boot' }, 50852: t => { t.exports = 'process' }, 96438: t => { t.exports = 'update' }, 59152: t => { t.exports = 'pointerlockchange' }, 47777: t => { t.exports = 'pointerdown' }, 27957: t => { t.exports = 'pointerdownoutside' }, 19444: t => { t.exports = 'pointermove' }, 54251: t => { t.exports = 'pointerout' }, 18667: t => { t.exports = 'pointerover' }, 27192: t => { t.exports = 'pointerup' }, 24652: t => { t.exports = 'pointerupoutside' }, 45132: t => { t.exports = 'wheel' }, 44512: t => { t.exports = 'preupdate' }, 15757: t => { t.exports = 'shutdown' }, 41637: t => { t.exports = 'start' }, 93802: t => { t.exports = 'update' }, 8214: (t, e, i) => { t.exports = { BOOT: i(7179), DESTROY: i(85375), DRAG_END: i(39843), DRAG_ENTER: i(23388), DRAG: i(16133), DRAG_LEAVE: i(27829), DRAG_OVER: i(53904), DRAG_START: i(56058), DROP: i(2642), GAME_OUT: i(56718), GAME_OVER: i(25936), GAMEOBJECT_DOWN: i(88171), GAMEOBJECT_DRAG_END: i(36147), GAMEOBJECT_DRAG_ENTER: i(71692), GAMEOBJECT_DRAG: i(96149), GAMEOBJECT_DRAG_LEAVE: i(81285), GAMEOBJECT_DRAG_OVER: i(74048), GAMEOBJECT_DRAG_START: i(21322), GAMEOBJECT_DROP: i(49378), GAMEOBJECT_MOVE: i(86754), GAMEOBJECT_OUT: i(86433), GAMEOBJECT_OVER: i(60709), GAMEOBJECT_POINTER_DOWN: i(24081), GAMEOBJECT_POINTER_MOVE: i(11172), GAMEOBJECT_POINTER_OUT: i(18907), GAMEOBJECT_POINTER_OVER: i(95579), GAMEOBJECT_POINTER_UP: i(35368), GAMEOBJECT_POINTER_WHEEL: i(26972), GAMEOBJECT_UP: i(47078), GAMEOBJECT_WHEEL: i(73802), MANAGER_BOOT: i(27503), MANAGER_PROCESS: i(50852), MANAGER_UPDATE: i(96438), POINTER_DOWN: i(47777), POINTER_DOWN_OUTSIDE: i(27957), POINTER_MOVE: i(19444), POINTER_OUT: i(54251), POINTER_OVER: i(18667), POINTER_UP: i(27192), POINTER_UP_OUTSIDE: i(24652), POINTER_WHEEL: i(45132), POINTERLOCK_CHANGE: i(59152), PRE_UPDATE: i(44512), SHUTDOWN: i(15757), START: i(41637), UPDATE: i(93802) } }, 97421: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e) { this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = 0.1 }, update: function (t) { this.value = t }, getValue: function () { return Math.abs(this.value) < this.threshold ? 0 : this.value }, destroy: function () { this.pad = null, this.events = null } }); t.exports = s }, 28884: (t, e, i) => { const s = i(83419); const n = i(92734); const r = new s({ initialize: function (t, e) { this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1 }, update: function (t) { this.value = t; const e = this.pad; const i = this.index; t >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(n.BUTTON_DOWN, e, this, t), this.pad.emit(n.GAMEPAD_BUTTON_DOWN, i, t, this)) : this.pressed && (this.pressed = !1, this.events.emit(n.BUTTON_UP, e, this, t), this.pad.emit(n.GAMEPAD_BUTTON_UP, i, t, this)) }, destroy: function () { this.pad = null, this.events = null } }); t.exports = r }, 99125: (t, e, i) => { const s = i(97421); const n = i(28884); const r = i(83419); const o = i(50792); const a = i(26099); const h = new r({ Extends: o, initialize: function (t, e) { o.call(this), this.manager = t, this.pad = e, this.id = e.id, this.index = e.index; for (var i = [], r = 0; r < e.buttons.length; r++)i.push(new n(this, r)); this.buttons = i; const h = []; for (r = 0; r < e.axes.length; r++)h.push(new s(this, r)); this.axes = h, this.vibration = e.vibrationActuator; const l = { value: 0, pressed: !1 }; this._LCLeft = i[14] ? i[14] : l, this._LCRight = i[15] ? i[15] : l, this._LCTop = i[12] ? i[12] : l, this._LCBottom = i[13] ? i[13] : l, this._RCLeft = i[2] ? i[2] : l, this._RCRight = i[1] ? i[1] : l, this._RCTop = i[3] ? i[3] : l, this._RCBottom = i[0] ? i[0] : l, this._FBLeftTop = i[4] ? i[4] : l, this._FBLeftBottom = i[6] ? i[6] : l, this._FBRightTop = i[5] ? i[5] : l, this._FBRightBottom = i[7] ? i[7] : l; const u = { value: 0 }; this._HAxisLeft = h[0] ? h[0] : u, this._VAxisLeft = h[1] ? h[1] : u, this._HAxisRight = h[2] ? h[2] : u, this._VAxisRight = h[3] ? h[3] : u, this.leftStick = new a(), this.rightStick = new a(), this._created = performance.now() }, getAxisTotal: function () { return this.axes.length }, getAxisValue: function (t) { return this.axes[t].getValue() }, setAxisThreshold: function (t) { for (let e = 0; e < this.axes.length; e++) this.axes[e].threshold = t }, getButtonTotal: function () { return this.buttons.length }, getButtonValue: function (t) { return this.buttons[t].value }, isButtonDown: function (t) { return this.buttons[t].pressed }, update: function (t) { if (!(t.timestamp < this._created)) { let e; const i = this.buttons; const s = t.buttons; let n = i.length; for (e = 0; e < n; e++)i[e].update(s[e].value); const r = this.axes; const o = t.axes; for (n = r.length, e = 0; e < n; e++)r[e].update(o[e]); n >= 2 && (this.leftStick.set(r[0].getValue(), r[1].getValue()), n >= 4 && this.rightStick.set(r[2].getValue(), r[3].getValue())) } }, destroy: function () { let t; for (this.removeAllListeners(), this.manager = null, this.pad = null, t = 0; t < this.buttons.length; t++) this.buttons[t].destroy(); for (t = 0; t < this.axes.length; t++) this.axes[t].destroy(); this.buttons = [], this.axes = [] }, connected: { get: function () { return this.pad.connected } }, timestamp: { get: function () { return this.pad.timestamp } }, left: { get: function () { return this._LCLeft.pressed } }, right: { get: function () { return this._LCRight.pressed } }, up: { get: function () { return this._LCTop.pressed } }, down: { get: function () { return this._LCBottom.pressed } }, A: { get: function () { return this._RCBottom.pressed } }, Y: { get: function () { return this._RCTop.pressed } }, X: { get: function () { return this._RCLeft.pressed } }, B: { get: function () { return this._RCRight.pressed } }, L1: { get: function () { return this._FBLeftTop.value } }, L2: { get: function () { return this._FBLeftBottom.value } }, R1: { get: function () { return this._FBRightTop.value } }, R2: { get: function () { return this._FBRightBottom.value } } }); t.exports = h }, 56654: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(92734); const o = i(99125); const a = i(35154); const h = i(89639); const l = i(8214); const u = new s({ Extends: n, initialize: function (t) { n.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once(l.BOOT, this.boot, this), t.pluginEvents.on(l.START, this.start, this) }, boot: function () { const t = this.scene.sys.game; const e = this.settings.input; const i = t.config; this.enabled = a(e, 'gamepad', i.inputGamepad) && t.device.input.gamepads, this.target = a(e, 'gamepad.target', i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(l.DESTROY, this.destroy, this) }, start: function () { this.enabled && (this.startListeners(), this.refreshPads()), this.sceneInputPlugin.pluginEvents.once(l.SHUTDOWN, this.shutdown, this) }, isActive: function () { return this.enabled && this.scene.sys.isActive() }, startListeners: function () { const t = this; const e = this.target; const i = function (e) { !e.defaultPrevented && t.isActive() && (t.refreshPads(), t.queue.push(e)) }; this.onGamepadHandler = i, e.addEventListener('gamepadconnected', i, !1), e.addEventListener('gamepaddisconnected', i, !1), this.sceneInputPlugin.pluginEvents.on(l.UPDATE, this.update, this) }, stopListeners: function () { this.target.removeEventListener('gamepadconnected', this.onGamepadHandler), this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(l.UPDATE, this.update); for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t].removeAllListeners() }, disconnectAll: function () { for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t].pad.connected = !1 }, refreshPads: function () { const t = navigator.getGamepads(); if (t) for (let e = this.gamepads, i = 0; i < t.length; i++) { const s = t[i]; if (s) { const n = s.id; const r = s.index; const a = e[r]; if (a) a.id !== n ? (a.destroy(), e[r] = new o(this, s)) : a.update(s); else { const h = new o(this, s); e[r] = h, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = h) : this._pad3 = h : this._pad2 = h : this._pad1 = h } } } else this.disconnectAll() }, getAll: function () { for (var t = [], e = this.gamepads, i = 0; i < e.length; i++)e[i] && t.push(e[i]); return t }, getPad: function (t) { for (let e = this.gamepads, i = 0; i < e.length; i++) if (e[i] && e[i].index === t) return e[i] }, update: function () { if (this.enabled) { this.refreshPads(); const t = this.queue.length; if (t !== 0) for (let e = this.queue.splice(0, t), i = 0; i < t; i++) { const s = e[i]; const n = this.getPad(s.gamepad.index); s.type === 'gamepadconnected' ? this.emit(r.CONNECTED, n, s) : s.type === 'gamepaddisconnected' && this.emit(r.DISCONNECTED, n, s) } } }, shutdown: function () { this.stopListeners(), this.removeAllListeners() }, destroy: function () { this.shutdown(); for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t] && this.gamepads[t].destroy(); this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null }, total: { get: function () { return this.gamepads.length } }, pad1: { get: function () { return this._pad1 } }, pad2: { get: function () { return this._pad2 } }, pad3: { get: function () { return this._pad3 } }, pad4: { get: function () { return this._pad4 } } }); h.register('GamepadPlugin', u, 'gamepad', 'gamepad', 'inputGamepad'), t.exports = u }, 89651: t => { t.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5 } }, 65294: t => { t.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 } }, 90089: t => { t.exports = { UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3 } }, 64894: (t, e, i) => { t.exports = { DUALSHOCK_4: i(65294), SNES_USB: i(89651), XBOX_360: i(90089) } }, 46008: t => { t.exports = 'down' }, 7629: t => { t.exports = 'up' }, 42206: t => { t.exports = 'connected' }, 86544: t => { t.exports = 'disconnected' }, 94784: t => { t.exports = 'down' }, 14325: t => { t.exports = 'up' }, 92734: (t, e, i) => { t.exports = { BUTTON_DOWN: i(46008), BUTTON_UP: i(7629), CONNECTED: i(42206), DISCONNECTED: i(86544), GAMEPAD_BUTTON_DOWN: i(94784), GAMEPAD_BUTTON_UP: i(14325) } }, 48646: (t, e, i) => { t.exports = { Axis: i(97421), Button: i(28884), Events: i(92734), Gamepad: i(99125), GamepadPlugin: i(56654), Configs: i(64894) } }, 14350: (t, e, i) => { const s = i(93301); const n = i(79291); let r = { CreatePixelPerfectHandler: i(84409), CreateInteractiveObject: i(74457), Events: i(8214), Gamepad: i(48646), InputManager: i(7003), InputPlugin: i(48205), InputPluginCache: i(89639), Keyboard: i(51442), Mouse: i(87078), Pointer: i(42515), Touch: i(95618) }; r = n(!1, r, s), t.exports = r }, 78970: (t, e, i) => { const s = i(72905); const n = i(83419); const r = i(8443); const o = i(8214); const a = i(46032); const h = i(29747); const l = new n({ initialize: function (t) { this.manager = t, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = h, this.onKeyUp = h, t.events.once(o.MANAGER_BOOT, this.boot, this) }, boot: function () { const t = this.manager.config; this.enabled = t.inputKeyboard, this.target = t.inputKeyboardEventTarget, this.addCapture(t.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(r.POST_STEP, this.postUpdate, this) }, startListeners: function () { const t = this; this.onKeyDown = function (e) { if (!e.defaultPrevented && t.enabled && t.manager) { t.queue.push(e), t.manager.events.emit(o.MANAGER_PROCESS); const i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey; t.preventDefault && !i && t.captures.indexOf(e.keyCode) > -1 && e.preventDefault() } }, this.onKeyUp = function (e) { if (!e.defaultPrevented && t.enabled && t.manager) { t.queue.push(e), t.manager.events.emit(o.MANAGER_PROCESS); const i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey; t.preventDefault && !i && t.captures.indexOf(e.keyCode) > -1 && e.preventDefault() } }; const e = this.target; e && (e.addEventListener('keydown', this.onKeyDown, !1), e.addEventListener('keyup', this.onKeyUp, !1), this.enabled = !0) }, stopListeners: function () { const t = this.target; t.removeEventListener('keydown', this.onKeyDown, !1), t.removeEventListener('keyup', this.onKeyUp, !1), this.enabled = !1 }, postUpdate: function () { this.queue = [] }, addCapture: function (t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let s = t[i]; typeof s === 'string' && (s = a[s.trim().toUpperCase()]), e.indexOf(s) === -1 && e.push(s) } this.preventDefault = e.length > 0 }, removeCapture: function (t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let n = t[i]; typeof n === 'string' && (n = a[n.toUpperCase()]), s(e, n) } this.preventDefault = e.length > 0 }, clearCaptures: function () { this.captures = [], this.preventDefault = !1 }, destroy: function () { this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(r.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null } }); t.exports = l }, 28846: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(95922); const o = i(8443); const a = i(35154); const h = i(8214); const l = i(89639); const u = i(30472); const c = i(46032); const d = i(87960); const f = i(74600); const p = i(44594); const v = i(56583); const g = new s({ Extends: n, initialize: function (t) { n.call(this), this.game = t.systems.game, this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.manager = t.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], this.prevCode = null, this.prevTime = 0, this.prevType = null, t.pluginEvents.once(h.BOOT, this.boot, this), t.pluginEvents.on(h.START, this.start, this) }, boot: function () { const t = this.settings.input; this.enabled = a(t, 'keyboard', !0); const e = a(t, 'keyboard.capture', null); e && this.addCaptures(e), this.sceneInputPlugin.pluginEvents.once(h.DESTROY, this.destroy, this) }, start: function () { this.sceneInputPlugin.manager.events.on(h.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(h.SHUTDOWN, this.shutdown, this), this.game.events.on(o.BLUR, this.resetKeys, this), this.scene.sys.events.on(p.PAUSE, this.resetKeys, this), this.scene.sys.events.on(p.SLEEP, this.resetKeys, this) }, isActive: function () { return this.enabled && this.scene.sys.canInput() }, addCapture: function (t) { return this.manager.addCapture(t), this }, removeCapture: function (t) { return this.manager.removeCapture(t), this }, getCaptures: function () { return this.manager.captures }, enableGlobalCapture: function () { return this.manager.preventDefault = !0, this }, disableGlobalCapture: function () { return this.manager.preventDefault = !1, this }, clearCaptures: function () { return this.manager.clearCaptures(), this }, createCursorKeys: function () { return this.addKeys({ up: c.UP, down: c.DOWN, left: c.LEFT, right: c.RIGHT, space: c.SPACE, shift: c.SHIFT }) }, addKeys: function (t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const s = {}; if (typeof t === 'string') { t = t.split(','); for (let n = 0; n < t.length; n++) { const r = t[n].trim(); r && (s[r] = this.addKey(r, e, i)) } } else for (const o in t) s[o] = this.addKey(t[o], e, i); return s }, addKey: function (t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const s = this.keys; if (t instanceof u) { const n = s.indexOf(t); return n > -1 ? s[n] = t : s[t.keyCode] = t, e && this.addCapture(t.keyCode), t.setEmitOnRepeat(i), t } return typeof t === 'string' && (t = c[t.toUpperCase()]), s[t] || (s[t] = new u(this, t), e && this.addCapture(t), s[t].setEmitOnRepeat(i)), s[t] }, removeKey: function (t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = !1); let s; const n = this.keys; if (t instanceof u) { const r = n.indexOf(t); r > -1 && (s = this.keys[r], this.keys[r] = void 0) } else typeof t === 'string' && (t = c[t.toUpperCase()]); return n[t] && (s = n[t], n[t] = void 0), s && (s.plugin = null, i && this.removeCapture(s.keyCode), e && s.destroy()), this }, removeAllKeys: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.keys, s = 0; s < i.length; s++) { const n = i[s]; n && (i[s] = void 0, e && this.removeCapture(n.keyCode), t && n.destroy()) } return this }, createCombo: function (t, e) { return new d(this, t, e) }, checkDown: function (t, e) { if (void 0 === e && (e = 0), this.enabled && t.isDown) { const i = v(this.time - t.timeDown, e); if (i > t._tick) return t._tick = i, !0 } return !1 }, update: function () { const t = this.manager.queue; const e = t.length; if (this.isActive() && e !== 0) for (let i = this.keys, s = 0; s < e; s++) { var n = t[s]; const o = n.keyCode; const a = i[o]; let h = !1; void 0 === n.cancelled && (n.cancelled = 0, n.stopImmediatePropagation = function () { n.cancelled = 1 }, n.stopPropagation = function () { n.cancelled = -1 }), n.cancelled !== -1 && (o === this.prevCode && n.timeStamp === this.prevTime && n.type === this.prevType || (this.prevCode = o, this.prevTime = n.timeStamp, this.prevType = n.type, n.type === 'keydown' ? (a && (h = a.isDown, a.onDown(n)), n.cancelled || a && h || (f[o] && this.emit(r.KEY_DOWN + f[o], n), n.cancelled || this.emit(r.ANY_KEY_DOWN, n))) : (a && a.onUp(n), n.cancelled || (f[o] && this.emit(r.KEY_UP + f[o], n), n.cancelled || this.emit(r.ANY_KEY_UP, n))), n.cancelled === 1 && (n.cancelled = 0))) } }, resetKeys: function () { for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].reset(); return this }, shutdown: function () { this.removeAllKeys(!0), this.removeAllListeners(), this.sceneInputPlugin.manager.events.off(h.MANAGER_PROCESS, this.update, this), this.game.events.off(o.BLUR, this.resetKeys), this.scene.sys.events.off(p.PAUSE, this.resetKeys, this), this.scene.sys.events.off(p.SLEEP, this.resetKeys, this), this.queue = [] }, destroy: function () { this.shutdown(); for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].destroy(); this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null }, time: { get: function () { return this.sceneInputPlugin.manager.time } } }); l.register('KeyboardPlugin', g, 'keyboard', 'keyboard', 'inputKeyboard'), t.exports = g }, 66970: t => { t.exports = function (t, e) { return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1) } }, 87960: (t, e, i) => { const s = i(83419); const n = i(95922); const r = i(95540); const o = i(68769); const a = i(92803); const h = new s({ initialize: function (t, e, i) { if (void 0 === i && (i = {}), e.length < 2) return !1; this.manager = t, this.enabled = !0, this.keyCodes = []; for (let s = 0; s < e.length; s++) { const h = e[s]; typeof h === 'string' ? this.keyCodes.push(h.toUpperCase().charCodeAt(0)) : typeof h === 'number' ? this.keyCodes.push(h) : h.hasOwnProperty('keyCode') && this.keyCodes.push(h.keyCode) } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = r(i, 'resetOnWrongKey', !0), this.maxKeyDelay = r(i, 'maxKeyDelay', 0), this.resetOnMatch = r(i, 'resetOnMatch', !1), this.deleteOnMatch = r(i, 'deleteOnMatch', !1); const l = this; this.onKeyDown = function (t) { !l.matched && l.enabled && (o(t, l) && (l.manager.emit(n.COMBO_MATCH, l, t), l.resetOnMatch ? a(l) : l.deleteOnMatch && l.destroy())) }, this.manager.on(n.ANY_KEY_DOWN, this.onKeyDown) }, progress: { get: function () { return this.index / this.size } }, destroy: function () { this.enabled = !1, this.keyCodes = [], this.manager.off(n.ANY_KEY_DOWN, this.onKeyDown), this.manager = null } }); t.exports = h }, 68769: (t, e, i) => { const s = i(66970); t.exports = function (t, e) { if (e.matched) return !0; let i = !1; let n = !1; if (t.keyCode === e.current) if (e.index > 0 && e.maxKeyDelay > 0) { const r = e.timeLastMatched + e.maxKeyDelay; t.timeStamp <= r && (n = !0, i = s(t, e)) } else n = !0, i = s(t, e); return !n && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), i && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), i } }, 92803: t => { t.exports = function (t) { return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t } }, 92612: t => { t.exports = 'keydown' }, 23345: t => { t.exports = 'keyup' }, 21957: t => { t.exports = 'keycombomatch' }, 44743: t => { t.exports = 'down' }, 3771: t => { t.exports = 'keydown-' }, 46358: t => { t.exports = 'keyup-' }, 75674: t => { t.exports = 'up' }, 95922: (t, e, i) => { t.exports = { ANY_KEY_DOWN: i(92612), ANY_KEY_UP: i(23345), COMBO_MATCH: i(21957), DOWN: i(44743), KEY_DOWN: i(3771), KEY_UP: i(46358), UP: i(75674) } }, 51442: (t, e, i) => { t.exports = { Events: i(95922), KeyboardManager: i(78970), KeyboardPlugin: i(28846), Key: i(30472), KeyCodes: i(46032), KeyCombo: i(87960), AdvanceKeyCombo: i(66970), ProcessKeyCombo: i(68769), ResetKeyCombo: i(92803), JustDown: i(90229), JustUp: i(38796), DownDuration: i(37015), UpDuration: i(41170) } }, 37015: t => { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeDown; return t.isDown && i < e } }, 90229: t => { t.exports = function (t) { return !!t._justDown && (t._justDown = !1, !0) } }, 38796: t => { t.exports = function (t) { return !!t._justUp && (t._justUp = !1, !0) } }, 30472: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(95922); const o = new s({ Extends: n, initialize: function (t, e) { n.call(this), this.plugin = t, this.keyCode = e, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1 }, setEmitOnRepeat: function (t) { return this.emitOnRepeat = t, this }, onDown: function (t) { this.originalEvent = t, this.enabled && (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.location = t.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(r.DOWN, this, t) : (this.isDown = !0, this.isUp = !1, this.timeDown = t.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(r.DOWN, this, t))) }, onUp: function (t) { this.originalEvent = t, this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = t.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(r.UP, this, t)) }, reset: function () { return this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this }, getDuration: function () { return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0 }, destroy: function () { this.removeAllListeners(), this.originalEvent = null, this.plugin = null } }); t.exports = o }, 46032: t => { t.exports = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62, BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175 } }, 74600: (t, e, i) => { const s = i(46032); const n = {}; for (const r in s) n[s[r]] = r; t.exports = n }, 41170: t => { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeUp; return t.isUp && i < e } }, 85098: (t, e, i) => { const s = i(83419); const n = i(89357); const r = i(8214); const o = i(29747); const a = new s({ initialize: function (t) { this.manager = t, this.preventDefaultDown = !0, this.preventDefaultUp = !0, this.preventDefaultMove = !0, this.preventDefaultWheel = !1, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = o, this.onMouseDown = o, this.onMouseUp = o, this.onMouseDownWindow = o, this.onMouseUpWindow = o, this.onMouseOver = o, this.onMouseOut = o, this.onMouseWheel = o, this.pointerLockChange = o, this.isTop = !0, t.events.once(r.MANAGER_BOOT, this.boot, this) }, boot: function () { const t = this.manager.config; this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.passive = t.inputMousePassive, this.preventDefaultDown = t.inputMousePreventDefaultDown, this.preventDefaultUp = t.inputMousePreventDefaultUp, this.preventDefaultMove = t.inputMousePreventDefaultMove, this.preventDefaultWheel = t.inputMousePreventDefaultWheel, this.target ? typeof this.target === 'string' && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners() }, disableContextMenu: function () { return this.target.addEventListener('contextmenu', function (t) { return t.preventDefault(), !1 }), this }, requestPointerLock: function () { if (n.pointerLock) { const t = this.target; t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock() } }, releasePointerLock: function () { n.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()) }, startListeners: function () { const t = this.target; if (t) { const e = this; const i = this.manager; const s = i.canvas; const r = window && window.focus && i.game.config.autoFocus; this.onMouseMove = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && (i.onMouseMove(t), e.preventDefaultMove && t.preventDefault()) }, this.onMouseDown = function (t) { r && window.focus(), !t.defaultPrevented && e.enabled && i && i.enabled && (i.onMouseDown(t), e.preventDefaultDown && t.target === s && t.preventDefault()) }, this.onMouseDownWindow = function (t) { t.sourceCapabilities && t.sourceCapabilities.firesTouchEvents || !t.defaultPrevented && e.enabled && i && i.enabled && t.target !== s && i.onMouseDown(t) }, this.onMouseUp = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && (i.onMouseUp(t), e.preventDefaultUp && t.target === s && t.preventDefault()) }, this.onMouseUpWindow = function (t) { t.sourceCapabilities && t.sourceCapabilities.firesTouchEvents || !t.defaultPrevented && e.enabled && i && i.enabled && t.target !== s && i.onMouseUp(t) }, this.onMouseOver = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && i.setCanvasOver(t) }, this.onMouseOut = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && i.setCanvasOut(t) }, this.onMouseWheel = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && i.onMouseWheel(t), e.preventDefaultWheel && t.target === s && t.preventDefault() }; const o = { passive: !0 }; if (t.addEventListener('mousemove', this.onMouseMove), t.addEventListener('mousedown', this.onMouseDown), t.addEventListener('mouseup', this.onMouseUp), t.addEventListener('mouseover', this.onMouseOver, o), t.addEventListener('mouseout', this.onMouseOut, o), this.preventDefaultWheel ? t.addEventListener('wheel', this.onMouseWheel, { passive: !1 }) : t.addEventListener('wheel', this.onMouseWheel, o), window && i.game.config.inputWindowEvents) try { window.top.addEventListener('mousedown', this.onMouseDownWindow, o), window.top.addEventListener('mouseup', this.onMouseUpWindow, o) } catch (t) { window.addEventListener('mousedown', this.onMouseDownWindow, o), window.addEventListener('mouseup', this.onMouseUpWindow, o), this.isTop = !1 } n.pointerLock && (this.pointerLockChange = function (t) { const s = e.target; e.locked = document.pointerLockElement === s || document.mozPointerLockElement === s || document.webkitPointerLockElement === s, i.onPointerLockChange(t) }, document.addEventListener('pointerlockchange', this.pointerLockChange, !0), document.addEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.addEventListener('webkitpointerlockchange', this.pointerLockChange, !0)), this.enabled = !0 } }, stopListeners: function () { let t = this.target; t.removeEventListener('mousemove', this.onMouseMove), t.removeEventListener('mousedown', this.onMouseDown), t.removeEventListener('mouseup', this.onMouseUp), t.removeEventListener('mouseover', this.onMouseOver), t.removeEventListener('mouseout', this.onMouseOut), window && ((t = this.isTop ? window.top : window).removeEventListener('mousedown', this.onMouseDownWindow), t.removeEventListener('mouseup', this.onMouseUpWindow)), n.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)) }, destroy: function () { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null } }); t.exports = a }, 87078: (t, e, i) => { t.exports = { MouseManager: i(85098) } }, 36210: (t, e, i) => { const s = i(83419); const n = i(8214); const r = i(29747); const o = new s({ initialize: function (t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = r, this.onTouchStartWindow = r, this.onTouchMove = r, this.onTouchEnd = r, this.onTouchEndWindow = r, this.onTouchCancel = r, this.onTouchCancelWindow = r, this.isTop = !0, t.events.once(n.MANAGER_BOOT, this.boot, this) }, boot: function () { const t = this.manager.config; this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target ? typeof this.target === 'string' && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners() }, disableContextMenu: function () { return this.target.addEventListener('contextmenu', function (t) { return t.preventDefault(), !1 }), this }, startListeners: function () { const t = this.target; if (t) { const e = this; const i = this.manager; const s = i.canvas; const n = window && window.focus && i.game.config.autoFocus; this.onTouchMove = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && (i.onTouchMove(t), e.capture && t.cancelable && t.preventDefault()) }, this.onTouchStart = function (t) { n && window.focus(), !t.defaultPrevented && e.enabled && i && i.enabled && (i.onTouchStart(t), e.capture && t.cancelable && t.target === s && t.preventDefault()) }, this.onTouchStartWindow = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && t.target !== s && i.onTouchStart(t) }, this.onTouchEnd = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && (i.onTouchEnd(t), e.capture && t.cancelable && t.target === s && t.preventDefault()) }, this.onTouchEndWindow = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && t.target !== s && i.onTouchEnd(t) }, this.onTouchCancel = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && (i.onTouchCancel(t), e.capture && t.preventDefault()) }, this.onTouchCancelWindow = function (t) { !t.defaultPrevented && e.enabled && i && i.enabled && i.onTouchCancel(t) }; const r = this.capture; const o = { passive: !0 }; const a = { passive: !1 }; if (t.addEventListener('touchstart', this.onTouchStart, r ? a : o), t.addEventListener('touchmove', this.onTouchMove, r ? a : o), t.addEventListener('touchend', this.onTouchEnd, r ? a : o), t.addEventListener('touchcancel', this.onTouchCancel, r ? a : o), window && i.game.config.inputWindowEvents) try { window.top.addEventListener('touchstart', this.onTouchStartWindow, a), window.top.addEventListener('touchend', this.onTouchEndWindow, a), window.top.addEventListener('touchcancel', this.onTouchCancelWindow, a) } catch (t) { window.addEventListener('touchstart', this.onTouchStartWindow, a), window.addEventListener('touchend', this.onTouchEndWindow, a), window.addEventListener('touchcancel', this.onTouchCancelWindow, a), this.isTop = !1 } this.enabled = !0 } }, stopListeners: function () { let t = this.target; t.removeEventListener('touchstart', this.onTouchStart), t.removeEventListener('touchmove', this.onTouchMove), t.removeEventListener('touchend', this.onTouchEnd), t.removeEventListener('touchcancel', this.onTouchCancel), window && ((t = this.isTop ? window.top : window).removeEventListener('touchstart', this.onTouchStartWindow), t.removeEventListener('touchend', this.onTouchEndWindow), t.removeEventListener('touchcancel', this.onTouchCancelWindow)) }, destroy: function () { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null } }); t.exports = o }, 95618: (t, e, i) => { t.exports = { TouchManager: i(36210) } }, 41299: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(54899); const o = i(95540); const a = i(98356); const h = i(3374); const l = i(84376); const u = i(92638); const c = new s({ initialize: function (t, e) { if (this.loader = t, this.cache = o(e, 'cache', !1), this.type = o(e, 'type', !1), !this.type) throw new Error('Invalid File type: ' + this.type); this.key = o(e, 'key', !1); const i = this.key; if (t.prefix && t.prefix !== '' && (this.key = t.prefix + i), !this.key) throw new Error('Invalid File key: ' + this.key); let s = o(e, 'url'); void 0 === s ? s = t.path + i + '.' + o(e, 'extension', '') : typeof s !== 'string' || s.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/) || (s = t.path + s), this.url = s, this.src = '', this.xhrSettings = u(o(e, 'responseType', void 0)), o(e, 'xhrSettings', !1) && (this.xhrSettings = h(this.xhrSettings, o(e, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? n.FILE_POPULATED : n.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = o(e, 'config', {}), this.multiFile, this.linkFile, this.base64 = typeof s === 'string' && s.indexOf('data:') === 0 }, setLink: function (t) { this.linkFile = t, t.linkFile = this }, resetXHR: function () { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0) }, load: function () { this.state === n.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.state = n.FILE_LOADING, this.src = a(this, this.loader.baseURL), this.src.indexOf('data:') === 0 && (this.base64 = !0), this.xhrLoader = l(this, this.loader.xhr)) }, onLoad: function (t, e) { const i = t.responseURL && this.loader.localSchemes.some(function (e) { return t.responseURL.indexOf(e) === 0 }) && e.target.status === 0; let s = !(e.target && e.target.status !== 200) || i; t.readyState === 4 && t.status >= 400 && t.status <= 599 && (s = !1), this.state = n.FILE_LOADED, this.resetXHR(), this.loader.nextFile(this, s) }, onBase64Load: function (t) { this.xhrLoader = t, this.state = n.FILE_LOADED, this.percentComplete = 1, this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete), this.loader.nextFile(this, !0) }, onError: function () { this.resetXHR(), this.loader.nextFile(this, !1) }, onProgress: function (t) { t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete)) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.onProcessComplete() }, onProcessComplete: function () { this.state = n.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this) }, onProcessError: function () { console.error('Failed to process file: %s "%s"', this.type, this.key), this.state = n.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this) }, hasCacheConflict: function () { return this.cache && this.cache.exists(this.key) }, addToCache: function () { this.cache && this.data && this.cache.add(this.key, this.data) }, pendingDestroy: function (t) { if (this.state !== n.FILE_PENDING_DESTROY) { void 0 === t && (t = this.data); const e = this.key; const i = this.type; this.loader.emit(r.FILE_COMPLETE, e, i, t), this.loader.emit(r.FILE_KEY_COMPLETE + i + '-' + e, e, i, t), this.loader.flagForRemoval(this), this.state = n.FILE_PENDING_DESTROY } }, destroy: function () { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null } }); c.createObjectURL = function (t, e, i) { if (typeof URL === 'function') t.src = URL.createObjectURL(e); else { const s = new FileReader(); s.onload = function () { t.removeAttribute('crossOrigin'), t.src = 'data:' + (e.type || i) + ';base64,' + s.result.split(',')[1] }, s.onerror = t.onerror, s.readAsDataURL(e) } }, c.revokeObjectURL = function (t) { typeof URL === 'function' && URL.revokeObjectURL(t.src) }, t.exports = c }, 74099: t => { let e = {}; const i = { install: function (t) { for (const i in e) t[i] = e[i] }, register: function (t, i) { e[t] = i }, destroy: function () { e = {} } }; t.exports = i }, 98356: t => { t.exports = function (t, e) { return !!t.url && (t.url.match(/^(?:blob:|data:|capacitor:\/\/|http:\/\/|https:\/\/|\/\/)/) ? t.url : e + t.url) } }, 74261: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(35072); const o = i(50792); const a = i(54899); const h = i(74099); const l = i(95540); const u = i(35154); const c = i(37277); const d = i(44594); const f = i(92638); const p = new s({ Extends: o, initialize: function (t) { o.call(this); const e = t.sys.game.config; const i = t.sys.settings.loader; this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, this.sceneManager = t.sys.game.scene, h.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(l(i, 'baseURL', e.loaderBaseURL)), this.setPath(l(i, 'path', e.loaderPath)), this.setPrefix(l(i, 'prefix', e.loaderPrefix)), this.maxParallelDownloads = l(i, 'maxParallelDownloads', e.loaderMaxParallelDownloads), this.xhr = f(l(i, 'responseType', e.loaderResponseType), l(i, 'async', e.loaderAsync), l(i, 'user', e.loaderUser), l(i, 'password', e.loaderPassword), l(i, 'timeout', e.loaderTimeout), l(i, 'withCredentials', e.loaderWithCredentials)), this.crossOrigin = l(i, 'crossOrigin', e.loaderCrossOrigin), this.imageLoadType = l(i, 'imageLoadType', e.loaderImageLoadType), this.localSchemes = l(i, 'localScheme', e.loaderLocalScheme), this.totalToLoad = 0, this.progress = 0, this.list = new r(), this.inflight = new r(), this.queue = new r(), this._deleteQueue = new r(), this.totalFailed = 0, this.totalComplete = 0, this.state = n.LOADER_IDLE, this.multiKeyIndex = 0, t.sys.events.once(d.BOOT, this.boot, this), t.sys.events.on(d.START, this.pluginStart, this) }, boot: function () { this.systems.events.once(d.DESTROY, this.destroy, this) }, pluginStart: function () { this.systems.events.once(d.SHUTDOWN, this.shutdown, this) }, setBaseURL: function (t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.baseURL = t, this }, setPath: function (t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.path = t, this }, setPrefix: function (t) { return void 0 === t && (t = ''), this.prefix = t, this }, setCORS: function (t) { return this.crossOrigin = t, this }, addFile: function (t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; this.keyExists(i) || (this.list.set(i), this.emit(a.ADD, i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress())) } }, keyExists: function (t) { let e = t.hasCacheConflict(); return e || this.list.iterate(function (i) { if (i.type === t.type && i.key === t.key) return e = !0, !1 }), !e && this.isLoading() && (this.inflight.iterate(function (i) { if (i.type === t.type && i.key === t.key) return e = !0, !1 }), this.queue.iterate(function (i) { if (i.type === t.type && i.key === t.key) return e = !0, !1 })), e }, addPack: function (t, e) { if (typeof e === 'string') { const i = u(t, e); i && (t = { packKey: i }) } let s = 0; const n = this.baseURL; const r = this.path; const o = this.prefix; for (const a in t) if (Object.prototype.hasOwnProperty.call(t, a)) { const h = t[a]; const c = l(h, 'baseURL', n); const d = l(h, 'path', r); const f = l(h, 'prefix', o); const p = l(h, 'files', null); const v = l(h, 'defaultType', 'void'); if (Array.isArray(p)) { this.setBaseURL(c), this.setPath(d), this.setPrefix(f); for (let g = 0; g < p.length; g++) { const m = p[g]; const y = m.hasOwnProperty('type') ? m.type : v; this[y] && (this[y](m), s++) } } } return this.setBaseURL(n), this.setPath(r), this.setPrefix(o), s > 0 }, isLoading: function () { return this.state === n.LOADER_LOADING || this.state === n.LOADER_PROCESSING }, isReady: function () { return this.state === n.LOADER_IDLE || this.state === n.LOADER_COMPLETE }, start: function () { this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(a.START, this), this.list.size === 0 ? this.loadComplete() : (this.state = n.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(d.UPDATE, this.update, this))) }, updateProgress: function () { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(a.PROGRESS, this.progress) }, update: function () { this.state === n.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue() }, checkLoadQueue: function () { this.list.each(function (t) { if ((t.state === n.FILE_POPULATED || t.state === n.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1 }, this) }, nextFile: function (t, e) { this.inflight && (this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit(a.FILE_LOAD, t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit(a.FILE_LOAD_ERROR, t), this.fileProcessComplete(t))) }, fileProcessComplete: function (t) { this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (t.state === n.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === n.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && (t.multiFile.addToCache(), t.multiFile.pendingDestroy()) : (t.addToCache(), t.pendingDestroy())), this.queue.delete(t), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete()) }, loadComplete: function () { this.emit(a.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = n.LOADER_COMPLETE, this.systems.events.off(d.UPDATE, this.update, this), this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit(a.COMPLETE, this, this.totalComplete, this.totalFailed) }, flagForRemoval: function (t) { this._deleteQueue.set(t) }, saveJSON: function (t, e) { return this.save(JSON.stringify(t), e) }, save: function (t, e, i) { void 0 === e && (e = 'file.json'), void 0 === i && (i = 'application/json'); const s = new Blob([t], { type: i }); const n = URL.createObjectURL(s); const r = document.createElement('a'); return r.download = e, r.textContent = 'Download ' + e, r.href = n, r.click(), this }, reset: function () { this.list.clear(), this.inflight.clear(), this.queue.clear(); const t = this.systems.game.config; const e = this.systems.settings.loader; this.setBaseURL(l(e, 'baseURL', t.loaderBaseURL)), this.setPath(l(e, 'path', t.loaderPath)), this.setPrefix(l(e, 'prefix', t.loaderPrefix)), this.state = n.LOADER_IDLE }, shutdown: function () { this.reset(), this.state = n.LOADER_SHUTDOWN, this.removeAllListeners(), this.systems.events.off(d.UPDATE, this.update, this), this.systems.events.off(d.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.state = n.LOADER_DESTROYED, this.systems.events.off(d.UPDATE, this.update, this), this.systems.events.off(d.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null } }); c.register('Loader', p, 'load'), t.exports = p }, 3374: (t, e, i) => { const s = i(79291); const n = i(92638); t.exports = function (t, e) { const i = void 0 === t ? n() : s({}, t); if (e) for (const r in e) void 0 !== e[r] && (i[r] = e[r]); return i } }, 26430: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(54899); const o = new s({ initialize: function (t, e, i, s) { const r = []; s.forEach(function (t) { t && r.push(t) }), this.loader = t, this.type = e, this.key = i; const o = this.key; t.prefix && t.prefix !== '' && (this.key = t.prefix + o), this.multiKeyIndex = t.multiKeyIndex++, this.files = r, this.state = n.FILE_PENDING, this.complete = !1, this.pending = r.length, this.failed = 0, this.config = {}, this.baseURL = t.baseURL, this.path = t.path, this.prefix = t.prefix; for (let a = 0; a < r.length; a++)r[a].multiFile = this }, isReadyToProcess: function () { return this.pending === 0 && this.failed === 0 && !this.complete }, addToMultiFile: function (t) { return this.files.push(t), t.multiFile = this, this.pending++, this.complete = !1, this }, onFileComplete: function (t) { this.files.indexOf(t) !== -1 && this.pending-- }, onFileFailed: function (t) { this.files.indexOf(t) !== -1 && (this.failed++, console.error('File failed: %s "%s" (via %s "%s")', this.type, this.key, t.type, t.key)) }, pendingDestroy: function () { if (this.state !== n.FILE_PENDING_DESTROY) { const t = this.key; const e = this.type; this.loader.emit(r.FILE_COMPLETE, t, e), this.loader.emit(r.FILE_KEY_COMPLETE + e + '-' + t, t, e), this.loader.flagForRemoval(this); for (let i = 0; i < this.files.length; i++) this.files[i].pendingDestroy(); this.state = n.FILE_PENDING_DESTROY } }, destroy: function () { this.loader = null, this.files = null, this.config = null } }); t.exports = o }, 84376: (t, e, i) => { const s = i(3374); t.exports = function (t, e) { const i = s(e, t.xhrSettings); if (!t.base64) { const n = new XMLHttpRequest(); if (n.open('GET', t.src, i.async, i.user, i.password), n.responseType = t.xhrSettings.responseType, n.timeout = i.timeout, i.headers) for (const r in i.headers) n.setRequestHeader(r, i.headers[r]); return i.header && i.headerValue && n.setRequestHeader(i.header, i.headerValue), i.requestedWith && n.setRequestHeader('X-Requested-With', i.requestedWith), i.overrideMimeType && n.overrideMimeType(i.overrideMimeType), i.withCredentials && (n.withCredentials = !0), n.onload = t.onLoad.bind(t, n), n.onerror = t.onError.bind(t, n), n.onprogress = t.onProgress.bind(t), n.ontimeout = t.onError.bind(t, n), n.send(), n } const o = t.url.split(';base64,').pop() || t.url.split(',').pop(); const a = { responseText: atob(o) }; t.onBase64Load(a) } }, 92638: t => { t.exports = function (t, e, i, s, n, r) { return void 0 === t && (t = ''), void 0 === e && (e = !0), void 0 === i && (i = ''), void 0 === s && (s = ''), void 0 === n && (n = 0), void 0 === r && (r = !1), { responseType: t, async: e, user: i, password: s, timeout: n, headers: void 0, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0, withCredentials: r } } }, 23906: t => { t.exports = { LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19, FILE_PENDING_DESTROY: 20 } }, 42155: t => { t.exports = 'addfile' }, 38991: t => { t.exports = 'complete' }, 27540: t => { t.exports = 'filecomplete' }, 87464: t => { t.exports = 'filecomplete-' }, 94486: t => { t.exports = 'loaderror' }, 13035: t => { t.exports = 'load' }, 38144: t => { t.exports = 'fileprogress' }, 97520: t => { t.exports = 'postprocess' }, 85595: t => { t.exports = 'progress' }, 55680: t => { t.exports = 'start' }, 54899: (t, e, i) => { t.exports = { ADD: i(42155), COMPLETE: i(38991), FILE_COMPLETE: i(27540), FILE_KEY_COMPLETE: i(87464), FILE_LOAD_ERROR: i(94486), FILE_LOAD: i(13035), FILE_PROGRESS: i(38144), POST_PROCESS: i(97520), PROGRESS: i(85595), START: i(55680) } }, 14135: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(518); const o = i(54899); const a = new s({ Extends: r, initialize: function (t, e, i, s, n) { r.call(this, t, e, i, s, n), this.type = 'animationJSON' }, onProcess: function () { this.loader.once(o.POST_PROCESS, this.onLoadComplete, this), r.prototype.onProcess.call(this) }, onLoadComplete: function () { this.loader.systems.anims.fromJSON(this.data) } }); n.register('animation', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, s, i)); return this }), t.exports = a }, 76272: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(518); const l = i(26430); const u = new s({ Extends: l, initialize: function (t, e, i, s, n, u) { let c, d; if (a(e)) { const f = e; e = r(f, 'key'), c = new o(t, { key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings') }), d = new h(t, { key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'json'), xhrSettings: r(f, 'atlasXhrSettings') }) } else c = new o(t, e, i, n), d = new h(t, e, s, u); c.linkFile ? l.call(this, t, 'atlasjson', e, [c, d, c.linkFile]) : l.call(this, t, 'atlasjson', e, [c, d]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0 } } }); n.register('aseprite', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = u }, 38734: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(518); const l = i(26430); const u = new s({ Extends: l, initialize: function (t, e, i, s, n, u) { let c, d; if (a(e)) { const f = e; e = r(f, 'key'), c = new o(t, { key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings') }), d = new h(t, { key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'json'), xhrSettings: r(f, 'atlasXhrSettings') }) } else c = new o(t, e, i, n), d = new h(t, e, s, u); c.linkFile ? l.call(this, t, 'atlasjson', e, [c, d, c.linkFile]) : l.call(this, t, 'atlasjson', e, [c, d]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), this.complete = !0 } } }); n.register('atlas', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = u }, 74599: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(26430); const l = i(57318); const u = new s({ Extends: h, initialize: function (t, e, i, s, n, u) { let c, d; if (a(e)) { const f = e; e = r(f, 'key'), c = new o(t, { key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings') }), d = new l(t, { key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'xml'), xhrSettings: r(f, 'atlasXhrSettings') }) } else c = new o(t, e, i, n), d = new l(t, e, s, u); c.linkFile ? h.call(this, t, 'atlasxml', e, [c, d, c.linkFile]) : h.call(this, t, 'atlasxml', e, [c, d]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), this.complete = !0 } } }); n.register('atlasXML', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = u }, 21097: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(89749); const l = i(41212); const u = new s({ Extends: r, initialize: function (t, e, i, s, n) { if (l(e)) { const o = e; e = a(o, 'key'), s = a(o, 'xhrSettings'), n = a(o, 'context', n) } const h = { type: 'audio', cache: t.cacheManager.audio, extension: i.type, responseType: 'arraybuffer', key: e, url: i.url, xhrSettings: s, config: { context: n } }; r.call(this, t, h) }, onProcess: function () { this.state = n.FILE_PROCESSING; const t = this; this.config.context.decodeAudioData(this.xhrLoader.response, function (e) { t.data = e, t.onProcessComplete() }, function (e) { console.error('Error decoding audio: ' + t.key + ' - ', e ? e.message : null), t.onProcessError() }), this.config.context = null } }); u.create = function (t, e, i, s, n) { const r = t.systems.game; const o = r.config.audio; const c = r.device.audio; l(e) && (i = a(e, 'url', []), s = a(e, 'config', {})); const d = u.getAudioURL(r, i); return d ? c.webAudio && !o.disableWebAudio ? new u(t, e, d, n, r.sound.context) : new h(t, e, d, s) : (console.warn('No audio URLs for "%s" matched this device', e), null) }, u.getAudioURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { const s = a(e[i], 'url', e[i]); if (s.indexOf('blob:') === 0 || s.indexOf('data:') === 0) return { url: s, type: '' }; let n = s.match(/\.([a-zA-Z0-9]+)($|\?)/); if (n = a(e[i], 'type', n ? n[1] : '').toLowerCase(), t.device.audio[n]) return { url: s, type: n } } return null }, o.register('audio', function (t, e, i, s) { let n; const r = this.systems.game; const o = r.config.audio; const a = r.device.audio; if (o.noAudio || !a.webAudio && !a.audioData) return this; if (Array.isArray(t)) for (let h = 0; h < t.length; h++)(n = u.create(this, t[h])) && this.addFile(n); else (n = u.create(this, t, e, i, s)) && this.addFile(n); return this }), t.exports = u }, 89524: (t, e, i) => { const s = i(21097); const n = i(83419); const r = i(74099); const o = i(95540); const a = i(41212); const h = i(518); const l = i(26430); const u = new n({ Extends: l, initialize: function (t, e, i, n, r, u, c) { if (a(e)) { const d = e; e = o(d, 'key'), i = o(d, 'jsonURL'), n = o(d, 'audioURL'), r = o(d, 'audioConfig'), u = o(d, 'audioXhrSettings'), c = o(d, 'jsonXhrSettings') } let f; if (n) { const p = s.create(t, e, n, r, u); p && (f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [p, f]), this.config.resourceLoad = !1) } else f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [f]), this.config.resourceLoad = !0, this.config.audioConfig = r, this.config.audioXhrSettings = u }, onFileComplete: function (t) { if (this.files.indexOf(t) !== -1 && (this.pending--, this.config.resourceLoad && t.type === 'json' && t.data.hasOwnProperty('resources'))) { const e = t.data.resources; const i = o(this.config, 'audioConfig'); const n = o(this.config, 'audioXhrSettings'); const r = s.create(this.loader, t.key, e, i, n); r && (this.addToMultiFile(r), this.loader.addFile(r)) } }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.complete = !0 } } }); r.register('audioSprite', function (t, e, i, s, n, r) { let o; const a = this.systems.game; const h = a.config.audio; const l = a.device.audio; if (h && h.noAudio || !l.webAudio && !l.audioData) return this; if (Array.isArray(t)) for (let c = 0; c < t.length; c++)(o = new u(this, t[c])).files && this.addFile(o.files); else (o = new u(this, t, e, i, s, n, r)).files && this.addFile(o.files); return this }) }, 85722: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, n) { let o = 'bin'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), s = a(l, 'xhrSettings'), o = a(l, 'extension', o), n = a(l, 'dataType', n) } const u = { type: 'binary', cache: t.cacheManager.binary, extension: o, responseType: 'arraybuffer', key: e, url: i, xhrSettings: s, config: { dataType: n } }; r.call(this, t, u) }, onProcess: function () { this.state = n.FILE_PROCESSING; const t = this.config.dataType; this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete() } }); o.register('binary', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, s, i)); return this }), t.exports = l }, 97025: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(26430); const l = i(21859); const u = i(57318); const c = new s({ Extends: h, initialize: function (t, e, i, s, n, l) { let c, d; if (a(e)) { const f = e; e = r(f, 'key'), c = new o(t, { key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings') }), d = new u(t, { key: e, url: r(f, 'fontDataURL'), extension: r(f, 'fontDataExtension', 'xml'), xhrSettings: r(f, 'fontDataXhrSettings') }) } else c = new o(t, e, i, n), d = new u(t, e, s, l); c.linkFile ? h.call(this, t, 'bitmapfont', e, [c, d, c.linkFile]) : h.call(this, t, 'bitmapfont', e, [c, d]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(); const i = t.cache.get(t.key); const s = l(e.data, t.cache.getFrame(t.key), 0, 0, i); this.loader.cacheManager.bitmapFont.add(t.key, { data: s, texture: t.key, frame: null }), this.complete = !0 } } }); n.register('bitmapFont', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new c(this, t[o]), this.addFile(r.files); else r = new c(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = c }, 16024: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'css'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), s = a(o, 'xhrSettings'), n = a(o, 'extension', n) } const l = { type: 'script', cache: !1, extension: n, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, l) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = document.createElement('style'), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete() } }); o.register('css', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i)); return this }), t.exports = l }, 69559: (t, e, i) => { const s = i(38734); const n = i(85722); const r = i(83419); const o = i(74099); const a = i(95540); const h = i(19550); const l = i(41212); const u = i(518); const c = i(31403); const d = i(46975); const f = i(59327); const p = i(26430); const v = i(82038); const g = i(55222); const m = new r({ Extends: p, initialize: function (t, e, i, s) { if (i.multiAtlasURL) { const r = new u(t, { key: e, url: i.multiAtlasURL, xhrSettings: s, config: i }); p.call(this, t, 'texture', e, [r]) } else { const o = i.textureURL.substr(i.textureURL.length - 3); i.type || (i.type = o.toLowerCase() === 'ktx' ? 'KTX' : 'PVR'); const a = new n(t, { key: e, url: i.textureURL, extension: o, xhrSettings: s, config: i }); if (i.atlasURL) { const h = new u(t, { key: e, url: i.atlasURL, xhrSettings: s, config: i }); p.call(this, t, 'texture', e, [a, h]) } else p.call(this, t, 'texture', e, [a]) } this.config = i }, onFileComplete: function (t) { if (this.files.indexOf(t) !== -1) { if (this.pending--, !this.config.multiAtlasURL) return; if (t.type === 'json' && t.data.hasOwnProperty('textures')) { const e = t.data.textures; const i = this.config; const s = this.loader; const r = s.baseURL; const o = s.path; const h = s.prefix; const l = a(i, 'multiBaseURL', this.baseURL); const u = a(i, 'multiPath', this.path); const c = a(i, 'prefix', this.prefix); const d = a(i, 'textureXhrSettings'); l && s.setBaseURL(l), u && s.setPath(u), c && s.setPrefix(c); for (let f = 0; f < e.length; f++) { const p = e[f].image; const v = 'CMA' + this.multiKeyIndex + '_' + p; const g = new n(s, v, p, d); if (this.addToMultiFile(g), s.addFile(g), e[f].normalMap) { const m = new n(s, v, e[f].normalMap, d); m.type = 'normalMap', g.setLink(m), this.addToMultiFile(m), s.addFile(m) } } s.setBaseURL(r), s.setPath(o), s.setPrefix(h) } } }, addToCache: function () { function t (t) { console.warn('Compressed Texture Invalid: "' + r.key + '". ' + t) } if (this.isReadyToProcess()) { const e = this.config; if (e.multiAtlasURL) this.addMultiToCache(); else { let i; const s = this.loader.systems.renderer; const n = this.loader.textureManager; var r = this.files[0]; const o = this.files[1]; if (e.type === 'PVR' ? i = v(r.data) : e.type === 'KTX' && ((i = c(r.data)) || t('KTX file contains unsupported format.')), i && !g(i) && (t('Texture dimensions failed verification. Check the texture format specifications for ' + e.format + ' 0x' + i.internalFormat.toString(16) + '.'), i = null), i && !s.supportsCompressedTexture(e.format, i.internalFormat) && (t('Texture format ' + e.format + ' with internal format ' + i.internalFormat + ' not supported by the GPU. Texture invalid. This is often due to the texture using sRGB instead of linear RGB.'), i = null), i) { i.format = s.getCompressedTextureName(e.format, i.internalFormat); const a = o && o.data ? o.data : null; n.addCompressedTexture(r.key, i, a) } } this.complete = !0 } }, addMultiToCache: function () { for (var t, e = this.config, i = this.files[0], s = [], n = [], r = [], o = this.loader.systems.renderer, a = this.loader.textureManager, h = 1; h < this.files.length; h++) { const l = this.files[h]; if (l.type !== 'normalMap') for (let u = l.key.indexOf('_'), d = l.key.substr(u + 1), f = l.data, p = 0; p < i.data.textures.length; p++) { const g = i.data.textures[p]; if (g.image === d) { e.type === 'PVR' ? t = v(f) : e.type === 'KTX' && (t = c(f)), t && o.supportsCompressedTexture(e.format, t.internalFormat) && (t.format = o.getCompressedTextureName(e.format, t.internalFormat), n.push(t), s.push(g), l.linkFile && r.push(l.linkFile.data)); break } } } r.length === 0 && (r = void 0), a.addAtlasJSONArray(this.key, n, s, r), this.complete = !0 } }); o.register('texture', function (t, e, i) { const n = this.systems.renderer; const r = function (t, e, i, r) { let o = { format: null, type: null, textureURL: void 0, atlasURL: void 0, multiAtlasURL: void 0, multiPath: void 0, multiBaseURL: void 0 }; if (l(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), r = a(u, 'xhrSettings') } let c = !1; for (const p in i) if (n.supportsCompressedTexture(p)) { const v = i[p]; typeof v === 'string' ? o.textureURL = v : o = d(v, o), o.format = p.toUpperCase(), c = !0; break } if (c) if (o.format === 'IMG') { let g; g = o.multiAtlasURL ? new f(t, e, o.multiAtlasURL, o.multiPath, o.multiBaseURL, r).files : o.atlasURL ? new s(t, e, o.textureURL, o.atlasURL, r).files : new h(t, e, o.textureURL, r), t.addFile(g) } else { const y = new m(t, e, o, r); t.addFile(y.files) } else console.warn('No supported compressed texture format or IMG fallback', e) }; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r(this, t[o]); else r(this, t, e, i); return this }), t.exports = m }, 47931: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = i(73894); const u = new s({ Extends: r, initialize: function (t, e, i, s, n) { let o = 'glsl'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), s = a(l, 'shaderType', 'fragment'), n = a(l, 'xhrSettings'), o = a(l, 'extension', o) } else void 0 === s && (s = 'fragment'); const u = { type: 'glsl', cache: t.cacheManager.shader, extension: o, responseType: 'text', key: e, url: i, config: { shaderType: s }, xhrSettings: n }; r.call(this, t, u) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() }, addToCache: function () { const t = this.data.split('\n'); let e = this.extractBlock(t, 0); if (e) for (; e;) { const i = this.getShaderName(e.header); const s = this.getShaderType(e.header); const n = this.getShaderUniforms(e.header); const r = e.shader; if (this.cache.has(i)) { const o = this.cache.get(i); s === 'fragment' ? o.fragmentSrc = r : o.vertexSrc = r, o.uniforms || (o.uniforms = n) } else s === 'fragment' ? this.cache.add(i, new l(i, r, '', n)) : this.cache.add(i, new l(i, '', r, n)); e = this.extractBlock(t, e.offset) } else this.config.shaderType === 'fragment' ? this.cache.add(this.key, new l(this.key, this.data)) : this.cache.add(this.key, new l(this.key, '', this.data)) }, getShaderName: function (t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'name:') return i.substring(5).trim() } return this.key }, getShaderType: function (t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'type:') return i.substring(5).trim() } return this.config.shaderType }, getShaderUniforms: function (t) { for (var e = {}, i = 0; i < t.length; i++) { const s = t[i].trim(); if (s.substring(0, 8) === 'uniform.') { const n = s.indexOf(':'); if (n) { const r = s.substring(8, n); try { e[r] = JSON.parse(s.substring(n + 1)) } catch (t) { console.warn('Invalid uniform JSON: ' + r) } } } } return e }, extractBlock: function (t, e) { for (var i = -1, s = -1, n = -1, r = !1, o = !1, a = [], h = [], l = e; l < t.length; l++) { const u = t[l].trim(); if (u === '---') if (i === -1) i = l, r = !0; else { if (!r) { o = !1; break } s = l, r = !1, o = !0 } else r ? a.push(u) : o && (h.push(u), n = l) } return r || s === -1 ? null : { header: a, shader: h.join('\n'), offset: n } } }); o.register('glsl', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i, s)); return this }), t.exports = u }, 89749: (t, e, i) => { const s = i(83419); const n = i(54899); const r = i(41299); const o = i(95540); const a = i(98356); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s) { if (h(e)) { const n = e; e = o(n, 'key'), s = o(n, 'config', s) } const a = { type: 'audio', cache: t.cacheManager.audio, extension: i.type, key: e, url: i.url, config: s }; r.call(this, t, a), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0 }, onLoad: function () { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)) }, onError: function () { for (let t = 0; t < this.data.length; t++) { const e = this.data[t]; e.oncanplaythrough = null, e.onerror = null } this.loader.nextFile(this, !1) }, onProgress: function (t) { const e = t.target; e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(n.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad() }, load: function () { this.data = []; const t = this.config && this.config.instances || 1; this.filesTotal = t, this.filesLoaded = 0, this.percentComplete = 0; for (var e = 0; e < t; e++) { var i = new Audio(); i.dataset || (i.dataset = {}), i.dataset.name = this.key + ('0' + e).slice(-2), i.dataset.used = 'false', this.locked ? i.dataset.locked = 'true' : (i.dataset.locked = 'false', i.preload = 'auto', i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i) } for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = a(this, this.loader.baseURL), this.locked || i.load(); this.locked && setTimeout(this.onLoad.bind(this)) } }); t.exports = l }, 88470: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'html'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), s = a(o, 'xhrSettings'), n = a(o, 'extension', n) } const l = { type: 'text', cache: t.cacheManager.html, extension: n, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, l) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() } }); o.register('html', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i)); return this }), t.exports = l }, 14643: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, n, o) { void 0 === s && (s = 512), void 0 === n && (n = 512); let l = 'html'; if (h(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), o = a(u, 'xhrSettings'), l = a(u, 'extension', l), s = a(u, 'width', s), n = a(u, 'height', n) } const c = { type: 'html', cache: t.textureManager, extension: l, responseType: 'text', key: e, url: i, xhrSettings: o, config: { width: s, height: n } }; r.call(this, t, c) }, onProcess: function () { this.state = n.FILE_PROCESSING; const t = this.config.width; const e = this.config.height; const i = []; i.push('<svg width="' + t + 'px" height="' + e + 'px" viewBox="0 0 ' + t + ' ' + e + '" xmlns="http://www.w3.org/2000/svg">'), i.push('<foreignObject width="100%" height="100%">'), i.push('<body xmlns="http://www.w3.org/1999/xhtml">'), i.push(this.xhrLoader.responseText), i.push('</body>'), i.push('</foreignObject>'), i.push('</svg>'); const s = [i.join('\n')]; const o = this; try { var a = new window.Blob(s, { type: 'image/svg+xml;charset=utf-8' }) } catch (t) { return o.state = n.FILE_ERRORED, void o.onProcessComplete() } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { r.revokeObjectURL(o.data), o.onProcessComplete() }, this.data.onerror = function () { r.revokeObjectURL(o.data), o.onProcessError() }, r.createObjectURL(this.data, a, 'image/svg+xml') }, addToCache: function () { this.cache.addImage(this.key, this.data) } }); o.register('htmlTexture', function (t, e, i, s, n) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, s, n)); return this }), t.exports = l }, 19550: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = i(98356); const u = new s({ Extends: r, initialize: function t (e, i, s, n, o) { let l; let u = 'png'; if (h(i)) { const c = i; i = a(c, 'key'), s = a(c, 'url'), l = a(c, 'normalMap'), n = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'frameConfig') } Array.isArray(s) && (l = s[1], s = s[0]); const d = { type: 'image', cache: e.textureManager, extension: u, responseType: 'blob', key: i, url: s, xhrSettings: n, config: o }; if (r.call(this, e, d), l) { const f = new t(e, this.key, l, n, o); f.type = 'normalMap', this.setLink(f), e.addFile(f) } this.useImageElementLoad = e.imageLoadType === 'HTMLImageElement' || this.base64, this.useImageElementLoad && (this.load = this.loadImage, this.onProcess = this.onProcessImage) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { r.revokeObjectURL(t.data), t.onProcessComplete() }, this.data.onerror = function () { r.revokeObjectURL(t.data), t.onProcessError() }, r.createObjectURL(this.data, this.xhrLoader.response, 'image/png') }, onProcessImage: function () { const t = this.state; this.state = n.FILE_PROCESSING, t === n.FILE_LOADED ? this.onProcessComplete() : this.onProcessError() }, loadImage: function () { this.state = n.FILE_LOADING, this.src = l(this, this.loader.baseURL), this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { t.state = n.FILE_LOADED, t.loader.nextFile(t, !0) }, this.data.onerror = function () { t.loader.nextFile(t, !1) }, this.data.src = this.src }, addToCache: function () { const t = this.linkFile; t ? t.state >= n.FILE_COMPLETE && (t.type === 'spritesheet' ? t.addToCache() : this.type === 'normalMap' ? this.cache.addImage(this.key, t.data, this.data) : this.cache.addImage(this.key, this.data, t.data)) : this.cache.addImage(this.key, this.data) } }); o.register('image', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, i)); return this }), t.exports = u }, 518: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(35154); const l = i(41212); const u = new s({ Extends: r, initialize: function (t, e, i, s, o) { let u = 'json'; if (l(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), s = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'dataKey', o) } const d = { type: 'json', cache: t.cacheManager.json, extension: u, responseType: 'text', key: e, url: i, xhrSettings: s, config: o }; r.call(this, t, d), l(i) && (this.data = o ? h(i, o) : i, this.state = n.FILE_POPULATED) }, onProcess: function () { if (this.state !== n.FILE_POPULATED) { this.state = n.FILE_PROCESSING; try { var t = JSON.parse(this.xhrLoader.responseText) } catch (t) { throw this.onProcessError(), t } const e = this.config; this.data = typeof e === 'string' ? h(t, e, t) : t } this.onProcessComplete() } }); o.register('json', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, s, i)); return this }), t.exports = u }, 59327: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(518); const l = i(26430); const u = new s({ Extends: l, initialize: function (t, e, i, s, n, o, u) { if (a(e)) { const c = e; e = r(c, 'key'), i = r(c, 'url', !1) ? r(c, 'url') : r(c, 'atlasURL'), o = r(c, 'xhrSettings'), s = r(c, 'path'), n = r(c, 'baseURL'), u = r(c, 'textureXhrSettings') } const d = new h(t, e, i, o); l.call(this, t, 'multiatlas', e, [d]), this.config.path = s, this.config.baseURL = n, this.config.textureXhrSettings = u }, onFileComplete: function (t) { if (this.files.indexOf(t) !== -1 && (this.pending--, t.type === 'json' && t.data.hasOwnProperty('textures'))) { const e = t.data.textures; const i = this.config; const s = this.loader; const n = s.baseURL; const a = s.path; const h = s.prefix; const l = r(i, 'baseURL', this.baseURL); const u = r(i, 'path', this.path); const c = r(i, 'prefix', this.prefix); const d = r(i, 'textureXhrSettings'); s.setBaseURL(l), s.setPath(u), s.setPrefix(c); for (let f = 0; f < e.length; f++) { const p = e[f].image; const v = 'MA' + this.multiKeyIndex + '_' + p; const g = new o(s, v, p, d); if (this.addToMultiFile(g), s.addFile(g), e[f].normalMap) { const m = new o(s, v, e[f].normalMap, d); m.type = 'normalMap', g.setLink(m), this.addToMultiFile(m), s.addFile(m) } } s.setBaseURL(n), s.setPath(a), s.setPrefix(h) } }, addToCache: function () { if (this.isReadyToProcess()) { for (var t = this.files[0], e = [], i = [], s = [], n = 1; n < this.files.length; n++) { const r = this.files[n]; if (r.type !== 'normalMap') for (let o = r.key.indexOf('_'), a = r.key.substr(o + 1), h = r.data, l = 0; l < t.data.textures.length; l++) { const u = t.data.textures[l]; if (u.image === a) { i.push(h), e.push(u), r.linkFile && s.push(r.linkFile.data); break } } } s.length === 0 && (s = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, s), this.complete = !0 } } }); n.register('multiatlas', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = u }, 99297: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(41212); const a = i(26430); const h = i(34328); const l = new s({ Extends: a, initialize: function (t, e, i, s) { let n = 'js'; const l = []; if (o(e)) { const u = e; e = r(u, 'key'), i = r(u, 'url'), s = r(u, 'xhrSettings'), n = r(u, 'extension', n) } Array.isArray(i) || (i = [i]); for (let c = 0; c < i.length; c++) { const d = new h(t, { key: e + '_' + c.toString(), url: i[c], extension: n, xhrSettings: s }); d.onProcess = function () { this.onProcessComplete() }, l.push(d) } a.call(this, t, 'scripts', e, l) }, addToCache: function () { if (this.isReadyToProcess()) { for (let t = 0; t < this.files.length; t++) { const e = this.files[t]; e.data = document.createElement('script'), e.data.language = 'javascript', e.data.type = 'text/javascript', e.data.defer = !1, e.data.text = e.xhrLoader.responseText, document.head.appendChild(e.data) } this.complete = !0 } } }); n.register('scripts', function (t, e, i) { let s; if (Array.isArray(t)) for (let n = 0; n < t.length; n++)s = new l(this, t[n]), this.addFile(s.files); else s = new l(this, t, e, i), this.addFile(s.files); return this }), t.exports = l }, 41846: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(41212); const a = i(26430); const h = i(85048); const l = i(61485); const u = i(78776); const c = new s({ Extends: a, initialize: function (t, e, i, s, n, h) { let l; let c; const d = t.cacheManager.obj; if (o(e)) { const f = e; e = r(f, 'key'), l = new u(t, { key: e, type: 'obj', cache: d, url: r(f, 'url'), extension: r(f, 'extension', 'obj'), xhrSettings: r(f, 'xhrSettings'), config: { flipUV: r(f, 'flipUV', n) } }), (s = r(f, 'matURL')) && (c = new u(t, { key: e, type: 'mat', cache: d, url: s, extension: r(f, 'matExtension', 'mat'), xhrSettings: r(f, 'xhrSettings') })) } else l = new u(t, { key: e, url: i, type: 'obj', cache: d, extension: 'obj', xhrSettings: h, config: { flipUV: n } }), s && (c = new u(t, { key: e, url: s, type: 'mat', cache: d, extension: 'mat', xhrSettings: h })); a.call(this, t, 'obj', e, [l, c]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = h(t.data, t.config.flipUV); e && (i.materials = l(e.data)), t.cache.add(t.key, i), this.complete = !0 } } }); n.register('obj', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new c(this, t[o]), this.addFile(r.files); else r = new c(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = c }, 58610: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(74099); const o = i(518); const a = new s({ Extends: o, initialize: function (t, e, i, s, n) { o.call(this, t, e, i, s, n), this.type = 'packfile' }, onProcess: function () { if (this.state !== n.FILE_POPULATED && (this.state = n.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.data.hasOwnProperty('files') && this.config) { const t = {}; t[this.config] = this.data, this.data = t } this.loader.addPack(this.data, this.config), this.onProcessComplete() } }); r.register('pack', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, s, i)); return this }), t.exports = a }, 48988: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, o, l) { let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), s = a(c, 'start'), o = a(c, 'mapping') } const d = { type: 'plugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { start: s, mapping: o } }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = n.FILE_POPULATED) }, onProcess: function () { const t = this.loader.systems.plugins; const e = this.config; const i = a(e, 'start', !1); const s = a(e, 'mapping', null); if (this.state === n.FILE_POPULATED) t.install(this.key, this.data, i, s); else { this.state = n.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data); const r = t.install(this.key, window[this.key], i, s); (i || s) && (this.loader.systems[s] = r, this.loader.scene[s] = r) } this.onProcessComplete() } }); o.register('plugin', function (t, e, i, s, n) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, s, n)); return this }), t.exports = l }, 67397: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, n) { let o = 'svg'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), s = a(l, 'svgConfig', {}), n = a(l, 'xhrSettings'), o = a(l, 'extension', o) } const u = { type: 'svg', cache: t.textureManager, extension: o, responseType: 'text', key: e, url: i, xhrSettings: n, config: { width: a(s, 'width'), height: a(s, 'height'), scale: a(s, 'scale') } }; r.call(this, t, u) }, onProcess: function () { this.state = n.FILE_PROCESSING; const t = this.xhrLoader.responseText; let e = [t]; let i = this.config.width; let s = this.config.height; const o = this.config.scale; t: if (i && s || o) { const a = (new DOMParser()).parseFromString(t, 'text/xml').getElementsByTagName('svg')[0]; const h = a.hasAttribute('viewBox'); let l = parseFloat(a.getAttribute('width')); let u = parseFloat(a.getAttribute('height')); if (!h && l && u) a.setAttribute('viewBox', '0  0 ' + l + ' ' + u); else if (h && !l && !u) { const c = a.getAttribute('viewBox').split(/\s+|,/); l = c[2], u = c[3] } if (o) { if (!l || !u) break t; i = l * o, s = u * o } a.setAttribute('width', i.toString() + 'px'), a.setAttribute('height', s.toString() + 'px'), e = [(new XMLSerializer()).serializeToString(a)] } try { var d = new window.Blob(e, { type: 'image/svg+xml;charset=utf-8' }) } catch (t) { return void this.onProcessError() } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const f = this; let p = !1; this.data.onload = function () { p || r.revokeObjectURL(f.data), f.onProcessComplete() }, this.data.onerror = function () { p ? f.onProcessError() : (p = !0, r.revokeObjectURL(f.data), f.data.src = 'data:image/svg+xml,' + encodeURIComponent(e.join(''))) }, r.createObjectURL(this.data, d, 'image/svg+xml') }, addToCache: function () { this.cache.addImage(this.key, this.data) } }); o.register('svg', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i, s)); return this }), t.exports = l }, 88423: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'js'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), s = a(o, 'xhrSettings'), n = a(o, 'extension', n) } const l = { type: 'text', extension: n, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, l) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() }, addToCache: function () { const t = this.data.concat('(function(){\nreturn new ' + this.key + '();\n}).call(this);'); const e = eval; this.loader.sceneManager.add(this.key, e(t)), this.complete = !0 } }); o.register('sceneFile', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i)); return this }), t.exports = l }, 56812: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, o, l) { let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), s = a(c, 'systemKey'), o = a(c, 'sceneKey') } const d = { type: 'scenePlugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { systemKey: s, sceneKey: o } }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = n.FILE_POPULATED) }, onProcess: function () { const t = this.loader.systems.plugins; const e = this.config; const i = this.key; const s = a(e, 'systemKey', i); const r = a(e, 'sceneKey', i); this.state === n.FILE_POPULATED ? t.installScenePlugin(s, this.data, r, this.loader.scene, !0) : (this.state = n.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(s, window[this.key], r, this.loader.scene, !0)), this.onProcessComplete() } }); o.register('scenePlugin', function (t, e, i, s, n) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, s, n)); return this }), t.exports = l }, 34328: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s, n) { let o = 'js'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), s = a(l, 'type', 'script'), n = a(l, 'xhrSettings'), o = a(l, 'extension', o) } else void 0 === s && (s = 'script'); const u = { type: s, cache: !1, extension: o, responseType: 'text', key: e, url: i, xhrSettings: n }; r.call(this, t, u) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete() } }); o.register('script', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i, s)); return this }), t.exports = l }, 85035: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(74099); const o = i(19550); const a = new s({ Extends: o, initialize: function (t, e, i, s, n) { o.call(this, t, e, i, n, s), this.type = 'spritesheet' }, addToCache: function () { const t = this.linkFile; t ? t.state >= n.FILE_COMPLETE && (this.type === 'normalMap' ? this.cache.addSpriteSheet(this.key, t.data, this.config, this.data) : this.cache.addSpriteSheet(this.key, this.data, this.config, t.data)) : this.cache.addSpriteSheet(this.key, this.data, this.config) } }); r.register('spritesheet', function (t, e, i, s) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i, s)); return this }), t.exports = a }, 78776: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'text'; let o = 'txt'; let l = t.cacheManager.text; if (h(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), s = a(u, 'xhrSettings'), o = a(u, 'extension', o), n = a(u, 'type', n), l = a(u, 'cache', l) } const c = { type: n, cache: l, extension: o, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, c) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() } }); o.register('text', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i)); return this }), t.exports = l }, 49477: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = i(80341); const u = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'csv'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), s = a(o, 'xhrSettings'), n = a(o, 'extension', n) } const u = { type: 'tilemapCSV', cache: t.cacheManager.tilemap, extension: n, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, u), this.tilemapFormat = l.CSV }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete() }, addToCache: function () { const t = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, t) } }); o.register('tilemapCSV', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, i)); return this }), t.exports = u }, 40807: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(518); const o = i(80341); const a = new s({ Extends: r, initialize: function (t, e, i, s) { r.call(this, t, e, i, s), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap }, addToCache: function () { const t = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, t) } }); n.register('tilemapImpact', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, i)); return this }), t.exports = a }, 56775: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(518); const o = i(80341); const a = new s({ Extends: r, initialize: function (t, e, i, s) { r.call(this, t, e, i, s), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap }, addToCache: function () { const t = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, t) } }); n.register('tilemapTiledJSON', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, i)); return this }), t.exports = a }, 25771: (t, e, i) => { const s = i(83419); const n = i(74099); const r = i(95540); const o = i(19550); const a = i(41212); const h = i(26430); const l = i(78776); const u = new s({ Extends: h, initialize: function (t, e, i, s, n, u) { let c, d; if (a(e)) { const f = e; e = r(f, 'key'), c = new o(t, { key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings') }), d = new l(t, { key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'txt'), xhrSettings: r(f, 'atlasXhrSettings') }) } else c = new o(t, e, i, n), d = new l(t, e, s, u); c.linkFile ? h.call(this, t, 'unityatlas', e, [c, d, c.linkFile]) : h.call(this, t, 'unityatlas', e, [c, d]) }, addToCache: function () { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), this.complete = !0 } } }); n.register('unityAtlas', function (t, e, i, s, n) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, s, n), this.addFile(r.files); return this }), t.exports = u }, 33720: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(98356); const h = i(95540); const l = i(41212); const u = new s({ Extends: r, initialize: function (t, e, i, s) { if (void 0 === s && (s = !1), l(e)) { const n = e; e = h(n, 'key'), i = h(n, 'url', []), s = h(n, 'noAudio', !1) } const o = t.systems.game.device.video.getVideoURL(i); o || console.warn('VideoFile: No supported format for ' + e); const a = { type: 'video', cache: t.cacheManager.video, extension: o.type, key: e, url: o.url, config: { noAudio: s } }; r.call(this, t, a) }, onProcess: function () { this.data = { url: this.src, noAudio: this.config.noAudio, crossOrigin: this.crossOrigin }, this.onProcessComplete() }, load: function () { this.src = a(this, this.loader.baseURL), this.state = n.FILE_LOADED, this.loader.nextFile(this, !0) } }); o.register('video', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, i)); return this }), t.exports = u }, 57318: (t, e, i) => { const s = i(83419); const n = i(23906); const r = i(41299); const o = i(74099); const a = i(95540); const h = i(41212); const l = i(56836); const u = new s({ Extends: r, initialize: function (t, e, i, s) { let n = 'xml'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), s = a(o, 'xhrSettings'), n = a(o, 'extension', n) } const l = { type: 'xml', cache: t.cacheManager.xml, extension: n, responseType: 'text', key: e, url: i, xhrSettings: s }; r.call(this, t, l) }, onProcess: function () { this.state = n.FILE_PROCESSING, this.data = l(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : this.onProcessError() } }); o.register('xml', function (t, e, i) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, i)); return this }), t.exports = u }, 64589: (t, e, i) => { t.exports = { AnimationJSONFile: i(14135), AsepriteFile: i(76272), AtlasJSONFile: i(38734), AtlasXMLFile: i(74599), AudioFile: i(21097), AudioSpriteFile: i(89524), BinaryFile: i(85722), BitmapFontFile: i(97025), CompressedTextureFile: i(69559), CSSFile: i(16024), GLSLFile: i(47931), HTML5AudioFile: i(89749), HTMLFile: i(88470), HTMLTextureFile: i(14643), ImageFile: i(19550), JSONFile: i(518), MultiAtlasFile: i(59327), MultiScriptFile: i(99297), OBJFile: i(41846), PackFile: i(58610), PluginFile: i(48988), SceneFile: i(88423), ScenePluginFile: i(56812), ScriptFile: i(34328), SpriteSheetFile: i(85035), SVGFile: i(67397), TextFile: i(78776), TilemapCSVFile: i(49477), TilemapImpactFile: i(40807), TilemapJSONFile: i(56775), UnityAtlasFile: i(25771), VideoFile: i(33720), XMLFile: i(57318) } }, 57777: (t, e, i) => { const s = i(23906); const n = i(79291); let r = { Events: i(54899), FileTypes: i(64589), File: i(41299), FileTypesManager: i(74099), GetURL: i(98356), LoaderPlugin: i(74261), MergeXHRSettings: i(3374), MultiFile: i(26430), XHRLoader: i(84376), XHRSettings: i(92638) }; r = n(!1, r, s), t.exports = r }, 53307: t => { t.exports = function (t) { for (var e = 0, i = 0; i < t.length; i++)e += +t[i]; return e / t.length } }, 85710: (t, e, i) => { const s = i(6411); t.exports = function (t, e) { return s(t) / s(e) / s(t - e) } }, 30976: t => { t.exports = function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t) } }, 87842: t => { t.exports = function (t, e, i, s, n) { const r = 0.5 * (s - e); const o = 0.5 * (n - i); const a = t * t; return (2 * i - 2 * s + r + o) * (t * a) + (-3 * i + 3 * s - 2 * r - o) * a + r * t + i } }, 26302: t => { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const s = Math.pow(i, -e); return Math.ceil(t * s) / s } }, 45319: t => { t.exports = function (t, e, i) { return Math.max(e, Math.min(i, t)) } }, 39506: (t, e, i) => { const s = i(36383); t.exports = function (t) { return t * s.DEG_TO_RAD } }, 61241: t => { t.exports = function (t, e) { return Math.abs(t - e) } }, 38857: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(37867); const o = i(29747); const a = new r(); const h = new n({ initialize: function t (e, i, s, n) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = t.DefaultOrder), this._x = e, this._y = i, this._z = s, this._order = n, this.onChangeCallback = o }, x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback(this) } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback(this) } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback(this) } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this.onChangeCallback(this) } }, set: function (t, e, i, s) { return void 0 === s && (s = this._order), this._x = t, this._y = e, this._z = i, this._order = s, this.onChangeCallback(this), this }, copy: function (t) { return this.set(t.x, t.y, t.z, t.order) }, setFromQuaternion: function (t, e, i) { return void 0 === e && (e = this._order), void 0 === i && (i = !1), a.fromQuat(t), this.setFromRotationMatrix(a, e, i) }, setFromRotationMatrix: function (t, e, i) { void 0 === e && (e = this._order), void 0 === i && (i = !1); const n = t.val; const r = n[0]; const o = n[4]; const a = n[8]; const h = n[1]; const l = n[5]; const u = n[9]; const c = n[2]; const d = n[6]; const f = n[10]; let p = 0; let v = 0; let g = 0; const m = 0.99999; switch (e) { case 'XYZ': v = Math.asin(s(a, -1, 1)), Math.abs(a) < m ? (p = Math.atan2(-u, f), g = Math.atan2(-o, r)) : p = Math.atan2(d, l); break; case 'YXZ': p = Math.asin(-s(u, -1, 1)), Math.abs(u) < m ? (v = Math.atan2(a, f), g = Math.atan2(h, l)) : v = Math.atan2(-c, r); break; case 'ZXY': p = Math.asin(s(d, -1, 1)), Math.abs(d) < m ? (v = Math.atan2(-c, f), g = Math.atan2(-o, l)) : g = Math.atan2(h, r); break; case 'ZYX': v = Math.asin(-s(c, -1, 1)), Math.abs(c) < m ? (p = Math.atan2(d, f), g = Math.atan2(h, r)) : g = Math.atan2(-o, l); break; case 'YZX': g = Math.asin(s(h, -1, 1)), Math.abs(h) < m ? (p = Math.atan2(-u, l), v = Math.atan2(-c, r)) : v = Math.atan2(a, f); break; case 'XZY': g = Math.asin(-s(o, -1, 1)), Math.abs(o) < m ? (p = Math.atan2(d, l), v = Math.atan2(a, r)) : p = Math.atan2(-u, f) } return this._x = p, this._y = v, this._z = g, this._order = e, i && this.onChangeCallback(this), this } }); h.RotationOrders = ['XYZ', 'YXZ', 'ZXY', 'ZYX', 'YZX', 'XZY'], h.DefaultOrder = 'XYZ', t.exports = h }, 6411: t => { t.exports = function (t) { if (t === 0) return 1; for (var e = t; --t;)e *= t; return e } }, 99472: t => { t.exports = function (t, e) { return Math.random() * (e - t) + t } }, 77623: t => { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const s = Math.pow(i, -e); return Math.floor(t * s) / s } }, 62945: (t, e, i) => { const s = i(45319); t.exports = function (t, e, i) { return (i - e) * (t = s(t, 0, 1)) + e } }, 38265: t => { t.exports = function (t, e) { return t / e / 1e3 } }, 78702: t => { t.exports = function (t) { return t == parseFloat(t) ? !(t % 2) : void 0 } }, 94883: t => { t.exports = function (t) { return t === parseFloat(t) ? !(t % 2) : void 0 } }, 28915: t => { t.exports = function (t, e, i) { return (e - t) * i + t } }, 94908: t => { t.exports = function (t, e, i) { return void 0 === i && (i = 0), t.clone().lerp(e, i) } }, 94434: (t, e, i) => { var s = new (i(83419))({ initialize: function (t) { this.val = new Float32Array(9), t ? this.copy(t) : this.identity() }, clone: function () { return new s(this) }, set: function (t) { return this.copy(t) }, copy: function (t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this }, fromMat4: function (t) { const e = t.val; const i = this.val; return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this }, fromArray: function (t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this }, identity: function () { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this }, transpose: function () { const t = this.val; const e = t[1]; const i = t[2]; const s = t[5]; return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = s, this }, invert: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = l * r - o * h; const c = -l * n + o * a; const d = h * n - r * a; let f = e * u + i * c + s * d; return f ? (f = 1 / f, t[0] = u * f, t[1] = (-l * i + s * h) * f, t[2] = (o * i - s * r) * f, t[3] = c * f, t[4] = (l * e - s * a) * f, t[5] = (-o * e + s * n) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * n) * f, this) : null }, adjoint: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return t[0] = r * l - o * h, t[1] = s * h - i * l, t[2] = i * o - s * r, t[3] = o * a - n * l, t[4] = e * l - s * a, t[5] = s * n - e * o, t[6] = n * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * n, this }, determinant: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return e * (l * r - o * h) + i * (-l * n + o * a) + s * (h * n - r * a) }, multiply: function (t) { const e = this.val; const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = t.val; const d = c[0]; const f = c[1]; const p = c[2]; const v = c[3]; const g = c[4]; const m = c[5]; const y = c[6]; const x = c[7]; const T = c[8]; return e[0] = d * i + f * r + p * h, e[1] = d * s + f * o + p * l, e[2] = d * n + f * a + p * u, e[3] = v * i + g * r + m * h, e[4] = v * s + g * o + m * l, e[5] = v * n + g * a + m * u, e[6] = y * i + x * r + T * h, e[7] = y * s + x * o + T * l, e[8] = y * n + x * a + T * u, this }, translate: function (t) { const e = this.val; const i = t.x; const s = t.y; return e[6] = i * e[0] + s * e[3] + e[6], e[7] = i * e[1] + s * e[4] + e[7], e[8] = i * e[2] + s * e[5] + e[8], this }, rotate: function (t) { const e = this.val; const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = Math.sin(t); const l = Math.cos(t); return e[0] = l * i + h * r, e[1] = l * s + h * o, e[2] = l * n + h * a, e[3] = l * r - h * i, e[4] = l * o - h * s, e[5] = l * a - h * n, this }, scale: function (t) { const e = this.val; const i = t.x; const s = t.y; return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = s * e[3], e[4] = s * e[4], e[5] = s * e[5], this }, fromQuat: function (t) { const e = t.x; const i = t.y; const s = t.z; const n = t.w; const r = e + e; const o = i + i; const a = s + s; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = s * a; const p = n * r; const v = n * o; const g = n * a; const m = this.val; return m[0] = 1 - (c + f), m[3] = l + g, m[6] = u - v, m[1] = l - g, m[4] = 1 - (h + f), m[7] = d + p, m[2] = u + v, m[5] = d - p, m[8] = 1 - (h + c), this }, normalFromMat4: function (t) { const e = t.val; const i = this.val; const s = e[0]; const n = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = e[6]; const u = e[7]; const c = e[8]; const d = e[9]; const f = e[10]; const p = e[11]; const v = e[12]; const g = e[13]; const m = e[14]; const y = e[15]; const x = s * h - n * a; const T = s * l - r * a; const w = s * u - o * a; const b = n * l - r * h; const S = n * u - o * h; const E = r * u - o * l; const A = c * g - d * v; const C = c * m - f * v; const _ = c * y - p * v; const M = d * m - f * g; const P = d * y - p * g; const R = f * y - p * m; let L = x * R - T * P + w * M + b * _ - S * C + E * A; return L ? (L = 1 / L, i[0] = (h * R - l * P + u * M) * L, i[1] = (l * _ - a * R - u * C) * L, i[2] = (a * P - h * _ + u * A) * L, i[3] = (r * P - n * R - o * M) * L, i[4] = (s * R - r * _ + o * C) * L, i[5] = (n * _ - s * P - o * A) * L, i[6] = (g * E - m * S + y * b) * L, i[7] = (m * w - v * E - y * T) * L, i[8] = (v * S - g * w + y * x) * L, this) : null } }); t.exports = s }, 37867: (t, e, i) => { const s = i(83419); const n = i(25836); const r = 1e-6; var o = new s({ initialize: function (t) { this.val = new Float32Array(16), t ? this.copy(t) : this.identity() }, clone: function () { return new o(this) }, set: function (t) { return this.copy(t) }, setValues: function (t, e, i, s, n, r, o, a, h, l, u, c, d, f, p, v) { const g = this.val; return g[0] = t, g[1] = e, g[2] = i, g[3] = s, g[4] = n, g[5] = r, g[6] = o, g[7] = a, g[8] = h, g[9] = l, g[10] = u, g[11] = c, g[12] = d, g[13] = f, g[14] = p, g[15] = v, this }, copy: function (t) { const e = t.val; return this.setValues(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]) }, fromArray: function (t) { return this.setValues(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]) }, zero: function () { return this.setValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) }, transform: function (t, e, i) { const s = a.fromQuat(i).val; const n = e.x; const r = e.y; const o = e.z; return this.setValues(s[0] * n, s[1] * n, s[2] * n, 0, s[4] * r, s[5] * r, s[6] * r, 0, s[8] * o, s[9] * o, s[10] * o, 0, t.x, t.y, t.z, 1) }, xyz: function (t, e, i) { this.identity(); const s = this.val; return s[12] = t, s[13] = e, s[14] = i, this }, scaling: function (t, e, i) { this.zero(); const s = this.val; return s[0] = t, s[5] = e, s[10] = i, s[15] = 1, this }, identity: function () { return this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) }, transpose: function () { const t = this.val; const e = t[1]; const i = t[2]; const s = t[3]; const n = t[6]; const r = t[7]; const o = t[11]; return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = n, t[11] = t[14], t[12] = s, t[13] = r, t[14] = o, this }, getInverse: function (t) { return this.copy(t), this.invert() }, invert: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const v = t[14]; const g = t[15]; const m = e * o - i * r; const y = e * a - s * r; const x = e * h - n * r; const T = i * a - s * o; const w = i * h - n * o; const b = s * h - n * a; const S = l * p - u * f; const E = l * v - c * f; const A = l * g - d * f; const C = u * v - c * p; const _ = u * g - d * p; const M = c * g - d * v; let P = m * M - y * _ + x * C + T * A - w * E + b * S; return P ? (P = 1 / P, this.setValues((o * M - a * _ + h * C) * P, (s * _ - i * M - n * C) * P, (p * b - v * w + g * T) * P, (c * w - u * b - d * T) * P, (a * A - r * M - h * E) * P, (e * M - s * A + n * E) * P, (v * x - f * b - g * y) * P, (l * b - c * x + d * y) * P, (r * _ - o * A + h * S) * P, (i * A - e * _ - n * S) * P, (f * w - p * x + g * m) * P, (u * x - l * w - d * m) * P, (o * E - r * C - a * S) * P, (e * C - i * E + s * S) * P, (p * y - f * T - v * m) * P, (l * T - u * y + c * m) * P)) : this }, adjoint: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const v = t[14]; const g = t[15]; return this.setValues(o * (c * g - d * v) - u * (a * g - h * v) + p * (a * d - h * c), -(i * (c * g - d * v) - u * (s * g - n * v) + p * (s * d - n * c)), i * (a * g - h * v) - o * (s * g - n * v) + p * (s * h - n * a), -(i * (a * d - h * c) - o * (s * d - n * c) + u * (s * h - n * a)), -(r * (c * g - d * v) - l * (a * g - h * v) + f * (a * d - h * c)), e * (c * g - d * v) - l * (s * g - n * v) + f * (s * d - n * c), -(e * (a * g - h * v) - r * (s * g - n * v) + f * (s * h - n * a)), e * (a * d - h * c) - r * (s * d - n * c) + l * (s * h - n * a), r * (u * g - d * p) - l * (o * g - h * p) + f * (o * d - h * u), -(e * (u * g - d * p) - l * (i * g - n * p) + f * (i * d - n * u)), e * (o * g - h * p) - r * (i * g - n * p) + f * (i * h - n * o), -(e * (o * d - h * u) - r * (i * d - n * u) + l * (i * h - n * o)), -(r * (u * v - c * p) - l * (o * v - a * p) + f * (o * c - a * u)), e * (u * v - c * p) - l * (i * v - s * p) + f * (i * c - s * u), -(e * (o * v - a * p) - r * (i * v - s * p) + f * (i * a - s * o)), e * (o * c - a * u) - r * (i * c - s * u) + l * (i * a - s * o)) }, determinant: function () { const t = this.val; const e = t[0]; const i = t[1]; const s = t[2]; const n = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const v = t[14]; const g = t[15]; return (e * o - i * r) * (c * g - d * v) - (e * a - s * r) * (u * g - d * p) + (e * h - n * r) * (u * v - c * p) + (i * a - s * o) * (l * g - d * f) - (i * h - n * o) * (l * v - c * f) + (s * h - n * a) * (l * p - u * f) }, multiply: function (t) { const e = this.val; const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = e[9]; const d = e[10]; const f = e[11]; const p = e[12]; const v = e[13]; const g = e[14]; const m = e[15]; const y = t.val; let x = y[0]; let T = y[1]; let w = y[2]; let b = y[3]; return e[0] = x * i + T * o + w * u + b * p, e[1] = x * s + T * a + w * c + b * v, e[2] = x * n + T * h + w * d + b * g, e[3] = x * r + T * l + w * f + b * m, x = y[4], T = y[5], w = y[6], b = y[7], e[4] = x * i + T * o + w * u + b * p, e[5] = x * s + T * a + w * c + b * v, e[6] = x * n + T * h + w * d + b * g, e[7] = x * r + T * l + w * f + b * m, x = y[8], T = y[9], w = y[10], b = y[11], e[8] = x * i + T * o + w * u + b * p, e[9] = x * s + T * a + w * c + b * v, e[10] = x * n + T * h + w * d + b * g, e[11] = x * r + T * l + w * f + b * m, x = y[12], T = y[13], w = y[14], b = y[15], e[12] = x * i + T * o + w * u + b * p, e[13] = x * s + T * a + w * c + b * v, e[14] = x * n + T * h + w * d + b * g, e[15] = x * r + T * l + w * f + b * m, this }, multiplyLocal: function (t) { const e = this.val; const i = t.val; return this.setValues(e[0] * i[0] + e[1] * i[4] + e[2] * i[8] + e[3] * i[12], e[0] * i[1] + e[1] * i[5] + e[2] * i[9] + e[3] * i[13], e[0] * i[2] + e[1] * i[6] + e[2] * i[10] + e[3] * i[14], e[0] * i[3] + e[1] * i[7] + e[2] * i[11] + e[3] * i[15], e[4] * i[0] + e[5] * i[4] + e[6] * i[8] + e[7] * i[12], e[4] * i[1] + e[5] * i[5] + e[6] * i[9] + e[7] * i[13], e[4] * i[2] + e[5] * i[6] + e[6] * i[10] + e[7] * i[14], e[4] * i[3] + e[5] * i[7] + e[6] * i[11] + e[7] * i[15], e[8] * i[0] + e[9] * i[4] + e[10] * i[8] + e[11] * i[12], e[8] * i[1] + e[9] * i[5] + e[10] * i[9] + e[11] * i[13], e[8] * i[2] + e[9] * i[6] + e[10] * i[10] + e[11] * i[14], e[8] * i[3] + e[9] * i[7] + e[10] * i[11] + e[11] * i[15], e[12] * i[0] + e[13] * i[4] + e[14] * i[8] + e[15] * i[12], e[12] * i[1] + e[13] * i[5] + e[14] * i[9] + e[15] * i[13], e[12] * i[2] + e[13] * i[6] + e[14] * i[10] + e[15] * i[14], e[12] * i[3] + e[13] * i[7] + e[14] * i[11] + e[15] * i[15]) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { const i = t.val; const s = e.val; const n = i[0]; const r = i[4]; const o = i[8]; const a = i[12]; const h = i[1]; const l = i[5]; const u = i[9]; const c = i[13]; const d = i[2]; const f = i[6]; const p = i[10]; const v = i[14]; const g = i[3]; const m = i[7]; const y = i[11]; const x = i[15]; const T = s[0]; const w = s[4]; const b = s[8]; const S = s[12]; const E = s[1]; const A = s[5]; const C = s[9]; const _ = s[13]; const M = s[2]; const P = s[6]; const R = s[10]; const L = s[14]; const O = s[3]; const F = s[7]; const D = s[11]; const k = s[15]; return this.setValues(n * T + r * E + o * M + a * O, h * T + l * E + u * M + c * O, d * T + f * E + p * M + v * O, g * T + m * E + y * M + x * O, n * w + r * A + o * P + a * F, h * w + l * A + u * P + c * F, d * w + f * A + p * P + v * F, g * w + m * A + y * P + x * F, n * b + r * C + o * R + a * D, h * b + l * C + u * R + c * D, d * b + f * C + p * R + v * D, g * b + m * C + y * R + x * D, n * S + r * _ + o * L + a * k, h * S + l * _ + u * L + c * k, d * S + f * _ + p * L + v * k, g * S + m * _ + y * L + x * k) }, translate: function (t) { return this.translateXYZ(t.x, t.y, t.z) }, translateXYZ: function (t, e, i) { const s = this.val; return s[12] = s[0] * t + s[4] * e + s[8] * i + s[12], s[13] = s[1] * t + s[5] * e + s[9] * i + s[13], s[14] = s[2] * t + s[6] * e + s[10] * i + s[14], s[15] = s[3] * t + s[7] * e + s[11] * i + s[15], this }, scale: function (t) { return this.scaleXYZ(t.x, t.y, t.z) }, scaleXYZ: function (t, e, i) { const s = this.val; return s[0] = s[0] * t, s[1] = s[1] * t, s[2] = s[2] * t, s[3] = s[3] * t, s[4] = s[4] * e, s[5] = s[5] * e, s[6] = s[6] * e, s[7] = s[7] * e, s[8] = s[8] * i, s[9] = s[9] * i, s[10] = s[10] * i, s[11] = s[11] * i, this }, makeRotationAxis: function (t, e) { const i = Math.cos(e); const s = Math.sin(e); const n = 1 - i; const r = t.x; const o = t.y; const a = t.z; const h = n * r; const l = n * o; return this.setValues(h * r + i, h * o - s * a, h * a + s * o, 0, h * o + s * a, l * o + i, l * a - s * r, 0, h * a - s * o, l * a + s * r, n * a * a + i, 0, 0, 0, 0, 1) }, rotate: function (t, e) { const i = this.val; let s = e.x; let n = e.y; let o = e.z; let a = Math.sqrt(s * s + n * n + o * o); if (Math.abs(a) < r) return this; s *= a = 1 / a, n *= a, o *= a; const h = Math.sin(t); const l = Math.cos(t); const u = 1 - l; const c = i[0]; const d = i[1]; const f = i[2]; const p = i[3]; const v = i[4]; const g = i[5]; const m = i[6]; const y = i[7]; const x = i[8]; const T = i[9]; const w = i[10]; const b = i[11]; const S = i[12]; const E = i[13]; const A = i[14]; const C = i[15]; const _ = s * s * u + l; const M = n * s * u + o * h; const P = o * s * u - n * h; const R = s * n * u - o * h; const L = n * n * u + l; const O = o * n * u + s * h; const F = s * o * u + n * h; const D = n * o * u - s * h; const k = o * o * u + l; return this.setValues(c * _ + v * M + x * P, d * _ + g * M + T * P, f * _ + m * M + w * P, p * _ + y * M + b * P, c * R + v * L + x * O, d * R + g * L + T * O, f * R + m * L + w * O, p * R + y * L + b * O, c * F + v * D + x * k, d * F + g * D + T * k, f * F + m * D + w * k, p * F + y * D + b * k, S, E, A, C) }, rotateX: function (t) { const e = this.val; const i = Math.sin(t); const s = Math.cos(t); const n = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = n * s + h * i, e[5] = r * s + l * i, e[6] = o * s + u * i, e[7] = a * s + c * i, e[8] = h * s - n * i, e[9] = l * s - r * i, e[10] = u * s - o * i, e[11] = c * s - a * i, this }, rotateY: function (t) { const e = this.val; const i = Math.sin(t); const s = Math.cos(t); const n = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = n * s - h * i, e[1] = r * s - l * i, e[2] = o * s - u * i, e[3] = a * s - c * i, e[8] = n * i + h * s, e[9] = r * i + l * s, e[10] = o * i + u * s, e[11] = a * i + c * s, this }, rotateZ: function (t) { const e = this.val; const i = Math.sin(t); const s = Math.cos(t); const n = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = n * s + h * i, e[1] = r * s + l * i, e[2] = o * s + u * i, e[3] = a * s + c * i, e[4] = h * s - n * i, e[5] = l * s - r * i, e[6] = u * s - o * i, e[7] = c * s - a * i, this }, fromRotationTranslation: function (t, e) { const i = t.x; const s = t.y; const n = t.z; const r = t.w; const o = i + i; const a = s + s; const h = n + n; const l = i * o; const u = i * a; const c = i * h; const d = s * a; const f = s * h; const p = n * h; const v = r * o; const g = r * a; const m = r * h; return this.setValues(1 - (d + p), u + m, c - g, 0, u - m, 1 - (l + p), f + v, 0, c + g, f - v, 1 - (l + d), 0, e.x, e.y, e.z, 1) }, fromQuat: function (t) { const e = t.x; const i = t.y; const s = t.z; const n = t.w; const r = e + e; const o = i + i; const a = s + s; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = s * a; const p = n * r; const v = n * o; const g = n * a; return this.setValues(1 - (c + f), l + g, u - v, 0, l - g, 1 - (h + f), d + p, 0, u + v, d - p, 1 - (h + c), 0, 0, 0, 0, 1) }, frustum: function (t, e, i, s, n, r) { const o = 1 / (e - t); const a = 1 / (s - i); const h = 1 / (n - r); return this.setValues(2 * n * o, 0, 0, 0, 0, 2 * n * a, 0, 0, (e + t) * o, (s + i) * a, (r + n) * h, -1, 0, 0, r * n * 2 * h, 0) }, perspective: function (t, e, i, s) { const n = 1 / Math.tan(t / 2); const r = 1 / (i - s); return this.setValues(n / e, 0, 0, 0, 0, n, 0, 0, 0, 0, (s + i) * r, -1, 0, 0, 2 * s * i * r, 0) }, perspectiveLH: function (t, e, i, s) { return this.setValues(2 * i / t, 0, 0, 0, 0, 2 * i / e, 0, 0, 0, 0, -s / (i - s), 1, 0, 0, i * s / (i - s), 0) }, ortho: function (t, e, i, s, n, r) { let o = t - e; let a = i - s; let h = n - r; return o = o === 0 ? o : 1 / o, a = a === 0 ? a : 1 / a, h = h === 0 ? h : 1 / h, this.setValues(-2 * o, 0, 0, 0, 0, -2 * a, 0, 0, 0, 0, 2 * h, 0, (t + e) * o, (s + i) * a, (r + n) * h, 1) }, lookAtRH: function (t, e, i) { const s = this.val; return c.subVectors(t, e), c.getLengthSquared() === 0 && (c.z = 1), c.normalize(), l.crossVectors(i, c), l.getLengthSquared() === 0 && (Math.abs(i.z) === 1 ? c.x += 1e-4 : c.z += 1e-4, c.normalize(), l.crossVectors(i, c)), l.normalize(), u.crossVectors(c, l), s[0] = l.x, s[1] = l.y, s[2] = l.z, s[4] = u.x, s[5] = u.y, s[6] = u.z, s[8] = c.x, s[9] = c.y, s[10] = c.z, this }, lookAt: function (t, e, i) { const s = t.x; const n = t.y; const o = t.z; const a = i.x; const h = i.y; const l = i.z; const u = e.x; const c = e.y; const d = e.z; if (Math.abs(s - u) < r && Math.abs(n - c) < r && Math.abs(o - d) < r) return this.identity(); let f = s - u; let p = n - c; let v = o - d; let g = 1 / Math.sqrt(f * f + p * p + v * v); let m = h * (v *= g) - l * (p *= g); let y = l * (f *= g) - a * v; let x = a * p - h * f; (g = Math.sqrt(m * m + y * y + x * x)) ? (m *= g = 1 / g, y *= g, x *= g) : (m = 0, y = 0, x = 0); let T = p * x - v * y; let w = v * m - f * x; let b = f * y - p * m; return (g = Math.sqrt(T * T + w * w + b * b)) ? (T *= g = 1 / g, w *= g, b *= g) : (T = 0, w = 0, b = 0), this.setValues(m, T, f, 0, y, w, p, 0, x, b, v, 0, -(m * s + y * n + x * o), -(T * s + w * n + b * o), -(f * s + p * n + v * o), 1) }, yawPitchRoll: function (t, e, i) { this.zero(), a.zero(), h.zero(); const s = this.val; const n = a.val; const r = h.val; let o = Math.sin(i); let l = Math.cos(i); return s[10] = 1, s[15] = 1, s[0] = l, s[1] = o, s[4] = -o, s[5] = l, o = Math.sin(e), l = Math.cos(e), n[0] = 1, n[15] = 1, n[5] = l, n[10] = l, n[9] = -o, n[6] = o, o = Math.sin(t), l = Math.cos(t), r[5] = 1, r[15] = 1, r[0] = l, r[2] = -o, r[8] = o, r[10] = l, this.multiplyLocal(a), this.multiplyLocal(h), this }, setWorldMatrix: function (t, e, i, s, n) { return this.yawPitchRoll(t.y, t.x, t.z), a.scaling(i.x, i.y, i.z), h.xyz(e.x, e.y, e.z), this.multiplyLocal(a), this.multiplyLocal(h), s && this.multiplyLocal(s), n && this.multiplyLocal(n), this }, multiplyToMat4: function (t, e) { const i = this.val; const s = t.val; const n = i[0]; const r = i[1]; const o = i[2]; const a = i[3]; const h = i[4]; const l = i[5]; const u = i[6]; const c = i[7]; const d = i[8]; const f = i[9]; const p = i[10]; const v = i[11]; const g = i[12]; const m = i[13]; const y = i[14]; const x = i[15]; const T = s[0]; const w = s[1]; const b = s[2]; const S = s[3]; const E = s[4]; const A = s[5]; const C = s[6]; const _ = s[7]; const M = s[8]; const P = s[9]; const R = s[10]; const L = s[11]; const O = s[12]; const F = s[13]; const D = s[14]; const k = s[15]; return e.setValues(T * n + w * h + b * d + S * g, w * r + w * l + b * f + S * m, b * o + w * u + b * p + S * y, S * a + w * c + b * v + S * x, E * n + A * h + C * d + _ * g, E * r + A * l + C * f + _ * m, E * o + A * u + C * p + _ * y, E * a + A * c + C * v + _ * x, M * n + P * h + R * d + L * g, M * r + P * l + R * f + L * m, M * o + P * u + R * p + L * y, M * a + P * c + R * v + L * x, O * n + F * h + D * d + k * g, O * r + F * l + D * f + k * m, O * o + F * u + D * p + k * y, O * a + F * c + D * v + k * x) }, fromRotationXYTranslation: function (t, e, i) { const s = e.x; const n = e.y; const r = e.z; const o = Math.sin(t.x); const a = Math.cos(t.x); const h = Math.sin(t.y); const l = Math.cos(t.y); let u = s; let c = n; let d = r; const f = -o; const p = 0 - f * h; const v = 0 - a * h; const g = f * l; const m = a * l; return i || (u = l * s + h * r, c = p * s + a * n + g * r, d = v * s + o * n + m * r), this.setValues(l, p, v, 0, 0, a, o, 0, h, g, m, 0, u, c, d, 1) }, getMaxScaleOnAxis: function () { const t = this.val; const e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]; const i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]; const s = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, i, s)) } }); var a = new o(); var h = new o(); var l = new n(); var u = new n(); var c = new n(); t.exports = o }, 86883: t => { t.exports = function (t, e, i) { return Math.min(t + e, i) } }, 50040: t => { t.exports = function (t) { const e = t.length; if (e === 0) return 0; t.sort(function (t, e) { return t - e }); const i = Math.floor(e / 2); return e % 2 == 0 ? (t[i] + t[i - 1]) / 2 : t[i] } }, 37204: t => { t.exports = function (t, e, i) { return Math.max(t - e, i) } }, 65201: t => { t.exports = function (t, e, i, s) { void 0 === i && (i = e + 1); let n = (t - e) / (i - e); return n > 1 ? void 0 !== s ? (n = (s - t) / (s - i)) < 0 && (n = 0) : n = 1 : n < 0 && (n = 0), n } }, 15746: (t, e, i) => { const s = i(83419); const n = i(94434); const r = i(29747); const o = i(25836); const a = 1e-6; const h = new Int8Array([1, 2, 0]); const l = new Float32Array([0, 0, 0]); const u = new o(1, 0, 0); const c = new o(0, 1, 0); const d = new o(); const f = new n(); const p = new s({ initialize: function (t, e, i, s) { this.onChangeCallback = r, this.set(t, e, i, s) }, x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback(this) } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback(this) } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback(this) } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this.onChangeCallback(this) } }, copy: function (t) { return this.set(t) }, set: function (t, e, i, s, n) { return void 0 === n && (n = !0), typeof t === 'object' ? (this._x = t.x || 0, this._y = t.y || 0, this._z = t.z || 0, this._w = t.w || 0) : (this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = s || 0), n && this.onChangeCallback(this), this }, add: function (t) { return this._x += t.x, this._y += t.y, this._z += t.z, this._w += t.w, this.onChangeCallback(this), this }, subtract: function (t) { return this._x -= t.x, this._y -= t.y, this._z -= t.z, this._w -= t.w, this.onChangeCallback(this), this }, scale: function (t) { return this._x *= t, this._y *= t, this._z *= t, this._w *= t, this.onChangeCallback(this), this }, length: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; return Math.sqrt(t * t + e * e + i * i + s * s) }, lengthSq: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; return t * t + e * e + i * i + s * s }, normalize: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; let n = t * t + e * e + i * i + s * s; return n > 0 && (n = 1 / Math.sqrt(n), this._x = t * n, this._y = e * n, this._z = i * n, this._w = s * n), this.onChangeCallback(this), this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lerp: function (t, e) { void 0 === e && (e = 0); const i = this.x; const s = this.y; const n = this.z; const r = this.w; return this.set(i + e * (t.x - i), s + e * (t.y - s), n + e * (t.z - n), r + e * (t.w - r)) }, rotationTo: function (t, e) { const i = t.x * e.x + t.y * e.y + t.z * e.z; return i < -0.999999 ? (d.copy(u).cross(t).length() < a && d.copy(c).cross(t), d.normalize(), this.setAxisAngle(d, Math.PI)) : i > 0.999999 ? this.set(0, 0, 0, 1) : (d.copy(t).cross(e), this._x = d.x, this._y = d.y, this._z = d.z, this._w = 1 + i, this.normalize()) }, setAxes: function (t, e, i) { const s = f.val; return s[0] = e.x, s[3] = e.y, s[6] = e.z, s[1] = i.x, s[4] = i.y, s[7] = i.z, s[2] = -t.x, s[5] = -t.y, s[8] = -t.z, this.fromMat3(f).normalize() }, identity: function () { return this.set(0, 0, 0, 1) }, setAxisAngle: function (t, e) { e *= 0.5; const i = Math.sin(e); return this.set(i * t.x, i * t.y, i * t.z, Math.cos(e)) }, multiply: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = this.w; const r = t.x; const o = t.y; const a = t.z; const h = t.w; return this.set(e * h + n * r + i * a - s * o, i * h + n * o + s * r - e * a, s * h + n * a + e * o - i * r, n * h - e * r - i * o - s * a) }, slerp: function (t, e) { const i = this.x; const s = this.y; const n = this.z; const r = this.w; let o = t.x; let h = t.y; let l = t.z; let u = t.w; let c = i * o + s * h + n * l + r * u; c < 0 && (c = -c, o = -o, h = -h, l = -l, u = -u); let d = 1 - e; let f = e; if (1 - c > a) { const p = Math.acos(c); const v = Math.sin(p); d = Math.sin((1 - e) * p) / v, f = Math.sin(e * p) / v } return this.set(d * i + f * o, d * s + f * h, d * n + f * l, d * r + f * u) }, invert: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; const n = t * t + e * e + i * i + s * s; const r = n ? 1 / n : 0; return this.set(-t * r, -e * r, -i * r, s * r) }, conjugate: function () { return this._x = -this.x, this._y = -this.y, this._z = -this.z, this.onChangeCallback(this), this }, rotateX: function (t) { t *= 0.5; const e = this.x; const i = this.y; const s = this.z; const n = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.set(e * o + n * r, i * o + s * r, s * o - i * r, n * o - e * r) }, rotateY: function (t) { t *= 0.5; const e = this.x; const i = this.y; const s = this.z; const n = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.set(e * o - s * r, i * o + n * r, s * o + e * r, n * o - i * r) }, rotateZ: function (t) { t *= 0.5; const e = this.x; const i = this.y; const s = this.z; const n = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.set(e * o + i * r, i * o - e * r, s * o + n * r, n * o - s * r) }, calculateW: function () { const t = this.x; const e = this.y; const i = this.z; return this.w = -Math.sqrt(1 - t * t - e * e - i * i), this }, setFromEuler: function (t, e) { const i = t.x / 2; const s = t.y / 2; const n = t.z / 2; const r = Math.cos(i); const o = Math.cos(s); const a = Math.cos(n); const h = Math.sin(i); const l = Math.sin(s); const u = Math.sin(n); switch (t.order) { case 'XYZ': this.set(h * o * a + r * l * u, r * l * a - h * o * u, r * o * u + h * l * a, r * o * a - h * l * u, e); break; case 'YXZ': this.set(h * o * a + r * l * u, r * l * a - h * o * u, r * o * u - h * l * a, r * o * a + h * l * u, e); break; case 'ZXY': this.set(h * o * a - r * l * u, r * l * a + h * o * u, r * o * u + h * l * a, r * o * a - h * l * u, e); break; case 'ZYX': this.set(h * o * a - r * l * u, r * l * a + h * o * u, r * o * u - h * l * a, r * o * a + h * l * u, e); break; case 'YZX': this.set(h * o * a + r * l * u, r * l * a + h * o * u, r * o * u - h * l * a, r * o * a - h * l * u, e); break; case 'XZY': this.set(h * o * a - r * l * u, r * l * a - h * o * u, r * o * u + h * l * a, r * o * a + h * l * u, e) } return this }, setFromRotationMatrix: function (t) { let e; const i = t.val; const s = i[0]; const n = i[4]; const r = i[8]; const o = i[1]; const a = i[5]; const h = i[9]; const l = i[2]; const u = i[6]; const c = i[10]; const d = s + a + c; return d > 0 ? (e = 0.5 / Math.sqrt(d + 1), this.set((u - h) * e, (r - l) * e, (o - n) * e, 0.25 / e)) : s > a && s > c ? (e = 2 * Math.sqrt(1 + s - a - c), this.set(0.25 * e, (n + o) / e, (r + l) / e, (u - h) / e)) : a > c ? (e = 2 * Math.sqrt(1 + a - s - c), this.set((n + o) / e, 0.25 * e, (h + u) / e, (r - l) / e)) : (e = 2 * Math.sqrt(1 + c - s - a), this.set((r + l) / e, (h + u) / e, 0.25 * e, (o - n) / e)), this }, fromMat3: function (t) { let e; const i = t.val; const s = i[0] + i[4] + i[8]; if (s > 0) e = Math.sqrt(s + 1), this.w = 0.5 * e, e = 0.5 / e, this._x = (i[7] - i[5]) * e, this._y = (i[2] - i[6]) * e, this._z = (i[3] - i[1]) * e; else { let n = 0; i[4] > i[0] && (n = 1), i[8] > i[3 * n + n] && (n = 2); const r = h[n]; const o = h[r]; e = Math.sqrt(i[3 * n + n] - i[3 * r + r] - i[3 * o + o] + 1), l[n] = 0.5 * e, e = 0.5 / e, l[r] = (i[3 * r + n] + i[3 * n + r]) * e, l[o] = (i[3 * o + n] + i[3 * n + o]) * e, this._x = l[0], this._y = l[1], this._z = l[2], this._w = (i[3 * o + r] - i[3 * r + o]) * e } return this.onChangeCallback(this), this } }); t.exports = p }, 43396: (t, e, i) => { const s = i(36383); t.exports = function (t) { return t * s.RAD_TO_DEG } }, 74362: t => { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t } }, 60706: t => { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; const s = 2 * Math.random() - 1; const n = Math.sqrt(1 - s * s) * e; return t.x = Math.cos(i) * n, t.y = Math.sin(i) * n, t.z = s * e, t } }, 67421: t => { t.exports = function (t, e) { return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t } }, 36305: t => { t.exports = function (t, e) { const i = t.x; const s = t.y; return t.x = i * Math.cos(e) - s * Math.sin(e), t.y = i * Math.sin(e) + s * Math.cos(e), t } }, 11520: t => { t.exports = function (t, e, i, s) { const n = Math.cos(s); const r = Math.sin(s); const o = t.x - e; const a = t.y - i; return t.x = o * n - a * r + e, t.y = o * r + a * n + i, t } }, 1163: t => { t.exports = function (t, e, i, s, n) { const r = s + Math.atan2(t.y - i, t.x - e); return t.x = e + n * Math.cos(r), t.y = i + n * Math.sin(r), t } }, 70336: t => { t.exports = function (t, e, i, s, n) { return t.x = e + n * Math.cos(s), t.y = i + n * Math.sin(s), t } }, 72678: (t, e, i) => { const s = i(25836); const n = i(37867); const r = i(15746); const o = new n(); const a = new r(); const h = new s(); t.exports = function (t, e, i) { return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o) } }, 2284: t => { t.exports = function (t) { return t > 0 ? Math.ceil(t) : Math.floor(t) } }, 41013: t => { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const s = Math.pow(i, -e); return Math.round(t * s) / s } }, 16922: t => { t.exports = function (t, e, i, s) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), s *= Math.PI / t; for (var n = [], r = [], o = 0; o < t; o++)e += (i -= e * s) * s, n[o] = i, r[o] = e; return { sin: r, cos: n, length: t } } }, 7602: t => { t.exports = function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t) } }, 54261: t => { t.exports = function (t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10) } }, 44408: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n) { void 0 === n && (n = new s()); let r = 0; let o = 0; return t > 0 && t <= e * i && (r = t > e - 1 ? t - (o = Math.floor(t / e)) * e : t), n.set(r, o) } }, 85955: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r, o, a, h) { void 0 === h && (h = new s()); const l = Math.sin(r); const u = Math.cos(r); const c = u * o; const d = l * o; const f = -l * a; const p = u * a; const v = 1 / (c * p + f * -d); return h.x = p * v * t + -f * v * e + (n * f - i * p) * v, h.y = c * v * e + -d * v * t + (-n * c + i * d) * v, h } }, 26099: (t, e, i) => { const s = i(83419); const n = i(43855); var r = new s({ initialize: function (t, e) { this.x = 0, this.y = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0) }, clone: function () { return new r(this.x, this.y) }, copy: function (t) { return this.x = t.x || 0, this.y = t.y || 0, this }, setFromObject: function (t) { return this.x = t.x || 0, this.y = t.y || 0, this }, set: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this }, setTo: function (t, e) { return this.set(t, e) }, setToPolar: function (t, e) { return e == null && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this }, equals: function (t) { return this.x === t.x && this.y === t.y }, fuzzyEquals: function (t, e) { return n(this.x, t.x, e) && n(this.y, t.y, e) }, angle: function () { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t }, setAngle: function (t) { return this.setToPolar(t, this.length()) }, add: function (t) { return this.x += t.x, this.y += t.y, this }, subtract: function (t) { return this.x -= t.x, this.y -= t.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, scale: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, distance: function (t) { const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i) }, distanceSq: function (t) { const e = t.x - this.x; const i = t.y - this.y; return e * e + i * i }, length: function () { const t = this.x; const e = this.y; return Math.sqrt(t * t + e * e) }, setLength: function (t) { return this.normalize().scale(t) }, lengthSq: function () { const t = this.x; const e = this.y; return t * t + e * e }, normalize: function () { const t = this.x; const e = this.y; let i = t * t + e * e; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this }, normalizeRightHand: function () { const t = this.x; return this.x = -1 * this.y, this.y = t, this }, normalizeLeftHand: function () { const t = this.x; return this.x = this.y, this.y = -1 * t, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lerp: function (t, e) { void 0 === e && (e = 0); const i = this.x; const s = this.y; return this.x = i + e * (t.x - i), this.y = s + e * (t.y - s), this }, transformMat3: function (t) { const e = this.x; const i = this.y; const s = t.val; return this.x = s[0] * e + s[3] * i + s[6], this.y = s[1] * e + s[4] * i + s[7], this }, transformMat4: function (t) { const e = this.x; const i = this.y; const s = t.val; return this.x = s[0] * e + s[4] * i + s[12], this.y = s[1] * e + s[5] * i + s[13], this }, reset: function () { return this.x = 0, this.y = 0, this }, limit: function (t) { const e = this.length(); return e && e > t && this.scale(t / e), this }, reflect: function (t) { return t = t.clone().normalize(), this.subtract(t.scale(2 * this.dot(t))) }, mirror: function (t) { return this.reflect(t).negate() }, rotate: function (t) { const e = Math.cos(t); const i = Math.sin(t); return this.set(e * this.x - i * this.y, i * this.x + e * this.y) }, project: function (t) { const e = this.dot(t) / t.dot(t); return this.copy(t).scale(e) } }); r.ZERO = new r(), r.RIGHT = new r(1, 0), r.LEFT = new r(-1, 0), r.UP = new r(0, -1), r.DOWN = new r(0, 1), r.ONE = new r(1, 1), t.exports = r }, 25836: (t, e, i) => { var s = new (i(83419))({ initialize: function (t, e, i) { this.x = 0, this.y = 0, this.z = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0) }, up: function () { return this.x = 0, this.y = 1, this.z = 0, this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clone: function () { return new s(this.x, this.y, this.z) }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, crossVectors: function (t, e) { const i = t.x; const s = t.y; const n = t.z; const r = e.x; const o = e.y; const a = e.z; return this.x = s * a - n * o, this.y = n * r - i * a, this.z = i * o - s * r, this }, equals: function (t) { return this.x === t.x && this.y === t.y && this.z === t.z }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this }, set: function (t, e, i) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this }, setFromMatrixPosition: function (t) { return this.fromArray(t.val, 12) }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.val, 4 * e) }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, add: function (t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addScale: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e || 0, this }, subtract: function (t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this }, scale: function (t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, distance: function (t) { const e = t.x - this.x; const i = t.y - this.y; const s = t.z - this.z || 0; return Math.sqrt(e * e + i * i + s * s) }, distanceSq: function (t) { const e = t.x - this.x; const i = t.y - this.y; const s = t.z - this.z || 0; return e * e + i * i + s * s }, length: function () { const t = this.x; const e = this.y; const i = this.z; return Math.sqrt(t * t + e * e + i * i) }, lengthSq: function () { const t = this.x; const e = this.y; const i = this.z; return t * t + e * e + i * i }, normalize: function () { const t = this.x; const e = this.y; const i = this.z; let s = t * t + e * e + i * i; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s), this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, cross: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.x; const r = t.y; const o = t.z; return this.x = i * o - s * r, this.y = s * n - e * o, this.z = e * r - i * n, this }, lerp: function (t, e) { void 0 === e && (e = 0); const i = this.x; const s = this.y; const n = this.z; return this.x = i + e * (t.x - i), this.y = s + e * (t.y - s), this.z = n + e * (t.z - n), this }, applyMatrix3: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; return this.x = n[0] * e + n[3] * i + n[6] * s, this.y = n[1] * e + n[4] * i + n[7] * s, this.z = n[2] * e + n[5] * i + n[8] * s, this }, applyMatrix4: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; const r = 1 / (n[3] * e + n[7] * i + n[11] * s + n[15]); return this.x = (n[0] * e + n[4] * i + n[8] * s + n[12]) * r, this.y = (n[1] * e + n[5] * i + n[9] * s + n[13]) * r, this.z = (n[2] * e + n[6] * i + n[10] * s + n[14]) * r, this }, transformMat3: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; return this.x = e * n[0] + i * n[3] + s * n[6], this.y = e * n[1] + i * n[4] + s * n[7], this.z = e * n[2] + i * n[5] + s * n[8], this }, transformMat4: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; return this.x = n[0] * e + n[4] * i + n[8] * s + n[12], this.y = n[1] * e + n[5] * i + n[9] * s + n[13], this.z = n[2] * e + n[6] * i + n[10] * s + n[14], this }, transformCoordinates: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; const r = e * n[0] + i * n[4] + s * n[8] + n[12]; const o = e * n[1] + i * n[5] + s * n[9] + n[13]; const a = e * n[2] + i * n[6] + s * n[10] + n[14]; const h = e * n[3] + i * n[7] + s * n[11] + n[15]; return this.x = r / h, this.y = o / h, this.z = a / h, this }, transformQuat: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * s - o * i; const l = a * i + o * e - n * s; const u = a * s + n * i - r * e; const c = -n * e - r * i - o * s; return this.x = h * a + c * -n + l * -o - u * -r, this.y = l * a + c * -r + u * -n - h * -o, this.z = u * a + c * -o + h * -r - l * -n, this }, project: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.val; const r = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = n[4]; const u = n[5]; const c = n[6]; const d = n[7]; const f = n[8]; const p = n[9]; const v = n[10]; const g = n[11]; const m = n[12]; const y = n[13]; const x = n[14]; const T = 1 / (e * h + i * d + s * g + n[15]); return this.x = (e * r + i * l + s * f + m) * T, this.y = (e * o + i * u + s * p + y) * T, this.z = (e * a + i * c + s * v + x) * T, this }, projectViewMatrix: function (t, e) { return this.applyMatrix4(t).applyMatrix4(e) }, unprojectViewMatrix: function (t, e) { return this.applyMatrix4(t).applyMatrix4(e) }, unproject: function (t, e) { const i = t.x; const s = t.y; const n = t.z; const r = t.w; const o = this.x - i; const a = r - this.y - 1 - s; const h = this.z; return this.x = 2 * o / n - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e) }, reset: function () { return this.x = 0, this.y = 0, this.z = 0, this } }); s.ZERO = new s(), s.RIGHT = new s(1, 0, 0), s.LEFT = new s(-1, 0, 0), s.UP = new s(0, -1, 0), s.DOWN = new s(0, 1, 0), s.FORWARD = new s(0, 0, 1), s.BACK = new s(0, 0, -1), s.ONE = new s(1, 1, 1), t.exports = s }, 61369: (t, e, i) => { var s = new (i(83419))({ initialize: function (t, e, i, s) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = s || 0) }, clone: function () { return new s(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this }, equals: function (t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w }, set: function (t, e, i, s) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = s || 0), this }, add: function (t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this }, subtract: function (t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this }, scale: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, length: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; return Math.sqrt(t * t + e * e + i * i + s * s) }, lengthSq: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; return t * t + e * e + i * i + s * s }, normalize: function () { const t = this.x; const e = this.y; const i = this.z; const s = this.w; let n = t * t + e * e + i * i + s * s; return n > 0 && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n, this.w = s * n), this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lerp: function (t, e) { void 0 === e && (e = 0); const i = this.x; const s = this.y; const n = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = s + e * (t.y - s), this.z = n + e * (t.z - n), this.w = r + e * (t.w - r), this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this }, distance: function (t) { const e = t.x - this.x; const i = t.y - this.y; const s = t.z - this.z || 0; const n = t.w - this.w || 0; return Math.sqrt(e * e + i * i + s * s + n * n) }, distanceSq: function (t) { const e = t.x - this.x; const i = t.y - this.y; const s = t.z - this.z || 0; const n = t.w - this.w || 0; return e * e + i * i + s * s + n * n }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, transformMat4: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = this.w; const r = t.val; return this.x = r[0] * e + r[4] * i + r[8] * s + r[12] * n, this.y = r[1] * e + r[5] * i + r[9] * s + r[13] * n, this.z = r[2] * e + r[6] * i + r[10] * s + r[14] * n, this.w = r[3] * e + r[7] * i + r[11] * s + r[15] * n, this }, transformQuat: function (t) { const e = this.x; const i = this.y; const s = this.z; const n = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * s - o * i; const l = a * i + o * e - n * s; const u = a * s + n * i - r * e; const c = -n * e - r * i - o * s; return this.x = h * a + c * -n + l * -o - u * -r, this.y = l * a + c * -r + u * -n - h * -o, this.z = u * a + c * -o + h * -r - l * -n, this }, reset: function () { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this } }); s.prototype.sub = s.prototype.subtract, s.prototype.mul = s.prototype.multiply, s.prototype.div = s.prototype.divide, s.prototype.dist = s.prototype.distance, s.prototype.distSq = s.prototype.distanceSq, s.prototype.len = s.prototype.length, s.prototype.lenSq = s.prototype.lengthSq, t.exports = s }, 60417: t => { t.exports = function (t, e, i) { return Math.abs(t - e) <= i } }, 15994: t => { t.exports = function (t, e, i) { const s = i - e; return e + ((t - e) % s + s) % s } }, 31040: t => { t.exports = function (t, e, i, s) { return Math.atan2(s - e, i - t) } }, 55495: t => { t.exports = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x) } }, 128: t => { t.exports = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y) } }, 41273: t => { t.exports = function (t, e, i, s) { return Math.atan2(i - t, s - e) } }, 1432: (t, e, i) => { const s = i(36383); t.exports = function (t) { return t > Math.PI && (t -= s.PI2), Math.abs(((t + s.TAU) % s.PI2 - s.PI2) % s.PI2) } }, 12407: t => { t.exports = function (t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI } }, 53993: (t, e, i) => { const s = i(99472); t.exports = function () { return s(-Math.PI, Math.PI) } }, 86564: (t, e, i) => { const s = i(99472); t.exports = function () { return s(-180, 180) } }, 90154: (t, e, i) => { const s = i(12407); t.exports = function (t) { return s(t + Math.PI) } }, 48736: (t, e, i) => { const s = i(36383); t.exports = function (t, e, i) { return void 0 === i && (i = 0.05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= s.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += s.PI2 : e -= s.PI2), e > t ? t += i : e < t && (t -= i))), t } }, 61430: t => { t.exports = function (t, e) { const i = e - t; return i === 0 ? 0 : i - 360 * Math.floor((i - -180) / 360) } }, 86554: (t, e, i) => { const s = i(15994); t.exports = function (t) { return s(t, -Math.PI, Math.PI) } }, 30954: (t, e, i) => { const s = i(15994); t.exports = function (t) { return s(t, -180, 180) } }, 25588: (t, e, i) => { t.exports = { Between: i(31040), BetweenPoints: i(55495), BetweenPointsY: i(128), BetweenY: i(41273), CounterClockwise: i(1432), Normalize: i(12407), Random: i(53993), RandomDegrees: i(86564), Reverse: i(90154), RotateTo: i(48736), ShortestBetween: i(61430), Wrap: i(86554), WrapDegrees: i(30954) } }, 36383: t => { const e = { PI2: 2 * Math.PI, TAU: 0.5 * Math.PI, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991 }; t.exports = e }, 20339: t => { t.exports = function (t, e, i, s) { const n = t - i; const r = e - s; return Math.sqrt(n * n + r * r) } }, 52816: t => { t.exports = function (t, e) { const i = t.x - e.x; const s = t.y - e.y; return Math.sqrt(i * i + s * s) } }, 64559: t => { t.exports = function (t, e) { const i = t.x - e.x; const s = t.y - e.y; return i * i + s * s } }, 82340: t => { t.exports = function (t, e, i, s) { return Math.max(Math.abs(t - i), Math.abs(e - s)) } }, 14390: t => { t.exports = function (t, e, i, s, n) { return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n)) } }, 2243: t => { t.exports = function (t, e, i, s) { return Math.abs(t - i) + Math.abs(e - s) } }, 89774: t => { t.exports = function (t, e, i, s) { const n = t - i; const r = e - s; return n * n + r * r } }, 50994: (t, e, i) => { t.exports = { Between: i(20339), BetweenPoints: i(52816), BetweenPointsSquared: i(64559), Chebyshev: i(82340), Power: i(14390), Snake: i(2243), Squared: i(89774) } }, 62640: (t, e, i) => { const s = i(54178); const n = i(41521); const r = i(79980); const o = i(85433); const a = i(99140); const h = i(48857); const l = i(81596); const u = i(59133); const c = i(98516); const d = i(35248); const f = i(82500); const p = i(49752); t.exports = { Power0: l, Power1: u.Out, Power2: o.Out, Power3: c.Out, Power4: d.Out, Linear: l, Quad: u.Out, Cubic: o.Out, Quart: c.Out, Quint: d.Out, Sine: f.Out, Expo: h.Out, Circ: r.Out, Elastic: a.Out, Back: s.Out, Bounce: n.Out, Stepped: p, 'Quad.easeIn': u.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': c.In, 'Quint.easeIn': d.In, 'Sine.easeIn': f.In, 'Expo.easeIn': h.In, 'Circ.easeIn': r.In, 'Elastic.easeIn': a.In, 'Back.easeIn': s.In, 'Bounce.easeIn': n.In, 'Quad.easeOut': u.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': c.Out, 'Quint.easeOut': d.Out, 'Sine.easeOut': f.Out, 'Expo.easeOut': h.Out, 'Circ.easeOut': r.Out, 'Elastic.easeOut': a.Out, 'Back.easeOut': s.Out, 'Bounce.easeOut': n.Out, 'Quad.easeInOut': u.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': c.InOut, 'Quint.easeInOut': d.InOut, 'Sine.easeInOut': f.InOut, 'Expo.easeInOut': h.InOut, 'Circ.easeInOut': r.InOut, 'Elastic.easeInOut': a.InOut, 'Back.easeInOut': s.InOut, 'Bounce.easeInOut': n.InOut } }, 1639: t => { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e) } }, 50099: t => { t.exports = function (t, e) { void 0 === e && (e = 1.70158); const i = 1.525 * e; return (t *= 2) < 1 ? t * t * ((i + 1) * t - i) * 0.5 : 0.5 * ((t -= 2) * t * ((i + 1) * t + i) + 2) } }, 41286: t => { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1 } }, 54178: (t, e, i) => { t.exports = { In: i(1639), Out: i(41286), InOut: i(50099) } }, 59590: t => { t.exports = function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) } }, 41788: t => { t.exports = function (t) { let e = !1; return t < 0.5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5 } }, 69905: t => { t.exports = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375 } }, 41521: (t, e, i) => { t.exports = { In: i(59590), Out: i(69905), InOut: i(41788) } }, 91861: t => { t.exports = function (t) { return 1 - Math.sqrt(1 - t * t) } }, 4177: t => { t.exports = function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) } }, 57512: t => { t.exports = function (t) { return Math.sqrt(1 - --t * t) } }, 79980: (t, e, i) => { t.exports = { In: i(91861), Out: i(57512), InOut: i(4177) } }, 51150: t => { t.exports = function (t) { return t * t * t } }, 82820: t => { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) } }, 35033: t => { t.exports = function (t) { return --t * t * t + 1 } }, 85433: (t, e, i) => { t.exports = { In: i(51150), Out: i(35033), InOut: i(82820) } }, 69965: t => { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let s = i / 4; return e < 1 ? e = 1 : s = i * Math.asin(1 / e) / (2 * Math.PI), -e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / i) } }, 50665: t => { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let s = i / 4; return e < 1 ? e = 1 : s = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / i) * -0.5 : e * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / i) * 0.5 + 1 } }, 7744: t => { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let s = i / 4; return e < 1 ? e = 1 : s = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / i) + 1 } }, 99140: (t, e, i) => { t.exports = { In: i(69965), Out: i(7744), InOut: i(50665) } }, 24590: t => { t.exports = function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001 } }, 87844: t => { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))) } }, 89433: t => { t.exports = function (t) { return 1 - Math.pow(2, -10 * t) } }, 48857: (t, e, i) => { t.exports = { In: i(24590), Out: i(89433), InOut: i(87844) } }, 48820: (t, e, i) => { t.exports = { Back: i(54178), Bounce: i(41521), Circular: i(79980), Cubic: i(85433), Elastic: i(99140), Expo: i(48857), Linear: i(81596), Quadratic: i(59133), Quartic: i(98516), Quintic: i(35248), Sine: i(82500), Stepped: i(49752) } }, 7147: t => { t.exports = function (t) { return t } }, 81596: (t, e, i) => { t.exports = i(7147) }, 34826: t => { t.exports = function (t) { return t * t } }, 20544: t => { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) } }, 92029: t => { t.exports = function (t) { return t * (2 - t) } }, 59133: (t, e, i) => { t.exports = { In: i(34826), Out: i(92029), InOut: i(20544) } }, 64413: t => { t.exports = function (t) { return t * t * t * t } }, 78137: t => { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) } }, 45840: t => { t.exports = function (t) { return 1 - --t * t * t * t } }, 98516: (t, e, i) => { t.exports = { In: i(64413), Out: i(45840), InOut: i(78137) } }, 87745: t => { t.exports = function (t) { return t * t * t * t * t } }, 16509: t => { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) } }, 17868: t => { t.exports = function (t) { return --t * t * t * t * t + 1 } }, 35248: (t, e, i) => { t.exports = { In: i(87745), Out: i(17868), InOut: i(16509) } }, 80461: t => { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 1 - Math.cos(t * Math.PI / 2) } }, 34025: t => { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * t)) } }, 52768: t => { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : Math.sin(t * Math.PI / 2) } }, 82500: (t, e, i) => { t.exports = { In: i(80461), Out: i(52768), InOut: i(34025) } }, 72251: t => { t.exports = function (t, e) { return void 0 === e && (e = 1), t <= 0 ? 0 : t >= 1 ? 1 : 1 / e * (1 + (e * t | 0)) } }, 49752: (t, e, i) => { t.exports = i(72251) }, 75698: t => { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e) } }, 43855: t => { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i } }, 25777: t => { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e) } }, 5470: t => { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t > e - i } }, 94977: t => { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t < e + i } }, 48379: (t, e, i) => { t.exports = { Ceil: i(75698), Equal: i(43855), Floor: i(25777), GreaterThan: i(5470), LessThan: i(94977) } }, 75508: (t, e, i) => { const s = i(36383); const n = i(79291); let r = { Angle: i(25588), Distance: i(50994), Easing: i(48820), Fuzzy: i(48379), Interpolation: i(38289), Pow2: i(49001), Snap: i(73697), RandomDataGenerator: i(28453), Average: i(53307), Bernstein: i(85710), Between: i(30976), CatmullRom: i(87842), CeilTo: i(26302), Clamp: i(45319), DegToRad: i(39506), Difference: i(61241), Euler: i(38857), Factorial: i(6411), FloatBetween: i(99472), FloorTo: i(77623), FromPercent: i(62945), GetSpeed: i(38265), IsEven: i(78702), IsEvenStrict: i(94883), Linear: i(28915), LinearXY: i(94908), MaxAdd: i(86883), Median: i(50040), MinSub: i(37204), Percent: i(65201), RadToDeg: i(43396), RandomXY: i(74362), RandomXYZ: i(60706), RandomXYZW: i(67421), Rotate: i(36305), RotateAround: i(11520), RotateAroundDistance: i(1163), RotateTo: i(70336), RoundAwayFromZero: i(2284), RoundTo: i(41013), SinCosTableGenerator: i(16922), SmootherStep: i(54261), SmoothStep: i(7602), ToXY: i(44408), TransformXY: i(85955), Within: i(60417), Wrap: i(15994), Vector2: i(26099), Vector3: i(25836), Vector4: i(61369), Matrix3: i(94434), Matrix4: i(37867), Quaternion: i(15746), RotateVec3: i(72678) }; r = n(!1, r, s), t.exports = r }, 89318: (t, e, i) => { const s = i(85710); t.exports = function (t, e) { for (var i = 0, n = t.length - 1, r = 0; r <= n; r++)i += Math.pow(1 - e, n - r) * Math.pow(e, r) * t[r] * s(n, r); return i } }, 77259: (t, e, i) => { const s = i(87842); t.exports = function (t, e) { const i = t.length - 1; let n = i * e; let r = Math.floor(n); return t[0] === t[i] ? (e < 0 && (r = Math.floor(n = i * (1 + e))), s(n - r, t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i])) : e < 0 ? t[0] - (s(-n, t[0], t[0], t[1], t[1]) - t[0]) : e > 1 ? t[i] - (s(n - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : s(n - r, t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2]) } }, 36316: t => { t.exports = function (t, e, i, s, n) { return (function (t, e) { const i = 1 - t; return i * i * i * e }(t, e)) + (function (t, e) { const i = 1 - t; return 3 * i * i * t * e }(t, i)) + (function (t, e) { return 3 * (1 - t) * t * t * e }(t, s)) + (function (t, e) { return t * t * t * e }(t, n)) } }, 28392: (t, e, i) => { const s = i(28915); t.exports = function (t, e) { const i = t.length - 1; const n = i * e; const r = Math.floor(n); return e < 0 ? s(t[0], t[1], n) : e > 1 ? s(t[i], t[i - 1], i - n) : s(t[r], t[r + 1 > i ? i : r + 1], n - r) } }, 32112: t => { t.exports = function (t, e, i, s) { return (function (t, e) { const i = 1 - t; return i * i * e }(t, e)) + (function (t, e) { return 2 * (1 - t) * t * e }(t, i)) + (function (t, e) { return t * t * e }(t, s)) } }, 47235: (t, e, i) => { const s = i(7602); t.exports = function (t, e, i) { return e + (i - e) * s(t, 0, 1) } }, 50178: (t, e, i) => { const s = i(54261); t.exports = function (t, e, i) { return e + (i - e) * s(t, 0, 1) } }, 38289: (t, e, i) => { t.exports = { Bezier: i(89318), CatmullRom: i(77259), CubicBezier: i(36316), Linear: i(28392), QuadraticBezier: i(32112), SmoothStep: i(47235), SmootherStep: i(50178) } }, 98439: t => { t.exports = function (t) { const e = Math.log(t) / 0.6931471805599453; return 1 << Math.ceil(e) } }, 50030: t => { t.exports = function (t, e) { return t > 0 && (t & t - 1) == 0 && e > 0 && (e & e - 1) == 0 } }, 81230: t => { t.exports = function (t) { return t > 0 && (t & t - 1) == 0 } }, 49001: (t, e, i) => { t.exports = { GetNext: i(98439), IsSize: i(50030), IsValue: i(81230) } }, 28453: (t, e, i) => { const s = new (i(83419))({ initialize: function (t) { void 0 === t && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t) }, rnd: function () { const t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2 }, hash: function (t) { let e; let i = this.n; t = t.toString(); for (let s = 0; s < t.length; s++)e = 0.02519603282416938 * (i += t.charCodeAt(s)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i); return this.n = i, 2.3283064365386963e-10 * (i >>> 0) }, init: function (t) { typeof t === 'string' ? this.state(t) : this.sow(t) }, sow: function (t) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, t) for (let e = 0; e < t.length && t[e] != null; e++) { const i = t[e]; this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0) } }, integer: function () { return 4294967296 * this.rnd() }, frac: function () { return this.rnd() + 11102230246251565e-32 * (2097152 * this.rnd() | 0) }, real: function () { return this.integer() + this.frac() }, integerInRange: function (t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t) }, between: function (t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t) }, realInRange: function (t, e) { return this.frac() * (e - t) + t }, normal: function () { return 1 - 2 * this.frac() }, uuid: function () { let t = ''; let e = ''; for (e = t = ''; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : '-'); return e }, pick: function (t) { return t[this.integerInRange(0, t.length - 1)] }, sign: function () { return this.pick(this.signs) }, weightedPick: function (t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 0.5) + 0.5)] }, timestamp: function (t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6) }, angle: function () { return this.integerInRange(-180, 180) }, rotation: function () { return this.realInRange(-3.1415926, 3.1415926) }, state: function (t) { return typeof t === 'string' && t.match(/^!rnd/) && (t = t.split(','), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(',') }, shuffle: function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(this.frac() * (e + 1)); const s = t[i]; t[i] = t[e], t[e] = s } return t } }); t.exports = s }, 63448: t => { t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.ceil(t / e), s ? (i + t) / e : i + t) } }, 56583: t => { t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.floor(t / e), s ? (i + t) / e : i + t) } }, 77720: t => { t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.round(t / e), s ? (i + t) / e : i + t) } }, 73697: (t, e, i) => { t.exports = { Ceil: i(63448), Floor: i(56583), To: i(77720) } }, 85454: (t, e, i) => { i(63595); const s = i(8054); const n = i(79291); let r = { Actions: i(61061), Animations: i(60421), BlendModes: i(10312), Cache: i(83388), Cameras: i(26638), Core: i(42857), Class: i(83419), Create: i(15822), Curves: i(25410), Data: i(44965), Display: i(27460), DOM: i(84902), Events: i(93055), FX: i(66064), Game: i(50127), GameObjects: i(77856), Geom: i(55738), Input: i(14350), Loader: i(57777), Math: i(75508), Physics: i(44563), Plugins: i(18922), Renderer: i(36909), Scale: i(93364), ScaleModes: i(29795), Scene: i(97482), Scenes: i(62194), Structs: i(41392), Textures: i(27458), Tilemaps: i(62501), Time: i(90291), Tweens: i(43066), Utils: i(91799) }; r.Sound = i(23717), r = n(!1, r, s), t.exports = r, i.g.Phaser = r }, 71289: (t, e, i) => { const s = i(83419); const n = i(92209); const r = i(88571); const o = new s({ Extends: r, Mixins: [n.Acceleration, n.Angular, n.Bounce, n.Collision, n.Debug, n.Drag, n.Enable, n.Friction, n.Gravity, n.Immovable, n.Mass, n.Pushable, n.Size, n.Velocity], initialize: function (t, e, i, s, n) { r.call(this, t, e, i, s, n), this.body = null } }); t.exports = o }, 86689: (t, e, i) => { const s = i(83419); const n = i(39506); const r = i(20339); const o = i(89774); const a = i(66022); const h = i(95540); const l = i(46975); const u = i(72441); const c = i(47956); const d = i(37277); const f = i(44594); const p = i(26099); const v = i(82248); const g = new s({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, this._category = 1, t.sys.events.once(f.BOOT, this.boot, this), t.sys.events.on(f.START, this.start, this) }, boot: function () { this.world = new v(this.scene, this.config), this.add = new a(this.world), this.systems.events.once(f.DESTROY, this.destroy, this) }, start: function () { this.world || (this.world = new v(this.scene, this.config), this.add = new a(this.world)); const t = this.systems.events; h(this.config, 'customUpdate', !1) || t.on(f.UPDATE, this.world.update, this.world), t.on(f.POST_UPDATE, this.world.postUpdate, this.world), t.once(f.SHUTDOWN, this.shutdown, this) }, enableUpdate: function () { this.systems.events.on(f.UPDATE, this.world.update, this.world) }, disableUpdate: function () { this.systems.events.off(f.UPDATE, this.world.update, this.world) }, getConfig: function () { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return l(h(e, 'arcade', {}), h(t, 'arcade', {})) }, nextCategory: function () { return this._category = this._category << 1, this._category }, overlap: function (t, e, i, s, n) { return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i), this.world.collideObjects(t, e, i, s, n, !0) }, collide: function (t, e, i, s, n) { return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i), this.world.collideObjects(t, e, i, s, n, !1) }, collideTiles: function (t, e, i, s, n) { return this.world.collideTiles(t, e, i, s, n) }, overlapTiles: function (t, e, i, s, n) { return this.world.overlapTiles(t, e, i, s, n) }, pause: function () { return this.world.pause() }, resume: function () { return this.world.resume() }, accelerateTo: function (t, e, i, s, n, r) { void 0 === s && (s = 60); const o = Math.atan2(i - t.y, e - t.x); return t.body.acceleration.setToPolar(o, s), void 0 !== n && void 0 !== r && t.body.maxVelocity.set(n, r), o }, accelerateToObject: function (t, e, i, s, n) { return this.accelerateTo(t, e.x, e.y, i, s, n) }, closest: function (t, e) { e || (e = this.world.bodies.entries); for (var i = Number.MAX_VALUE, s = null, n = t.x, r = t.y, a = e.length, h = 0; h < a; h++) { const l = e[h]; const u = l.body || l; if (t !== l && t !== u && t !== u.gameObject && t !== u.center) { const c = o(n, r, u.center.x, u.center.y); c < i && (s = l, i = c) } } return s }, furthest: function (t, e) { e || (e = this.world.bodies.entries); for (var i = -1, s = null, n = t.x, r = t.y, a = e.length, h = 0; h < a; h++) { const l = e[h]; const u = l.body || l; if (t !== l && t !== u && t !== u.gameObject && t !== u.center) { const c = o(n, r, u.center.x, u.center.y); c > i && (s = l, i = c) } } return s }, moveTo: function (t, e, i, s, n) { void 0 === s && (s = 60), void 0 === n && (n = 0); const o = Math.atan2(i - t.y, e - t.x); return n > 0 && (s = r(t.x, t.y, e, i) / (n / 1e3)), t.body.velocity.setToPolar(o, s), o }, moveToObject: function (t, e, i, s) { return this.moveTo(t, e.x, e.y, i, s) }, velocityFromAngle: function (t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(n(t), e) }, velocityFromRotation: function (t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(t, e) }, overlapRect: function (t, e, i, s, n, r) { return c(this.world, t, e, i, s, n, r) }, overlapCirc: function (t, e, i, s, n) { return u(this.world, t, e, i, s, n) }, shutdown: function () { if (this.world) { const t = this.systems.events; t.off(f.UPDATE, this.world.update, this.world), t.off(f.POST_UPDATE, this.world.postUpdate, this.world), t.off(f.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null, this._category = 1 } }, destroy: function () { this.shutdown(), this.scene.sys.events.off(f.START, this.start, this), this.scene = null, this.systems = null } }); d.register('ArcadePhysics', g, 'arcadePhysics'), t.exports = g }, 13759: (t, e, i) => { const s = i(83419); const n = i(92209); const r = i(68287); const o = new s({ Extends: r, Mixins: [n.Acceleration, n.Angular, n.Bounce, n.Collision, n.Debug, n.Drag, n.Enable, n.Friction, n.Gravity, n.Immovable, n.Mass, n.Pushable, n.Size, n.Velocity], initialize: function (t, e, i, s, n) { r.call(this, t, e, i, s, n), this.body = null } }); t.exports = o }, 37742: (t, e, i) => { const s = i(83419); const n = i(78389); const r = i(37747); const o = i(63012); const a = i(43396); const h = i(87841); const l = i(37303); const u = i(95829); const c = i(26099); const d = new s({ Mixins: [n], initialize: function (t, e) { let i = 64; let s = 64; const n = void 0 !== e; n && e.displayWidth && (i = e.displayWidth, s = e.displayHeight), n || (e = { x: 0, y: 0, angle: 0, rotation: 0, scaleX: 1, scaleY: 1, displayOriginX: 0, displayOriginY: 0 }), this.world = t, this.gameObject = n ? e : void 0, this.isBody = !0, this.transform = { x: e.x, y: e.y, rotation: e.angle, scaleX: e.scaleX, scaleY: e.scaleY, displayOriginX: e.displayOriginX, displayOriginY: e.displayOriginY }, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new c(), this.position = new c(e.x - e.scaleX * e.displayOriginX, e.y - e.scaleY * e.displayOriginY), this.prev = this.position.clone(), this.prevFrame = this.position.clone(), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = s, this.sourceWidth = i, this.sourceHeight = s, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(s / 2), this.center = new c(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new c(), this.newVelocity = new c(), this.deltaMax = new c(), this.acceleration = new c(), this.allowDrag = !0, this.drag = new c(), this.allowGravity = !0, this.gravity = new c(), this.bounce = new c(), this.worldBounce = null, this.customBoundsRectangle = t.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new c(1e4, 1e4), this.maxSpeed = -1, this.friction = new c(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = r.FACING_NONE, this.immovable = !1, this.pushable = !0, this.slideFactor = new c(1, 1), this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = u(!1), this.touching = u(!0), this.wasTouching = u(!0), this.blocked = u(!0), this.syncBounds = !1, this.physicsType = r.DYNAMIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new h(), this.directControl = !1, this.autoFrame = this.position.clone() }, updateBounds: function () { const t = this.gameObject; const e = this.transform; if (t.parentContainer) { const i = t.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2); e.x = i.tx, e.y = i.ty, e.rotation = a(i.rotation), e.scaleX = i.scaleX, e.scaleY = i.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY } else e.x = t.x, e.y = t.y, e.rotation = t.angle, e.scaleX = t.scaleX, e.scaleY = t.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY; let s = !1; if (this.syncBounds) { const n = t.getBounds(this._bounds); this.width = n.width, this.height = n.height, s = !0 } else { const r = Math.abs(e.scaleX); const o = Math.abs(e.scaleY); this._sx === r && this._sy === o || (this.width = this.sourceWidth * r, this.height = this.sourceHeight * o, this._sx = r, this._sy = o, s = !0) } s && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()) }, updateCenter: function () { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight) }, updateFromGameObject: function () { this.updateBounds(); const t = this.transform; this.position.x = t.x + t.scaleX * (this.offset.x - t.displayOriginX), this.position.y = t.y + t.scaleY * (this.offset.y - t.displayOriginY), this.updateCenter() }, resetFlags: function (t) { void 0 === t && (t = !1); const e = this.wasTouching; const i = this.touching; const s = this.blocked; t ? u(!0, e) : (e.none = i.none, e.up = i.up, e.down = i.down, e.left = i.left, e.right = i.right), u(!0, i), u(!0, s), this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1 }, preUpdate: function (t, e) { if (t && this.resetFlags(), this.gameObject && this.updateFromGameObject(), this.rotation = this.transform.rotation, this.preRotation = this.rotation, this.moves) { const i = this.position; this.prev.x = i.x, this.prev.y = i.y, this.prevFrame.x = i.x, this.prevFrame.y = i.y } t && this.update(e) }, update: function (t) { const e = this.prev; const i = this.position; const s = this.velocity; if (e.set(i.x, i.y), !this.moves) return this._dx = i.x - e.x, void (this._dy = i.y - e.y); if (this.directControl) { const n = this.autoFrame; s.set((i.x - n.x) / t, (i.y - n.y) / t), this.world.updateMotion(this, t), this._dx = i.x - n.x, this._dy = i.y - n.y } else this.world.updateMotion(this, t), this.newVelocity.set(s.x * t, s.y * t), i.add(this.newVelocity), this._dx = i.x - e.x, this._dy = i.y - e.y; const r = s.x; const a = s.y; if (this.updateCenter(), this.angle = Math.atan2(a, r), this.speed = Math.sqrt(r * r + a * a), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) { const h = this.blocked; this.world.emit(o.WORLD_BOUNDS, this, h.up, h.down, h.left, h.right) } }, postUpdate: function () { const t = this.position; let e = t.x - this.prevFrame.x; let i = t.y - this.prevFrame.y; const s = this.gameObject; if (this.moves) { const n = this.deltaMax.x; const o = this.deltaMax.y; n !== 0 && e !== 0 && (e < 0 && e < -n ? e = -n : e > 0 && e > n && (e = n)), o !== 0 && i !== 0 && (i < 0 && i < -o ? i = -o : i > 0 && i > o && (i = o)), s && (s.x += e, s.y += i) } e < 0 ? this.facing = r.FACING_LEFT : e > 0 && (this.facing = r.FACING_RIGHT), i < 0 ? this.facing = r.FACING_UP : i > 0 && (this.facing = r.FACING_DOWN), this.allowRotation && s && (s.angle += this.deltaZ()), this._tx = e, this._ty = i, this.autoFrame.set(t.x, t.y) }, setBoundsRectangle: function (t) { return this.customBoundsRectangle = t || this.world.bounds, this }, checkWorldBounds: function () { const t = this.position; const e = this.velocity; const i = this.blocked; const s = this.customBoundsRectangle; const n = this.world.checkCollision; const r = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const o = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; let a = !1; return t.x < s.x && n.left ? (t.x = s.x, e.x *= r, i.left = !0, a = !0) : this.right > s.right && n.right && (t.x = s.right - this.width, e.x *= r, i.right = !0, a = !0), t.y < s.y && n.up ? (t.y = s.y, e.y *= o, i.up = !0, a = !0) : this.bottom > s.bottom && n.down && (t.y = s.bottom - this.height, e.y *= o, i.down = !0, a = !0), a && (this.blocked.none = !1, this.updateCenter()), a }, setOffset: function (t, e) { return void 0 === e && (e = t), this.offset.set(t, e), this }, setGameObject: function (t, e) { return void 0 === e && (e = !0), this.world.remove(this), this.gameObject && this.gameObject.body && (this.gameObject.body = null), this.gameObject = t, t.body && (t.body = this), this.setSize(), this.world.add(this), this.enable = e, this }, setSize: function (t, e, i) { void 0 === i && (i = !0); const s = this.gameObject; if (s && (!t && s.frame && (t = s.frame.realWidth), !e && s.frame && (e = s.frame.realHeight)), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && s && s.getCenter) { const n = (s.width - t) / 2; const r = (s.height - e) / 2; this.offset.set(n, r) } return this.isCircle = !1, this.radius = 0, this }, setCircle: function (t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this }, reset: function (t, e) { this.stop(); const i = this.gameObject; i && (i.setPosition(t, e), this.rotation = i.angle, this.preRotation = i.angle); const s = this.position; i && i.getTopLeft ? i.getTopLeft(s) : s.set(t, e), this.prev.copy(s), this.prevFrame.copy(s), this.autoFrame.copy(s), i && this.updateBounds(), this.updateCenter(), this.collideWorldBounds && this.checkWorldBounds(), this.resetFlags(!0) }, stop: function () { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this }, getBounds: function (t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t }, hitTest: function (t, e) { return this.isCircle ? this.radius > 0 && t >= this.left && t <= this.right && e >= this.top && e <= this.bottom && (this.center.x - t) * (this.center.x - t) + (this.center.y - e) * (this.center.y - e) <= this.radius * this.radius : l(this, t, e) }, onFloor: function () { return this.blocked.down }, onCeiling: function () { return this.blocked.up }, onWall: function () { return this.blocked.left || this.blocked.right }, deltaAbsX: function () { return this._dx > 0 ? this._dx : -this._dx }, deltaAbsY: function () { return this._dy > 0 ? this._dy : -this._dy }, deltaX: function () { return this._dx }, deltaY: function () { return this._dy }, deltaXFinal: function () { return this._tx }, deltaYFinal: function () { return this._ty }, deltaZ: function () { return this.rotation - this.preRotation }, destroy: function () { this.enable = !1, this.world && this.world.pendingDestroy.set(this) }, drawDebug: function (t) { const e = this.position; const i = e.x + this.halfWidth; const s = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, s, this.width / 2) : (this.checkCollision.up && t.lineBetween(e.x, e.y, e.x + this.width, e.y), this.checkCollision.right && t.lineBetween(e.x + this.width, e.y, e.x + this.width, e.y + this.height), this.checkCollision.down && t.lineBetween(e.x, e.y + this.height, e.x + this.width, e.y + this.height), this.checkCollision.left && t.lineBetween(e.x, e.y, e.x, e.y + this.height))), this.debugShowVelocity && (t.lineStyle(t.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, s, i + this.velocity.x / 2, s + this.velocity.y / 2)) }, willDrawDebug: function () { return this.debugShowBody || this.debugShowVelocity }, setDirectControl: function (t) { return void 0 === t && (t = !0), this.directControl = t, this }, setCollideWorldBounds: function (t, e, i, s) { void 0 === t && (t = !0), this.collideWorldBounds = t; const n = void 0 !== e; const r = void 0 !== i; return (n || r) && (this.worldBounce || (this.worldBounce = new c()), n && (this.worldBounce.x = e), r && (this.worldBounce.y = i)), void 0 !== s && (this.onWorldBounds = s), this }, setVelocity: function (t, e) { return this.velocity.set(t, e), t = this.velocity.x, e = this.velocity.y, this.speed = Math.sqrt(t * t + e * e), this }, setVelocityX: function (t) { return this.setVelocity(t, this.velocity.y) }, setVelocityY: function (t) { return this.setVelocity(this.velocity.x, t) }, setMaxVelocity: function (t, e) { return this.maxVelocity.set(t, e), this }, setMaxVelocityX: function (t) { return this.maxVelocity.x = t, this }, setMaxVelocityY: function (t) { return this.maxVelocity.y = t, this }, setMaxSpeed: function (t) { return this.maxSpeed = t, this }, setSlideFactor: function (t, e) { return this.slideFactor.set(t, e), this }, setBounce: function (t, e) { return this.bounce.set(t, e), this }, setBounceX: function (t) { return this.bounce.x = t, this }, setBounceY: function (t) { return this.bounce.y = t, this }, setAcceleration: function (t, e) { return this.acceleration.set(t, e), this }, setAccelerationX: function (t) { return this.acceleration.x = t, this }, setAccelerationY: function (t) { return this.acceleration.y = t, this }, setAllowDrag: function (t) { return void 0 === t && (t = !0), this.allowDrag = t, this }, setAllowGravity: function (t) { return void 0 === t && (t = !0), this.allowGravity = t, this }, setAllowRotation: function (t) { return void 0 === t && (t = !0), this.allowRotation = t, this }, setDrag: function (t, e) { return this.drag.set(t, e), this }, setDamping: function (t) { return this.useDamping = t, this }, setDragX: function (t) { return this.drag.x = t, this }, setDragY: function (t) { return this.drag.y = t, this }, setGravity: function (t, e) { return this.gravity.set(t, e), this }, setGravityX: function (t) { return this.gravity.x = t, this }, setGravityY: function (t) { return this.gravity.y = t, this }, setFriction: function (t, e) { return this.friction.set(t, e), this }, setFrictionX: function (t) { return this.friction.x = t, this }, setFrictionY: function (t) { return this.friction.y = t, this }, setAngularVelocity: function (t) { return this.angularVelocity = t, this }, setAngularAcceleration: function (t) { return this.angularAcceleration = t, this }, setAngularDrag: function (t) { return this.angularDrag = t, this }, setMass: function (t) { return this.mass = t, this }, setImmovable: function (t) { return void 0 === t && (t = !0), this.immovable = t, this }, setEnable: function (t) { return void 0 === t && (t = !0), this.enable = t, this }, processX: function (t, e, i, s) { this.x += t, this.updateCenter(), e !== null && (this.velocity.x = e * this.slideFactor.x); const n = this.blocked; i && (n.left = !0, n.none = !1), s && (n.right = !0, n.none = !1) }, processY: function (t, e, i, s) { this.y += t, this.updateCenter(), e !== null && (this.velocity.y = e * this.slideFactor.y); const n = this.blocked; i && (n.up = !0, n.none = !1), s && (n.down = !0, n.none = !1) }, x: { get: function () { return this.position.x }, set: function (t) { this.position.x = t } }, y: { get: function () { return this.position.y }, set: function (t) { this.position.y = t } }, left: { get: function () { return this.position.x } }, right: { get: function () { return this.position.x + this.width } }, top: { get: function () { return this.position.y } }, bottom: { get: function () { return this.position.y + this.height } } }); t.exports = d }, 79342: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s, n, r, o) { this.world = t, this.name = '', this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = s, this.collideCallback = n, this.processCallback = r, this.callbackContext = o }, setName: function (t) { return this.name = t, this }, update: function () { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly) }, destroy: function () { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null } }); t.exports = s }, 66022: (t, e, i) => { const s = i(71289); const n = i(13759); const r = i(37742); const o = i(83419); const a = i(37747); const h = i(60758); const l = i(72624); const u = i(71464); const c = new o({ initialize: function (t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys }, collider: function (t, e, i, s, n) { return this.world.addCollider(t, e, i, s, n) }, overlap: function (t, e, i, s, n) { return this.world.addOverlap(t, e, i, s, n) }, existing: function (t, e) { const i = e ? a.STATIC_BODY : a.DYNAMIC_BODY; return this.world.enableBody(t, i), t }, staticImage: function (t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.world.enableBody(r, a.STATIC_BODY), r }, image: function (t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.world.enableBody(r, a.DYNAMIC_BODY), r }, staticSprite: function (t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, a.STATIC_BODY), r }, sprite: function (t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, a.DYNAMIC_BODY), r }, staticGroup: function (t, e) { return this.sys.updateList.add(new u(this.world, this.world.scene, t, e)) }, group: function (t, e) { return this.sys.updateList.add(new h(this.world, this.world.scene, t, e)) }, body: function (t, e, i, s) { const n = new r(this.world); return n.position.set(t, e), i && s && n.setSize(i, s), this.world.add(n, a.DYNAMIC_BODY), n }, staticBody: function (t, e, i, s) { const n = new l(this.world); return n.position.set(t, e), i && s && n.setSize(i, s), this.world.add(n, a.STATIC_BODY), n }, destroy: function () { this.world = null, this.scene = null, this.sys = null } }); t.exports = c }, 79599: t => { t.exports = function (t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return e } }, 64897: (t, e, i) => { const s = i(37747); t.exports = function (t, e, i, n) { let r = 0; const o = t.deltaAbsX() + e.deltaAbsX() + n; return t._dx === 0 && e._dx === 0 ? (t.embedded = !0, e.embedded = !0) : t._dx > e._dx ? (r = t.right - e.x) > o && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? r = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0, e.physicsType !== s.STATIC_BODY || i || (t.blocked.none = !1, t.blocked.right = !0), t.physicsType !== s.STATIC_BODY || i || (e.blocked.none = !1, e.blocked.left = !0)) : t._dx < e._dx && (-(r = t.x - e.width - e.x) > o && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? r = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0, e.physicsType !== s.STATIC_BODY || i || (t.blocked.none = !1, t.blocked.left = !0), t.physicsType !== s.STATIC_BODY || i || (e.blocked.none = !1, e.blocked.right = !0))), t.overlapX = r, e.overlapX = r, r } }, 45170: (t, e, i) => { const s = i(37747); t.exports = function (t, e, i, n) { let r = 0; const o = t.deltaAbsY() + e.deltaAbsY() + n; return t._dy === 0 && e._dy === 0 ? (t.embedded = !0, e.embedded = !0) : t._dy > e._dy ? (r = t.bottom - e.y) > o && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? r = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0, e.physicsType !== s.STATIC_BODY || i || (t.blocked.none = !1, t.blocked.down = !0), t.physicsType !== s.STATIC_BODY || i || (e.blocked.none = !1, e.blocked.up = !0)) : t._dy < e._dy && (-(r = t.y - e.bottom) > o && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? r = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0, e.physicsType !== s.STATIC_BODY || i || (t.blocked.none = !1, t.blocked.up = !0), t.physicsType !== s.STATIC_BODY || i || (e.blocked.none = !1, e.blocked.down = !0))), t.overlapY = r, e.overlapY = r, r } }, 60758: (t, e, i) => { const s = i(13759); const n = i(83419); const r = i(78389); const o = i(37747); const a = i(95540); const h = i(26479); const l = i(41212); const u = new n({ Extends: h, Mixins: [r], initialize: function (t, e, i, n) { if (i || n) if (l(i)) n = i, i = null, n.internalCreateCallback = this.createCallbackHandler, n.internalRemoveCallback = this.removeCallbackHandler; else if (Array.isArray(i) && l(i[0])) { const r = this; i.forEach(function (t) { t.internalCreateCallback = r.createCallbackHandler, t.internalRemoveCallback = r.removeCallbackHandler, t.classType = a(t, 'classType', s) }), n = null } else n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; else n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; this.world = t, n && (n.classType = a(n, 'classType', s)), this.physicsType = o.DYNAMIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this.defaults = { setCollideWorldBounds: a(n, 'collideWorldBounds', !1), setBoundsRectangle: a(n, 'customBoundsRectangle', null), setAccelerationX: a(n, 'accelerationX', 0), setAccelerationY: a(n, 'accelerationY', 0), setAllowDrag: a(n, 'allowDrag', !0), setAllowGravity: a(n, 'allowGravity', !0), setAllowRotation: a(n, 'allowRotation', !0), setDamping: a(n, 'useDamping', !1), setBounceX: a(n, 'bounceX', 0), setBounceY: a(n, 'bounceY', 0), setDragX: a(n, 'dragX', 0), setDragY: a(n, 'dragY', 0), setEnable: a(n, 'enable', !0), setGravityX: a(n, 'gravityX', 0), setGravityY: a(n, 'gravityY', 0), setFrictionX: a(n, 'frictionX', 0), setFrictionY: a(n, 'frictionY', 0), setMaxSpeed: a(n, 'maxSpeed', -1), setMaxVelocityX: a(n, 'maxVelocityX', 1e4), setMaxVelocityY: a(n, 'maxVelocityY', 1e4), setVelocityX: a(n, 'velocityX', 0), setVelocityY: a(n, 'velocityY', 0), setAngularVelocity: a(n, 'angularVelocity', 0), setAngularAcceleration: a(n, 'angularAcceleration', 0), setAngularDrag: a(n, 'angularDrag', 0), setMass: a(n, 'mass', 1), setImmovable: a(n, 'immovable', !1) }, h.call(this, e, i, n), this.type = 'PhysicsGroup' }, createCallbackHandler: function (t) { t.body || this.world.enableBody(t, o.DYNAMIC_BODY); const e = t.body; for (const i in this.defaults) e[i](this.defaults[i]) }, removeCallbackHandler: function (t) { t.body && this.world.disableBody(t) }, setVelocity: function (t, e, i) { void 0 === i && (i = 0); for (let s = this.getChildren(), n = 0; n < s.length; n++)s[n].body.velocity.set(t + n * i, e + n * i); return this }, setVelocityX: function (t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), s = 0; s < i.length; s++)i[s].body.velocity.x = t + s * e; return this }, setVelocityY: function (t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), s = 0; s < i.length; s++)i[s].body.velocity.y = t + s * e; return this } }); t.exports = u }, 3017: t => { let e; let i; let s; let n; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let v; let g; let m; const y = function () { return u && v && i.blocked.right ? (e.processX(-m, a, !1, !0), 1) : l && g && i.blocked.left ? (e.processX(m, a, !0), 1) : f && g && e.blocked.right ? (i.processX(-m, h, !1, !0), 2) : d && v && e.blocked.left ? (i.processX(m, h, !0), 2) : 0 }; const x = function (t) { if (s && n) m *= 0.5, t === 0 || t === 3 ? (e.processX(m, r), i.processX(-m, o)) : (e.processX(-m, r), i.processX(m, o)); else if (s && !n) t === 0 || t === 3 ? e.processX(m, a, !0) : e.processX(-m, a, !1, !0); else if (!s && n) t === 0 || t === 3 ? i.processX(-m, h, !1, !0) : i.processX(m, h, !0); else { const v = 0.5 * m; t === 0 ? p ? (e.processX(m, 0, !0), i.processX(0, null, !1, !0)) : f ? (e.processX(v, 0, !0), i.processX(-v, 0, !1, !0)) : (e.processX(v, i.velocity.x, !0), i.processX(-v, null, !1, !0)) : t === 1 ? c ? (e.processX(0, null, !1, !0), i.processX(m, 0, !0)) : u ? (e.processX(-v, 0, !1, !0), i.processX(v, 0, !0)) : (e.processX(-v, null, !1, !0), i.processX(v, e.velocity.x, !0)) : t === 2 ? p ? (e.processX(-m, 0, !1, !0), i.processX(0, null, !0)) : d ? (e.processX(-v, 0, !1, !0), i.processX(v, 0, !0)) : (e.processX(-v, i.velocity.x, !1, !0), i.processX(v, null, !0)) : t === 3 && (c ? (e.processX(0, null, !0), i.processX(-m, 0, !1, !0)) : l ? (e.processX(v, 0, !0), i.processX(-v, 0, !1, !0)) : (e.processX(v, i.velocity.y, !0), i.processX(-v, null, !1, !0))) } return !0 }; t.exports = { BlockCheck: y, Check: function () { const t = e.velocity.x; const s = i.velocity.x; let n = Math.sqrt(s * s * i.mass / e.mass) * (s > 0 ? 1 : -1); let a = Math.sqrt(t * t * e.mass / i.mass) * (t > 0 ? 1 : -1); const h = 0.5 * (n + a); return a -= h, r = h + (n -= h) * e.bounce.x, o = h + a * i.bounce.x, l && g ? x(0) : d && v ? x(1) : u && v ? x(2) : !(!f || !g) && x(3) }, Set: function (t, r, o) { i = r; const x = (e = t).velocity.x; const T = i.velocity.x; return s = e.pushable, l = e._dx < 0, u = e._dx > 0, c = e._dx === 0, v = Math.abs(e.right - i.x) <= Math.abs(i.right - e.x), a = T - x * e.bounce.x, n = i.pushable, d = i._dx < 0, f = i._dx > 0, p = i._dx === 0, g = !v, h = x - T * i.bounce.x, m = Math.abs(o), y() }, Run: x, RunImmovableBody1: function (t) { t === 1 ? i.velocity.x = 0 : v ? i.processX(m, h, !0) : i.processX(-m, h, !1, !0), e.moves && (i.y += (e.y - e.prev.y) * e.friction.y, i._dy = i.y - i.prev.y) }, RunImmovableBody2: function (t) { t === 2 ? e.velocity.x = 0 : g ? e.processX(m, a, !0) : e.processX(-m, a, !1, !0), i.moves && (e.y += (i.y - i.prev.y) * i.friction.y, e._dy = e.y - e.prev.y) } } }, 47962: t => { let e; let i; let s; let n; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let v; let g; let m; const y = function () { return u && v && i.blocked.down ? (e.processY(-m, a, !1, !0), 1) : l && g && i.blocked.up ? (e.processY(m, a, !0), 1) : f && g && e.blocked.down ? (i.processY(-m, h, !1, !0), 2) : d && v && e.blocked.up ? (i.processY(m, h, !0), 2) : 0 }; const x = function (t) { if (s && n) m *= 0.5, t === 0 || t === 3 ? (e.processY(m, r), i.processY(-m, o)) : (e.processY(-m, r), i.processY(m, o)); else if (s && !n) t === 0 || t === 3 ? e.processY(m, a, !0) : e.processY(-m, a, !1, !0); else if (!s && n) t === 0 || t === 3 ? i.processY(-m, h, !1, !0) : i.processY(m, h, !0); else { const v = 0.5 * m; t === 0 ? p ? (e.processY(m, 0, !0), i.processY(0, null, !1, !0)) : f ? (e.processY(v, 0, !0), i.processY(-v, 0, !1, !0)) : (e.processY(v, i.velocity.y, !0), i.processY(-v, null, !1, !0)) : t === 1 ? c ? (e.processY(0, null, !1, !0), i.processY(m, 0, !0)) : u ? (e.processY(-v, 0, !1, !0), i.processY(v, 0, !0)) : (e.processY(-v, null, !1, !0), i.processY(v, e.velocity.y, !0)) : t === 2 ? p ? (e.processY(-m, 0, !1, !0), i.processY(0, null, !0)) : d ? (e.processY(-v, 0, !1, !0), i.processY(v, 0, !0)) : (e.processY(-v, i.velocity.y, !1, !0), i.processY(v, null, !0)) : t === 3 && (c ? (e.processY(0, null, !0), i.processY(-m, 0, !1, !0)) : l ? (e.processY(v, 0, !0), i.processY(-v, 0, !1, !0)) : (e.processY(v, i.velocity.y, !0), i.processY(-v, null, !1, !0))) } return !0 }; t.exports = { BlockCheck: y, Check: function () { const t = e.velocity.y; const s = i.velocity.y; let n = Math.sqrt(s * s * i.mass / e.mass) * (s > 0 ? 1 : -1); let a = Math.sqrt(t * t * e.mass / i.mass) * (t > 0 ? 1 : -1); const h = 0.5 * (n + a); return a -= h, r = h + (n -= h) * e.bounce.y, o = h + a * i.bounce.y, l && g ? x(0) : d && v ? x(1) : u && v ? x(2) : !(!f || !g) && x(3) }, Set: function (t, r, o) { i = r; const x = (e = t).velocity.y; const T = i.velocity.y; return s = e.pushable, l = e._dy < 0, u = e._dy > 0, c = e._dy === 0, v = Math.abs(e.bottom - i.y) <= Math.abs(i.bottom - e.y), a = T - x * e.bounce.y, n = i.pushable, d = i._dy < 0, f = i._dy > 0, p = i._dy === 0, g = !v, h = x - T * i.bounce.y, m = Math.abs(o), y() }, Run: x, RunImmovableBody1: function (t) { t === 1 ? i.velocity.y = 0 : v ? i.processY(m, h, !0) : i.processY(-m, h, !1, !0), e.moves && (i.x += (e.x - e.prev.x) * e.friction.x, i._dx = i.x - i.prev.x) }, RunImmovableBody2: function (t) { t === 2 ? e.velocity.y = 0 : g ? e.processY(m, a, !0) : e.processY(-m, a, !1, !0), i.moves && (e.x += (i.x - i.prev.x) * i.friction.x, e._dx = e.x - e.prev.x) } } }, 14087: (t, e, i) => { const s = i(64897); const n = i(3017); t.exports = function (t, e, i, r, o) { void 0 === o && (o = s(t, e, i, r)); const a = t.immovable; const h = e.immovable; if (i || o === 0 || a && h || t.customSeparateX || e.customSeparateX) return o !== 0 || t.embedded && e.embedded; const l = n.Set(t, e, o); return a || h ? (a ? n.RunImmovableBody1(l) : h && n.RunImmovableBody2(l), !0) : l > 0 || n.Check() } }, 89936: (t, e, i) => { const s = i(45170); const n = i(47962); t.exports = function (t, e, i, r, o) { void 0 === o && (o = s(t, e, i, r)); const a = t.immovable; const h = e.immovable; if (i || o === 0 || a && h || t.customSeparateY || e.customSeparateY) return o !== 0 || t.embedded && e.embedded; const l = n.Set(t, e, o); return a || h ? (a ? n.RunImmovableBody1(l) : h && n.RunImmovableBody2(l), !0) : l > 0 || n.Check() } }, 95829: t => { t.exports = function (t, e) { return void 0 === e && (e = {}), e.none = t, e.up = !1, e.down = !1, e.left = !1, e.right = !1, t || (e.up = !0, e.down = !0, e.left = !0, e.right = !0), e } }, 72624: (t, e, i) => { const s = i(87902); const n = i(83419); const r = i(78389); const o = i(37747); const a = i(37303); const h = i(95829); const l = i(26099); const u = new n({ Mixins: [r], initialize: function (t, e) { let i = 64; let s = 64; const n = void 0 !== e; n && e.displayWidth && (i = e.displayWidth, s = e.displayHeight), n || (e = { x: 0, y: 0, angle: 0, rotation: 0, scaleX: 1, scaleY: 1, displayOriginX: 0, displayOriginY: 0 }), this.world = t, this.gameObject = n ? e : void 0, this.isBody = !0, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new l(), this.position = new l(e.x - i * e.originX, e.y - s * e.originY), this.width = i, this.height = s, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new l(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = l.ZERO, this.allowGravity = !1, this.gravity = l.ZERO, this.bounce = l.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.pushable = !1, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = h(!1), this.touching = h(!0), this.wasTouching = h(!0), this.blocked = h(!0), this.physicsType = o.STATIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, this._dx = 0, this._dy = 0 }, setGameObject: function (t, e) { return t && t !== this.gameObject && (this.gameObject.body = null, t.body = this, this.gameObject = t), e && this.updateFromGameObject(), this }, updateFromGameObject: function () { this.world.staticTree.remove(this); const t = this.gameObject; return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this }, setOffset: function (t, e) { return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this }, setSize: function (t, e, i) { void 0 === i && (i = !0); const s = this.gameObject; if (s && s.frame && (t || (t = s.frame.realWidth), e || (e = s.frame.realHeight)), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), i && s && s.getCenter) { const n = s.displayWidth / 2; const r = s.displayHeight / 2; this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(n - this.halfWidth, r - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y } return this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this }, setCircle: function (t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this }, updateCenter: function () { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight) }, reset: function (t, e) { const i = this.gameObject; void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.setPosition(t, e), i.getTopLeft(this.position), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this) }, stop: function () { return this }, getBounds: function (t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t }, hitTest: function (t, e) { return this.isCircle ? s(this, t, e) : a(this, t, e) }, postUpdate: function () { }, deltaAbsX: function () { return 0 }, deltaAbsY: function () { return 0 }, deltaX: function () { return 0 }, deltaY: function () { return 0 }, deltaZ: function () { return 0 }, destroy: function () { this.enable = !1, this.world.pendingDestroy.set(this) }, drawDebug: function (t) { const e = this.position; const i = e.x + this.halfWidth; const s = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? t.strokeCircle(i, s, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height)) }, willDrawDebug: function () { return this.debugShowBody }, setMass: function (t) { return t <= 0 && (t = 0.1), this.mass = t, this }, x: { get: function () { return this.position.x }, set: function (t) { this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this) } }, y: { get: function () { return this.position.y }, set: function (t) { this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this) } }, left: { get: function () { return this.position.x } }, right: { get: function () { return this.position.x + this.width } }, top: { get: function () { return this.position.y } }, bottom: { get: function () { return this.position.y + this.height } } }); t.exports = u }, 71464: (t, e, i) => { const s = i(13759); const n = i(83419); const r = i(78389); const o = i(37747); const a = i(95540); const h = i(26479); const l = i(41212); const u = new n({ Extends: h, Mixins: [r], initialize: function (t, e, i, n) { i || n ? l(i) ? (n = i, i = null, n.internalCreateCallback = this.createCallbackHandler, n.internalRemoveCallback = this.removeCallbackHandler, n.createMultipleCallback = this.createMultipleCallbackHandler, n.classType = a(n, 'classType', s)) : Array.isArray(i) && l(i[0]) ? (n = i, i = null, n.forEach(function (t) { t.internalCreateCallback = this.createCallbackHandler, t.internalRemoveCallback = this.removeCallbackHandler, t.createMultipleCallback = this.createMultipleCallbackHandler, t.classType = a(t, 'classType', s) })) : n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler } : n = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: s }, this.world = t, this.physicsType = o.STATIC_BODY, this.collisionCategory = 1, this.collisionMask = 1, h.call(this, e, i, n), this.type = 'StaticPhysicsGroup' }, createCallbackHandler: function (t) { t.body || this.world.enableBody(t, o.STATIC_BODY) }, removeCallbackHandler: function (t) { t.body && this.world.disableBody(t) }, createMultipleCallbackHandler: function () { this.refresh() }, refresh: function () { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].body.reset(); return this } }); t.exports = u }, 82248: (t, e, i) => { const s = i(55495); const n = i(37742); const r = i(45319); const o = i(83419); const a = i(79342); const h = i(37747); const l = i(20339); const u = i(52816); const c = i(50792); const d = i(63012); const f = i(43855); const p = i(5470); const v = i(94977); const g = i(64897); const m = i(45170); const y = i(96523); const x = i(35154); const T = i(36383); const w = i(25774); const b = i(96602); const S = i(87841); const E = i(59542); const A = i(40012); const C = i(14087); const _ = i(89936); const M = i(35072); const P = i(72624); const R = i(2483); const L = i(61340); const O = i(26099); const F = i(15994); const D = new o({ Extends: c, initialize: function (t, e) { c.call(this), this.scene = t, this.bodies = new M(), this.staticBodies = new M(), this.pendingDestroy = new M(), this.colliders = new w(), this.gravity = new O(x(e, 'gravity.x', 0), x(e, 'gravity.y', 0)), this.bounds = new S(x(e, 'x', 0), x(e, 'y', 0), x(e, 'width', t.sys.scale.width), x(e, 'height', t.sys.scale.height)), this.checkCollision = { up: x(e, 'checkCollision.up', !0), down: x(e, 'checkCollision.down', !0), left: x(e, 'checkCollision.left', !0), right: x(e, 'checkCollision.right', !0) }, this.fps = x(e, 'fps', 60), this.fixedStep = x(e, 'fixedStep', !0), this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = x(e, 'timeScale', 1), this.OVERLAP_BIAS = x(e, 'overlapBias', 4), this.TILE_BIAS = x(e, 'tileBias', 16), this.forceX = x(e, 'forceX', !1), this.isPaused = x(e, 'isPaused', !1), this._total = 0, this.drawDebug = x(e, 'debug', !1), this.debugGraphic, this.defaults = { debugShowBody: x(e, 'debugShowBody', !0), debugShowStaticBody: x(e, 'debugShowStaticBody', !0), debugShowVelocity: x(e, 'debugShowVelocity', !0), bodyDebugColor: x(e, 'debugBodyColor', 16711935), staticBodyDebugColor: x(e, 'debugStaticBodyColor', 255), velocityDebugColor: x(e, 'debugVelocityColor', 65280) }, this.maxEntries = x(e, 'maxEntries', 16), this.useTree = x(e, 'useTree', !0), this.tree = new E(this.maxEntries), this.staticTree = new E(this.maxEntries), this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 }, this._tempMatrix = new L(), this._tempMatrix2 = new L(), this.tileFilterOptions = { isColliding: !0, isNotEmpty: !0, hasInterestingFace: !0 }, this.drawDebug && this.createDebugGraphic() }, enable: function (t, e) { void 0 === e && (e = h.DYNAMIC_BODY), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; if (s.isParent) for (let n = s.getChildren(), r = 0; r < n.length; r++) { const o = n[r]; o.isParent ? this.enable(o, e) : this.enableBody(o, e) } else this.enableBody(s, e) } }, enableBody: function (t, e) { return void 0 === e && (e = h.DYNAMIC_BODY), t.hasTransformComponent && (t.body || (e === h.DYNAMIC_BODY ? t.body = new n(this, t) : e === h.STATIC_BODY && (t.body = new P(this, t))), this.add(t.body)), t }, add: function (t) { return t.physicsType === h.DYNAMIC_BODY ? this.bodies.set(t) : t.physicsType === h.STATIC_BODY && (this.staticBodies.set(t), this.staticTree.insert(t)), t.enable = !0, t }, disable: function (t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.isParent) for (let s = i.getChildren(), n = 0; n < s.length; n++) { const r = s[n]; r.isParent ? this.disable(r) : this.disableBody(r.body) } else this.disableBody(i.body) } }, disableBody: function (t) { this.remove(t), t.enable = !1 }, remove: function (t) { t.physicsType === h.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === h.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t)) }, createDebugGraphic: function () { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t }, setBounds: function (t, e, i, s, n, r, o, a) { return this.bounds.setTo(t, e, i, s), void 0 !== n && this.setBoundsCollision(n, r, o, a), this }, setBoundsCollision: function (t, e, i, s) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === s && (s = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = s, this }, pause: function () { return this.isPaused = !0, this.emit(d.PAUSE), this }, resume: function () { return this.isPaused = !1, this.emit(d.RESUME), this }, addCollider: function (t, e, i, s, n) { void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i); const r = new a(this, !1, t, e, i, s, n); return this.colliders.add(r), r }, addOverlap: function (t, e, i, s, n) { void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i); const r = new a(this, !0, t, e, i, s, n); return this.colliders.add(r), r }, removeCollider: function (t) { return this.colliders.remove(t), this }, setFPS: function (t) { return this.fps = t, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this }, update: function (t, e) { if (!this.isPaused && this.bodies.size !== 0) { let i; let s; let n = this._frameTime; const r = this._frameTimeMS * this.timeScale; this._elapsed += e; const o = this.bodies.entries; let a = this._elapsed >= r; for (this.fixedStep || (n = 0.001 * e, a = !0, this._elapsed = 0), i = 0; i < o.length; i++)(s = o[i]).enable && s.preUpdate(a, n); if (a) { this._elapsed -= r, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(o)); const h = this.colliders.update(); for (i = 0; i < h.length; i++) { const l = h[i]; l.active && l.update() } this.emit(d.WORLD_STEP, n) } for (; this._elapsed >= r;) this._elapsed -= r, this.step(n) } }, step: function (t) { let e; let i; const s = this.bodies.entries; const n = s.length; for (e = 0; e < n; e++)(i = s[e]).enable && i.update(t); this.useTree && (this.tree.clear(), this.tree.load(s)); const r = this.colliders.update(); for (e = 0; e < r.length; e++) { const o = r[e]; o.active && o.update() } this.emit(d.WORLD_STEP, t), this.stepsLastFrame++ }, singleStep: function () { this.update(0, this._frameTimeMS), this.postUpdate() }, postUpdate: function () { let t; let e; let i = this.bodies.entries; let s = i.length; const n = this.bodies; const r = this.staticBodies; if (this.stepsLastFrame) for (this.stepsLastFrame = 0, t = 0; t < s; t++)(e = i[t]).enable && e.postUpdate(); if (this.drawDebug) { const o = this.debugGraphic; for (o.clear(), t = 0; t < s; t++)(e = i[t]).willDrawDebug() && e.drawDebug(o); for (s = (i = r.entries).length, t = 0; t < s; t++)(e = i[t]).willDrawDebug() && e.drawDebug(o) } const a = this.pendingDestroy; if (a.size > 0) { const l = this.tree; const u = this.staticTree; for (s = (i = a.entries).length, t = 0; t < s; t++)(e = i[t]).physicsType === h.DYNAMIC_BODY ? (l.remove(e), n.delete(e)) : e.physicsType === h.STATIC_BODY && (u.remove(e), r.delete(e)), e.world = void 0, e.gameObject = void 0; a.clear() } }, updateMotion: function (t, e) { t.allowRotation && this.computeAngularVelocity(t, e), this.computeVelocity(t, e) }, computeAngularVelocity: function (t, e) { let i = t.angularVelocity; const s = t.angularAcceleration; let n = t.angularDrag; const o = t.maxAngular; s ? i += s * e : t.allowDrag && n && (p(i - (n *= e), 0, 0.1) ? i -= n : v(i + n, 0, 0.1) ? i += n : i = 0); const a = (i = r(i, -o, o)) - t.angularVelocity; t.angularVelocity += a, t.rotation += t.angularVelocity * e }, computeVelocity: function (t, e) { let i = t.velocity.x; const s = t.acceleration.x; let n = t.drag.x; const o = t.maxVelocity.x; let a = t.velocity.y; const h = t.acceleration.y; let l = t.drag.y; const u = t.maxVelocity.y; let c = t.speed; const d = t.maxSpeed; const g = t.allowDrag; const m = t.useDamping; t.allowGravity && (i += (this.gravity.x + t.gravity.x) * e, a += (this.gravity.y + t.gravity.y) * e), s ? i += s * e : g && n && (m ? (i *= n = Math.pow(n, e), c = Math.sqrt(i * i + a * a), f(c, 0, 0.001) && (i = 0)) : p(i - (n *= e), 0, 0.01) ? i -= n : v(i + n, 0, 0.01) ? i += n : i = 0), h ? a += h * e : g && l && (m ? (a *= l = Math.pow(l, e), c = Math.sqrt(i * i + a * a), f(c, 0, 0.001) && (a = 0)) : p(a - (l *= e), 0, 0.01) ? a -= l : v(a + l, 0, 0.01) ? a += l : a = 0), i = r(i, -o, o), a = r(a, -u, u), t.velocity.set(i, a), d > -1 && t.velocity.length() > d && (t.velocity.normalize().scale(d), c = d), t.speed = c }, separate: function (t, e, i, s, n) { let r; let o; let a = !1; let h = !0; if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return a; if (i && !1 === i.call(s, t.gameObject, e.gameObject)) return a; if (t.isCircle || e.isCircle) { const l = this.separateCircle(t, e, n); l.result ? (a = !0, h = !1) : (r = l.x, o = l.y, h = !0) } if (h) { let u = !1; let c = !1; const f = this.OVERLAP_BIAS; n ? (u = C(t, e, n, f, r), c = _(t, e, n, f, o)) : this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (u = C(t, e, n, f, r), this.intersects(t, e) && (c = _(t, e, n, f, o))) : (c = _(t, e, n, f, o), this.intersects(t, e) && (u = C(t, e, n, f, r))), a = u || c } return a && (n ? (t.onOverlap || e.onOverlap) && this.emit(d.OVERLAP, t.gameObject, e.gameObject, t, e) : (t.onCollide || e.onCollide) && this.emit(d.COLLIDE, t.gameObject, e.gameObject, t, e)), a }, separateCircle: function (t, e, i) { g(t, e, !1, 0), m(t, e, !1, 0); const n = t.isCircle; const r = e.isCircle; const o = t.center; const a = e.center; const h = t.immovable; const c = e.immovable; const d = t.velocity; const f = e.velocity; let p = 0; let v = !0; if (n !== r) { v = !1; let y = o.x; let x = o.y; let w = t.halfWidth; let b = e.position.x; let S = e.position.y; let E = e.right; let A = e.bottom; r && (y = a.x, x = a.y, w = e.halfWidth, b = t.position.x, S = t.position.y, E = t.right, A = t.bottom), x < S ? y < b ? p = l(y, x, b, S) - w : y > E && (p = l(y, x, E, S) - w) : x > A && (y < b ? p = l(y, x, b, A) - w : y > E && (p = l(y, x, E, A) - w)), p *= -1 } else p = t.halfWidth + e.halfWidth - u(o, a); t.overlapR = p, e.overlapR = p; const C = s(o, a); let _ = (p + T.EPSILON) * Math.cos(C); let M = (p + T.EPSILON) * Math.sin(C); const P = { overlap: p, result: !1, x: _, y: M }; if (i && (!v || v && p !== 0)) return P.result = !0, P; if (!v && p === 0 || h && c || t.customSeparateX || e.customSeparateX) return P.x = void 0, P.y = void 0, P; const R = !t.pushable && !e.pushable; if (v) { const L = o.x - a.x; const O = o.y - a.y; const F = Math.sqrt(Math.pow(L, 2) + Math.pow(O, 2)); const D = (a.x - o.x) / F || 0; const k = (a.y - o.y) / F || 0; let I = 2 * (d.x * D + d.y * k - f.x * D - f.y * k) / (t.mass + e.mass); (h || c) && (I *= 2), h || (d.x = d.x - I / t.mass * D, d.y = d.y - I / t.mass * k, d.multiply(t.bounce)), c || (f.x = f.x + I / e.mass * D, f.y = f.y + I / e.mass * k, f.multiply(e.bounce)), h || c || (_ *= 0.5, M *= 0.5), h || (t.x -= _, t.y -= M, t.updateCenter()), c || (e.x += _, e.y += M, e.updateCenter()), P.result = !0 } else !h || t.pushable || R ? (t.x -= _, t.y -= M, t.updateCenter()) : (!c || e.pushable || R) && (e.x += _, e.y += M, e.updateCenter()), P.x = void 0, P.y = void 0; return P }, intersects: function (t, e) { return t !== e && (t.isCircle || e.isCircle ? t.isCircle ? e.isCircle ? u(t.center, e.center) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : this.circleBodyIntersects(e, t) : !(t.right <= e.left || t.bottom <= e.top || t.left >= e.right || t.top >= e.bottom)) }, circleBodyIntersects: function (t, e) { const i = r(t.center.x, e.left, e.right); const s = r(t.center.y, e.top, e.bottom); return (t.center.x - i) * (t.center.x - i) + (t.center.y - s) * (t.center.y - s) <= t.halfWidth * t.halfWidth }, overlap: function (t, e, i, s, n) { return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i), this.collideObjects(t, e, i, s, n, !0) }, collide: function (t, e, i, s, n) { return void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i), this.collideObjects(t, e, i, s, n, !1) }, collideObjects: function (t, e, i, s, n, r) { let o, a; !t.isParent || void 0 !== t.physicsType && void 0 !== e && t !== e || (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries); const h = Array.isArray(t); const l = Array.isArray(e); if (this._total = 0, h || l) if (!h && l) for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, s, n, r); else if (h && !l) if (e) for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, s, n, r); else for (o = 0; o < t.length; o++) { const u = t[o]; for (a = o + 1; a < t.length; a++)o !== a && this.collideHandler(u, t[a], i, s, n, r) } else for (o = 0; o < t.length; o++) for (a = 0; a < e.length; a++) this.collideHandler(t[o], e[a], i, s, n, r); else this.collideHandler(t, e, i, s, n, r); return this._total > 0 }, collideHandler: function (t, e, i, s, n, r) { if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, s, n, r); if (!t || !e) return !1; if (t.body || t.isBody) { if (e.body || e.isBody) return this.collideSpriteVsSprite(t, e, i, s, n, r); if (e.isParent) return this.collideSpriteVsGroup(t, e, i, s, n, r); if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, s, n, r) } else if (t.isParent) { if (e.body || e.isBody) return this.collideSpriteVsGroup(e, t, i, s, n, r); if (e.isParent) return this.collideGroupVsGroup(t, e, i, s, n, r); if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, s, n, r) } else if (t.isTilemap) { if (e.body || e.isBody) return this.collideSpriteVsTilemapLayer(e, t, i, s, n, r); if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, s, n, r) } }, canCollide: function (t, e) { return t && e && (t.collisionMask & e.collisionCategory) != 0 && (e.collisionMask & t.collisionCategory) != 0 }, collideSpriteVsSprite: function (t, e, i, s, n, r) { const o = t.isBody ? t : t.body; const a = e.isBody ? e : e.body; return !!this.canCollide(o, a) && (this.separate(o, a, s, n, r) && (i && i.call(n, t, e), this._total++), !0) }, collideSpriteVsGroup: function (t, e, i, s, n, r) { let o; let a; let l; const u = t.isBody ? t : t.body; if (e.length !== 0 && u && u.enable && !u.checkCollision.none && this.canCollide(u, e)) if (this.useTree || e.physicsType === h.STATIC_BODY) { const c = this.treeMinMax; c.minX = u.left, c.minY = u.top, c.maxX = u.right, c.maxY = u.bottom; const d = e.physicsType === h.DYNAMIC_BODY ? this.tree.search(c) : this.staticTree.search(c); for (a = d.length, o = 0; o < a; o++)u !== (l = d[o]) && l.enable && !l.checkCollision.none && e.contains(l.gameObject) && this.separate(u, l, s, n, r) && (i && i.call(n, u.gameObject, l.gameObject), this._total++) } else { const f = e.getChildren(); const p = e.children.entries.indexOf(t); for (a = f.length, o = 0; o < a; o++)(l = f[o].body) && o !== p && l.enable && this.separate(u, l, s, n, r) && (i && i.call(n, u.gameObject, l.gameObject), this._total++) } }, collideGroupVsTilemapLayer: function (t, e, i, s, n, r) { if (!this.canCollide(t, e)) return !1; const o = t.getChildren(); if (o.length === 0) return !1; for (var a = !1, h = 0; h < o.length; h++)(o[h].body || o[h].isBody) && this.collideSpriteVsTilemapLayer(o[h], e, i, s, n, r) && (a = !0); return a }, collideTiles: function (t, e, i, s, n) { return !(e.length === 0 || t.body && !t.body.enable || t.isBody && !t.enable) && this.collideSpriteVsTilesHandler(t, e, i, s, n, !1, !1) }, overlapTiles: function (t, e, i, s, n) { return !(e.length === 0 || t.body && !t.body.enable || t.isBody && !t.enable) && this.collideSpriteVsTilesHandler(t, e, i, s, n, !0, !1) }, collideSpriteVsTilemapLayer: function (t, e, i, s, n, r) { const o = t.isBody ? t : t.body; if (!o.enable || o.checkCollision.none || !this.canCollide(o, e)) return !1; const a = e.layer; const h = o.x - a.tileWidth * e.scaleX; const l = o.y - a.tileHeight * e.scaleY; const u = o.width + a.tileWidth * e.scaleX; const c = o.height + a.tileHeight * e.scaleY; const d = r ? null : this.tileFilterOptions; const f = y(h, l, u, c, d, e.scene.cameras.main, e.layer); return f.length !== 0 && this.collideSpriteVsTilesHandler(t, f, i, s, n, r, !0) }, collideSpriteVsTilesHandler: function (t, e, i, s, n, r, o) { for (var a, h, l = t.isBody ? t : t.body, u = { left: 0, right: 0, top: 0, bottom: 0 }, c = !1, f = 0; f < e.length; f++) { const p = (h = (a = e[f]).tilemapLayer).tileToWorldXY(a.x, a.y); u.left = p.x, u.top = p.y, u.right = u.left + a.width * h.scaleX, u.bottom = u.top + a.height * h.scaleY, R(u, l) && (!s || s.call(n, t, a)) && b(a, t) && (r || A(f, l, a, u, h, this.TILE_BIAS, o)) && (this._total++, c = !0, i && i.call(n, t, a), r && l.onOverlap ? this.emit(d.TILE_OVERLAP, t, a, l) : l.onCollide && this.emit(d.TILE_COLLIDE, t, a, l)) } return c }, collideGroupVsGroup: function (t, e, i, s, n, r) { if (t.length !== 0 && e.length !== 0 && this.canCollide(t, e)) for (let o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, s, n, r) }, wrap: function (t, e) { t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e) }, wrapArray: function (t, e) { for (let i = 0; i < t.length; i++) this.wrapObject(t[i], e) }, wrapObject: function (t, e) { void 0 === e && (e = 0), t.x = F(t.x, this.bounds.left - e, this.bounds.right + e), t.y = F(t.y, this.bounds.top - e, this.bounds.bottom + e) }, shutdown: function () { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners() }, destroy: function () { this.shutdown(), this.scene = null, this.debugGraphic && (this.debugGraphic.destroy(), this.debugGraphic = null) } }); t.exports = D }, 1093: t => { t.exports = { setAcceleration: function (t, e) { return this.body.acceleration.set(t, e), this }, setAccelerationX: function (t) { return this.body.acceleration.x = t, this }, setAccelerationY: function (t) { return this.body.acceleration.y = t, this } } }, 59023: t => { t.exports = { setAngularVelocity: function (t) { return this.body.angularVelocity = t, this }, setAngularAcceleration: function (t) { return this.body.angularAcceleration = t, this }, setAngularDrag: function (t) { return this.body.angularDrag = t, this } } }, 62069: t => { t.exports = { setBounce: function (t, e) { return this.body.bounce.set(t, e), this }, setBounceX: function (t) { return this.body.bounce.x = t, this }, setBounceY: function (t) { return this.body.bounce.y = t, this }, setCollideWorldBounds: function (t, e, i, s) { return this.body.setCollideWorldBounds(t, e, i, s), this } } }, 78389: (t, e, i) => { const s = i(79599); const n = { setCollisionCategory: function (t) { return (this.body ? this.body : this).collisionCategory = t, this }, willCollideWith: function (t) { return ((this.body ? this.body : this).collisionMask & t) != 0 }, addCollidesWith: function (t) { const e = this.body ? this.body : this; return e.collisionMask = e.collisionMask | t, this }, removeCollidesWith: function (t) { const e = this.body ? this.body : this; return e.collisionMask = e.collisionMask & ~t, this }, setCollidesWith: function (t) { return (this.body ? this.body : this).collisionMask = s(t), this }, resetCollisionCategory: function () { const t = this.body ? this.body : this; return t.collisionCategory = 1, t.collisionMask = 1, this } }; t.exports = n }, 87118: t => { t.exports = { setDebug: function (t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this }, setDebugBodyColor: function (t) { return this.body.debugBodyColor = t, this }, debugShowBody: { get: function () { return this.body.debugShowBody }, set: function (t) { this.body.debugShowBody = t } }, debugShowVelocity: { get: function () { return this.body.debugShowVelocity }, set: function (t) { this.body.debugShowVelocity = t } }, debugBodyColor: { get: function () { return this.body.debugBodyColor }, set: function (t) { this.body.debugBodyColor = t } } } }, 52819: t => { t.exports = { setDrag: function (t, e) { return this.body.drag.set(t, e), this }, setDragX: function (t) { return this.body.drag.x = t, this }, setDragY: function (t) { return this.body.drag.y = t, this }, setDamping: function (t) { return this.body.useDamping = t, this } } }, 4074: t => { const e = { setDirectControl: function (t) { return this.body.setDirectControl(t), this }, enableBody: function (t, e, i, s, n) { return t && this.body.reset(e, i), s && (this.body.gameObject.active = !0), n && (this.body.gameObject.visible = !0), this.body.enable = !0, this }, disableBody: function (t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this }, refreshBody: function () { return this.body.updateFromGameObject(), this } }; t.exports = e }, 40831: t => { t.exports = { setFriction: function (t, e) { return this.body.friction.set(t, e), this }, setFrictionX: function (t) { return this.body.friction.x = t, this }, setFrictionY: function (t) { return this.body.friction.y = t, this } } }, 26775: t => { t.exports = { setGravity: function (t, e) { return this.body.gravity.set(t, e), this }, setGravityX: function (t) { return this.body.gravity.x = t, this }, setGravityY: function (t) { return this.body.gravity.y = t, this } } }, 9437: t => { const e = { setImmovable: function (t) { return void 0 === t && (t = !0), this.body.immovable = t, this } }; t.exports = e }, 30621: t => { t.exports = { setMass: function (t) { return this.body.mass = t, this } } }, 72441: (t, e, i) => { const s = i(47956); const n = i(96503); const r = i(2044); const o = i(81491); t.exports = function (t, e, i, a, h, l) { const u = s(t, e - a, i - a, 2 * a, 2 * a, h, l); if (u.length === 0) return u; for (var c = new n(e, i, a), d = new n(), f = [], p = 0; p < u.length; p++) { const v = u[p]; v.isCircle ? (d.setTo(v.center.x, v.center.y, v.halfWidth), r(c, d) && f.push(v)) : o(c, v) && f.push(v) } return f } }, 47956: t => { t.exports = function (t, e, i, s, n, r, o) { void 0 === r && (r = !0), void 0 === o && (o = !1); let a = []; let h = []; const l = t.treeMinMax; if (l.minX = e, l.minY = i, l.maxX = e + s, l.maxY = i + n, o && (h = t.staticTree.search(l)), r && t.useTree) a = t.tree.search(l); else if (r) { const u = t.bodies; const c = { position: { x: e, y: i }, left: e, top: i, right: e + s, bottom: i + n, isCircle: !1 }; const d = t.intersects; u.iterate(function (t) { d(t, c) && a.push(t) }) } return h.concat(a) } }, 62121: t => { const e = { setPushable: function (t) { return void 0 === t && (t = !0), this.body.pushable = t, this } }; t.exports = e }, 29384: t => { t.exports = { setOffset: function (t, e) { return this.body.setOffset(t, e), this }, setSize: function (t, e, i) { return this.body.setSize(t, e, i), this }, setBodySize: function (t, e, i) { return this.body.setSize(t, e, i), this }, setCircle: function (t, e, i) { return this.body.setCircle(t, e, i), this } } }, 15098: t => { t.exports = { setVelocity: function (t, e) { return this.body.setVelocity(t, e), this }, setVelocityX: function (t) { return this.body.setVelocityX(t), this }, setVelocityY: function (t) { return this.body.setVelocityY(t), this }, setMaxVelocity: function (t, e) { return this.body.maxVelocity.set(t, e), this } } }, 92209: (t, e, i) => { t.exports = { Acceleration: i(1093), Angular: i(59023), Bounce: i(62069), Collision: i(78389), Debug: i(87118), Drag: i(52819), Enable: i(4074), Friction: i(40831), Gravity: i(26775), Immovable: i(9437), Mass: i(30621), OverlapCirc: i(72441), OverlapRect: i(47956), Pushable: i(62121), Size: i(29384), Velocity: i(15098) } }, 37747: t => { t.exports = { DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14 } }, 20009: t => { t.exports = 'collide' }, 36768: t => { t.exports = 'overlap' }, 60473: t => { t.exports = 'pause' }, 89954: t => { t.exports = 'resume' }, 61804: t => { t.exports = 'tilecollide' }, 7161: t => { t.exports = 'tileoverlap' }, 34689: t => { t.exports = 'worldbounds' }, 16006: t => { t.exports = 'worldstep' }, 63012: (t, e, i) => { t.exports = { COLLIDE: i(20009), OVERLAP: i(36768), PAUSE: i(60473), RESUME: i(89954), TILE_COLLIDE: i(61804), TILE_OVERLAP: i(7161), WORLD_BOUNDS: i(34689), WORLD_STEP: i(16006) } }, 27064: (t, e, i) => { const s = i(37747); const n = i(79291); let r = { ArcadePhysics: i(86689), Body: i(37742), Collider: i(79342), Components: i(92209), Events: i(63012), Factory: i(66022), GetCollidesWith: i(79599), GetOverlapX: i(64897), GetOverlapY: i(45170), SeparateX: i(14087), SeparateY: i(89936), Group: i(60758), Image: i(71289), Sprite: i(13759), StaticBody: i(72624), StaticGroup: i(71464), Tilemap: i(55173), World: i(82248) }; r = n(!1, r, s), t.exports = r }, 96602: t => { t.exports = function (t, e) { return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t) } }, 36294: t => { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.left = !0) : e > 0 && (t.blocked.none = !1, t.blocked.right = !0), t.position.x -= e, t.updateCenter(), t.bounce.x === 0 ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x } }, 67013: t => { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.up = !0) : e > 0 && (t.blocked.none = !1, t.blocked.down = !0), t.position.y -= e, t.updateCenter(), t.bounce.y === 0 ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y } }, 40012: (t, e, i) => { const s = i(21329); const n = i(53442); const r = i(2483); t.exports = function (t, e, i, o, a, h, l) { const u = o.left; const c = o.top; const d = o.right; const f = o.bottom; let p = i.faceLeft || i.faceRight; let v = i.faceTop || i.faceBottom; if (l || (p = !0, v = !0), !p && !v) return !1; let g = 0; let m = 0; let y = 0; let x = 1; if (e.deltaAbsX() > e.deltaAbsY() ? y = -1 : e.deltaAbsX() < e.deltaAbsY() && (x = -1), e.deltaX() !== 0 && e.deltaY() !== 0 && p && v && (y = Math.min(Math.abs(e.position.x - d), Math.abs(e.right - u)), x = Math.min(Math.abs(e.position.y - f), Math.abs(e.bottom - c))), y < x) { if (p && (g = s(e, i, u, d, h, l)) !== 0 && !r(o, e)) return !0; v && (m = n(e, i, c, f, h, l)) } else { if (v && (m = n(e, i, c, f, h, l)) !== 0 && !r(o, e)) return !0; p && (g = s(e, i, u, d, h, l)) } return g !== 0 || m !== 0 } }, 21329: (t, e, i) => { const s = i(36294); t.exports = function (t, e, i, n, r, o) { let a = 0; let h = e.faceLeft; let l = e.faceRight; let u = e.collideLeft; let c = e.collideRight; return o || (h = !0, l = !0, u = !0, c = !0), t.deltaX() < 0 && c && t.checkCollision.left ? l && t.x < n && (a = t.x - n) < -r && (a = 0) : t.deltaX() > 0 && u && t.checkCollision.right && h && t.right > i && (a = t.right - i) > r && (a = 0), a !== 0 && (t.customSeparateX ? t.overlapX = a : s(t, a)), a } }, 53442: (t, e, i) => { const s = i(67013); t.exports = function (t, e, i, n, r, o) { let a = 0; let h = e.faceTop; let l = e.faceBottom; let u = e.collideUp; let c = e.collideDown; return o || (h = !0, l = !0, u = !0, c = !0), t.deltaY() < 0 && c && t.checkCollision.up ? l && t.y < n && (a = t.y - n) < -r && (a = 0) : t.deltaY() > 0 && u && t.checkCollision.down && h && t.bottom > i && (a = t.bottom - i) > r && (a = 0), a !== 0 && (t.customSeparateY ? t.overlapY = a : s(t, a)), a } }, 2483: t => { t.exports = function (t, e) { return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom) } }, 55173: (t, e, i) => { const s = { ProcessTileCallbacks: i(96602), ProcessTileSeparationX: i(36294), ProcessTileSeparationY: i(67013), SeparateTile: i(40012), TileCheckX: i(21329), TileCheckY: i(53442), TileIntersectsBody: i(2483) }; t.exports = s }, 44563: (t, e, i) => { t.exports = { Arcade: i(27064), Matter: i(3875) } }, 68174: (t, e, i) => { const s = i(83419); const n = i(26099); const r = new s({ initialize: function () { this.boundsCenter = new n(), this.centerDiff = new n() }, parseBody: function (t) { if (!(t = t.hasOwnProperty('body') ? t.body : t).hasOwnProperty('bounds') || !t.hasOwnProperty('centerOfMass')) return !1; const e = this.boundsCenter; const i = this.centerDiff; const s = t.bounds.max.x - t.bounds.min.x; const n = t.bounds.max.y - t.bounds.min.y; const r = s * t.centerOfMass.x; const o = n * t.centerOfMass.y; return e.set(s / 2, n / 2), i.set(r - e.x, o - e.y), !0 }, getTopLeft: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e + s.x + r.x, i + s.y + r.y) } return !1 }, getTopCenter: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e + r.x, i + s.y + r.y) } return !1 }, getTopRight: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e - (s.x - r.x), i + s.y + r.y) } return !1 }, getLeftCenter: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e + s.x + r.x, i + r.y) } return !1 }, getCenter: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.centerDiff; return new n(e + s.x, i + s.y) } return !1 }, getRightCenter: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e - (s.x - r.x), i + r.y) } return !1 }, getBottomLeft: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e + s.x + r.x, i - (s.y - r.y)) } return !1 }, getBottomCenter: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e + r.x, i - (s.y - r.y)) } return !1 }, getBottomRight: function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const s = this.boundsCenter; const r = this.centerDiff; return new n(e - (s.x - r.x), i - (s.y - r.y)) } return !1 } }); t.exports = r }, 19933: (t, e, i) => { const s = i(6790); s.Body = i(22562), s.Composite = i(69351), s.World = i(4372), s.Collision = i(52284), s.Detector = i(81388), s.Pairs = i(99561), s.Pair = i(4506), s.Query = i(73296), s.Resolver = i(66272), s.Constraint = i(48140), s.Common = i(53402), s.Engine = i(48413), s.Events = i(35810), s.Sleeping = i(53614), s.Plugin = i(73832), s.Bodies = i(66280), s.Composites = i(74116), s.Axes = i(66615), s.Bounds = i(15647), s.Svg = i(74058), s.Vector = i(31725), s.Vertices = i(41598), s.World.add = s.Composite.add, s.World.remove = s.Composite.remove, s.World.addComposite = s.Composite.addComposite, s.World.addBody = s.Composite.addBody, s.World.addConstraint = s.Composite.addConstraint, s.World.clear = s.Composite.clear, t.exports = s }, 28137: (t, e, i) => { const s = i(66280); const n = i(83419); const r = i(74116); const o = i(48140); const a = i(74058); const h = i(75803); const l = i(23181); const u = i(34803); const c = i(73834); const d = i(19496); const f = i(85791); const p = i(98713); const v = i(41598); const g = new n({ initialize: function (t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys }, rectangle: function (t, e, i, n, r) { const o = s.rectangle(t, e, i, n, r); return this.world.add(o), o }, trapezoid: function (t, e, i, n, r, o) { const a = s.trapezoid(t, e, i, n, r, o); return this.world.add(a), a }, circle: function (t, e, i, n, r) { const o = s.circle(t, e, i, n, r); return this.world.add(o), o }, polygon: function (t, e, i, n, r) { const o = s.polygon(t, e, i, n, r); return this.world.add(o), o }, fromVertices: function (t, e, i, n, r, o, a) { typeof i === 'string' && (i = v.fromPath(i)); const h = s.fromVertices(t, e, i, n, r, o, a); return this.world.add(h), h }, fromPhysicsEditor: function (t, e, i, s, n) { void 0 === n && (n = !0); const r = d.parseBody(t, e, i, s); return n && !this.world.has(r) && this.world.add(r), r }, fromSVG: function (t, e, i, n, r, o) { void 0 === n && (n = 1), void 0 === r && (r = {}), void 0 === o && (o = !0); for (var h = i.getElementsByTagName('path'), l = [], u = 0; u < h.length; u++) { const c = a.pathToVertices(h[u], 30); n !== 1 && v.scale(c, n, n), l.push(c) } const d = s.fromVertices(t, e, l, r); return o && this.world.add(d), d }, fromJSON: function (t, e, i, s, n) { void 0 === s && (s = {}), void 0 === n && (n = !0); const r = f.parseBody(t, e, i, s); return r && n && this.world.add(r), r }, imageStack: function (t, e, i, s, n, o, a, h, u) { void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === u && (u = {}); const c = this.world; const d = this.sys.displayList; u.addToWorld = !1; const f = r.stack(i, s, n, o, a, h, function (i, s) { const n = new l(c, i, s, t, e, u); return d.add(n), n.body }); return c.add(f), f }, stack: function (t, e, i, s, n, o, a) { const h = r.stack(t, e, i, s, n, o, a); return this.world.add(h), h }, pyramid: function (t, e, i, s, n, o, a) { const h = r.pyramid(t, e, i, s, n, o, a); return this.world.add(h), h }, chain: function (t, e, i, s, n, o) { return r.chain(t, e, i, s, n, o) }, mesh: function (t, e, i, s, n) { return r.mesh(t, e, i, s, n) }, newtonsCradle: function (t, e, i, s, n) { const o = r.newtonsCradle(t, e, i, s, n); return this.world.add(o), o }, car: function (t, e, i, s, n) { const o = r.car(t, e, i, s, n); return this.world.add(o), o }, softBody: function (t, e, i, s, n, o, a, h, l, u) { const c = r.softBody(t, e, i, s, n, o, a, h, l, u); return this.world.add(c), c }, joint: function (t, e, i, s, n) { return this.constraint(t, e, i, s, n) }, spring: function (t, e, i, s, n) { return this.constraint(t, e, i, s, n) }, constraint: function (t, e, i, s, n) { void 0 === s && (s = 1), void 0 === n && (n = {}), n.bodyA = t.type === 'body' ? t : t.body, n.bodyB = e.type === 'body' ? e : e.body, isNaN(i) || (n.length = i), n.stiffness = s; const r = o.create(n); return this.world.add(r), r }, worldConstraint: function (t, e, i, s) { void 0 === i && (i = 1), void 0 === s && (s = {}), s.bodyB = t.type === 'body' ? t : t.body, isNaN(e) || (s.length = e), s.stiffness = i; const n = o.create(s); return this.world.add(n), n }, mouseSpring: function (t) { return this.pointerConstraint(t) }, pointerConstraint: function (t) { void 0 === t && (t = {}), t.hasOwnProperty('render') || (t.render = { visible: !1 }); const e = new p(this.scene, this.world, t); return this.world.add(e.constraint), e }, image: function (t, e, i, s, n) { const r = new l(this.world, t, e, i, s, n); return this.sys.displayList.add(r), r }, tileBody: function (t, e) { return new c(this.world, t, e) }, sprite: function (t, e, i, s, n) { const r = new u(this.world, t, e, i, s, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), r }, gameObject: function (t, e, i) { return h(this.world, t, e, i) }, destroy: function () { this.world = null, this.scene = null, this.sys = null } }); t.exports = g }, 75803: (t, e, i) => { const s = i(31884); const n = i(95540); const r = i(26099); t.exports = function (t, e, i, o) { void 0 === i && (i = {}), void 0 === o && (o = !0); const a = e.x; const h = e.y; if (e.body = { temp: !0, position: { x: a, y: h } }, [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity].forEach(function (t) { for (const i in t) (s = t[i]).get && typeof s.get === 'function' || s.set && typeof s.set === 'function' ? Object.defineProperty(e, i, { get: t[i].get, set: t[i].set }) : Object.defineProperty(e, i, { value: t[i] }); let s }), e.world = t, e._tempVec2 = new r(a, h), i.hasOwnProperty('type') && i.type === 'body') e.setExistingBody(i, o); else { let l = n(i, 'shape', null); l || (l = 'rectangle'), i.addToWorld = o, e.setBody(l, i) } return e } }, 23181: (t, e, i) => { const s = i(83419); const n = i(31884); const r = i(95643); const o = i(95540); const a = i(88571); const h = i(72699); const l = i(26099); const u = new s({ Extends: a, Mixins: [n.Bounce, n.Collision, n.Force, n.Friction, n.Gravity, n.Mass, n.Sensor, n.SetBody, n.Sleep, n.Static, n.Transform, n.Velocity, h], initialize: function (t, e, i, s, n, a) { r.call(this, t.scene, 'Image'), this._crop = this.resetCropObject(), this.setTexture(s, n), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new l(e, i); const h = o(a, 'shape', null); h ? this.setBody(h, a) : this.setRectangle(this.width, this.height, a), this.setPosition(e, i), this.initPipeline(), this.initPostPipeline(!0) } }); t.exports = u }, 42045: (t, e, i) => { const s = i(60461); const n = i(66615); const r = i(66280); const o = i(22562); const a = i(68174); const h = i(15647); const l = i(83419); const u = i(52284); const c = i(53402); const d = i(69351); const f = i(74116); const p = i(48140); const v = i(81388); const g = i(20339); const m = i(28137); const y = i(95540); const x = i(35154); const T = i(18210); const w = i(40178); const b = i(6790); const S = i(74507); const E = i(46975); const A = i(4506); const C = i(99561); const _ = i(73832); const M = i(37277); const P = i(73296); const R = i(66272); const L = i(44594); const O = i(74058); const F = i(31725); const D = i(41598); const k = i(68243); c.setDecomp(i(55973)); const I = new l({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = o, this.composite = d, this.collision = u, this.detector = v, this.pair = A, this.pairs = C, this.query = P, this.resolver = R, this.constraint = p, this.bodies = r, this.composites = f, this.axes = n, this.bounds = h, this.svg = O, this.vector = F, this.vertices = D, this.verts = D, this._tempVec2 = F.create(), x(this.config, 'plugins.collisionevents', !0) && this.enableCollisionEventsPlugin(), x(this.config, 'plugins.attractors', !1) && this.enableAttractorPlugin(), x(this.config, 'plugins.wrap', !1) && this.enableWrapPlugin(), R._restingThresh = x(this.config, 'restingThresh', 4), R._restingThreshTangent = x(this.config, 'restingThreshTangent', 6), R._positionDampen = x(this.config, 'positionDampen', 0.9), R._positionWarming = x(this.config, 'positionWarming', 0.8), R._frictionNormalMultiplier = x(this.config, 'frictionNormalMultiplier', 5), t.sys.events.once(L.BOOT, this.boot, this), t.sys.events.on(L.START, this.start, this) }, boot: function () { this.world = new k(this.scene, this.config), this.add = new m(this.world), this.bodyBounds = new a(), this.systems.events.once(L.DESTROY, this.destroy, this) }, start: function () { this.world || (this.world = new k(this.scene, this.config), this.add = new m(this.world)); const t = this.systems.events; t.on(L.UPDATE, this.world.update, this.world), t.on(L.POST_UPDATE, this.world.postUpdate, this.world), t.once(L.SHUTDOWN, this.shutdown, this) }, getConfig: function () { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return E(y(e, 'matter', {}), y(t, 'matter', {})) }, enableAttractorPlugin: function () { return _.register(T), _.use(b, T), this }, enableWrapPlugin: function () { return _.register(S), _.use(b, S), this }, enableCollisionEventsPlugin: function () { return _.register(w), _.use(b, w), this }, pause: function () { return this.world.pause() }, resume: function () { return this.world.resume() }, set60Hz: function () { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this }, set30Hz: function () { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this }, step: function (t, e) { this.world.step(t, e) }, containsPoint: function (t, e, i) { t = this.getMatterBodies(t); const s = F.create(e, i); return P.point(t, s).length > 0 }, intersectPoint: function (t, e, i) { i = this.getMatterBodies(i); const s = F.create(t, e); const n = []; return P.point(i, s).forEach(function (t) { n.indexOf(t) === -1 && n.push(t) }), n }, intersectRect: function (t, e, i, s, n, r) { void 0 === n && (n = !1), r = this.getMatterBodies(r); const o = { min: { x: t, y: e }, max: { x: t + i, y: e + s } }; const a = []; return P.region(r, o, n).forEach(function (t) { a.indexOf(t) === -1 && a.push(t) }), a }, intersectRay: function (t, e, i, s, n, r) { void 0 === n && (n = 1), r = this.getMatterBodies(r); for (var o = [], a = P.ray(r, F.create(t, e), F.create(i, s), n), h = 0; h < a.length; h++)o.push(a[h].body); return o }, intersectBody: function (t, e) { e = this.getMatterBodies(e); for (var i = [], s = P.collides(t, e), n = 0; n < s.length; n++) { const r = s[n]; r.bodyA === t ? i.push(r.bodyB) : i.push(r.bodyA) } return i }, overlap: function (t, e, i, s, n) { void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = i), Array.isArray(t) || (t = [t]), t = this.getMatterBodies(t), e = this.getMatterBodies(e); for (var r = !1, o = 0; o < t.length; o++) for (let a = t[o], h = P.collides(a, e), l = 0; l < h.length; l++) { const u = h[l]; const c = u.bodyA.id === a.id ? u.bodyB : u.bodyA; if (!s || s.call(n, a, c, u)) if (r = !0, i) i.call(n, a, c, u); else if (!s) return !0 } return r }, setCollisionCategory: function (t, e) { return (t = this.getMatterBodies(t)).forEach(function (t) { t.collisionFilter.category = e }), this }, setCollisionGroup: function (t, e) { return (t = this.getMatterBodies(t)).forEach(function (t) { t.collisionFilter.group = e }), this }, setCollidesWith: function (t, e) { t = this.getMatterBodies(t); let i = 0; if (Array.isArray(e)) for (let s = 0; s < e.length; s++)i |= e[s]; else i = e; return t.forEach(function (t) { t.collisionFilter.mask = i }), this }, getMatterBodies: function (t) { if (!t) return this.world.getAllBodies(); Array.isArray(t) || (t = [t]); for (var e = [], i = 0; i < t.length; i++) { const s = t[i].hasOwnProperty('body') ? t[i].body : t[i]; e.push(s) } return e }, setVelocity: function (t, e, i) { t = this.getMatterBodies(t); const s = this._tempVec2; return s.x = e, s.y = i, t.forEach(function (t) { o.setVelocity(t, s) }), this }, setVelocityX: function (t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.x = e, t.forEach(function (t) { i.y = t.velocity.y, o.setVelocity(t, i) }), this }, setVelocityY: function (t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.y = e, t.forEach(function (t) { i.x = t.velocity.x, o.setVelocity(t, i) }), this }, setAngularVelocity: function (t, e) { return (t = this.getMatterBodies(t)).forEach(function (t) { o.setAngularVelocity(t, e) }), this }, applyForce: function (t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return t.forEach(function (t) { i.x = t.position.x, i.y = t.position.y, o.applyForce(t, i, e) }), this }, applyForceFromPosition: function (t, e, i, s) { t = this.getMatterBodies(t); const n = this._tempVec2; return t.forEach(function (t) { void 0 === s && (s = t.angle), n.x = i * Math.cos(s), n.y = i * Math.sin(s), o.applyForce(t, e, n) }), this }, applyForceFromAngle: function (t, e, i) { t = this.getMatterBodies(t); const s = this._tempVec2; return t.forEach(function (t) { void 0 === i && (i = t.angle), s.x = e * Math.cos(i), s.y = e * Math.sin(i), o.applyForce(t, { x: t.position.x, y: t.position.y }, s) }), this }, getConstraintLength: function (t) { let e = t.pointA.x; let i = t.pointA.y; let s = t.pointB.x; let n = t.pointB.y; return t.bodyA && (e += t.bodyA.position.x, i += t.bodyA.position.y), t.bodyB && (s += t.bodyB.position.x, n += t.bodyB.position.y), g(e, i, s, n) }, alignBody: function (t, e, i, n) { let r; switch (t = t.hasOwnProperty('body') ? t.body : t, n) { case s.TOP_LEFT: case s.LEFT_TOP: r = this.bodyBounds.getTopLeft(t, e, i); break; case s.TOP_CENTER: r = this.bodyBounds.getTopCenter(t, e, i); break; case s.TOP_RIGHT: case s.RIGHT_TOP: r = this.bodyBounds.getTopRight(t, e, i); break; case s.LEFT_CENTER: r = this.bodyBounds.getLeftCenter(t, e, i); break; case s.CENTER: r = this.bodyBounds.getCenter(t, e, i); break; case s.RIGHT_CENTER: r = this.bodyBounds.getRightCenter(t, e, i); break; case s.LEFT_BOTTOM: case s.BOTTOM_LEFT: r = this.bodyBounds.getBottomLeft(t, e, i); break; case s.BOTTOM_CENTER: r = this.bodyBounds.getBottomCenter(t, e, i); break; case s.BOTTOM_RIGHT: case s.RIGHT_BOTTOM: r = this.bodyBounds.getBottomRight(t, e, i) } return r && o.setPosition(t, r), this }, shutdown: function () { const t = this.systems.events; this.world && (t.off(L.UPDATE, this.world.update, this.world), t.off(L.POST_UPDATE, this.world.postUpdate, this.world)), t.off(L.SHUTDOWN, this.shutdown, this), this.add && this.add.destroy(), this.world && this.world.destroy(), this.add = null, this.world = null }, destroy: function () { this.shutdown(), this.scene.sys.events.off(L.START, this.start, this), this.scene = null, this.systems = null } }); M.register('MatterPhysics', I, 'matterPhysics'), t.exports = I }, 34803: (t, e, i) => { const s = i(9674); const n = i(83419); const r = i(31884); const o = i(95643); const a = i(95540); const h = i(72699); const l = i(68287); const u = i(26099); const c = new n({ Extends: l, Mixins: [r.Bounce, r.Collision, r.Force, r.Friction, r.Gravity, r.Mass, r.Sensor, r.SetBody, r.Sleep, r.Static, r.Transform, r.Velocity, h], initialize: function (t, e, i, n, r, h) { o.call(this, t.scene, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new s(this), this.setTexture(n, r), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new u(e, i); const l = a(h, 'shape', null); l ? this.setBody(l, h) : this.setRectangle(this.width, this.height, h), this.setPosition(e, i), this.initPipeline(), this.initPostPipeline(!0) } }); t.exports = c }, 73834: (t, e, i) => { const s = i(66280); const n = i(22562); const r = i(83419); const o = i(31884); const a = i(62644); const h = i(50792); const l = i(95540); const u = i(97022); const c = i(41598); const d = new r({ Extends: h, Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static], initialize: function (t, e, i) { h.call(this), this.tile = e, this.world = t, e.physics.matterBody && e.physics.matterBody.destroy(), e.physics.matterBody = this; const s = l(i, 'body', null); const r = l(i, 'addToWorld', !0); if (s) this.setBody(s, r); else { const o = e.getCollisionGroup(); l(o, 'objects', []).length > 0 ? this.setFromTileCollision(i) : this.setFromTileRectangle(i) } if (e.flipX || e.flipY) { const a = { x: e.getCenterX(), y: e.getCenterY() }; const u = e.flipX ? -1 : 1; const c = e.flipY ? -1 : 1; n.scale(s, u, c, a) } }, setFromTileRectangle: function (t) { void 0 === t && (t = {}), u(t, 'isStatic') || (t.isStatic = !0), u(t, 'addToWorld') || (t.addToWorld = !0); const e = this.tile.getBounds(); const i = e.x + e.width / 2; const n = e.y + e.height / 2; const r = s.rectangle(i, n, e.width, e.height, t); return this.setBody(r, t.addToWorld), this }, setFromTileCollision: function (t) { void 0 === t && (t = {}), u(t, 'isStatic') || (t.isStatic = !0), u(t, 'addToWorld') || (t.addToWorld = !0); for (var e = this.tile.tilemapLayer.scaleX, i = this.tile.tilemapLayer.scaleY, r = this.tile.getLeft(), o = this.tile.getTop(), h = this.tile.getCollisionGroup(), d = l(h, 'objects', []), f = [], p = 0; p < d.length; p++) { const v = d[p]; let g = r + v.x * e; let m = o + v.y * i; const y = v.width * e; const x = v.height * i; let T = null; if (v.rectangle) T = s.rectangle(g + y / 2, m + x / 2, y, x, t); else if (v.ellipse) T = s.circle(g + y / 2, m + x / 2, y / 2, t); else if (v.polygon || v.polyline) { const w = (v.polygon ? v.polygon : v.polyline).map(function (t) { return { x: t.x * e, y: t.y * i } }); const b = c.create(w); const S = c.centre(b); g += S.x, m += S.y, T = s.fromVertices(g, m, b, t) } T && f.push(T) } if (f.length === 1) this.setBody(f[0], t.addToWorld); else if (f.length > 1) { const E = a(t); E.parts = f, this.setBody(n.create(E), E.addToWorld) } return this }, setBody: function (t, e) { return void 0 === e && (e = !0), this.body && this.removeBody(), this.body = t, this.body.gameObject = this, e && this.world.add(this.body), this }, removeBody: function () { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this }, destroy: function () { this.removeBody(), this.tile.physics.matterBody = void 0, this.removeAllListeners() } }); t.exports = d }, 19496: (t, e, i) => { const s = i(66280); const n = i(22562); const r = i(53402); const o = i(95540); const a = i(41598); const h = { parseBody: function (t, e, i, s) { void 0 === s && (s = {}); for (var a = o(i, 'fixtures', []), h = [], l = 0; l < a.length; l++) for (let u = this.parseFixture(a[l]), c = 0; c < u.length; c++)h.push(u[c]); const d = r.clone(i, !0); r.extend(d, s, !0), delete d.fixtures, delete d.type; const f = n.create(d); return n.setParts(f, h), n.setPosition(f, { x: t, y: e }), f }, parseFixture: function (t) { let e; const i = r.extend({}, !1, t); if (delete i.circle, delete i.vertices, t.circle) { const n = o(t.circle, 'x'); const a = o(t.circle, 'y'); const h = o(t.circle, 'radius'); e = [s.circle(n, a, h, i)] } else t.vertices && (e = this.parseVertices(t.vertices, i)); return e }, parseVertices: function (t, e) { void 0 === e && (e = {}); for (var i = [], o = 0; o < t.length; o++)a.clockwiseSort(t[o]), i.push(n.create(r.extend({ position: a.centre(t[o]), vertices: t[o] }, e))); return s.flagCoincidentParts(i) } }; t.exports = h }, 85791: (t, e, i) => { const s = i(66280); const n = i(22562); const r = { parseBody: function (t, e, i, r) { let o; void 0 === r && (r = {}); const a = i.vertices; if (a.length === 1) r.vertices = a[0], o = n.create(r), s.flagCoincidentParts(o.parts); else { for (var h = [], l = 0; l < a.length; l++) { const u = n.create({ vertices: a[l] }); h.push(u) } s.flagCoincidentParts(h), r.parts = h, o = n.create(r) } return o.label = i.label, n.setPosition(o, { x: t, y: e }), o } }; t.exports = r }, 98713: (t, e, i) => { const s = i(15647); const n = i(83419); const r = i(69351); const o = i(48140); const a = i(81388); const h = i(1121); const l = i(8214); const u = i(46975); const c = i(53614); const d = i(26099); const f = i(41598); const p = new n({ initialize: function (t, e, i) { void 0 === i && (i = {}); this.scene = t, this.world = e, this.camera = null, this.pointer = null, this.active = !0, this.position = new d(), this.body = null, this.part = null, this.constraint = o.create(u(i, { label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 } })), this.world.on(h.BEFORE_UPDATE, this.update, this), t.sys.input.on(l.POINTER_DOWN, this.onDown, this), t.sys.input.on(l.POINTER_UP, this.onUp, this) }, onDown: function (t) { this.pointer || (this.pointer = t, this.camera = t.camera) }, onUp: function (t) { t === this.pointer && (this.pointer = null) }, getBody: function (t) { const e = this.position; const i = this.constraint; this.camera.getWorldPoint(t.x, t.y, e); for (let n = r.allBodies(this.world.localWorld), o = 0; o < n.length; o++) { const l = n[o]; if (!l.ignorePointer && s.contains(l.bounds, e) && a.canCollide(l.collisionFilter, i.collisionFilter) && this.hitTestBody(l, e)) return this.world.emit(h.DRAG_START, l, this.part, this), !0 } return !1 }, hitTestBody: function (t, e) { for (let i = this.constraint, s = t.parts.length, n = s > 1 ? 1 : 0; n < s; n++) { const r = t.parts[n]; if (f.contains(r.vertices, e)) return i.pointA = e, i.pointB = { x: e.x - t.position.x, y: e.y - t.position.y }, i.bodyB = t, i.angleB = t.angle, c.set(t, !1), this.part = r, this.body = t, !0 } return !1 }, update: function () { const t = this.pointer; let e = this.body; if (this.active && t) if (t.isDown || !e) { if (t.isDown) { if (!this.camera || !e && !this.getBody(t)) return; e = this.body; const i = this.position; const s = this.constraint; this.camera.getWorldPoint(t.x, t.y, i), s.pointA.x = i.x, s.pointA.y = i.y, c.set(e, !1), this.world.emit(h.DRAG, e, this) } } else this.stopDrag(); else e && this.stopDrag() }, stopDrag: function () { const t = this.body; const e = this.constraint; e.bodyB = null, e.pointB = null, this.pointer = null, this.body = null, this.part = null, t && this.world.emit(h.DRAG_END, t, this) }, destroy: function () { this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(h.BEFORE_UPDATE, this.update), this.scene.sys.input.off(l.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(l.POINTER_UP, this.onUp, this) } }); t.exports = p }, 68243: (t, e, i) => { const s = i(66280); const n = i(22562); const r = i(83419); const o = i(53402); const a = i(69351); const h = i(48413); const l = i(50792); const u = i(1121); const c = i(95540); const d = i(35154); const f = i(22562); const p = i(35810); const v = i(73834); const g = i(4372); const m = i(31725); const y = new r({ Extends: l, initialize: function (t, e) { l.call(this), this.scene = t, this.engine = h.create(e), this.localWorld = this.engine.world; const i = d(e, 'gravity', null); i ? this.setGravity(i.x, i.y, i.scale) : !1 === i && this.setGravity(0, 0, 0), this.walls = { left: null, right: null, top: null, bottom: null }, this.enabled = d(e, 'enabled', !0), this.getDelta = d(e, 'getDelta', this.update60Hz); const s = c(e, 'runner', {}); const n = c(s, 'fps', !1); let r = c(s, 'fps', 60); const o = c(s, 'delta', 1e3 / r); const a = c(s, 'deltaMin', 1e3 / r); const u = c(s, 'deltaMax', 1e3 / (0.5 * r)); n || (r = 1e3 / o), this.runner = { fps: r, deltaSampleSize: c(s, 'deltaSampleSize', 60), counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: c(s, 'isFixed', !1), delta: o, deltaMin: a, deltaMax: u }, this.autoUpdate = d(e, 'autoUpdate', !0); const f = d(e, 'debug', !1); if (this.drawDebug = typeof f === 'object' || f, this.debugGraphic, this.debugConfig = { showAxes: c(f, 'showAxes', !1), showAngleIndicator: c(f, 'showAngleIndicator', !1), angleColor: c(f, 'angleColor', 15208787), showBroadphase: c(f, 'showBroadphase', !1), broadphaseColor: c(f, 'broadphaseColor', 16757760), showBounds: c(f, 'showBounds', !1), boundsColor: c(f, 'boundsColor', 16777215), showVelocity: c(f, 'showVelocity', !1), velocityColor: c(f, 'velocityColor', 44783), showCollisions: c(f, 'showCollisions', !1), collisionColor: c(f, 'collisionColor', 16094476), showSeparations: c(f, 'showSeparations', !1), separationColor: c(f, 'separationColor', 16753920), showBody: c(f, 'showBody', !0), showStaticBody: c(f, 'showStaticBody', !0), showInternalEdges: c(f, 'showInternalEdges', !1), renderFill: c(f, 'renderFill', !1), renderLine: c(f, 'renderLine', !0), fillColor: c(f, 'fillColor', 1075465), fillOpacity: c(f, 'fillOpacity', 1), lineColor: c(f, 'lineColor', 2678297), lineOpacity: c(f, 'lineOpacity', 1), lineThickness: c(f, 'lineThickness', 1), staticFillColor: c(f, 'staticFillColor', 857979), staticLineColor: c(f, 'staticLineColor', 1255396), showSleeping: c(f, 'showSleeping', !1), staticBodySleepOpacity: c(f, 'staticBodySleepOpacity', 0.7), sleepFillColor: c(f, 'sleepFillColor', 4605510), sleepLineColor: c(f, 'sleepLineColor', 10066585), showSensors: c(f, 'showSensors', !0), sensorFillColor: c(f, 'sensorFillColor', 857979), sensorLineColor: c(f, 'sensorLineColor', 1255396), showPositions: c(f, 'showPositions', !0), positionSize: c(f, 'positionSize', 4), positionColor: c(f, 'positionColor', 14697178), showJoint: c(f, 'showJoint', !0), jointColor: c(f, 'jointColor', 14737474), jointLineOpacity: c(f, 'jointLineOpacity', 1), jointLineThickness: c(f, 'jointLineThickness', 2), pinSize: c(f, 'pinSize', 4), pinColor: c(f, 'pinColor', 4382944), springColor: c(f, 'springColor', 14697184), anchorColor: c(f, 'anchorColor', 15724527), anchorSize: c(f, 'anchorSize', 4), showConvexHulls: c(f, 'showConvexHulls', !1), hullColor: c(f, 'hullColor', 14091216) }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy(), c(e, 'setBounds', !1)) { const p = e.setBounds; if (typeof p === 'boolean') this.setBounds(); else { const v = c(p, 'x', 0); const g = c(p, 'y', 0); const m = c(p, 'width', t.sys.scale.width); const y = c(p, 'height', t.sys.scale.height); const x = c(p, 'thickness', 64); const T = c(p, 'left', !0); const w = c(p, 'right', !0); const b = c(p, 'top', !0); const S = c(p, 'bottom', !0); this.setBounds(v, g, m, y, x, T, w, b, S) } } }, setCompositeRenderStyle: function (t) { let e; let i; let s; const n = t.bodies; const r = t.constraints; const o = t.composites; for (e = 0; e < n.length; e++)s = (i = n[e]).render, this.setBodyRenderStyle(i, s.lineColor, s.lineOpacity, s.lineThickness, s.fillColor, s.fillOpacity); for (e = 0; e < r.length; e++)s = (i = r[e]).render, this.setConstraintRenderStyle(i, s.lineColor, s.lineOpacity, s.lineThickness, s.pinSize, s.anchorColor, s.anchorSize); for (e = 0; e < o.length; e++)i = o[e], this.setCompositeRenderStyle(i); return this }, setBodyRenderStyle: function (t, e, i, s, n, r) { const o = t.render; const a = this.debugConfig; return o ? (e == null && (e = t.isStatic ? a.staticLineColor : a.lineColor), i == null && (i = a.lineOpacity), s == null && (s = a.lineThickness), n == null && (n = t.isStatic ? a.staticFillColor : a.fillColor), r == null && (r = a.fillOpacity), !1 !== e && (o.lineColor = e), !1 !== i && (o.lineOpacity = i), !1 !== s && (o.lineThickness = s), !1 !== n && (o.fillColor = n), !1 !== r && (o.fillOpacity = r), this) : this }, setConstraintRenderStyle: function (t, e, i, s, n, r, o) { const a = t.render; const h = this.debugConfig; if (!a) return this; if (e == null) { const l = a.type; l === 'line' ? e = h.jointColor : l === 'pin' ? e = h.pinColor : l === 'spring' && (e = h.springColor) } return i == null && (i = h.jointLineOpacity), s == null && (s = h.jointLineThickness), n == null && (n = h.pinSize), r == null && (r = h.anchorColor), o == null && (o = h.anchorSize), !1 !== e && (a.lineColor = e), !1 !== i && (a.lineOpacity = i), !1 !== s && (a.lineThickness = s), !1 !== n && (a.pinSize = n), !1 !== r && (a.anchorColor = r), !1 !== o && (a.anchorSize = o), this }, setEventsProxy: function () { const t = this; const e = this.engine; const i = this.localWorld; this.drawDebug && (p.on(i, 'compositeModified', function (e) { t.setCompositeRenderStyle(e) }), p.on(i, 'beforeAdd', function (e) { for (let i = [].concat(e.object), s = 0; s < i.length; s++) { const n = i[s]; const r = n.render; n.type === 'body' ? t.setBodyRenderStyle(n, r.lineColor, r.lineOpacity, r.lineThickness, r.fillColor, r.fillOpacity) : n.type === 'composite' ? t.setCompositeRenderStyle(n) : n.type === 'constraint' && t.setConstraintRenderStyle(n, r.lineColor, r.lineOpacity, r.lineThickness, r.pinSize, r.anchorColor, r.anchorSize) } })), p.on(i, 'beforeAdd', function (e) { t.emit(u.BEFORE_ADD, e) }), p.on(i, 'afterAdd', function (e) { t.emit(u.AFTER_ADD, e) }), p.on(i, 'beforeRemove', function (e) { t.emit(u.BEFORE_REMOVE, e) }), p.on(i, 'afterRemove', function (e) { t.emit(u.AFTER_REMOVE, e) }), p.on(e, 'beforeUpdate', function (e) { t.emit(u.BEFORE_UPDATE, e) }), p.on(e, 'afterUpdate', function (e) { t.emit(u.AFTER_UPDATE, e) }), p.on(e, 'collisionStart', function (e) { let i; let s; const n = e.pairs; n.length > 0 && (i = n[0].bodyA, s = n[0].bodyB), t.emit(u.COLLISION_START, e, i, s) }), p.on(e, 'collisionActive', function (e) { let i; let s; const n = e.pairs; n.length > 0 && (i = n[0].bodyA, s = n[0].bodyB), t.emit(u.COLLISION_ACTIVE, e, i, s) }), p.on(e, 'collisionEnd', function (e) { let i; let s; const n = e.pairs; n.length > 0 && (i = n[0].bodyA, s = n[0].bodyB), t.emit(u.COLLISION_END, e, i, s) }) }, setBounds: function (t, e, i, s, n, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === s && (s = this.scene.sys.scale.height), void 0 === n && (n = 64), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - n, e - n, n, s + 2 * n), this.updateWall(o, 'right', t + i, e - n, n, s + 2 * n), this.updateWall(a, 'top', t, e - n, i, n), this.updateWall(h, 'bottom', t, e + s, i, n), this }, updateWall: function (t, e, i, s, n, r) { const o = this.walls[e]; t ? (o && g.remove(this.localWorld, o), i += n / 2, s += r / 2, this.walls[e] = this.create(i, s, n, r, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (o && g.remove(this.localWorld, o), this.walls[e] = null) }, createDebugGraphic: function () { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t }, disableGravity: function () { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this }, setGravity: function (t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 1), void 0 === i && (i = 0.001), this.localWorld.gravity.x = t, this.localWorld.gravity.y = e, this.localWorld.gravity.scale = i, this }, create: function (t, e, i, n, r) { const o = s.rectangle(t, e, i, n, r); return g.add(this.localWorld, o), o }, add: function (t) { return g.add(this.localWorld, t), this }, remove: function (t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i]; const n = s.body ? s.body : s; a.remove(this.localWorld, n, e) } return this }, removeConstraint: function (t, e) { return a.remove(this.localWorld, t, e), this }, convertTilemapLayer: function (t, e) { const i = t.layer; const s = t.getTilesWithin(0, 0, i.width, i.height, { isColliding: !0 }); return this.convertTiles(s, e), this }, convertTiles: function (t, e) { if (t.length === 0) return this; for (let i = 0; i < t.length; i++) new v(this, t[i], e); return this }, nextGroup: function (t) { return f.nextGroup(t) }, nextCategory: function () { return f.nextCategory() }, pause: function () { return this.enabled = !1, this.emit(u.PAUSE), this }, resume: function () { return this.enabled = !0, this.emit(u.RESUME), this }, update: function (t, e) { if (this.enabled && this.autoUpdate) { const i = this.engine; const s = this.runner; const n = i.timing; s.isFixed ? e = this.getDelta(t, e) : (e = t - s.timePrev || s.delta, s.timePrev = t, s.deltaHistory.push(e), s.deltaHistory = s.deltaHistory.slice(-s.deltaSampleSize), e = (e = (e = Math.min.apply(null, s.deltaHistory)) < s.deltaMin ? s.deltaMin : e) > s.deltaMax ? s.deltaMax : e, s.delta = e), s.timeScalePrev = n.timeScale, s.frameCounter += 1, t - s.counterTimestamp >= 1e3 && (s.fps = s.frameCounter * ((t - s.counterTimestamp) / 1e3), s.counterTimestamp = t, s.frameCounter = 0), h.update(i, e) } }, step: function (t) { h.update(this.engine, t) }, update60Hz: function () { return 1e3 / 60 }, update30Hz: function () { return 1e3 / 30 }, has: function (t) { const e = t.hasOwnProperty('body') ? t.body : t; return a.get(this.localWorld, e.id, e.type) !== null }, getAllBodies: function () { return a.allBodies(this.localWorld) }, getAllConstraints: function () { return a.allConstraints(this.localWorld) }, getAllComposites: function () { return a.allComposites(this.localWorld) }, postUpdate: function () { if (this.drawDebug) { const t = this.debugConfig; const e = this.engine; const i = this.debugGraphic; const s = a.allBodies(this.localWorld); this.debugGraphic.clear(), t.showBroadphase && e.broadphase.controller && this.renderGrid(e.broadphase, i, t.broadphaseColor, 0.5), t.showBounds && this.renderBodyBounds(s, i, t.boundsColor, 0.5), (t.showBody || t.showStaticBody) && this.renderBodies(s), t.showJoint && this.renderJoints(), (t.showAxes || t.showAngleIndicator) && this.renderBodyAxes(s, i, t.showAxes, t.angleColor, 0.5), t.showVelocity && this.renderBodyVelocity(s, i, t.velocityColor, 1, 2), t.showSeparations && this.renderSeparations(e.pairs.list, i, t.separationColor), t.showCollisions && this.renderCollisions(e.pairs.list, i, t.collisionColor) } }, renderGrid: function (t, e, i, s) { e.lineStyle(1, i, s); for (let n = o.keys(t.buckets), r = 0; r < n.length; r++) { const a = n[r]; if (!(t.buckets[a].length < 2)) { const h = a.split(/C|R/); e.strokeRect(parseInt(h[1], 10) * t.bucketWidth, parseInt(h[2], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight) } } return this }, renderSeparations: function (t, e, i) { e.lineStyle(1, i, 1); for (let s = 0; s < t.length; s++) { const n = t[s]; if (n.isActive) { const r = n.collision; const o = r.bodyA; const a = r.bodyB; const h = o.position; const l = a.position; const u = r.penetration; let c = o.isStatic || a.isStatic ? 1 : 4; a.isStatic && (c = 0), e.lineBetween(l.x, l.y, l.x - u.x * c, l.y - u.y * c), c = o.isStatic || a.isStatic ? 1 : 4, o.isStatic && (c = 0), e.lineBetween(h.x, h.y, h.x - u.x * c, h.y - u.y * c) } } return this }, renderCollisions: function (t, e, i) { let s, n; for (e.lineStyle(1, i, 0.5), e.fillStyle(i, 1), s = 0; s < t.length; s++) if ((n = t[s]).isActive) for (let r = 0; r < n.activeContacts.length; r++) { const o = n.activeContacts[r].vertex; e.fillRect(o.x - 2, o.y - 2, 5, 5) } for (s = 0; s < t.length; s++) if ((n = t[s]).isActive) { const a = n.collision; const h = n.activeContacts; if (h.length > 0) { let l = h[0].vertex.x; let u = h[0].vertex.y; h.length === 2 && (l = (h[0].vertex.x + h[1].vertex.x) / 2, u = (h[0].vertex.y + h[1].vertex.y) / 2), a.bodyB === a.supports[0].body || a.bodyA.isStatic ? e.lineBetween(l - 8 * a.normal.x, u - 8 * a.normal.y, l, u) : e.lineBetween(l + 8 * a.normal.x, u + 8 * a.normal.y, l, u) } } return this }, renderBodyBounds: function (t, e, i, s) { e.lineStyle(1, i, s); for (let n = 0; n < t.length; n++) { const r = t[n]; if (r.render.visible) { const o = r.bounds; if (o) e.strokeRect(o.min.x, o.min.y, o.max.x - o.min.x, o.max.y - o.min.y); else for (let a = r.parts, h = a.length > 1 ? 1 : 0; h < a.length; h++) { const l = a[h]; e.strokeRect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y) } } } return this }, renderBodyAxes: function (t, e, i, s, n) { e.lineStyle(1, s, n); for (let r = 0; r < t.length; r++) { var o; var a; var h; const l = t[r]; const u = l.parts; if (l.render.visible) if (i) for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++) { const c = o.axes[h]; e.lineBetween(o.position.x, o.position.y, o.position.x + 20 * c.x, o.position.y + 20 * c.y) } else for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++)e.lineBetween(o.position.x, o.position.y, (o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2) } return this }, renderBodyVelocity: function (t, e, i, s, n) { e.lineStyle(n, i, s); for (let r = 0; r < t.length; r++) { const o = t[r]; o.render.visible && e.lineBetween(o.position.x, o.position.y, o.position.x + 2 * (o.position.x - o.positionPrev.x), o.position.y + 2 * (o.position.y - o.positionPrev.y)) } return this }, renderBodies: function (t) { for (let e = this.debugGraphic, i = this.debugConfig, s = i.showBody, n = i.showStaticBody, r = i.showSleeping, o = i.showInternalEdges, a = i.showConvexHulls, h = i.renderFill, l = i.renderLine, u = i.staticBodySleepOpacity, c = i.sleepFillColor, d = i.sleepLineColor, f = i.hullColor, p = 0; p < t.length; p++) { const v = t[p]; if (v.render.visible && ((n || !v.isStatic) && (s || v.isStatic))) { let g = v.render.lineColor; let m = v.render.lineOpacity; const y = v.render.lineThickness; let x = v.render.fillColor; let T = v.render.fillOpacity; r && v.isSleeping && (v.isStatic ? (m *= u, T *= u) : (g = d, x = c)), h || (x = null), l || (g = null), this.renderBody(v, e, o, g, m, y, x, T); const w = v.parts.length; a && w > 1 && this.renderConvexHull(v, e, f, y) } } }, renderBody: function (t, e, i, s, n, r, o, a) { void 0 === s && (s = null), void 0 === n && (n = null), void 0 === r && (r = 1), void 0 === o && (o = null), void 0 === a && (a = null); for (var h = this.debugConfig, l = h.sensorFillColor, u = h.sensorLineColor, c = t.parts, d = c.length, f = d > 1 ? 1 : 0; f < d; f++) { const p = c[f]; const v = p.render; const g = v.opacity; if (v.visible && g !== 0 && (!p.isSensor || h.showSensors)) { const m = p.circleRadius; if (e.beginPath(), p.isSensor ? (o !== null && e.fillStyle(l, a * g), s !== null && e.lineStyle(r, u, n * g)) : (o !== null && e.fillStyle(o, a * g), s !== null && e.lineStyle(r, s, n * g)), m) e.arc(p.position.x, p.position.y, m, 0, 2 * Math.PI); else { const y = p.vertices; const x = y.length; e.moveTo(y[0].x, y[0].y); for (let T = 1; T < x; T++) { const w = y[T]; if (!y[T - 1].isInternal || i ? e.lineTo(w.x, w.y) : e.moveTo(w.x, w.y), T < x && w.isInternal && !i) { const b = (T + 1) % x; e.moveTo(y[b].x, y[b].y) } } e.closePath() } o !== null && e.fillPath(), s !== null && e.strokePath() } } if (h.showPositions && !t.isStatic) { const S = t.position.x; const E = t.position.y; const A = Math.ceil(h.positionSize / 2); e.fillStyle(h.positionColor, 1), e.fillRect(S - A, E - A, h.positionSize, h.positionSize) } return this }, renderConvexHull: function (t, e, i, s) { if (void 0 === s && (s = 1), t.parts.length > 1) { const n = t.vertices; e.lineStyle(s, i), e.beginPath(), e.moveTo(n[0].x, n[0].y); for (let r = 1; r < n.length; r++)e.lineTo(n[r].x, n[r].y); e.lineTo(n[0].x, n[0].y), e.strokePath() } return this }, renderJoints: function () { for (let t = this.debugGraphic, e = a.allConstraints(this.localWorld), i = 0; i < e.length; i++) { const s = e[i].render; const n = s.lineColor; const r = s.lineOpacity; const o = s.lineThickness; const h = s.pinSize; const l = s.anchorColor; const u = s.anchorSize; this.renderConstraint(e[i], t, n, r, o, h, l, u) } }, renderConstraint: function (t, e, i, s, n, r, a, h) { const l = t.render; if (!l.visible || !t.pointA || !t.pointB) return this; e.lineStyle(n, i, s); let u; let c; const d = t.bodyA; const f = t.bodyB; if (u = d ? m.add(d.position, t.pointA) : t.pointA, l.type === 'pin') e.strokeCircle(u.x, u.y, r); else { if (c = f ? m.add(f.position, t.pointB) : t.pointB, e.beginPath(), e.moveTo(u.x, u.y), l.type === 'spring') for (var p, v = m.sub(c, u), g = m.perp(m.normalise(v)), y = Math.ceil(o.clamp(t.length / 5, 12, 20)), x = 1; x < y; x += 1)p = x % 2 == 0 ? 1 : -1, e.lineTo(u.x + v.x * (x / y) + g.x * p * 4, u.y + v.y * (x / y) + g.y * p * 4); e.lineTo(c.x, c.y) } return e.strokePath(), l.anchors && h > 0 && (e.fillStyle(a), e.fillCircle(u.x, u.y, h), e.fillCircle(c.x, c.y, h)), this }, resetCollisionIDs: function () { return n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, this }, shutdown: function () { p.off(this.engine), this.removeAllListeners(), g.clear(this.localWorld, !1), h.clear(this.engine), this.drawDebug && this.debugGraphic.destroy() }, destroy: function () { this.shutdown() } }); t.exports = y }, 70410: t => { t.exports = { setBounce: function (t) { return this.body.restitution = t, this } } }, 66968: t => { const e = { setCollisionCategory: function (t) { return this.body.collisionFilter.category = t, this }, setCollisionGroup: function (t) { return this.body.collisionFilter.group = t, this }, setCollidesWith: function (t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return this.body.collisionFilter.mask = e, this }, setOnCollide: function (t) { return this.body.onCollideCallback = t, this }, setOnCollideEnd: function (t) { return this.body.onCollideEndCallback = t, this }, setOnCollideActive: function (t) { return this.body.onCollideActiveCallback = t, this }, setOnCollideWith: function (t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const s = t[i].hasOwnProperty('body') ? t[i].body : t[i]; this.body.setOnCollideWith(s, e) } return this } }; t.exports = e }, 51607: (t, e, i) => { const s = i(22562); const n = { applyForce: function (t) { return this._tempVec2.set(this.body.position.x, this.body.position.y), s.applyForce(this.body, this._tempVec2, t), this }, applyForceFrom: function (t, e) { return s.applyForce(this.body, t, e), this }, thrust: function (t) { const e = this.body.angle; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), s.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustLeft: function (t) { const e = this.body.angle - Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), s.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustRight: function (t) { const e = this.body.angle + Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), s.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this }, thrustBack: function (t) { const e = this.body.angle - Math.PI; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), s.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this } }; t.exports = n }, 5436: t => { const e = { setFriction: function (t, e, i) { return this.body.friction = t, void 0 !== e && (this.body.frictionAir = e), void 0 !== i && (this.body.frictionStatic = i), this }, setFrictionAir: function (t) { return this.body.frictionAir = t, this }, setFrictionStatic: function (t) { return this.body.frictionStatic = t, this } }; t.exports = e }, 39858: t => { t.exports = { setIgnoreGravity: function (t) { return this.body.ignoreGravity = t, this } } }, 37302: (t, e, i) => { const s = i(22562); const n = i(26099); const r = { setMass: function (t) { return s.setMass(this.body, t), this }, setDensity: function (t) { return s.setDensity(this.body, t), this }, centerOfMass: { get: function () { return new n(this.body.centerOfMass.x, this.body.centerOfMass.y) } } }; t.exports = r }, 39132: t => { t.exports = { setSensor: function (t) { return this.body.isSensor = t, this }, isSensor: function () { return this.body.isSensor } } }, 57772: (t, e, i) => { const s = i(66280); const n = i(22562); const r = i(43855); const o = i(95540); const a = i(19496); const h = i(85791); const l = i(41598); const u = { setRectangle: function (t, e, i) { return this.setBody({ type: 'rectangle', width: t, height: e }, i) }, setCircle: function (t, e) { return this.setBody({ type: 'circle', radius: t }, e) }, setPolygon: function (t, e, i) { return this.setBody({ type: 'polygon', sides: e, radius: t }, i) }, setTrapezoid: function (t, e, i, s) { return this.setBody({ type: 'trapezoid', width: t, height: e, slope: i }, s) }, setExistingBody: function (t, e) { void 0 === e && (e = !0), this.body && this.world.remove(this.body, !0), this.body = t; for (let i = 0; i < t.parts.length; i++)t.parts[i].gameObject = this; const s = this; if (t.destroy = function () { s.world.remove(s.body, !0), s.body.gameObject = null }, e && (this.world.has(t) && this.world.remove(t, !0), this.world.add(t)), this._originComponent) { const n = t.render.sprite.xOffset; const o = t.render.sprite.yOffset; const a = t.centerOfMass.x; const h = t.centerOfMass.y; if (r(a, 0.5) && r(h, 0.5)) this.setOrigin(n + 0.5, o + 0.5); else { const l = t.centerOffset.x; const u = t.centerOffset.y; this.setOrigin(n + l / this.displayWidth, o + u / this.displayHeight) } } return this }, setBody: function (t, e) { if (!t) return this; let i; typeof t === 'string' && (t = { type: t }); const r = o(t, 'type', 'rectangle'); const u = o(t, 'x', this._tempVec2.x); const c = o(t, 'y', this._tempVec2.y); const d = o(t, 'width', this.width); const f = o(t, 'height', this.height); switch (r) { case 'rectangle': i = s.rectangle(u, c, d, f, e); break; case 'circle': var p = o(t, 'radius', Math.max(d, f) / 2); var v = o(t, 'maxSides', 25); i = s.circle(u, c, p, e, v); break; case 'trapezoid': var g = o(t, 'slope', 0.5); i = s.trapezoid(u, c, d, f, g, e); break; case 'polygon': var m = o(t, 'sides', 5); var y = o(t, 'radius', Math.max(d, f) / 2); i = s.polygon(u, c, m, y, e); break; case 'fromVertices': case 'fromVerts': var x = o(t, 'verts', null); if (x) if (typeof x === 'string' && (x = l.fromPath(x)), this.body && !this.body.hasOwnProperty('temp')) n.setVertices(this.body, x), i = this.body; else { const T = o(t, 'flagInternal', !1); const w = o(t, 'removeCollinear', 0.01); const b = o(t, 'minimumArea', 10); i = s.fromVertices(u, c, x, e, T, w, b) } break; case 'fromPhysicsEditor': i = a.parseBody(u, c, t, e); break; case 'fromPhysicsTracer': i = h.parseBody(u, c, t, e) } return i && this.setExistingBody(i, t.addToWorld), this } }; t.exports = u }, 38083: (t, e, i) => { const s = i(1121); const n = i(53614); const r = i(35810); const o = { setToSleep: function () { return n.set(this.body, !0), this }, setAwake: function () { return n.set(this.body, !1), this }, setSleepThreshold: function (t) { return void 0 === t && (t = 60), this.body.sleepThreshold = t, this }, setSleepEvents: function (t, e) { return this.setSleepStartEvent(t), this.setSleepEndEvent(e), this }, setSleepStartEvent: function (t) { if (t) { const e = this.world; r.on(this.body, 'sleepStart', function (t) { e.emit(s.SLEEP_START, t, this) }) } else r.off(this.body, 'sleepStart'); return this }, setSleepEndEvent: function (t) { if (t) { const e = this.world; r.on(this.body, 'sleepEnd', function (t) { e.emit(s.SLEEP_END, t, this) }) } else r.off(this.body, 'sleepEnd'); return this } }; t.exports = o }, 90556: (t, e, i) => { const s = i(22562); const n = { setStatic: function (t) { return s.setStatic(this.body, t), this }, isStatic: function () { return this.body.isStatic } }; t.exports = n }, 85436: (t, e, i) => { const s = i(22562); const n = i(36383); const r = i(86554); const o = i(30954); const a = { x: { get: function () { return this.body.position.x }, set: function (t) { this._tempVec2.set(t, this.y), s.setPosition(this.body, this._tempVec2) } }, y: { get: function () { return this.body.position.y }, set: function (t) { this._tempVec2.set(this.x, t), s.setPosition(this.body, this._tempVec2) } }, scaleX: { get: function () { return this._scaleX }, set: function (t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, s.scale(this.body, e, i), s.scale(this.body, t, this._scaleY) } }, scaleY: { get: function () { return this._scaleY }, set: function (t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, s.scale(this.body, e, i), s.scale(this.body, this._scaleX, t) } }, angle: { get: function () { return o(this.body.angle * n.RAD_TO_DEG) }, set: function (t) { this.rotation = o(t) * n.DEG_TO_RAD } }, rotation: { get: function () { return this.body.angle }, set: function (t) { this._rotation = r(t), s.setAngle(this.body, this._rotation) } }, setPosition: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._tempVec2.set(t, e), s.setPosition(this.body, this._tempVec2), this }, setRotation: function (t) { return void 0 === t && (t = 0), this._rotation = r(t), s.setAngle(this.body, t), this }, setFixedRotation: function () { return s.setInertia(this.body, 1 / 0), this }, setAngle: function (t) { return void 0 === t && (t = 0), this.angle = t, s.setAngle(this.body, this.rotation), this }, setScale: function (t, e, i) { void 0 === t && (t = 1), void 0 === e && (e = t); const n = 1 / this._scaleX; const r = 1 / this._scaleY; return this._scaleX = t, this._scaleY = e, s.scale(this.body, n, r, i), s.scale(this.body, t, e, i), this } }; t.exports = a }, 42081: (t, e, i) => { const s = i(22562); const n = { setVelocityX: function (t) { return this._tempVec2.set(t, this.body.velocity.y), s.setVelocity(this.body, this._tempVec2), this }, setVelocityY: function (t) { return this._tempVec2.set(this.body.velocity.x, t), s.setVelocity(this.body, this._tempVec2), this }, setVelocity: function (t, e) { return this._tempVec2.set(t, e), s.setVelocity(this.body, this._tempVec2), this }, getVelocity: function () { return s.getVelocity(this.body) }, setAngularVelocity: function (t) { return s.setAngularVelocity(this.body, t), this }, getAngularVelocity: function () { return s.getAngularVelocity(this.body) }, setAngularSpeed: function (t) { return s.setAngularSpeed(this.body, t), this }, getAngularSpeed: function () { return s.getAngularSpeed(this.body) } }; t.exports = n }, 31884: (t, e, i) => { t.exports = { Bounce: i(70410), Collision: i(66968), Force: i(51607), Friction: i(5436), Gravity: i(39858), Mass: i(37302), Sensor: i(39132), SetBody: i(57772), Sleep: i(38083), Static: i(90556), Transform: i(85436), Velocity: i(42081) } }, 85608: t => { t.exports = 'afteradd' }, 1213: t => { t.exports = 'afterremove' }, 25968: t => { t.exports = 'afterupdate' }, 67205: t => { t.exports = 'beforeadd' }, 39438: t => { t.exports = 'beforeremove' }, 44823: t => { t.exports = 'beforeupdate' }, 92593: t => { t.exports = 'collisionactive' }, 60128: t => { t.exports = 'collisionend' }, 76861: t => { t.exports = 'collisionstart' }, 92362: t => { t.exports = 'dragend' }, 76408: t => { t.exports = 'drag' }, 93971: t => { t.exports = 'dragstart' }, 5656: t => { t.exports = 'pause' }, 47861: t => { t.exports = 'resume' }, 79099: t => { t.exports = 'sleepend' }, 35906: t => { t.exports = 'sleepstart' }, 1121: (t, e, i) => { t.exports = { AFTER_ADD: i(85608), AFTER_REMOVE: i(1213), AFTER_UPDATE: i(25968), BEFORE_ADD: i(67205), BEFORE_REMOVE: i(39438), BEFORE_UPDATE: i(44823), COLLISION_ACTIVE: i(92593), COLLISION_END: i(60128), COLLISION_START: i(76861), DRAG_END: i(92362), DRAG: i(76408), DRAG_START: i(93971), PAUSE: i(5656), RESUME: i(47861), SLEEP_END: i(79099), SLEEP_START: i(35906) } }, 3875: (t, e, i) => { t.exports = { BodyBounds: i(68174), Components: i(31884), Events: i(1121), Factory: i(28137), MatterGameObject: i(75803), Image: i(23181), Matter: i(19933), MatterPhysics: i(42045), PolyDecomp: i(55973), Sprite: i(34803), TileBody: i(73834), PhysicsEditorParser: i(19496), PhysicsJSONParser: i(85791), PointerConstraint: i(98713), World: i(68243) } }, 22562: (t, e, i) => { const s = {}; t.exports = s; const n = i(41598); const r = i(31725); const o = i(53614); const a = i(53402); const h = i(15647); const l = i(66615); !(function () { s._timeCorrection = !0, s._inertiaScale = 4, s._nextCollidingGroupId = 1, s._nextNonCollidingGroupId = -1, s._nextCategory = 1, s._baseDelta = 1e3 / 60, s.create = function (e) { const i = { id: a.nextId(), type: 'body', label: 'Body', parts: [], plugin: {}, angle: 0, vertices: null, position: { x: 0, y: 0 }, force: { x: 0, y: 0 }, torque: 0, positionImpulse: { x: 0, y: 0 }, constraintImpulse: { x: 0, y: 0, angle: 0 }, totalContacts: 0, speed: 0, angularSpeed: 0, velocity: { x: 0, y: 0 }, angularVelocity: 0, isSensor: !1, isStatic: !1, isSleeping: !1, motion: 0, sleepThreshold: 60, density: 0.001, restitution: 0, friction: 0.1, frictionStatic: 0.5, frictionAir: 0.01, collisionFilter: { category: 1, mask: 4294967295, group: 0 }, slop: 0.05, timeScale: 1, events: null, bounds: null, chamfer: null, circleRadius: 0, positionPrev: null, anglePrev: 0, parent: null, axes: null, area: 0, mass: 0, inverseMass: 0, inertia: 0, deltaTime: 1e3 / 60, inverseInertia: 0, _original: null, render: { visible: !0, opacity: 1, sprite: { xOffset: 0, yOffset: 0 }, fillColor: null, fillOpacity: null, lineColor: null, lineOpacity: null, lineThickness: null }, gameObject: null, scale: { x: 1, y: 1 }, centerOfMass: { x: 0, y: 0 }, centerOffset: { x: 0, y: 0 }, gravityScale: { x: 1, y: 1 }, ignoreGravity: !1, ignorePointer: !1, onCollideCallback: null, onCollideEndCallback: null, onCollideActiveCallback: null, onCollideWith: {} }; !e.hasOwnProperty('position') && e.hasOwnProperty('vertices') ? e.position = n.centre(e.vertices) : e.hasOwnProperty('vertices') || (i.vertices = n.fromPath('L 0 0 L 40 0 L 40 40 L 0 40')); const s = a.extend(i, e); return t(s, e), s.setOnCollideWith = function (t, e) { return e ? this.onCollideWith[t.id] = e : delete this.onCollideWith[t.id], this }, s }, s.nextGroup = function (t) { return t ? s._nextNonCollidingGroupId-- : s._nextCollidingGroupId++ }, s.nextCategory = function () { return s._nextCategory = s._nextCategory << 1, s._nextCategory }; var t = function (t, e) { if (e = e || {}, s.set(t, { bounds: t.bounds || h.create(t.vertices), positionPrev: t.positionPrev || r.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t }), n.rotate(t.vertices, t.angle, t.position), l.rotate(t.axes, t.angle), h.update(t.bounds, t.vertices, t.velocity), s.set(t, { axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia }), t.parts.length === 1) { const i = t.bounds; const o = t.centerOfMass; const a = t.centerOffset; const u = i.max.x - i.min.x; const c = i.max.y - i.min.y; o.x = -(i.min.x - t.position.x) / u, o.y = -(i.min.y - t.position.y) / c, a.x = u * o.x, a.y = c * o.y } }; s.set = function (t, e, i) { let n; for (n in typeof e === 'string' && (n = e, (e = {})[n] = i), e) if (Object.prototype.hasOwnProperty.call(e, n)) switch (i = e[n], n) { case 'isStatic': s.setStatic(t, i); break; case 'isSleeping': o.set(t, i); break; case 'mass': s.setMass(t, i); break; case 'density': s.setDensity(t, i); break; case 'inertia': s.setInertia(t, i); break; case 'vertices': s.setVertices(t, i); break; case 'position': s.setPosition(t, i); break; case 'angle': s.setAngle(t, i); break; case 'velocity': s.setVelocity(t, i); break; case 'angularVelocity': s.setAngularVelocity(t, i); break; case 'speed': s.setSpeed(t, i); break; case 'angularSpeed': s.setAngularSpeed(t, i); break; case 'parts': s.setParts(t, i); break; case 'centre': s.setCentre(t, i); break; default: t[n] = i } }, s.setStatic = function (t, e) { for (let i = 0; i < t.parts.length; i++) { const s = t.parts[i]; e ? (s.isStatic || (s._original = { restitution: s.restitution, friction: s.friction, mass: s.mass, inertia: s.inertia, density: s.density, inverseMass: s.inverseMass, inverseInertia: s.inverseInertia }), s.restitution = 0, s.friction = 1, s.mass = s.inertia = s.density = 1 / 0, s.inverseMass = s.inverseInertia = 0, s.positionPrev.x = s.position.x, s.positionPrev.y = s.position.y, s.anglePrev = s.angle, s.angularVelocity = 0, s.speed = 0, s.angularSpeed = 0, s.motion = 0) : s._original && (s.restitution = s._original.restitution, s.friction = s._original.friction, s.mass = s._original.mass, s.inertia = s._original.inertia, s.density = s._original.density, s.inverseMass = s._original.inverseMass, s.inverseInertia = s._original.inverseInertia, s._original = null), s.isStatic = e } }, s.setMass = function (t, e) { const i = t.inertia / (t.mass / 6); t.inertia = i * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area }, s.setDensity = function (t, e) { s.setMass(t, e * t.area), t.density = e }, s.setInertia = function (t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia }, s.setVertices = function (t, e) { e[0].body === t ? t.vertices = e : t.vertices = n.create(e, t), t.axes = l.fromVertices(t.vertices), t.area = n.area(t.vertices), s.setMass(t, t.density * t.area); const i = n.centre(t.vertices); n.translate(t.vertices, i, -1), s.setInertia(t, s._inertiaScale * n.inertia(t.vertices, t.mass)), n.translate(t.vertices, t.position), h.update(t.bounds, t.vertices, t.velocity) }, s.setParts = function (t, e, i) { let r; for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, r = 0; r < e.length; r++) { const o = e[r]; o !== t && (o.parent = t, t.parts.push(o)) } if (t.parts.length !== 1) { if (i = void 0 === i || i) { let a = []; for (r = 0; r < e.length; r++)a = a.concat(e[r].vertices); n.clockwiseSort(a); const l = n.hull(a); const u = n.centre(l); s.setVertices(t, l), n.translate(t.vertices, u) } const c = s._totalProperties(t); const d = c.centre.x; const f = c.centre.y; const p = t.bounds; const v = t.centerOfMass; const g = t.centerOffset; h.update(p, t.vertices, t.velocity), v.x = -(p.min.x - d) / (p.max.x - p.min.x), v.y = -(p.min.y - f) / (p.max.y - p.min.y), g.x = d, g.y = f, t.area = c.area, t.parent = t, t.position.x = d, t.position.y = f, t.positionPrev.x = d, t.positionPrev.y = f, s.setMass(t, c.mass), s.setInertia(t, c.inertia), s.setPosition(t, c.centre) } }, s.setCentre = function (t, e, i) { i ? (t.positionPrev.x += e.x, t.positionPrev.y += e.y, t.position.x += e.x, t.position.y += e.y) : (t.positionPrev.x = e.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = e.y - (t.position.y - t.positionPrev.y), t.position.x = e.x, t.position.y = e.y) }, s.setPosition = function (t, e, i) { const s = r.sub(e, t.position); i ? (t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.velocity.x = s.x, t.velocity.y = s.y, t.speed = r.magnitude(s)) : (t.positionPrev.x += s.x, t.positionPrev.y += s.y); for (let o = 0; o < t.parts.length; o++) { const a = t.parts[o]; a.position.x += s.x, a.position.y += s.y, n.translate(a.vertices, s), h.update(a.bounds, a.vertices, t.velocity) } }, s.setAngle = function (t, e, i) { const s = e - t.angle; i ? (t.anglePrev = t.angle, t.angularVelocity = s, t.angularSpeed = Math.abs(s)) : t.anglePrev += s; for (let o = 0; o < t.parts.length; o++) { const a = t.parts[o]; a.angle += s, n.rotate(a.vertices, s, t.position), l.rotate(a.axes, s), h.update(a.bounds, a.vertices, t.velocity), o > 0 && r.rotateAbout(a.position, s, t.position, a.position) } }, s.setVelocity = function (t, e) { const i = t.deltaTime / s._baseDelta; t.positionPrev.x = t.position.x - e.x * i, t.positionPrev.y = t.position.y - e.y * i, t.velocity.x = (t.position.x - t.positionPrev.x) / i, t.velocity.y = (t.position.y - t.positionPrev.y) / i, t.speed = r.magnitude(t.velocity) }, s.getVelocity = function (t) { const e = s._baseDelta / t.deltaTime; return { x: (t.position.x - t.positionPrev.x) * e, y: (t.position.y - t.positionPrev.y) * e } }, s.getSpeed = function (t) { return r.magnitude(s.getVelocity(t)) }, s.setSpeed = function (t, e) { s.setVelocity(t, r.mult(r.normalise(s.getVelocity(t)), e)) }, s.setAngularVelocity = function (t, e) { const i = t.deltaTime / s._baseDelta; t.anglePrev = t.angle - e * i, t.angularVelocity = (t.angle - t.anglePrev) / i, t.angularSpeed = Math.abs(t.angularVelocity) }, s.getAngularVelocity = function (t) { return (t.angle - t.anglePrev) * s._baseDelta / t.deltaTime }, s.getAngularSpeed = function (t) { return Math.abs(s.getAngularVelocity(t)) }, s.setAngularSpeed = function (t, e) { s.setAngularVelocity(t, a.sign(s.getAngularVelocity(t)) * e) }, s.translate = function (t, e, i) { s.setPosition(t, r.add(t.position, e), i) }, s.rotate = function (t, e, i, n) { if (i) { const r = Math.cos(e); const o = Math.sin(e); const a = t.position.x - i.x; const h = t.position.y - i.y; s.setPosition(t, { x: i.x + (a * r - h * o), y: i.y + (a * o + h * r) }, n), s.setAngle(t, t.angle + e, n) } else s.setAngle(t, t.angle + e, n) }, s.scale = function (t, e, i, r) { let o = 0; let a = 0; r = r || t.position; for (var u = t.inertia === 1 / 0, c = 0; c < t.parts.length; c++) { const d = t.parts[c]; d.scale.x = e, d.scale.y = i, n.scale(d.vertices, e, i, r), d.axes = l.fromVertices(d.vertices), d.area = n.area(d.vertices), s.setMass(d, t.density * d.area), n.translate(d.vertices, { x: -d.position.x, y: -d.position.y }), s.setInertia(d, s._inertiaScale * n.inertia(d.vertices, d.mass)), n.translate(d.vertices, { x: d.position.x, y: d.position.y }), c > 0 && (o += d.area, a += d.inertia), d.position.x = r.x + (d.position.x - r.x) * e, d.position.y = r.y + (d.position.y - r.y) * i, h.update(d.bounds, d.vertices, t.velocity) } t.parts.length > 1 && (t.area = o, t.isStatic || (s.setMass(t, t.density * o), s.setInertia(t, a))), t.circleRadius && (e === i ? t.circleRadius *= e : t.circleRadius = null), u && s.setInertia(t, 1 / 0) }, s.update = function (t, e) { const i = (e = (void 0 !== e ? e : 1e3 / 60) * t.timeScale) * e; const o = s._timeCorrection ? e / (t.deltaTime || e) : 1; const u = 1 - t.frictionAir * (e / a._baseDelta); const c = (t.position.x - t.positionPrev.x) * o; const d = (t.position.y - t.positionPrev.y) * o; t.velocity.x = c * u + t.force.x / t.mass * i, t.velocity.y = d * u + t.force.y / t.mass * i, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.deltaTime = e, t.angularVelocity = (t.angle - t.anglePrev) * u * o + t.torque / t.inertia * i, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = r.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity); for (let f = 0; f < t.parts.length; f++) { const p = t.parts[f]; n.translate(p.vertices, t.velocity), f > 0 && (p.position.x += t.velocity.x, p.position.y += t.velocity.y), t.angularVelocity !== 0 && (n.rotate(p.vertices, t.angularVelocity, t.position), l.rotate(p.axes, t.angularVelocity), f > 0 && r.rotateAbout(p.position, t.angularVelocity, t.position, p.position)), h.update(p.bounds, p.vertices, t.velocity) } }, s.updateVelocities = function (t) { const e = s._baseDelta / t.deltaTime; const i = t.velocity; i.x = (t.position.x - t.positionPrev.x) * e, i.y = (t.position.y - t.positionPrev.y) * e, t.speed = Math.sqrt(i.x * i.x + i.y * i.y), t.angularVelocity = (t.angle - t.anglePrev) * e, t.angularSpeed = Math.abs(t.angularVelocity) }, s.applyForce = function (t, e, i) { const s = e.x - t.position.x; const n = e.y - t.position.y; t.force.x += i.x, t.force.y += i.y, t.torque += s * i.y - n * i.x }, s._totalProperties = function (t) { for (var e = { mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 } }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { const s = t.parts[i]; const n = s.mass !== 1 / 0 ? s.mass : 1; e.mass += n, e.area += s.area, e.inertia += s.inertia, e.centre = r.add(e.centre, r.mult(s.position, n)) } return e.centre = r.div(e.centre, e.mass), e } }()) }, 69351: (t, e, i) => { const s = {}; t.exports = s; const n = i(35810); const r = i(53402); const o = i(15647); const a = i(22562); s.create = function (t) { return r.extend({ id: r.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {}, cache: { allBodies: null, allConstraints: null, allComposites: null } }, t) }, s.setModified = function (t, e, i, r) { if (n.trigger(t, 'compositeModified', t), t.isModified = e, e && t.cache && (t.cache.allBodies = null, t.cache.allConstraints = null, t.cache.allComposites = null), i && t.parent && s.setModified(t.parent, e, i, r), r) for (let o = 0; o < t.composites.length; o++) { const a = t.composites[o]; s.setModified(a, e, i, r) } }, s.add = function (t, e) { const i = [].concat(e); n.trigger(t, 'beforeAdd', { object: e }); for (let o = 0; o < i.length; o++) { const a = i[o]; switch (a.type) { case 'body': if (a.parent !== a) { r.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break } s.addBody(t, a); break; case 'constraint': s.addConstraint(t, a); break; case 'composite': s.addComposite(t, a); break; case 'mouseConstraint': s.addConstraint(t, a.constraint) } } return n.trigger(t, 'afterAdd', { object: e }), t }, s.remove = function (t, e, i) { const r = [].concat(e); n.trigger(t, 'beforeRemove', { object: e }); for (let o = 0; o < r.length; o++) { const a = r[o]; switch (a.type) { case 'body': s.removeBody(t, a, i); break; case 'constraint': s.removeConstraint(t, a, i); break; case 'composite': s.removeComposite(t, a, i); break; case 'mouseConstraint': s.removeConstraint(t, a.constraint) } } return n.trigger(t, 'afterRemove', { object: e }), t }, s.addComposite = function (t, e) { return t.composites.push(e), e.parent = t, s.setModified(t, !0, !0, !1), t }, s.removeComposite = function (t, e, i) { const n = r.indexOf(t.composites, e); if (n !== -1 && s.removeCompositeAt(t, n), i) for (let o = 0; o < t.composites.length; o++)s.removeComposite(t.composites[o], e, !0); return t }, s.removeCompositeAt = function (t, e) { return t.composites.splice(e, 1), s.setModified(t, !0, !0, !1), t }, s.addBody = function (t, e) { return t.bodies.push(e), s.setModified(t, !0, !0, !1), t }, s.removeBody = function (t, e, i) { const n = r.indexOf(t.bodies, e); if (n !== -1 && s.removeBodyAt(t, n), i) for (let o = 0; o < t.composites.length; o++)s.removeBody(t.composites[o], e, !0); return t }, s.removeBodyAt = function (t, e) { return t.bodies.splice(e, 1), s.setModified(t, !0, !0, !1), t }, s.addConstraint = function (t, e) { return t.constraints.push(e), s.setModified(t, !0, !0, !1), t }, s.removeConstraint = function (t, e, i) { const n = r.indexOf(t.constraints, e); if (n !== -1 && s.removeConstraintAt(t, n), i) for (let o = 0; o < t.composites.length; o++)s.removeConstraint(t.composites[o], e, !0); return t }, s.removeConstraintAt = function (t, e) { return t.constraints.splice(e, 1), s.setModified(t, !0, !0, !1), t }, s.clear = function (t, e, i) { if (i) for (let n = 0; n < t.composites.length; n++)s.clear(t.composites[n], e, !0); return e ? t.bodies = t.bodies.filter(function (t) { return t.isStatic }) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, s.setModified(t, !0, !0, !1), t }, s.allBodies = function (t) { if (t.cache && t.cache.allBodies) return t.cache.allBodies; for (var e = [].concat(t.bodies), i = 0; i < t.composites.length; i++)e = e.concat(s.allBodies(t.composites[i])); return t.cache && (t.cache.allBodies = e), e }, s.allConstraints = function (t) { if (t.cache && t.cache.allConstraints) return t.cache.allConstraints; for (var e = [].concat(t.constraints), i = 0; i < t.composites.length; i++)e = e.concat(s.allConstraints(t.composites[i])); return t.cache && (t.cache.allConstraints = e), e }, s.allComposites = function (t) { if (t.cache && t.cache.allComposites) return t.cache.allComposites; for (var e = [].concat(t.composites), i = 0; i < t.composites.length; i++)e = e.concat(s.allComposites(t.composites[i])); return t.cache && (t.cache.allComposites = e), e }, s.get = function (t, e, i) { let n, r; switch (i) { case 'body': n = s.allBodies(t); break; case 'constraint': n = s.allConstraints(t); break; case 'composite': n = s.allComposites(t).concat(t) } return n ? (r = n.filter(function (t) { return t.id.toString() === e.toString() })).length === 0 ? null : r[0] : null }, s.move = function (t, e, i) { return s.remove(t, e), s.add(i, e), t }, s.rebase = function (t) { for (let e = s.allBodies(t).concat(s.allConstraints(t)).concat(s.allComposites(t)), i = 0; i < e.length; i++)e[i].id = r.nextId(); return t }, s.translate = function (t, e, i) { for (let n = i ? s.allBodies(t) : t.bodies, r = 0; r < n.length; r++)a.translate(n[r], e); return t }, s.rotate = function (t, e, i, n) { for (let r = Math.cos(e), o = Math.sin(e), h = n ? s.allBodies(t) : t.bodies, l = 0; l < h.length; l++) { const u = h[l]; const c = u.position.x - i.x; const d = u.position.y - i.y; a.setPosition(u, { x: i.x + (c * r - d * o), y: i.y + (c * o + d * r) }), a.rotate(u, e) } return t }, s.scale = function (t, e, i, n, r) { for (let o = r ? s.allBodies(t) : t.bodies, h = 0; h < o.length; h++) { const l = o[h]; const u = l.position.x - n.x; const c = l.position.y - n.y; a.setPosition(l, { x: n.x + u * e, y: n.y + c * i }), a.scale(l, e, i) } return t }, s.bounds = function (t) { for (var e = s.allBodies(t), i = [], n = 0; n < e.length; n += 1) { const r = e[n]; i.push(r.bounds.min, r.bounds.max) } return o.create(i) } }, 4372: (t, e, i) => { const s = {}; t.exports = s; const n = i(69351); s.create = n.create, s.add = n.add, s.remove = n.remove, s.clear = n.clear, s.addComposite = n.addComposite, s.addBody = n.addBody, s.addConstraint = n.addConstraint }, 52284: (t, e, i) => { const s = {}; t.exports = s; let n; let r; let o; const a = i(41598); const h = i(4506); n = [], r = { overlap: 0, axis: null }, o = { overlap: 0, axis: null }, s.create = function (t, e) { return { pair: null, collided: !1, bodyA: t, bodyB: e, parentA: t.parent, parentB: e.parent, depth: 0, normal: { x: 0, y: 0 }, tangent: { x: 0, y: 0 }, penetration: { x: 0, y: 0 }, supports: [] } }, s.collides = function (t, e, i) { if (s._overlapAxes(r, t.vertices, e.vertices, t.axes), r.overlap <= 0) return null; if (s._overlapAxes(o, e.vertices, t.vertices, e.axes), o.overlap <= 0) return null; let n; let l; const u = i && i.table[h.id(t, e)]; u ? n = u.collision : ((n = s.create(t, e)).collided = !0, n.bodyA = t.id < e.id ? t : e, n.bodyB = t.id < e.id ? e : t, n.parentA = n.bodyA.parent, n.parentB = n.bodyB.parent), t = n.bodyA, e = n.bodyB, l = r.overlap < o.overlap ? r : o; const c = n.normal; const d = n.supports; const f = l.axis; const p = f.x; const v = f.y; p * (e.position.x - t.position.x) + v * (e.position.y - t.position.y) < 0 ? (c.x = p, c.y = v) : (c.x = -p, c.y = -v), n.tangent.x = -c.y, n.tangent.y = c.x, n.depth = l.overlap, n.penetration.x = c.x * n.depth, n.penetration.y = c.y * n.depth; const g = s._findSupports(t, e, c, 1); let m = 0; if (a.contains(t.vertices, g[0]) && (d[m++] = g[0]), a.contains(t.vertices, g[1]) && (d[m++] = g[1]), m < 2) { const y = s._findSupports(e, t, c, -1); a.contains(e.vertices, y[0]) && (d[m++] = y[0]), m < 2 && a.contains(e.vertices, y[1]) && (d[m++] = y[1]) } return m === 0 && (d[m++] = g[0]), d.length = m, n }, s._overlapAxes = function (t, e, i, s) { let n; let r; let o; let a; let h; let l; const u = e.length; const c = i.length; const d = e[0].x; const f = e[0].y; const p = i[0].x; const v = i[0].y; const g = s.length; let m = Number.MAX_VALUE; let y = 0; for (h = 0; h < g; h++) { const x = s[h]; const T = x.x; const w = x.y; let b = d * T + f * w; let S = p * T + v * w; let E = b; let A = S; for (l = 1; l < u; l += 1)(a = e[l].x * T + e[l].y * w) > E ? E = a : a < b && (b = a); for (l = 1; l < c; l += 1)(a = i[l].x * T + i[l].y * w) > A ? A = a : a < S && (S = a); if ((n = (r = E - S) < (o = A - b) ? r : o) < m && (m = n, y = h, n <= 0)) break } t.axis = s[y], t.overlap = m }, s._projectToAxis = function (t, e, i) { for (var s = e[0].x * i.x + e[0].y * i.y, n = s, r = 1; r < e.length; r += 1) { const o = e[r].x * i.x + e[r].y * i.y; o > n ? n = o : o < s && (s = o) } t.min = s, t.max = n }, s._findSupports = function (t, e, i, s) { let r; let o; let a; let h; let l; const u = e.vertices; const c = u.length; const d = t.position.x; const f = t.position.y; const p = i.x * s; const v = i.y * s; let g = Number.MAX_VALUE; for (l = 0; l < c; l += 1)(h = p * (d - (o = u[l]).x) + v * (f - o.y)) < g && (g = h, r = o); return g = p * (d - (a = u[(c + r.index - 1) % c]).x) + v * (f - a.y), p * (d - (o = u[(r.index + 1) % c]).x) + v * (f - o.y) < g ? (n[0] = r, n[1] = o, n) : (n[0] = r, n[1] = a, n) } }, 43424: t => { const e = {}; t.exports = e, e.create = function (t) { return { vertex: t, normalImpulse: 0, tangentImpulse: 0 } } }, 81388: (t, e, i) => { const s = {}; t.exports = s; const n = i(53402); const r = i(52284); s.create = function (t) { return n.extend({ bodies: [], pairs: null }, t) }, s.setBodies = function (t, e) { t.bodies = e.slice(0) }, s.clear = function (t) { t.bodies = [] }, s.collisions = function (t) { let e; let i; const n = []; const o = t.pairs; const a = t.bodies; const h = a.length; const l = s.canCollide; const u = r.collides; for (a.sort(s._compareBoundsX), e = 0; e < h; e++) { const c = a[e]; let d = c.bounds; const f = c.bounds.max.x; const p = c.bounds.max.y; const v = c.bounds.min.y; const g = c.isStatic || c.isSleeping; const m = c.parts.length; const y = m === 1; for (i = e + 1; i < h; i++) { const x = a[i]; if ((_ = x.bounds).min.x > f) break; if (!(p < _.min.y || v > _.max.y) && (!g || !x.isStatic && !x.isSleeping) && l(c.collisionFilter, x.collisionFilter)) { const T = x.parts.length; if (y && T === 1) (A = u(c, x, o)) && n.push(A); else for (let w = T > 1 ? 1 : 0, b = m > 1 ? 1 : 0; b < m; b++) for (let S = c.parts[b], E = (d = S.bounds, w); E < T; E++) { var A; const C = x.parts[E]; var _ = C.bounds; d.min.x > _.max.x || d.max.x < _.min.x || d.max.y < _.min.y || d.min.y > _.max.y || (A = u(S, C, o)) && n.push(A) } } } } return n }, s.canCollide = function (t, e) { return t.group === e.group && t.group !== 0 ? t.group > 0 : (t.mask & e.category) != 0 && (e.mask & t.category) != 0 }, s._compareBoundsX = function (t, e) { return t.bounds.min.x - e.bounds.min.x } }, 4506: (t, e, i) => { const s = {}; t.exports = s; const n = i(43424); s.create = function (t, e) { const i = t.bodyA; const n = t.bodyB; const r = { id: s.id(i, n), bodyA: i, bodyB: n, collision: t, contacts: [], activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: i.isSensor || n.isSensor, timeCreated: e, timeUpdated: e, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0 }; return s.update(r, t, e), r }, s.update = function (t, e, i) { const s = t.contacts; const r = e.supports; const o = t.activeContacts; const a = e.parentA; const h = e.parentB; const l = a.vertices.length; t.isActive = !0, t.timeUpdated = i, t.collision = e, t.separation = e.depth, t.inverseMass = a.inverseMass + h.inverseMass, t.friction = a.friction < h.friction ? a.friction : h.friction, t.frictionStatic = a.frictionStatic > h.frictionStatic ? a.frictionStatic : h.frictionStatic, t.restitution = a.restitution > h.restitution ? a.restitution : h.restitution, t.slop = a.slop > h.slop ? a.slop : h.slop, e.pair = t, o.length = 0; for (let u = 0; u < r.length; u++) { const c = r[u]; const d = c.body === a ? c.index : l + c.index; const f = s[d]; f ? o.push(f) : o.push(s[d] = n.create(c)) } }, s.setActive = function (t, e, i) { e ? (t.isActive = !0, t.timeUpdated = i) : (t.isActive = !1, t.activeContacts.length = 0) }, s.id = function (t, e) { return t.id < e.id ? 'A' + t.id + 'B' + e.id : 'A' + e.id + 'B' + t.id } }, 99561: (t, e, i) => { const s = {}; t.exports = s; const n = i(4506); const r = i(53402); s.create = function (t) { return r.extend({ table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [] }, t) }, s.update = function (t, e, i) { let s; let r; let o; let a; const h = t.list; let l = h.length; const u = t.table; const c = e.length; const d = t.collisionStart; const f = t.collisionEnd; const p = t.collisionActive; for (d.length = 0, f.length = 0, p.length = 0, a = 0; a < l; a++)h[a].confirmedActive = !1; for (a = 0; a < c; a++)(o = (s = e[a]).pair) ? (o.isActive ? p.push(o) : d.push(o), n.update(o, s, i), o.confirmedActive = !0) : (u[(o = n.create(s, i)).id] = o, d.push(o), h.push(o)); const v = []; for (l = h.length, a = 0; a < l; a++)(o = h[a]).confirmedActive || (n.setActive(o, !1, i), f.push(o), o.collision.bodyA.isSleeping || o.collision.bodyB.isSleeping || v.push(a)); for (a = 0; a < v.length; a++)o = h[r = v[a] - a], h.splice(r, 1), delete u[o.id] }, s.clear = function (t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t } }, 73296: (t, e, i) => { const s = {}; t.exports = s; const n = i(31725); const r = i(52284); const o = i(15647); const a = i(66280); const h = i(41598); s.collides = function (t, e) { for (var i = [], s = e.length, n = t.bounds, a = r.collides, h = o.overlaps, l = 0; l < s; l++) { const u = e[l]; const c = u.parts.length; const d = c === 1 ? 0 : 1; if (t !== u && h(u.bounds, n)) for (let f = d; f < c; f++) { const p = u.parts[f]; if (h(p.bounds, n)) { const v = a(p, t); if (v) { i.push(v); break } } } } return i }, s.ray = function (t, e, i, r) { r = r || 1e-100; for (var o = n.angle(e, i), h = n.magnitude(n.sub(e, i)), l = 0.5 * (i.x + e.x), u = 0.5 * (i.y + e.y), c = a.rectangle(l, u, h, r, { angle: o }), d = s.collides(c, t), f = 0; f < d.length; f += 1) { const p = d[f]; p.body = p.bodyB = p.bodyA } return d }, s.region = function (t, e, i) { for (var s = [], n = 0; n < t.length; n++) { const r = t[n]; const a = o.overlaps(r.bounds, e); (a && !i || !a && i) && s.push(r) } return s }, s.point = function (t, e) { for (var i = [], s = 0; s < t.length; s++) { const n = t[s]; if (o.contains(n.bounds, e)) for (let r = n.parts.length === 1 ? 0 : 1; r < n.parts.length; r++) { const a = n.parts[r]; if (o.contains(a.bounds, e) && h.contains(a.vertices, e)) { i.push(n); break } } } return i } }, 66272: (t, e, i) => { const s = {}; t.exports = s; const n = i(41598); const r = i(53402); const o = i(15647); s._restingThresh = 2, s._restingThreshTangent = Math.sqrt(6), s._positionDampen = 0.9, s._positionWarming = 0.8, s._frictionNormalMultiplier = 5, s._frictionMaxStatic = Number.MAX_VALUE, s.preSolvePosition = function (t) { let e; let i; let s; const n = t.length; for (e = 0; e < n; e++)(i = t[e]).isActive && (s = i.activeContacts.length, i.collision.parentA.totalContacts += s, i.collision.parentB.totalContacts += s) }, s.solvePosition = function (t, e, i) { let n; let o; let a; let h; let l; let u; let c; let d; const f = s._positionDampen * (i || 1); const p = r.clamp(e / r._baseDelta, 0, 1); const v = t.length; for (n = 0; n < v; n++)(o = t[n]).isActive && !o.isSensor && (h = (a = o.collision).parentA, l = a.parentB, u = a.normal, o.separation = u.x * (l.positionImpulse.x + a.penetration.x - h.positionImpulse.x) + u.y * (l.positionImpulse.y + a.penetration.y - h.positionImpulse.y)); for (n = 0; n < v; n++)(o = t[n]).isActive && !o.isSensor && (h = (a = o.collision).parentA, l = a.parentB, u = a.normal, d = o.separation - o.slop * p, (h.isStatic || l.isStatic) && (d *= 2), h.isStatic || h.isSleeping || (c = f / h.totalContacts, h.positionImpulse.x += u.x * d * c, h.positionImpulse.y += u.y * d * c), l.isStatic || l.isSleeping || (c = f / l.totalContacts, l.positionImpulse.x -= u.x * d * c, l.positionImpulse.y -= u.y * d * c)) }, s.postSolvePosition = function (t) { for (let e = s._positionWarming, i = t.length, r = n.translate, a = o.update, h = 0; h < i; h++) { const l = t[h]; const u = l.positionImpulse; const c = u.x; const d = u.y; const f = l.velocity; if (l.totalContacts = 0, c !== 0 || d !== 0) { for (let p = 0; p < l.parts.length; p++) { const v = l.parts[p]; r(v.vertices, u), a(v.bounds, v.vertices, f), v.position.x += c, v.position.y += d } l.positionPrev.x += c, l.positionPrev.y += d, c * f.x + d * f.y < 0 ? (u.x = 0, u.y = 0) : (u.x *= e, u.y *= e) } } }, s.preSolveVelocity = function (t) { let e; let i; const s = t.length; for (e = 0; e < s; e++) { const n = t[e]; if (n.isActive && !n.isSensor) { const r = n.activeContacts; const o = r.length; const a = n.collision; const h = a.parentA; const l = a.parentB; const u = a.normal; const c = a.tangent; for (i = 0; i < o; i++) { const d = r[i]; const f = d.vertex; const p = d.normalImpulse; const v = d.tangentImpulse; if (p !== 0 || v !== 0) { const g = u.x * p + c.x * v; const m = u.y * p + c.y * v; h.isStatic || h.isSleeping || (h.positionPrev.x += g * h.inverseMass, h.positionPrev.y += m * h.inverseMass, h.anglePrev += h.inverseInertia * ((f.x - h.position.x) * m - (f.y - h.position.y) * g)), l.isStatic || l.isSleeping || (l.positionPrev.x -= g * l.inverseMass, l.positionPrev.y -= m * l.inverseMass, l.anglePrev -= l.inverseInertia * ((f.x - l.position.x) * m - (f.y - l.position.y) * g)) } } } } }, s.solveVelocity = function (t, e) { let i; let n; let o; let a; const h = e / r._baseDelta; const l = h * h * h; const u = -s._restingThresh * h; const c = s._restingThreshTangent; const d = s._frictionNormalMultiplier * h; const f = s._frictionMaxStatic; const p = t.length; for (o = 0; o < p; o++) { const v = t[o]; if (v.isActive && !v.isSensor) { const g = v.collision; const m = g.parentA; const y = g.parentB; const x = m.velocity; const T = y.velocity; const w = g.normal.x; const b = g.normal.y; const S = g.tangent.x; const E = g.tangent.y; const A = v.activeContacts; const C = A.length; const _ = 1 / C; const M = m.inverseMass + y.inverseMass; const P = v.friction * v.frictionStatic * d; for (x.x = m.position.x - m.positionPrev.x, x.y = m.position.y - m.positionPrev.y, T.x = y.position.x - y.positionPrev.x, T.y = y.position.y - y.positionPrev.y, m.angularVelocity = m.angle - m.anglePrev, y.angularVelocity = y.angle - y.anglePrev, a = 0; a < C; a++) { const R = A[a]; const L = R.vertex; const O = L.x - m.position.x; const F = L.y - m.position.y; const D = L.x - y.position.x; const k = L.y - y.position.y; const I = x.x - F * m.angularVelocity; const B = x.y + O * m.angularVelocity; const N = I - (T.x - k * y.angularVelocity); const U = B - (T.y + D * y.angularVelocity); const X = w * N + b * U; const Y = S * N + E * U; const z = v.separation + X; let G = Math.min(z, 1); const V = (G = z < 0 ? 0 : G) * P; Y < -V || Y > V ? (n = Y > 0 ? Y : -Y, (i = v.friction * (Y > 0 ? 1 : -1) * l) < -n ? i = -n : i > n && (i = n)) : (i = Y, n = f); const W = O * b - F * w; const H = D * b - k * w; const j = _ / (M + m.inverseInertia * W * W + y.inverseInertia * H * H); let q = (1 + v.restitution) * X * j; if (i *= j, X < u) R.normalImpulse = 0; else { const K = R.normalImpulse; R.normalImpulse += q, R.normalImpulse > 0 && (R.normalImpulse = 0), q = R.normalImpulse - K } if (Y < -c || Y > c) R.tangentImpulse = 0; else { const Z = R.tangentImpulse; R.tangentImpulse += i, R.tangentImpulse < -n && (R.tangentImpulse = -n), R.tangentImpulse > n && (R.tangentImpulse = n), i = R.tangentImpulse - Z } const J = w * q + S * i; const Q = b * q + E * i; m.isStatic || m.isSleeping || (m.positionPrev.x += J * m.inverseMass, m.positionPrev.y += Q * m.inverseMass, m.anglePrev += (O * Q - F * J) * m.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= J * y.inverseMass, y.positionPrev.y -= Q * y.inverseMass, y.anglePrev -= (D * Q - k * J) * y.inverseInertia) } } } } }, 48140: (t, e, i) => { const s = {}; t.exports = s; const n = i(41598); const r = i(31725); const o = i(53614); const a = i(15647); const h = i(66615); const l = i(53402); s._warming = 0.4, s._torqueDampen = 1, s._minLength = 1e-6, s.create = function (t) { const e = t; e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 }); const i = e.bodyA ? r.add(e.bodyA.position, e.pointA) : e.pointA; const s = e.bodyB ? r.add(e.bodyB.position, e.pointB) : e.pointB; const n = r.magnitude(r.sub(i, s)); e.length = void 0 !== e.length ? e.length : n, e.id = e.id || l.nextId(), e.label = e.label || 'Constraint', e.type = 'constraint', e.stiffness = e.stiffness || (e.length > 0 ? 1 : 0.7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {}; const o = { visible: !0, type: 'line', anchors: !0, lineColor: null, lineOpacity: null, lineThickness: null, pinSize: null, anchorColor: null, anchorSize: null }; return e.length === 0 && e.stiffness > 0.1 ? (o.type = 'pin', o.anchors = !1) : e.stiffness < 0.9 && (o.type = 'spring'), e.render = l.extend(o, e.render), e }, s.preSolveAll = function (t) { for (let e = 0; e < t.length; e += 1) { const i = t[e]; const s = i.constraintImpulse; i.isStatic || s.x === 0 && s.y === 0 && s.angle === 0 || (i.position.x += s.x, i.position.y += s.y, i.angle += s.angle) } }, s.solveAll = function (t, e) { for (var i = l.clamp(e / l._baseDelta, 0, 1), n = 0; n < t.length; n += 1) { var r = t[n]; var o = !r.bodyA || r.bodyA && r.bodyA.isStatic; var a = !r.bodyB || r.bodyB && r.bodyB.isStatic; (o || a) && s.solve(t[n], i) } for (n = 0; n < t.length; n += 1)o = !(r = t[n]).bodyA || r.bodyA && r.bodyA.isStatic, a = !r.bodyB || r.bodyB && r.bodyB.isStatic, o || a || s.solve(t[n], i) }, s.solve = function (t, e) { const i = t.bodyA; const n = t.bodyB; const o = t.pointA; const a = t.pointB; if (i || n) { i && !i.isStatic && (r.rotate(o, i.angle - t.angleA, o), t.angleA = i.angle), n && !n.isStatic && (r.rotate(a, n.angle - t.angleB, a), t.angleB = n.angle); let h = o; let l = a; if (i && (h = r.add(i.position, o)), n && (l = r.add(n.position, a)), h && l) { const u = r.sub(h, l); let c = r.magnitude(u); c < s._minLength && (c = s._minLength); let d; let f; let p; let v; let g; const m = (c - t.length) / c; const y = t.stiffness >= 1 || t.length === 0 ? t.stiffness * e : t.stiffness * e * e; const x = t.damping * e; const T = r.mult(u, m * y); const w = (i ? i.inverseMass : 0) + (n ? n.inverseMass : 0); const b = w + ((i ? i.inverseInertia : 0) + (n ? n.inverseInertia : 0)); if (x > 0) { const S = r.create(); p = r.div(u, c), g = r.sub(n && r.sub(n.position, n.positionPrev) || S, i && r.sub(i.position, i.positionPrev) || S), v = r.dot(p, g) } i && !i.isStatic && (f = i.inverseMass / w, i.constraintImpulse.x -= T.x * f, i.constraintImpulse.y -= T.y * f, i.position.x -= T.x * f, i.position.y -= T.y * f, x > 0 && (i.positionPrev.x -= x * p.x * v * f, i.positionPrev.y -= x * p.y * v * f), d = r.cross(o, T) / b * s._torqueDampen * i.inverseInertia * (1 - t.angularStiffness), i.constraintImpulse.angle -= d, i.angle -= d), n && !n.isStatic && (f = n.inverseMass / w, n.constraintImpulse.x += T.x * f, n.constraintImpulse.y += T.y * f, n.position.x += T.x * f, n.position.y += T.y * f, x > 0 && (n.positionPrev.x += x * p.x * v * f, n.positionPrev.y += x * p.y * v * f), d = r.cross(a, T) / b * s._torqueDampen * n.inverseInertia * (1 - t.angularStiffness), n.constraintImpulse.angle += d, n.angle += d) } } }, s.postSolveAll = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; const l = i.constraintImpulse; if (!(i.isStatic || l.x === 0 && l.y === 0 && l.angle === 0)) { o.set(i, !1); for (let u = 0; u < i.parts.length; u++) { const c = i.parts[u]; n.translate(c.vertices, l), u > 0 && (c.position.x += l.x, c.position.y += l.y), l.angle !== 0 && (n.rotate(c.vertices, l.angle, i.position), h.rotate(c.axes, l.angle), u > 0 && r.rotateAbout(c.position, l.angle, i.position, c.position)), a.update(c.bounds, c.vertices, i.velocity) } l.angle *= s._warming, l.x *= s._warming, l.y *= s._warming } } }, s.pointAWorld = function (t) { return { x: (t.bodyA ? t.bodyA.position.x : 0) + (t.pointA ? t.pointA.x : 0), y: (t.bodyA ? t.bodyA.position.y : 0) + (t.pointA ? t.pointA.y : 0) } }, s.pointBWorld = function (t) { return { x: (t.bodyB ? t.bodyB.position.x : 0) + (t.pointB ? t.pointB.x : 0), y: (t.bodyB ? t.bodyB.position.y : 0) + (t.pointB ? t.pointB.y : 0) } }, s.currentLength = function (t) { const e = (t.bodyA ? t.bodyA.position.x : 0) + (t.pointA ? t.pointA.x : 0); const i = (t.bodyA ? t.bodyA.position.y : 0) + (t.pointA ? t.pointA.y : 0); const s = e - ((t.bodyB ? t.bodyB.position.x : 0) + (t.pointB ? t.pointB.x : 0)); const n = i - ((t.bodyB ? t.bodyB.position.y : 0) + (t.pointB ? t.pointB.y : 0)); return Math.sqrt(s * s + n * n) } }, 53402: (t, e, i) => { const s = {}; t.exports = s, (function () { s._baseDelta = 1e3 / 60, s._nextId = 0, s._seed = 0, s._nowStartTime = +new Date(), s._warnedOnce = {}, s._decomp = null, s.extend = function (t, e) { let i, n; typeof e === 'boolean' ? (i = 2, n = e) : (i = 1, n = !0); for (let r = i; r < arguments.length; r++) { const o = arguments[r]; if (o) for (const a in o) n && o[a] && o[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = o[a] : (t[a] = t[a] || {}, s.extend(t[a], n, o[a])) : t[a] = o[a] } return t }, s.clone = function (t, e) { return s.extend({}, e, t) }, s.keys = function (t) { if (Object.keys) return Object.keys(t); const e = []; for (const i in t) e.push(i); return e }, s.values = function (t) { const e = []; if (Object.keys) { for (let i = Object.keys(t), s = 0; s < i.length; s++)e.push(t[i[s]]); return e } for (const n in t) e.push(t[n]); return e }, s.get = function (t, e, i, s) { e = e.split('.').slice(i, s); for (let n = 0; n < e.length; n += 1)t = t[e[n]]; return t }, s.set = function (t, e, i, n, r) { const o = e.split('.').slice(n, r); return s.get(t, e, 0, -1)[o[o.length - 1]] = i, i }, s.shuffle = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(s.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n } return t }, s.choose = function (t) { return t[Math.floor(s.random() * t.length)] }, s.isElement = function (t) { return typeof HTMLElement !== 'undefined' ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName) }, s.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]' }, s.isFunction = function (t) { return typeof t === 'function' }, s.isPlainObject = function (t) { return typeof t === 'object' && t.constructor === Object }, s.isString = function (t) { return toString.call(t) === '[object String]' }, s.clamp = function (t, e, i) { return t < e ? e : t > i ? i : t }, s.sign = function (t) { return t < 0 ? -1 : 1 }, s.now = function () { if (typeof window !== 'undefined' && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow() } return Date.now ? Date.now() : new Date() - s._nowStartTime }, s.random = function (e, i) { return i = void 0 !== i ? i : 1, (e = void 0 !== e ? e : 0) + t() * (i - e) }; var t = function () { return s._seed = (9301 * s._seed + 49297) % 233280, s._seed / 233280 }; s.colorToNumber = function (t) { return (t = t.replace('#', '')).length == 3 && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16) }, s.logLevel = 1, s.log = function () { console && s.logLevel > 0 && s.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, s.info = function () { console && s.logLevel > 0 && s.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, s.warn = function () { console && s.logLevel > 0 && s.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))) }, s.warnOnce = function () { const t = Array.prototype.slice.call(arguments).join(' '); s._warnedOnce[t] || (s.warn(t), s._warnedOnce[t] = !0) }, s.deprecated = function (t, e, i) { t[e] = s.chain(function () { s.warnOnce(' deprecated ', i) }, t[e]) }, s.nextId = function () { return s._nextId++ }, s.indexOf = function (t, e) { if (t.indexOf) return t.indexOf(e); for (let i = 0; i < t.length; i++) if (t[i] === e) return i; return -1 }, s.map = function (t, e) { if (t.map) return t.map(e); for (var i = [], s = 0; s < t.length; s += 1)i.push(e(t[s])); return i }, s.topologicalSort = function (t) { const e = []; const i = []; const n = []; for (const r in t) i[r] || n[r] || s._topologicalSort(r, i, n, t, e); return e }, s._topologicalSort = function (t, e, i, n, r) { const o = n[t] || []; i[t] = !0; for (let a = 0; a < o.length; a += 1) { const h = o[a]; i[h] || (e[h] || s._topologicalSort(h, e, i, n, r)) } i[t] = !1, e[t] = !0, r.push(t) }, s.chain = function () { for (var t = [], e = 0; e < arguments.length; e += 1) { const i = arguments[e]; i._chained ? t.push.apply(t, i._chained) : t.push(i) } const s = function () { for (var e, i = new Array(arguments.length), s = 0, n = arguments.length; s < n; s++)i[s] = arguments[s]; for (s = 0; s < t.length; s += 1) { const r = t[s].apply(e, i); void 0 !== r && (e = r) } return e }; return s._chained = t, s }, s.chainPathBefore = function (t, e, i) { return s.set(t, e, s.chain(i, s.get(t, e))) }, s.chainPathAfter = function (t, e, i) { return s.set(t, e, s.chain(s.get(t, e), i)) }, s.setDecomp = function (t) { s._decomp = t }, s.getDecomp = function () { let t = s._decomp; try { t || typeof window === 'undefined' || (t = window.decomp), t || void 0 === i.g || (t = i.g.decomp) } catch (e) { t = null } return t } }()) }, 48413: (t, e, i) => { const s = {}; t.exports = s; const n = i(53614); const r = i(66272); const o = i(81388); const a = i(99561); const h = i(35810); const l = i(69351); const u = i(48140); const c = i(53402); const d = i(22562); s.create = function (t) { t = t || {}; const e = c.extend({ positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, gravity: { x: 0, y: 1, scale: 0.001 }, timing: { timestamp: 0, timeScale: 1, lastDelta: 0, lastElapsed: 0 } }, t); return e.world = t.world || l.create({ label: 'World' }), e.pairs = t.pairs || a.create(), e.detector = t.detector || o.create(), e.grid = { buckets: [] }, e.world.gravity = e.gravity, e.broadphase = e.grid, e.metrics = {}, e }, s.update = function (t, e) { let i; const d = c.now(); const f = t.world; const p = t.detector; const v = t.pairs; const g = t.timing; const m = g.timestamp; e = void 0 !== e ? e : c._baseDelta, e *= g.timeScale, g.timestamp += e, g.lastDelta = e; const y = { timestamp: g.timestamp, delta: e }; h.trigger(t, 'beforeUpdate', y); const x = l.allBodies(f); const T = l.allConstraints(f); for (f.isModified && (o.setBodies(p, x), l.setModified(f, !1, !1, !0)), t.enableSleeping && n.update(x, e), s._bodiesApplyGravity(x, t.gravity), e > 0 && s._bodiesUpdate(x, e), h.trigger(t, 'beforeSolve', y), u.preSolveAll(x), i = 0; i < t.constraintIterations; i++)u.solveAll(T, e); u.postSolveAll(x), p.pairs = t.pairs; const w = o.collisions(p); a.update(v, w, m), t.enableSleeping && n.afterCollisions(v.list), v.collisionStart.length > 0 && h.trigger(t, 'collisionStart', { pairs: v.collisionStart, timestamp: g.timestamp, delta: e }); const b = c.clamp(20 / t.positionIterations, 0, 1); for (r.preSolvePosition(v.list), i = 0; i < t.positionIterations; i++)r.solvePosition(v.list, e, b); for (r.postSolvePosition(x), u.preSolveAll(x), i = 0; i < t.constraintIterations; i++)u.solveAll(T, e); for (u.postSolveAll(x), r.preSolveVelocity(v.list), i = 0; i < t.velocityIterations; i++)r.solveVelocity(v.list, e); return s._bodiesUpdateVelocities(x), v.collisionActive.length > 0 && h.trigger(t, 'collisionActive', { pairs: v.collisionActive, timestamp: g.timestamp, delta: e }), v.collisionEnd.length > 0 && h.trigger(t, 'collisionEnd', { pairs: v.collisionEnd, timestamp: g.timestamp, delta: e }), s._bodiesClearForces(x), h.trigger(t, 'afterUpdate', y), t.timing.lastElapsed = c.now() - d, t }, s.merge = function (t, e) { if (c.extend(t, e), e.world) { t.world = e.world, s.clear(t); for (let i = l.allBodies(t.world), r = 0; r < i.length; r++) { const o = i[r]; n.set(o, !1), o.id = c.nextId() } } }, s.clear = function (t) { a.clear(t.pairs), o.clear(t.detector) }, s._bodiesClearForces = function (t) { for (let e = t.length, i = 0; i < e; i++) { const s = t[i]; s.force.x = 0, s.force.y = 0, s.torque = 0 } }, s._bodiesApplyGravity = function (t, e) { const i = void 0 !== e.scale ? e.scale : 0.001; const s = t.length; if ((e.x !== 0 || e.y !== 0) && i !== 0) for (let n = 0; n < s; n++) { const r = t[n]; r.ignoreGravity || r.isStatic || r.isSleeping || (r.force.y += r.mass * e.y * i, r.force.x += r.mass * e.x * i) } }, s._bodiesUpdate = function (t, e) { for (let i = t.length, s = 0; s < i; s++) { const n = t[s]; n.isStatic || n.isSleeping || d.update(n, e) } }, s._bodiesUpdateVelocities = function (t) { for (let e = t.length, i = 0; i < e; i++)d.updateVelocities(t[i]) } }, 35810: (t, e, i) => { const s = {}; t.exports = s; const n = i(53402); s.on = function (t, e, i) { for (var s, n = e.split(' '), r = 0; r < n.length; r++)s = n[r], t.events = t.events || {}, t.events[s] = t.events[s] || [], t.events[s].push(i); return i }, s.off = function (t, e, i) { if (e) { typeof e === 'function' && (i = e, e = n.keys(t.events).join(' ')); for (let s = e.split(' '), r = 0; r < s.length; r++) { const o = t.events[s[r]]; const a = []; if (i && o) for (let h = 0; h < o.length; h++)o[h] !== i && a.push(o[h]); t.events[s[r]] = a } } else t.events = {} }, s.trigger = function (t, e, i) { let s; let r; let o; let a; const h = t.events; if (h && n.keys(h).length > 0) { i || (i = {}), s = e.split(' '); for (let l = 0; l < s.length; l++) if (o = h[r = s[l]]) { (a = n.clone(i, !1)).name = r, a.source = t; for (let u = 0; u < o.length; u++)o[u].apply(t, [a]) } } } }, 6790: (t, e, i) => { const s = {}; t.exports = s; const n = i(73832); const r = i(53402); s.name = 'matter-js', s.version = '0.19.0', s.uses = [], s.used = [], s.use = function () { n.use(s, Array.prototype.slice.call(arguments)) }, s.before = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathBefore(s, t, e) }, s.after = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathAfter(s, t, e) } }, 73832: (t, e, i) => { const s = {}; t.exports = s; const n = i(53402); s._registry = {}, s.register = function (t) { if (s.isPlugin(t) || n.warn('Plugin.register:', s.toString(t), 'does not implement all required fields.'), t.name in s._registry) { const e = s._registry[t.name]; const i = s.versionParse(t.version).number; const r = s.versionParse(e.version).number; i > r ? (n.warn('Plugin.register:', s.toString(e), 'was upgraded to', s.toString(t)), s._registry[t.name] = t) : i < r ? n.warn('Plugin.register:', s.toString(e), 'can not be downgraded to', s.toString(t)) : t !== e && n.warn('Plugin.register:', s.toString(t), 'is already registered to different plugin object') } else s._registry[t.name] = t; return t }, s.resolve = function (t) { return s._registry[s.dependencyParse(t).name] }, s.toString = function (t) { return typeof t === 'string' ? t : (t.name || 'anonymous') + '@' + (t.version || t.range || '0.0.0') }, s.isPlugin = function (t) { return t && t.name && t.version && t.install }, s.isUsed = function (t, e) { return t.used.indexOf(e) > -1 }, s.isFor = function (t, e) { const i = t.for && s.dependencyParse(t.for); return !t.for || e.name === i.name && s.versionSatisfies(e.version, i.range) }, s.use = function (t, e) { if (t.uses = (t.uses || []).concat(e || []), t.uses.length !== 0) { for (var i = s.dependencies(t), r = n.topologicalSort(i), o = [], a = 0; a < r.length; a += 1) if (r[a] !== t.name) { var h = s.resolve(r[a]); h ? s.isUsed(t, h.name) || (s.isFor(h, t) || (n.warn('Plugin.use:', s.toString(h), 'is for', h.for, 'but installed on', s.toString(t) + '.'), h._warned = !0), h.install ? h.install(t) : (n.warn('Plugin.use:', s.toString(h), 'does not specify an install function.'), h._warned = !0), h._warned ? (o.push(' ' + s.toString(h)), delete h._warned) : o.push(' ' + s.toString(h)), t.used.push(h.name)) : o.push(' ' + r[a]) } o.length > 0 && !h.silent && n.info(o.join('  ')) } else n.warn('Plugin.use:', s.toString(t), 'does not specify any dependencies to install.') }, s.dependencies = function (t, e) { const i = s.dependencyParse(t); const r = i.name; if (!(r in (e = e || {}))) { t = s.resolve(t) || t, e[r] = n.map(t.uses || [], function (e) { s.isPlugin(e) && s.register(e); const r = s.dependencyParse(e); const o = s.resolve(e); return o && !s.versionSatisfies(o.version, r.range) ? (n.warn('Plugin.dependencies:', s.toString(o), 'does not satisfy', s.toString(r), 'used by', s.toString(i) + '.'), o._warned = !0, t._warned = !0) : o || (n.warn('Plugin.dependencies:', s.toString(e), 'used by', s.toString(i), 'could not be resolved.'), t._warned = !0), r.name }); for (let o = 0; o < e[r].length; o += 1)s.dependencies(e[r][o], e); return e } }, s.dependencyParse = function (t) { return n.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(t) || n.warn('Plugin.dependencyParse:', t, 'is not a valid dependency string.'), { name: t.split('@')[0], range: t.split('@')[1] || '*' }) : { name: t.name, range: t.range || t.version } }, s.versionParse = function (t) { const e = /^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/; e.test(t) || n.warn('Plugin.versionParse:', t, 'is not a valid version or range.'); const i = e.exec(t); const s = Number(i[4]); const r = Number(i[5]); const o = Number(i[6]); return { isRange: Boolean(i[1] || i[2]), version: i[3], range: t, operator: i[1] || i[2] || '', major: s, minor: r, patch: o, parts: [s, r, o], prerelease: i[7], number: 1e8 * s + 1e4 * r + o } }, s.versionSatisfies = function (t, e) { e = e || '*'; const i = s.versionParse(e); const n = s.versionParse(t); if (i.isRange) { if (i.operator === '*' || t === '*') return !0; if (i.operator === '>') return n.number > i.number; if (i.operator === '>=') return n.number >= i.number; if (i.operator === '~') return n.major === i.major && n.minor === i.minor && n.patch >= i.patch; if (i.operator === '^') return i.major > 0 ? n.major === i.major && n.number >= i.number : i.minor > 0 ? n.minor === i.minor && n.patch >= i.patch : n.patch === i.patch } return t === e || t === '*' } }, 53614: (t, e, i) => { const s = {}; t.exports = s; const n = i(22562); const r = i(35810); const o = i(53402); s._motionWakeThreshold = 0.18, s._motionSleepThreshold = 0.08, s._minBias = 0.9, s.update = function (t, e) { for (let i = e / o._baseDelta, r = s._motionSleepThreshold, a = 0; a < t.length; a++) { const h = t[a]; const l = n.getSpeed(h); const u = n.getAngularSpeed(h); const c = l * l + u * u; if (h.force.x === 0 && h.force.y === 0) { const d = Math.min(h.motion, c); const f = Math.max(h.motion, c); h.motion = s._minBias * d + (1 - s._minBias) * f, h.sleepThreshold > 0 && h.motion < r ? (h.sleepCounter += 1, h.sleepCounter >= h.sleepThreshold / i && s.set(h, !0)) : h.sleepCounter > 0 && (h.sleepCounter -= 1) } else s.set(h, !1) } }, s.afterCollisions = function (t) { for (let e = s._motionSleepThreshold, i = 0; i < t.length; i++) { const n = t[i]; if (n.isActive) { const r = n.collision; const o = r.bodyA.parent; const a = r.bodyB.parent; if (!(o.isSleeping && a.isSleeping || o.isStatic || a.isStatic) && (o.isSleeping || a.isSleeping)) { const h = o.isSleeping && !o.isStatic ? o : a; const l = h === o ? a : o; !h.isStatic && l.motion > e && s.set(h, !1) } } } }, s.set = function (t, e) { const i = t.isSleeping; e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, i || r.trigger(t, 'sleepStart')) : (t.isSleeping = !1, t.sleepCounter = 0, i && r.trigger(t, 'sleepEnd')) } }, 66280: (t, e, i) => { const s = {}; t.exports = s; const n = i(41598); const r = i(53402); const o = i(22562); const a = i(15647); const h = i(31725); s.rectangle = function (t, e, i, s, a) { a = a || {}; const h = { label: 'Rectangle Body', position: { x: t, y: e }, vertices: n.fromPath('L 0 0 L ' + i + ' 0 L ' + i + ' ' + s + ' L 0 ' + s) }; if (a.chamfer) { const l = a.chamfer; h.vertices = n.chamfer(h.vertices, l.radius, l.quality, l.qualityMin, l.qualityMax), delete a.chamfer } return o.create(r.extend({}, h, a)) }, s.trapezoid = function (t, e, i, s, a, h) { h = h || {}; let l; const u = i * (a *= 0.5); const c = u + (1 - 2 * a) * i; const d = c + u; l = a < 0.5 ? 'L 0 0 L ' + u + ' ' + -s + ' L ' + c + ' ' + -s + ' L ' + d + ' 0' : 'L 0 0 L ' + c + ' ' + -s + ' L ' + d + ' 0'; const f = { label: 'Trapezoid Body', position: { x: t, y: e }, vertices: n.fromPath(l) }; if (h.chamfer) { const p = h.chamfer; f.vertices = n.chamfer(f.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete h.chamfer } return o.create(r.extend({}, f, h)) }, s.circle = function (t, e, i, n, o) { n = n || {}; const a = { label: 'Circle Body', circleRadius: i }; o = o || 25; let h = Math.ceil(Math.max(10, Math.min(o, i))); return h % 2 == 1 && (h += 1), s.polygon(t, e, h, i, r.extend({}, a, n)) }, s.polygon = function (t, e, i, a, h) { if (h = h || {}, i < 3) return s.circle(t, e, a, h); for (var l = 2 * Math.PI / i, u = '', c = 0.5 * l, d = 0; d < i; d += 1) { const f = c + d * l; const p = Math.cos(f) * a; const v = Math.sin(f) * a; u += 'L ' + p.toFixed(3) + ' ' + v.toFixed(3) + ' ' } const g = { label: 'Polygon Body', position: { x: t, y: e }, vertices: n.fromPath(u) }; if (h.chamfer) { const m = h.chamfer; g.vertices = n.chamfer(g.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete h.chamfer } return o.create(r.extend({}, g, h)) }, s.fromVertices = function (t, e, i, s, l, u, c, d) { let f; let p; let v; let g; let m; let y; let x; let T; let w; let b; const S = r.getDecomp(); for (f = Boolean(S && S.quickDecomp), s = s || {}, v = [], l = void 0 !== l && l, u = void 0 !== u ? u : 0.01, c = void 0 !== c ? c : 10, d = void 0 !== d ? d : 0.01, r.isArray(i[0]) || (i = [i]), w = 0; w < i.length; w += 1) if (m = i[w], !(g = n.isConvex(m)) && !f && r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."), g || !f) m = g ? n.clockwiseSort(m) : n.hull(m), v.push({ position: { x: t, y: e }, vertices: m }); else { const E = m.map(function (t) { return [t.x, t.y] }); S.makeCCW(E), !1 !== u && S.removeCollinearPoints(E, u), !1 !== d && S.removeDuplicatePoints && S.removeDuplicatePoints(E, d); const A = S.quickDecomp(E); for (y = 0; y < A.length; y++) { const C = A[y].map(function (t) { return { x: t[0], y: t[1] } }); c > 0 && n.area(C) < c || v.push({ position: n.centre(C), vertices: C }) } } for (y = 0; y < v.length; y++)v[y] = o.create(r.extend(v[y], s)); if (l) for (y = 0; y < v.length; y++) { const _ = v[y]; for (x = y + 1; x < v.length; x++) { const M = v[x]; if (a.overlaps(_.bounds, M.bounds)) { const P = _.vertices; const R = M.vertices; for (T = 0; T < _.vertices.length; T++) for (b = 0; b < M.vertices.length; b++) { const L = h.magnitudeSquared(h.sub(P[(T + 1) % P.length], R[b])); const O = h.magnitudeSquared(h.sub(P[T], R[(b + 1) % R.length])); L < 5 && O < 5 && (P[T].isInternal = !0, R[b].isInternal = !0) } } } } return v.length > 1 ? (p = o.create(r.extend({ parts: v.slice(0) }, s)), o.setPosition(p, { x: t, y: e }), p) : v[0] }, s.flagCoincidentParts = function (t, e) { void 0 === e && (e = 5); for (let i = 0; i < t.length; i++) for (let s = t[i], n = i + 1; n < t.length; n++) { const r = t[n]; if (a.overlaps(s.bounds, r.bounds)) for (let o = s.vertices, l = r.vertices, u = 0; u < s.vertices.length; u++) for (let c = 0; c < r.vertices.length; c++) { const d = h.magnitudeSquared(h.sub(o[(u + 1) % o.length], l[c])); const f = h.magnitudeSquared(h.sub(o[u], l[(c + 1) % l.length])); d < e && f < e && (o[u].isInternal = !0, l[c].isInternal = !0) } } return t } }, 74116: (t, e, i) => { const s = {}; t.exports = s; const n = i(69351); const r = i(48140); const o = i(53402); const a = i(22562); const h = i(66280); s.stack = function (t, e, i, s, r, o, h) { for (var l, u = n.create({ label: 'Stack' }), c = t, d = e, f = 0, p = 0; p < s; p++) { for (var v = 0, g = 0; g < i; g++) { const m = h(c, d, g, p, l, f); if (m) { const y = m.bounds.max.y - m.bounds.min.y; const x = m.bounds.max.x - m.bounds.min.x; y > v && (v = y), a.translate(m, { x: 0.5 * x, y: 0.5 * y }), c = m.bounds.max.x + r, n.addBody(u, m), l = m, f += 1 } else c += r } d += v + o, c = t } return u }, s.chain = function (t, e, i, s, a, h) { for (let l = t.bodies, u = 1; u < l.length; u++) { const c = l[u - 1]; const d = l[u]; const f = c.bounds.max.y - c.bounds.min.y; const p = c.bounds.max.x - c.bounds.min.x; const v = d.bounds.max.y - d.bounds.min.y; const g = { bodyA: c, pointA: { x: p * e, y: f * i }, bodyB: d, pointB: { x: (d.bounds.max.x - d.bounds.min.x) * s, y: v * a } }; const m = o.extend(g, h); n.addConstraint(t, r.create(m)) } return t.label += ' Chain', t }, s.mesh = function (t, e, i, s, a) { let h; let l; let u; let c; let d; const f = t.bodies; for (h = 0; h < i; h++) { for (l = 1; l < e; l++)u = f[l - 1 + h * e], c = f[l + h * e], n.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))); if (h > 0) for (l = 0; l < e; l++)u = f[l + (h - 1) * e], c = f[l + h * e], n.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))), s && l > 0 && (d = f[l - 1 + (h - 1) * e], n.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))), s && l < e - 1 && (d = f[l + 1 + (h - 1) * e], n.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))) } return t.label += ' Mesh', t }, s.pyramid = function (t, e, i, n, r, o, h) { return s.stack(t, e, i, n, r, o, function (e, s, o, l, u, c) { const d = Math.min(n, Math.ceil(i / 2)); const f = u ? u.bounds.max.x - u.bounds.min.x : 0; if (!(l > d || o < (l = d - l) || o > i - 1 - l)) return c === 1 && a.translate(u, { x: (o + (i % 2 == 1 ? 1 : -1)) * f, y: 0 }), h(t + (u ? o * f : 0) + o * r, s, o, l, u, c) }) }, s.newtonsCradle = function (t, e, i, s, o) { for (var a = n.create({ label: 'Newtons Cradle' }), l = 0; l < i; l++) { const u = h.circle(t + l * (1.9 * s), e + o, s, { inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1 }); const c = r.create({ pointA: { x: t + l * (1.9 * s), y: e }, bodyB: u }); n.addBody(a, u), n.addConstraint(a, c) } return a }, s.car = function (t, e, i, s, o) { const l = a.nextGroup(!0); const u = 0.5 * -i + 20; const c = 0.5 * i - 20; const d = n.create({ label: 'Car' }); const f = h.rectangle(t, e, i, s, { collisionFilter: { group: l }, chamfer: { radius: 0.5 * s }, density: 2e-4 }); const p = h.circle(t + u, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const v = h.circle(t + c, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const g = r.create({ bodyB: f, pointB: { x: u, y: 0 }, bodyA: p, stiffness: 1, length: 0 }); const m = r.create({ bodyB: f, pointB: { x: c, y: 0 }, bodyA: v, stiffness: 1, length: 0 }); return n.addBody(d, f), n.addBody(d, p), n.addBody(d, v), n.addConstraint(d, g), n.addConstraint(d, m), d }, s.softBody = function (t, e, i, n, r, a, l, u, c, d) { c = o.extend({ inertia: 1 / 0 }, c), d = o.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, d); const f = s.stack(t, e, i, n, r, a, function (t, e) { return h.circle(t, e, u, c) }); return s.mesh(f, i, n, l, d), f.label = 'Soft Body', f } }, 66615: (t, e, i) => { const s = {}; t.exports = s; const n = i(31725); const r = i(53402); s.fromVertices = function (t) { for (var e = {}, i = 0; i < t.length; i++) { const s = (i + 1) % t.length; const o = n.normalise({ x: t[s].y - t[i].y, y: t[i].x - t[s].x }); let a = o.y === 0 ? 1 / 0 : o.x / o.y; e[a = a.toFixed(3).toString()] = o } return r.values(e) }, s.rotate = function (t, e) { if (e !== 0) for (let i = Math.cos(e), s = Math.sin(e), n = 0; n < t.length; n++) { var r; const o = t[n]; r = o.x * i - o.y * s, o.y = o.x * s + o.y * i, o.x = r } } }, 15647: t => { const e = {}; t.exports = e, e.create = function (t) { const i = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && e.update(i, t), i }, e.update = function (t, e, i) { t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0; for (let s = 0; s < e.length; s++) { const n = e[s]; n.x > t.max.x && (t.max.x = n.x), n.x < t.min.x && (t.min.x = n.x), n.y > t.max.y && (t.max.y = n.y), n.y < t.min.y && (t.min.y = n.y) } i && (i.x > 0 ? t.max.x += i.x : t.min.x += i.x, i.y > 0 ? t.max.y += i.y : t.min.y += i.y) }, e.contains = function (t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y }, e.overlaps = function (t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y }, e.translate = function (t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y }, e.shift = function (t, e) { const i = t.max.x - t.min.x; const s = t.max.y - t.min.y; t.min.x = e.x, t.max.x = e.x + i, t.min.y = e.y, t.max.y = e.y + s } }, 74058: (t, e, i) => { const s = {}; t.exports = s; i(15647); const n = i(53402); s.pathToVertices = function (t, e) { typeof window === 'undefined' || 'SVGPathSeg' in window || n.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.'); let i; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; const v = []; let g = 0; let m = 0; let y = 0; e = e || 15; const x = function (t, e, i) { const s = i % 2 == 1 && i > 1; if (!d || t != d.x || e != d.y) { d && s ? (f = d.x, p = d.y) : (f = 0, p = 0); const n = { x: f + t, y: p + e }; !s && d || (d = n), v.push(n), m = f + t, y = p + e } }; const T = function (t) { const e = t.pathSegTypeAsLetter.toUpperCase(); if (e !== 'Z') { switch (e) { case 'M': case 'L': case 'T': case 'C': case 'S': case 'Q': m = t.x, y = t.y; break; case 'H': m = t.x; break; case 'V': y = t.y }x(m, y, t.pathSegType) } }; for (s._svgPathToAbsolute(t), o = t.getTotalLength(), l = [], i = 0; i < t.pathSegList.numberOfItems; i += 1)l.push(t.pathSegList.getItem(i)); for (u = l.concat(); g < o;) { if ((h = l[t.getPathSegAtLength(g)]) != c) { for (; u.length && u[0] != h;)T(u.shift()); c = h } switch (h.pathSegTypeAsLetter.toUpperCase()) { case 'C': case 'T': case 'S': case 'Q': case 'A': a = t.getPointAtLength(g), x(a.x, a.y, 0) }g += e } for (i = 0, r = u.length; i < r; ++i)T(u[i]); return v }, s._svgPathToAbsolute = function (t) { for (var e, i, s, n, r, o, a = t.pathSegList, h = 0, l = 0, u = a.numberOfItems, c = 0; c < u; ++c) { const d = a.getItem(c); const f = d.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f)) 'x' in d && (h = d.x), 'y' in d && (l = d.y); else switch ('x1' in d && (s = h + d.x1), 'x2' in d && (r = h + d.x2), 'y1' in d && (n = l + d.y1), 'y2' in d && (o = l + d.y2), 'x' in d && (h += d.x), 'y' in d && (l += d.y), f) { case 'm': a.replaceItem(t.createSVGPathSegMovetoAbs(h, l), c); break; case 'l': a.replaceItem(t.createSVGPathSegLinetoAbs(h, l), c); break; case 'h': a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h), c); break; case 'v': a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l), c); break; case 'c': a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h, l, s, n, r, o), c); break; case 's': a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h, l, r, o), c); break; case 'q': a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h, l, s, n), c); break; case 't': a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h, l), c); break; case 'a': a.replaceItem(t.createSVGPathSegArcAbs(h, l, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), c); break; case 'z': case 'Z': h = e, l = i }f != 'M' && f != 'm' || (e = h, i = l) } } }, 31725: t => { const e = {}; t.exports = e, e.create = function (t, e) { return { x: t || 0, y: e || 0 } }, e.clone = function (t) { return { x: t.x, y: t.y } }, e.magnitude = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y) }, e.magnitudeSquared = function (t) { return t.x * t.x + t.y * t.y }, e.rotate = function (t, e, i) { const s = Math.cos(e); const n = Math.sin(e); i || (i = {}); const r = t.x * s - t.y * n; return i.y = t.x * n + t.y * s, i.x = r, i }, e.rotateAbout = function (t, e, i, s) { const n = Math.cos(e); const r = Math.sin(e); s || (s = {}); const o = i.x + ((t.x - i.x) * n - (t.y - i.y) * r); return s.y = i.y + ((t.x - i.x) * r + (t.y - i.y) * n), s.x = o, s }, e.normalise = function (t) { const i = e.magnitude(t); return i === 0 ? { x: 0, y: 0 } : { x: t.x / i, y: t.y / i } }, e.dot = function (t, e) { return t.x * e.x + t.y * e.y }, e.cross = function (t, e) { return t.x * e.y - t.y * e.x }, e.cross3 = function (t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x) }, e.add = function (t, e, i) { return i || (i = {}), i.x = t.x + e.x, i.y = t.y + e.y, i }, e.sub = function (t, e, i) { return i || (i = {}), i.x = t.x - e.x, i.y = t.y - e.y, i }, e.mult = function (t, e) { return { x: t.x * e, y: t.y * e } }, e.div = function (t, e) { return { x: t.x / e, y: t.y / e } }, e.perp = function (t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x } }, e.neg = function (t) { return { x: -t.x, y: -t.y } }, e.angle = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x) }, e._temp = [e.create(), e.create(), e.create(), e.create(), e.create(), e.create()] }, 41598: (t, e, i) => { const s = {}; t.exports = s; const n = i(31725); const r = i(53402); s.create = function (t, e) { for (var i = [], s = 0; s < t.length; s++) { const n = t[s]; const r = { x: n.x, y: n.y, index: s, body: e, isInternal: !1 }; i.push(r) } return i }, s.fromPath = function (t, e) { const i = []; return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, function (t, e, s) { i.push({ x: parseFloat(e), y: parseFloat(s) }) }), s.create(i, e) }, s.centre = function (t) { for (var e, i, r, o = s.area(t, !0), a = { x: 0, y: 0 }, h = 0; h < t.length; h++)r = (h + 1) % t.length, e = n.cross(t[h], t[r]), i = n.mult(n.add(t[h], t[r]), e), a = n.add(a, i); return n.div(a, 6 * o) }, s.mean = function (t) { for (var e = { x: 0, y: 0 }, i = 0; i < t.length; i++)e.x += t[i].x, e.y += t[i].y; return n.div(e, t.length) }, s.area = function (t, e) { for (var i = 0, s = t.length - 1, n = 0; n < t.length; n++)i += (t[s].x - t[n].x) * (t[s].y + t[n].y), s = n; return e ? i / 2 : Math.abs(i) / 2 }, s.inertia = function (t, e) { for (var i, s, r = 0, o = 0, a = t, h = 0; h < a.length; h++)s = (h + 1) % a.length, r += (i = Math.abs(n.cross(a[s], a[h]))) * (n.dot(a[s], a[s]) + n.dot(a[s], a[h]) + n.dot(a[h], a[h])), o += i; return e / 6 * (r / o) }, s.translate = function (t, e, i) { i = void 0 !== i ? i : 1; let s; const n = t.length; const r = e.x * i; const o = e.y * i; for (s = 0; s < n; s++)t[s].x += r, t[s].y += o; return t }, s.rotate = function (t, e, i) { if (e !== 0) { let s; let n; let r; let o; const a = Math.cos(e); const h = Math.sin(e); const l = i.x; const u = i.y; const c = t.length; for (o = 0; o < c; o++)n = (s = t[o]).x - l, r = s.y - u, s.x = l + (n * a - r * h), s.y = u + (n * h + r * a); return t } }, s.contains = function (t, e) { for (var i, s = e.x, n = e.y, r = t.length, o = t[r - 1], a = 0; a < r; a++) { if (i = t[a], (s - o.x) * (i.y - o.y) + (n - o.y) * (o.x - i.x) > 0) return !1; o = i } return !0 }, s.scale = function (t, e, i, r) { if (e === 1 && i === 1) return t; let o, a; r = r || s.centre(t); for (let h = 0; h < t.length; h++)o = t[h], a = n.sub(o, r), t[h].x = r.x + a.x * e, t[h].y = r.y + a.y * i; return t }, s.chamfer = function (t, e, i, s, o) { e = typeof e === 'number' ? [e] : e || [8], i = void 0 !== i ? i : -1, s = s || 2, o = o || 14; for (var a = [], h = 0; h < t.length; h++) { const l = t[h - 1 >= 0 ? h - 1 : t.length - 1]; const u = t[h]; const c = t[(h + 1) % t.length]; const d = e[h < e.length ? h : e.length - 1]; if (d !== 0) { const f = n.normalise({ x: u.y - l.y, y: l.x - u.x }); const p = n.normalise({ x: c.y - u.y, y: u.x - c.x }); const v = Math.sqrt(2 * Math.pow(d, 2)); const g = n.mult(r.clone(f), d); const m = n.normalise(n.mult(n.add(f, p), 0.5)); const y = n.sub(u, n.mult(m, v)); let x = i; i === -1 && (x = 1.75 * Math.pow(d, 0.32)), (x = r.clamp(x, s, o)) % 2 == 1 && (x += 1); for (let T = Math.acos(n.dot(f, p)) / x, w = 0; w < x; w++)a.push(n.add(n.rotate(g, T * w), y)) } else a.push(u) } return a }, s.clockwiseSort = function (t) { const e = s.mean(t); return t.sort(function (t, i) { return n.angle(e, t) - n.angle(e, i) }), t }, s.isConvex = function (t) { let e; let i; let s; let n; let r = 0; const o = t.length; if (o < 3) return null; for (e = 0; e < o; e++) if (s = (e + 2) % o, n = (t[i = (e + 1) % o].x - t[e].x) * (t[s].y - t[i].y), (n -= (t[i].y - t[e].y) * (t[s].x - t[i].x)) < 0 ? r |= 1 : n > 0 && (r |= 2), r === 3) return !1; return r !== 0 || null }, s.hull = function (t) { let e; let i; const s = []; const r = []; for ((t = t.slice(0)).sort(function (t, e) { const i = t.x - e.x; return i !== 0 ? i : t.y - e.y }), i = 0; i < t.length; i += 1) { for (e = t[i]; r.length >= 2 && n.cross3(r[r.length - 2], r[r.length - 1], e) <= 0;)r.pop(); r.push(e) } for (i = t.length - 1; i >= 0; i -= 1) { for (e = t[i]; s.length >= 2 && n.cross3(s[s.length - 2], s[s.length - 1], e) <= 0;)s.pop(); s.push(e) } return s.pop(), r.pop(), s.concat(r) } }, 18210: (t, e, i) => { const s = i(19933); var n = { name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.19.0', silent: !0, install: function (t) { t.after('Body.create', function () { n.Body.init(this) }), t.before('Engine.update', function (t) { n.Engine.update(t) }) }, Body: { init: function (t) { t.plugin.attractors = t.plugin.attractors || [] } }, Engine: { update: function (t) { for (let e = s.Composite.allBodies(t.world), i = 0; i < e.length; i++) { const n = e[i]; const r = n.plugin.attractors; if (r && r.length > 0) for (let o = 0; o < e.length; o++) { const a = e[o]; if (i !== o) for (let h = 0; h < r.length; h++) { const l = r[h]; let u = l; s.Common.isFunction(l) && (u = l(n, a)), u && s.Body.applyForce(a, a.position, u) } } } } }, Attractors: { gravityConstant: 0.001, gravity: function (t, e) { const i = s.Vector.sub(e.position, t.position); const r = s.Vector.magnitudeSquared(i) || 1e-4; const o = s.Vector.normalise(i); const a = -n.Attractors.gravityConstant * (t.mass * e.mass / r); const h = s.Vector.mult(o, a); s.Body.applyForce(t, t.position, s.Vector.neg(h)), s.Body.applyForce(e, e.position, h) } } }; t.exports = n }, 40178: t => { t.exports = { name: 'matter-collision-events', version: '0.1.6', for: 'matter-js@^0.19.0', silent: !0, install: function (t) { t.after('Engine.create', function () { t.Events.on(this, 'collisionStart', function (e) { e.pairs.map(function (e) { const i = e.bodyA; const s = e.bodyB; i.gameObject && i.gameObject.emit('collide', i, s, e), s.gameObject && s.gameObject.emit('collide', s, i, e), t.Events.trigger(i, 'onCollide', { pair: e }), t.Events.trigger(s, 'onCollide', { pair: e }), i.onCollideCallback && i.onCollideCallback(e), s.onCollideCallback && s.onCollideCallback(e), i.onCollideWith[s.id] && i.onCollideWith[s.id](s, e), s.onCollideWith[i.id] && s.onCollideWith[i.id](i, e) }) }), t.Events.on(this, 'collisionActive', function (e) { e.pairs.map(function (e) { const i = e.bodyA; const s = e.bodyB; i.gameObject && i.gameObject.emit('collideActive', i, s, e), s.gameObject && s.gameObject.emit('collideActive', s, i, e), t.Events.trigger(i, 'onCollideActive', { pair: e }), t.Events.trigger(s, 'onCollideActive', { pair: e }), i.onCollideActiveCallback && i.onCollideActiveCallback(e), s.onCollideActiveCallback && s.onCollideActiveCallback(e) }) }), t.Events.on(this, 'collisionEnd', function (e) { e.pairs.map(function (e) { const i = e.bodyA; const s = e.bodyB; i.gameObject && i.gameObject.emit('collideEnd', i, s, e), s.gameObject && s.gameObject.emit('collideEnd', s, i, e), t.Events.trigger(i, 'onCollideEnd', { pair: e }), t.Events.trigger(s, 'onCollideEnd', { pair: e }), i.onCollideEndCallback && i.onCollideEndCallback(e), s.onCollideEndCallback && s.onCollideEndCallback(e) }) }) }) } } }, 74507: (t, e, i) => { const s = i(19933); var n = { name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.19.0', silent: !0, install: function (t) { t.after('Engine.update', function () { n.Engine.update(this) }) }, Engine: { update: function (t) { for (var e = t.world, i = s.Composite.allBodies(e), r = s.Composite.allComposites(e), o = 0; o < i.length; o += 1) { const a = i[o]; a.plugin.wrap && n.Body.wrap(a, a.plugin.wrap) } for (o = 0; o < r.length; o += 1) { const h = r[o]; h.plugin.wrap && n.Composite.wrap(h, h.plugin.wrap) } } }, Bounds: { wrap: function (t, e) { let i = null; let s = null; if (void 0 !== e.min.x && void 0 !== e.max.x && (t.min.x > e.max.x ? i = e.min.x - t.max.x : t.max.x < e.min.x && (i = e.max.x - t.min.x)), void 0 !== e.min.y && void 0 !== e.max.y && (t.min.y > e.max.y ? s = e.min.y - t.max.y : t.max.y < e.min.y && (s = e.max.y - t.min.y)), i !== null || s !== null) return { x: i || 0, y: s || 0 } } }, Body: { wrap: function (t, e) { const i = n.Bounds.wrap(t.bounds, e); return i && s.Body.translate(t, i), i } }, Composite: { bounds: function (t) { for (var e = s.Composite.allBodies(t), i = [], n = 0; n < e.length; n += 1) { const r = e[n]; i.push(r.bounds.min, r.bounds.max) } return s.Bounds.create(i) }, wrap: function (t, e) { const i = n.Bounds.wrap(n.Composite.bounds(t), e); return i && s.Composite.translate(t, i), i } } }; t.exports = n }, 55973: t => { function e (t, e, i) { i = i || 0; let s; let n; let r; let o; let a; let h; let l; const u = [0, 0]; return s = t[1][1] - t[0][1], n = t[0][0] - t[1][0], r = s * t[0][0] + n * t[0][1], o = e[1][1] - e[0][1], a = e[0][0] - e[1][0], h = o * e[0][0] + a * e[0][1], S(l = s * a - o * n, 0, i) || (u[0] = (a * r - n * h) / l, u[1] = (s * h - o * r) / l), u } function i (t, e, i, s) { const n = e[0] - t[0]; const r = e[1] - t[1]; const o = s[0] - i[0]; const a = s[1] - i[1]; if (o * r - a * n == 0) return !1; const h = (n * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * n); const l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - o * r); return h >= 0 && h <= 1 && l >= 0 && l <= 1 } function s (t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]) } function n (t, e, i) { return s(t, e, i) > 0 } function r (t, e, i) { return s(t, e, i) >= 0 } function o (t, e, i) { return s(t, e, i) < 0 } function a (t, e, i) { return s(t, e, i) <= 0 } t.exports = { decomp: function (t) { const e = T(t); return e.length > 0 ? w(t, e) : [t] }, quickDecomp: function t (e, i, s, h, l, u, v) { u = u || 100, v = v || 0, l = l || 25, i = void 0 !== i ? i : [], s = s || [], h = h || []; let g = [0, 0]; let m = [0, 0]; let x = [0, 0]; let T = 0; let w = 0; let S = 0; let E = 0; let A = 0; let C = 0; let _ = 0; const M = []; const P = []; const R = e; const L = e; if (L.length < 3) return i; if (++v > u) return console.warn('quickDecomp: max level (' + u + ') reached.'), i; for (let O = 0; O < e.length; ++O) if (p(R, O)) { s.push(R[O]), T = w = Number.MAX_VALUE; for (var F = 0; F < e.length; ++F)n(d(R, O - 1), d(R, O), d(R, F)) && a(d(R, O - 1), d(R, O), d(R, F - 1)) && (x = b(d(R, O - 1), d(R, O), d(R, F), d(R, F - 1)), o(d(R, O + 1), d(R, O), x) && (S = c(R[O], x)) < w && (w = S, m = x, C = F)), n(d(R, O + 1), d(R, O), d(R, F + 1)) && a(d(R, O + 1), d(R, O), d(R, F)) && (x = b(d(R, O + 1), d(R, O), d(R, F), d(R, F + 1)), n(d(R, O - 1), d(R, O), x) && (S = c(R[O], x)) < T && (T = S, g = x, A = F)); if (C === (A + 1) % e.length) x[0] = (m[0] + g[0]) / 2, x[1] = (m[1] + g[1]) / 2, h.push(x), O < A ? (f(M, R, O, A + 1), M.push(x), P.push(x), C !== 0 && f(P, R, C, R.length), f(P, R, 0, O + 1)) : (O !== 0 && f(M, R, O, R.length), f(M, R, 0, A + 1), M.push(x), P.push(x), f(P, R, C, O + 1)); else { if (C > A && (A += e.length), E = Number.MAX_VALUE, A < C) return i; for (F = C; F <= A; ++F)r(d(R, O - 1), d(R, O), d(R, F)) && a(d(R, O + 1), d(R, O), d(R, F)) && (S = c(d(R, O), d(R, F))) < E && y(R, O, F) && (E = S, _ = F % e.length); O < _ ? (f(M, R, O, _ + 1), _ !== 0 && f(P, R, _, L.length), f(P, R, 0, O + 1)) : (O !== 0 && f(M, R, O, L.length), f(M, R, 0, _ + 1), f(P, R, _, O + 1)) } return M.length < P.length ? (t(M, i, s, h, l, u, v), t(P, i, s, h, l, u, v)) : (t(P, i, s, h, l, u, v), t(M, i, s, h, l, u, v)), i } return i.push(e), i }, isSimple: function (t) { let e; const s = t; for (e = 0; e < s.length - 1; e++) for (let n = 0; n < e - 1; n++) if (i(s[e], s[e + 1], s[n], s[n + 1])) return !1; for (e = 1; e < s.length - 2; e++) if (i(s[0], s[s.length - 1], s[e], s[e + 1])) return !1; return !0 }, removeCollinearPoints: function (t, e) { for (var i = 0, s = t.length - 1; t.length > 3 && s >= 0; --s)u(d(t, s - 1), d(t, s), d(t, s + 1), e) && (t.splice(s % t.length, 1), i++); return i }, removeDuplicatePoints: function (t, e) { for (let i = t.length - 1; i >= 1; --i) for (let s = t[i], n = i - 1; n >= 0; --n)E(s, t[n], e) && t.splice(i, 1) }, makeCCW: function (t) { for (var e = 0, i = t, s = 1; s < t.length; ++s)(i[s][1] < i[e][1] || i[s][1] === i[e][1] && i[s][0] > i[e][0]) && (e = s); return !n(d(t, e - 1), d(t, e), d(t, e + 1)) && ((function (t) { for (var e = [], i = t.length, s = 0; s !== i; s++)e.push(t.pop()); for (s = 0; s !== i; s++)t[s] = e[s] }(t)), !0) } }; const h = []; const l = []; function u (t, e, i, n) { if (n) { const r = h; const o = l; r[0] = e[0] - t[0], r[1] = e[1] - t[1], o[0] = i[0] - e[0], o[1] = i[1] - e[1]; const a = r[0] * o[0] + r[1] * o[1]; const u = Math.sqrt(r[0] * r[0] + r[1] * r[1]); const c = Math.sqrt(o[0] * o[0] + o[1] * o[1]); return Math.acos(a / (u * c)) < n } return s(t, e, i) === 0 } function c (t, e) { const i = e[0] - t[0]; const s = e[1] - t[1]; return i * i + s * s } function d (t, e) { const i = t.length; return t[e < 0 ? e % i + i : e % i] } function f (t, e, i, s) { for (let n = i; n < s; n++)t.push(e[n]) } function p (t, e) { return o(d(t, e - 1), d(t, e), d(t, e + 1)) } const v = []; const g = []; function m (t, i, s) { let n; let o; const h = v; const l = g; if (r(d(t, i + 1), d(t, i), d(t, s)) && a(d(t, i - 1), d(t, i), d(t, s))) return !1; o = c(d(t, i), d(t, s)); for (let u = 0; u !== t.length; ++u) if ((u + 1) % t.length !== i && u !== i && r(d(t, i), d(t, s), d(t, u + 1)) && a(d(t, i), d(t, s), d(t, u)) && (h[0] = d(t, i), h[1] = d(t, s), l[0] = d(t, u), l[1] = d(t, u + 1), n = e(h, l), c(d(t, i), n) < o)) return !1; return !0 } function y (t, e, s) { for (let n = 0; n !== t.length; ++n) if (n !== e && n !== s && (n + 1) % t.length !== e && (n + 1) % t.length !== s && i(d(t, e), d(t, s), d(t, n), d(t, n + 1))) return !1; return !0 } function x (t, e, i, s) { const n = s || []; if ((function (t) { t.length = 0 }(n)), e < i) for (var r = e; r <= i; r++)n.push(t[r]); else { for (r = 0; r <= i; r++)n.push(t[r]); for (r = e; r < t.length; r++)n.push(t[r]) } return n } function T (t) { for (var e = [], i = [], s = [], n = [], r = Number.MAX_VALUE, o = 0; o < t.length; ++o) if (p(t, o)) for (let a = 0; a < t.length; ++a) if (m(t, o, a)) { i = T(x(t, o, a, n)), s = T(x(t, a, o, n)); for (let h = 0; h < s.length; h++)i.push(s[h]); i.length < r && (e = i, r = i.length, e.push([d(t, o), d(t, a)])) } return e } function w (t, e) { if (e.length === 0) return [t]; if (e instanceof Array && e.length && e[0] instanceof Array && e[0].length === 2 && e[0][0] instanceof Array) { for (var i = [t], s = 0; s < e.length; s++) for (var n = e[s], r = 0; r < i.length; r++) { const o = w(i[r], n); if (o) { i.splice(r, 1), i.push(o[0], o[1]); break } } return i } n = e, s = t.indexOf(n[0]), r = t.indexOf(n[1]); return s !== -1 && r !== -1 && [x(t, s, r), x(t, r, s)] } function b (t, e, i, s, n) { n = n || 0; const r = e[1] - t[1]; const o = t[0] - e[0]; const a = r * t[0] + o * t[1]; const h = s[1] - i[1]; const l = i[0] - s[0]; const u = h * i[0] + l * i[1]; const c = r * l - h * o; return S(c, 0, n) ? [0, 0] : [(l * a - o * u) / c, (r * u - h * a) / c] } function S (t, e, i) { return i = i || 0, Math.abs(t - e) <= i } function E (t, e, i) { return S(t[0], e[0], i) && S(t[1], e[1], i) } }, 52018: (t, e, i) => { const s = new (i(83419))({ initialize: function (t) { this.pluginManager = t, this.game = t.game }, init: function () { }, start: function () { }, stop: function () { }, destroy: function () { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null } }); t.exports = s }, 42363: t => { t.exports = { Global: ['game', 'anims', 'cache', 'plugins', 'registry', 'scale', 'sound', 'textures', 'renderer'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] } }, 37277: t => { const e = {}; const i = {}; const s = { register: function (t, i, s, n) { void 0 === n && (n = !1), e[t] = { plugin: i, mapping: s, custom: n } }, registerCustom: function (t, e, s, n) { i[t] = { plugin: e, mapping: s, data: n } }, hasCore: function (t) { return e.hasOwnProperty(t) }, hasCustom: function (t) { return i.hasOwnProperty(t) }, getCore: function (t) { return e[t] }, getCustom: function (t) { return i[t] }, getCustomClass: function (t) { return i.hasOwnProperty(t) ? i[t].plugin : null }, remove: function (t) { e.hasOwnProperty(t) && delete e[t] }, removeCustom: function (t) { i.hasOwnProperty(t) && delete i[t] }, destroyCorePlugins: function () { for (const t in e) e.hasOwnProperty(t) && delete e[t] }, destroyCustomPlugins: function () { for (const t in i) i.hasOwnProperty(t) && delete i[t] } }; t.exports = s }, 77332: (t, e, i) => { const s = i(83419); const n = i(8443); const r = i(50792); const o = i(74099); const a = i(44603); const h = i(39429); const l = i(95540); const u = i(37277); const c = i(72905); const d = new s({ Extends: r, initialize: function (t) { r.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once(n.BOOT, this.boot, this) }, boot: function () { let t; let e; let i; let s; let r; let o; let a; const h = this.game.config; let u = h.installGlobalPlugins; for (u = u.concat(this._pendingGlobal), t = 0; t < u.length; t++)e = u[t], i = l(e, 'key', null), s = l(e, 'plugin', null), r = l(e, 'start', !1), o = l(e, 'mapping', null), a = l(e, 'data', null), i && (s ? this.install(i, s, r, o, a) : console.warn('Missing `plugin` for key: ' + i)); for (u = (u = h.installScenePlugins).concat(this._pendingScene), t = 0; t < u.length; t++)e = u[t], i = l(e, 'key', null), s = l(e, 'plugin', null), o = l(e, 'mapping', null), i && (s ? this.installScenePlugin(i, s, o) : console.warn('Missing `plugin` for key: ' + i)); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(n.DESTROY, this.destroy, this) }, addToScene: function (t, e, i) { let s; let n; let r; const o = this.game; const a = t.scene; const h = t.settings.map; const l = t.settings.isBooted; for (s = 0; s < e.length; s++)o[n = e[s]] ? (t[n] = o[n], h.hasOwnProperty(n) && (a[h[n]] = t[n])) : n === 'game' && h.hasOwnProperty(n) && (a[h[n]] = o); for (let c = 0; c < i.length; c++) for (r = i[c], s = 0; s < r.length; s++) if (n = r[s], u.hasCore(n)) { const d = u.getCore(n); const f = d.mapping; const p = new d.plugin(a, this, f); t[f] = p, d.custom ? a[f] = p : h.hasOwnProperty(f) && (a[h[f]] = p), l && p.boot() } for (r = this.plugins, s = 0; s < r.length; s++) { const v = r[s]; v.mapping && (a[v.mapping] = v.plugin) } }, getDefaultScenePlugins: function () { let t = this.game.config.defaultPlugins; return t = t.concat(this.scenePlugins) }, installScenePlugin: function (t, e, i, s, n) { if (void 0 === n && (n = !1), typeof e === 'function') { if (u.hasCore(t) || u.register(t, e, i, !0), this.scenePlugins.indexOf(t) === -1) this.scenePlugins.push(t); else if (!n && u.hasCore(t)) return void console.warn('Scene Plugin key in use: ' + t); if (s) { const r = new e(s, this, t); s.sys[t] = r, i && i !== '' && (s[i] = r), r.boot() } } else console.warn('Invalid Scene Plugin: ' + t) }, install: function (t, e, i, s, n) { if (void 0 === i && (i = !1), void 0 === s && (s = null), void 0 === n && (n = null), typeof e !== 'function') return console.warn('Invalid Plugin: ' + t), null; if (u.hasCustom(t)) return console.warn('Plugin key in use: ' + t), null; if (s !== null && (i = !0), this.game.isBooted) { if (u.registerCustom(t, e, s, n), i) return this.start(t) } else this._pendingGlobal.push({ key: t, plugin: e, start: i, mapping: s, data: n }); return null }, getIndex: function (t) { for (let e = this.plugins, i = 0; i < e.length; i++) { if (e[i].key === t) return i } return -1 }, getEntry: function (t) { const e = this.getIndex(t); if (e !== -1) return this.plugins[e] }, isActive: function (t) { const e = this.getEntry(t); return e && e.active }, start: function (t, e) { void 0 === e && (e = t); let i = this.getEntry(e); return i && !i.active ? (i.active = !0, i.plugin.start()) : i || (i = this.createEntry(t, e)), i ? i.plugin : null }, createEntry: function (t, e) { let i = u.getCustom(t); if (i) { const s = new i.plugin(this); i = { key: e, plugin: s, active: !0, mapping: i.mapping, data: i.data }, this.plugins.push(i), s.init(i.data), s.start() } return i }, stop: function (t) { const e = this.getEntry(t); return e && e.active && (e.active = !1, e.plugin.stop()), this }, get: function (t, e) { void 0 === e && (e = !0); let i = this.getEntry(t); if (i) return i.plugin; const s = this.getClass(t); return s && e ? (i = this.createEntry(t, t)) ? i.plugin : null : s || null }, getClass: function (t) { return u.getCustomClass(t) }, removeGlobalPlugin: function (t) { const e = this.getEntry(t); e && c(this.plugins, e), u.removeCustom(t) }, removeScenePlugin: function (t) { c(this.scenePlugins, t), u.remove(t) }, registerGameObject: function (t, e, i) { return e && h.register(t, e), i && a.register(t, i), this }, removeGameObject: function (t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), e && h.remove(t), i && a.remove(t), this }, registerFileType: function (t, e, i) { o.register(t, e), i && i.sys.load && (i.sys.load[t] = e) }, destroy: function () { for (let t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy(); u.destroyCustomPlugins(), this.game.noReturn && u.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = [] } }); t.exports = d }, 45145: (t, e, i) => { const s = i(52018); const n = i(83419); const r = i(44594); const o = new n({ Extends: s, initialize: function (t, e, i) { s.call(this, e), this.scene = t, this.systems = t.sys, this.pluginKey = i, t.sys.events.once(r.BOOT, this.boot, this) }, boot: function () { }, destroy: function () { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null } }); t.exports = o }, 18922: (t, e, i) => { t.exports = { BasePlugin: i(52018), DefaultPlugins: i(42363), PluginCache: i(37277), PluginManager: i(77332), ScenePlugin: i(45145) } }, 63595: () => { HTMLVideoElement && !('requestVideoFrameCallback' in HTMLVideoElement.prototype) && 'getVideoPlaybackQuality' in HTMLVideoElement.prototype && (HTMLVideoElement.prototype._rvfcpolyfillmap = {}, HTMLVideoElement.prototype.requestVideoFrameCallback = function (t) { const e = performance.now(); const i = this.getVideoPlaybackQuality(); const s = this.mozPresentedFrames || this.mozPaintedFrames || i.totalVideoFrames - i.droppedVideoFrames; const n = (r, o) => { const a = this.getVideoPlaybackQuality(); const h = this.mozPresentedFrames || this.mozPaintedFrames || a.totalVideoFrames - a.droppedVideoFrames; if (h > s) { const s = this.mozFrameDelay || a.totalFrameDelay - i.totalFrameDelay || 0; const n = o - r; t(o, { presentationTime: o + 1e3 * s, expectedDisplayTime: o + n, width: this.videoWidth, height: this.videoHeight, mediaTime: Math.max(0, this.currentTime || 0) + n / 1e3, presentedFrames: h, processingDuration: s }), delete this._rvfcpolyfillmap[e] } else this._rvfcpolyfillmap[e] = requestAnimationFrame(t => n(o, t)) }; return this._rvfcpolyfillmap[e] = requestAnimationFrame(t => n(e, t)), e }, HTMLVideoElement.prototype.cancelVideoFrameCallback = function (t) { cancelAnimationFrame(this._rvfcpolyfillmap[t]), delete this._rvfcpolyfillmap[t] }) }, 10312: t => { t.exports = { SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19, SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24, LIGHTER: 25, COPY: 26, XOR: 27 } }, 29795: t => { t.exports = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 } }, 68627: (t, e, i) => { const s = i(19715); const n = i(32880); const r = i(83419); const o = i(8054); const a = i(50792); const h = i(92503); const l = i(56373); const u = i(97480); const c = i(69442); const d = i(61340); const f = new r({ Extends: a, initialize: function (t) { a.call(this); const e = t.config; this.config = { clearBeforeRender: e.clearBeforeRender, backgroundColor: e.backgroundColor, antialias: e.antialias, roundPixels: e.roundPixels }, this.game = t, this.type = o.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.gameCanvas = t.canvas; const i = { alpha: t.config.transparent, desynchronized: t.config.desynchronized, willReadFrequently: !1 }; this.gameContext = e.context ? e.context : this.gameCanvas.getContext('2d', i), this.currentContext = this.gameContext, this.antialias = t.config.antialias, this.blendModes = l(), this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92 }, this._tempMatrix1 = new d(), this._tempMatrix2 = new d(), this._tempMatrix3 = new d(), this.isBooted = !1, this.init() }, init: function () { this.game.textures.once(c.READY, this.boot, this) }, boot: function () { const t = this.game; const e = t.scale.baseSize; this.width = e.width, this.height = e.height, this.isBooted = !0, t.scale.on(u.RESIZE, this.onResize, this), this.resize(e.width, e.height) }, onResize: function (t, e) { e.width === this.width && e.height === this.height || this.resize(e.width, e.height) }, resize: function (t, e) { this.width = t, this.height = e, this.emit(h.RESIZE, t, e) }, resetTransform: function () { this.currentContext.setTransform(1, 0, 0, 1, 0, 0) }, setBlendMode: function (t) { return this.currentContext.globalCompositeOperation = t, this }, setContext: function (t) { return this.currentContext = t || this.gameContext, this }, setAlpha: function (t) { return this.currentContext.globalAlpha = t, this }, preRender: function () { const t = this.gameContext; const e = this.config; const i = this.width; const s = this.height; t.globalAlpha = 1, t.globalCompositeOperation = 'source-over', t.setTransform(1, 0, 0, 1, 0, 0), e.clearBeforeRender && (t.clearRect(0, 0, i, s), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, s))), t.save(), this.drawCount = 0, this.emit(h.PRE_RENDER) }, render: function (t, e, i) { const n = e.length; this.emit(h.RENDER, t, i); const r = i.x; const o = i.y; const a = i.width; const l = i.height; const u = i.renderToTexture ? i.context : t.sys.context; u.save(), this.game.scene.customViewports && (u.beginPath(), u.rect(r, o, a, l), u.clip()), i.emit(s.PRE_RENDER, i), this.currentContext = u; const c = i.mask; c && c.preRenderCanvas(this, null, i._maskCamera), i.transparent || (u.fillStyle = i.backgroundColor.rgba, u.fillRect(r, o, a, l)), u.globalAlpha = i.alpha, u.globalCompositeOperation = 'source-over', this.drawCount += n, i.renderToTexture && i.emit(s.PRE_RENDER, i), i.matrix.copyToContext(u); for (let d = 0; d < n; d++) { const f = e[d]; f.mask && f.mask.preRenderCanvas(this, f, i), f.renderCanvas(this, f, i), f.mask && f.mask.postRenderCanvas(this, f, i) } u.setTransform(1, 0, 0, 1, 0, 0), u.globalCompositeOperation = 'source-over', u.globalAlpha = 1, i.flashEffect.postRenderCanvas(u), i.fadeEffect.postRenderCanvas(u), i.dirty = !1, c && c.postRenderCanvas(this), u.restore(), i.renderToTexture && (i.emit(s.POST_RENDER, i), i.renderToGame && t.sys.context.drawImage(i.canvas, r, o)), i.emit(s.POST_RENDER, i) }, postRender: function () { this.gameContext.restore(), this.emit(h.POST_RENDER); const t = this.snapshotState; t.callback && (n(this.gameCanvas, t), t.callback = null) }, snapshotCanvas: function (t, e, i, s, r, o, a, h, l) { void 0 === i && (i = !1), this.snapshotArea(s, r, o, a, e, h, l); const u = this.snapshotState; return u.getPixel = i, n(t, u), u.callback = null, this }, snapshot: function (t, e, i) { return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, t, e, i) }, snapshotArea: function (t, e, i, s, n, r, o) { const a = this.snapshotState; return a.callback = n, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gameCanvas.width), a.height = Math.min(s, this.gameCanvas.height), this }, snapshotPixel: function (t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this }, batchSprite: function (t, e, i, s) { const n = i.alpha * t.alpha; if (n !== 0) { const r = this.currentContext; const o = this._tempMatrix1; const a = this._tempMatrix2; const h = e.canvasData; let l = h.x; let u = h.y; let c = e.cutWidth; let d = e.cutHeight; const f = e.customPivot; const p = e.source.resolution; const v = t.displayOriginX; const g = t.displayOriginY; let m = -v + e.x; let y = -g + e.y; if (t.isCropped) { const x = t._crop; x.flipX === t.flipX && x.flipY === t.flipY || e.updateCropUVs(x, t.flipX, t.flipY), c = x.cw, d = x.ch, l = x.cx, u = x.cy, m = -v + x.x, y = -g + x.y, t.flipX && (m >= 0 ? m = -(m + c) : m < 0 && (m = Math.abs(m) - c)), t.flipY && (y >= 0 ? y = -(y + d) : y < 0 && (y = Math.abs(y) - d)) } let T = 1; let w = 1; t.flipX && (f || (m += -e.realWidth + 2 * v), T = -1), t.flipY && (f || (y += -e.realHeight + 2 * g), w = -1); const b = t.x; const S = t.y; a.applyITRS(b, S, t.rotation, t.scaleX * T, t.scaleY * w), o.copyFrom(i.matrix), s ? (o.multiplyWithOffset(s, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), a.e = b, a.f = S) : (a.e -= i.scrollX * t.scrollFactorX, a.f -= i.scrollY * t.scrollFactorY), o.multiply(a), i.roundPixels && (o.e = Math.round(o.e), o.f = Math.round(o.f)), r.save(), o.setToContext(r), r.globalCompositeOperation = this.blendModes[t.blendMode], r.globalAlpha = n, r.imageSmoothingEnabled = !e.source.scaleMode, t.mask && t.mask.preRenderCanvas(this, t, i), c > 0 && d > 0 && (i.roundPixels ? r.drawImage(e.source.image, l, u, c, d, Math.round(m), Math.round(y), Math.round(c / p), Math.round(d / p)) : r.drawImage(e.source.image, l, u, c, d, m, y, c / p, d / p)), t.mask && t.mask.postRenderCanvas(this, t, i), r.restore() } }, destroy: function () { this.removeAllListeners(), this.game = null, this.gameCanvas = null, this.gameContext = null } }); t.exports = f }, 55830: (t, e, i) => { t.exports = { CanvasRenderer: i(68627), GetBlendModes: i(56373), SetTransform: i(20926) } }, 56373: (t, e, i) => { const s = i(10312); const n = i(89289); t.exports = function () { const t = []; const e = n.supportNewBlendModes; const i = 'source-over'; return t[s.NORMAL] = i, t[s.ADD] = 'lighter', t[s.MULTIPLY] = e ? 'multiply' : i, t[s.SCREEN] = e ? 'screen' : i, t[s.OVERLAY] = e ? 'overlay' : i, t[s.DARKEN] = e ? 'darken' : i, t[s.LIGHTEN] = e ? 'lighten' : i, t[s.COLOR_DODGE] = e ? 'color-dodge' : i, t[s.COLOR_BURN] = e ? 'color-burn' : i, t[s.HARD_LIGHT] = e ? 'hard-light' : i, t[s.SOFT_LIGHT] = e ? 'soft-light' : i, t[s.DIFFERENCE] = e ? 'difference' : i, t[s.EXCLUSION] = e ? 'exclusion' : i, t[s.HUE] = e ? 'hue' : i, t[s.SATURATION] = e ? 'saturation' : i, t[s.COLOR] = e ? 'color' : i, t[s.LUMINOSITY] = e ? 'luminosity' : i, t[s.ERASE] = 'destination-out', t[s.SOURCE_IN] = 'source-in', t[s.SOURCE_OUT] = 'source-out', t[s.SOURCE_ATOP] = 'source-atop', t[s.DESTINATION_OVER] = 'destination-over', t[s.DESTINATION_IN] = 'destination-in', t[s.DESTINATION_OUT] = 'destination-out', t[s.DESTINATION_ATOP] = 'destination-atop', t[s.LIGHTER] = 'lighter', t[s.COPY] = 'copy', t[s.XOR] = 'xor', t } }, 20926: (t, e, i) => { const s = i(91296); t.exports = function (t, e, i, n, r) { const o = n.alpha * i.alpha; if (o <= 0) return !1; const a = s(i, n, r).calc; return e.globalCompositeOperation = t.blendModes[i.blendMode], e.globalAlpha = o, e.save(), a.setToContext(e), e.imageSmoothingEnabled = i.frame ? !i.frame.source.scaleMode : t.antialias, !0 } }, 63899: t => { t.exports = 'losewebgl' }, 6119: t => { t.exports = 'postrender' }, 48070: t => { t.exports = 'prerender' }, 15640: t => { t.exports = 'render' }, 8912: t => { t.exports = 'resize' }, 87124: t => { t.exports = 'restorewebgl' }, 92503: (t, e, i) => { t.exports = { LOSE_WEBGL: i(63899), POST_RENDER: i(6119), PRE_RENDER: i(48070), RENDER: i(15640), RESIZE: i(8912), RESTORE_WEBGL: i(87124) } }, 36909: (t, e, i) => { t.exports = { Events: i(92503), Snapshot: i(89966) }, t.exports.Canvas = i(55830), t.exports.WebGL = i(4159) }, 32880: (t, e, i) => { const s = i(27919); const n = i(40987); const r = i(95540); t.exports = function (t, e) { const i = r(e, 'callback'); const o = r(e, 'type', 'image/png'); const a = r(e, 'encoder', 0.92); const h = Math.abs(Math.round(r(e, 'x', 0))); const l = Math.abs(Math.round(r(e, 'y', 0))); const u = Math.floor(r(e, 'width', t.width)); const c = Math.floor(r(e, 'height', t.height)); if (r(e, 'getPixel', !1)) { const d = t.getContext('2d', { willReadFrequently: !1 }).getImageData(h, l, 1, 1).data; i.call(null, new n(d[0], d[1], d[2], d[3])) } else if (h !== 0 || l !== 0 || u !== t.width || c !== t.height) { const f = s.createWebGL(this, u, c); const p = f.getContext('2d', { willReadFrequently: !0 }); u > 0 && c > 0 && p.drawImage(t, h, l, u, c, 0, 0, u, c); const v = new Image(); v.onerror = function () { i.call(null), s.remove(f) }, v.onload = function () { i.call(null, v), s.remove(f) }, v.src = f.toDataURL(o, a) } else { const g = new Image(); g.onerror = function () { i.call(null) }, g.onload = function () { i.call(null, g) }, g.src = t.toDataURL(o, a) } } }, 88815: (t, e, i) => { const s = i(27919); const n = i(40987); const r = i(95540); t.exports = function (t, e) { const i = t; const o = r(e, 'callback'); const a = r(e, 'type', 'image/png'); const h = r(e, 'encoder', 0.92); const l = Math.abs(Math.round(r(e, 'x', 0))); const u = Math.abs(Math.round(r(e, 'y', 0))); const c = r(e, 'getPixel', !1); const d = r(e, 'isFramebuffer', !1); const f = d ? r(e, 'bufferWidth', 1) : i.drawingBufferWidth; const p = d ? r(e, 'bufferHeight', 1) : i.drawingBufferHeight; if (c) { const v = new Uint8Array(4); const g = d ? u : p - u; i.readPixels(l, g, 1, 1, i.RGBA, i.UNSIGNED_BYTE, v), o.call(null, new n(v[0], v[1], v[2], v[3])) } else { const m = Math.floor(r(e, 'width', f)); const y = Math.floor(r(e, 'height', p)); const x = m * y * 4; const T = new Uint8Array(x); i.readPixels(l, p - u - y, m, y, i.RGBA, i.UNSIGNED_BYTE, T); for (var w = s.createWebGL(this, m, y), b = w.getContext('2d', { willReadFrequently: !0 }), S = b.getImageData(0, 0, m, y), E = S.data, A = 0; A < y; A++) for (let C = 0; C < m; C++) { const _ = 4 * ((y - A - 1) * m + C); const M = d ? x - 4 * (A * m + (m - C)) : 4 * (A * m + C); E[M + 0] = T[_ + 0], E[M + 1] = T[_ + 1], E[M + 2] = T[_ + 2], E[M + 3] = T[_ + 3] } b.putImageData(S, 0, 0); const P = new Image(); P.onerror = function () { o.call(null), s.remove(w) }, P.onload = function () { o.call(null, P), s.remove(w) }, P.src = w.toDataURL(a, h) } } }, 89966: (t, e, i) => { t.exports = { Canvas: i(32880), WebGL: i(88815) } }, 7530: (t, e, i) => { const s = i(83419); const n = i(36060); const r = i(90330); const o = i(82264); const a = i(95540); const h = i(32302); const l = i(63448); const u = i(31302); const c = i(58918); const d = i(14811); const f = i(92651); const p = i(96569); const v = i(56527); const g = i(57516); const m = i(43439); const y = i(81041); const x = i(12385); const T = i(7589); const w = i(95428); const b = i(72905); const S = new s({ initialize: function (t) { this.game = t.game, this.renderer = t, this.classes = new r([[n.UTILITY_PIPELINE, T], [n.MULTI_PIPELINE, g], [n.BITMAPMASK_PIPELINE, u], [n.SINGLE_PIPELINE, x], [n.ROPE_PIPELINE, y], [n.LIGHT_PIPELINE, p], [n.POINTLIGHT_PIPELINE, m], [n.MOBILE_PIPELINE, v]]), this.postPipelineClasses = new r(), this.pipelines = new r(), this.postPipelineInstances = [], this.default = null, this.current = null, this.previous = null, this.MULTI_PIPELINE = null, this.BITMAPMASK_PIPELINE = null, this.UTILITY_PIPELINE = null, this.MOBILE_PIPELINE = null, this.FX_PIPELINE = null, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderTargets = [], this.maxDimension = 0, this.frameInc = 32, this.targetIndex = 0 }, boot: function (t, e, i) { const s = this.renderer; const r = this.renderTargets; this.frameInc = Math.floor(a(t, 'frameInc', 32)); let l; let u; const p = s.width; const v = s.height; const g = this.game.config.disablePreFX; if (this.game.config.disablePostFX || this.postPipelineClasses.setAll([[String(d.BARREL), c.Barrel], [String(d.BLOOM), c.Bloom], [String(d.BLUR), c.Blur], [String(d.BOKEH), c.Bokeh], [String(d.CIRCLE), c.Circle], [String(d.COLOR_MATRIX), c.ColorMatrix], [String(d.DISPLACEMENT), c.Displacement], [String(d.GLOW), c.Glow], [String(d.GRADIENT), c.Gradient], [String(d.PIXELATE), c.Pixelate], [String(d.SHADOW), c.Shadow], [String(d.SHINE), c.Shine], [String(d.VIGNETTE), c.Vignette], [String(d.WIPE), c.Wipe]]), !g) { this.classes.set(n.FX_PIPELINE, f); for (let m = Math.min(p, v), y = Math.ceil(m / this.frameInc), x = 1; x < y; x++) { const T = x * this.frameInc; r.push(new h(s, T, T)), r.push(new h(s, T, T)), r.push(new h(s, T, T)), this.maxDimension = T } r.push(new h(s, p, v, 1, 0, !0, !0)), r.push(new h(s, p, v, 1, 0, !0, !0)), r.push(new h(s, p, v, 1, 0, !0, !0)) } const w = this; const b = this.game; if (this.classes.each(function (t, e) { l = w.add(t, new e({ game: b })), t === n.UTILITY_PIPELINE && (w.UTILITY_PIPELINE = l, w.fullFrame1 = l.fullFrame1, w.fullFrame2 = l.fullFrame2, w.halfFrame1 = l.halfFrame1, w.halfFrame2 = l.halfFrame2) }), this.MULTI_PIPELINE = this.get(n.MULTI_PIPELINE), this.BITMAPMASK_PIPELINE = this.get(n.BITMAPMASK_PIPELINE), this.MOBILE_PIPELINE = this.get(n.MOBILE_PIPELINE), g || (this.FX_PIPELINE = this.get(n.FX_PIPELINE)), t) for (u in t) { const S = t[u]; (l = new S(b)).name = u, l.isPostFX ? this.postPipelineClasses.set(u, S) : this.has(u) || (this.classes.set(u, S), this.add(u, l)) } this.default = this.get(e), i && !o.os.desktop && (this.default = this.MOBILE_PIPELINE) }, setDefaultPipeline: function (t) { const e = this.get(t); return e && (this.default = e), e }, add: function (t, e) { if (!e.isPostFX) { const i = this.pipelines; const s = this.renderer; return i.has(t) ? console.warn('Pipeline exists: ' + t) : (e.name = t, e.manager = this, i.set(t, e)), e.hasBooted || e.boot(), s.width === 0 || s.height === 0 || e.isPreFX || e.resize(s.width, s.height), e } console.warn(t + ' is a Post Pipeline. Use `addPostPipeline` instead') }, addPostPipeline: function (t, e) { this.postPipelineClasses.has(t) || this.postPipelineClasses.set(t, e) }, flush: function () { this.current && this.current.flush() }, has: function (t) { const e = this.pipelines; return typeof t === 'string' ? e.has(t) : !!e.contains(t) }, get: function (t) { const e = this.pipelines; return typeof t === 'string' ? e.get(t) : e.contains(t) ? t : void 0 }, getPostPipeline: function (t, e, i) { let s; const n = this.postPipelineClasses; let r = ''; const o = typeof t; if (o === 'string' || o === 'number' ? (s = n.get(t), r = t) : o === 'function' ? (n.contains(t) && (s = t), r = t.name) : o === 'object' && (s = n.get(t.name), r = t.name), s) { const a = new s(this.game, i); return a.name = r, e && (a.gameObject = e), this.postPipelineInstances.push(a), a } }, removePostPipeline: function (t) { b(this.postPipelineInstances, t) }, remove: function (t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !0), this.pipelines.delete(t), e && this.classes.delete(t), i && this.postPipelineClasses.delete(t) }, set: function (t, e, i) { if (!t.isPostFX) return this.isCurrent(t, i) || (this.flush(), this.current && this.current.unbind(), this.current = t, t.bind(i)), t.updateProjectionMatrix(), t.onBind(e), t }, preBatch: function (t) { if (t.hasPostPipeline) { this.flush(); for (let e = t.postPipelines, i = e.length - 1; i >= 0; i--) { const s = e[i]; s.active && s.preBatch(t) } } }, postBatch: function (t) { if (t.hasPostPipeline) { this.flush(); for (let e = t.postPipelines, i = 0; i < e.length; i++) { const s = e[i]; s.active && s.postBatch(t) } } }, preBatchCamera: function (t) { if (t.hasPostPipeline) { this.flush(); for (let e = t.postPipelines, i = e.length - 1; i >= 0; i--) { const s = e[i]; s.active && s.preBatch(t) } } }, postBatchCamera: function (t) { if (t.hasPostPipeline) { this.flush(); for (let e = t.postPipelines, i = 0; i < e.length; i++) { const s = e[i]; s.active && s.postBatch(t) } } }, isCurrent: function (t, e) { const i = this.renderer; const s = this.current; return s && !e && (e = s.currentShader), !(s !== t || e.program !== i.currentProgram) }, copyFrame: function (t, e, i, s, n) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyFrame(t, e, i, s, n), this }, copyToGame: function (t) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).copyToGame(t), this }, drawFrame: function (t, e, i, s) { return this.setUtility(this.UTILITY_PIPELINE.colorMatrixShader).drawFrame(t, e, i, s), this }, blendFrames: function (t, e, i, s, n) { return this.setUtility(this.UTILITY_PIPELINE.linearShader).blendFrames(t, e, i, s, n), this }, blendFramesAdditive: function (t, e, i, s, n) { return this.setUtility(this.UTILITY_PIPELINE.addShader).blendFramesAdditive(t, e, i, s, n), this }, clearFrame: function (t, e) { return this.UTILITY_PIPELINE.clearFrame(t, e), this }, blitFrame: function (t, e, i, s, n, r) { return this.setUtility(this.UTILITY_PIPELINE.copyShader).blitFrame(t, e, i, s, n, r), this }, copyFrameRect: function (t, e, i, s, n, r, o, a) { return this.UTILITY_PIPELINE.copyFrameRect(t, e, i, s, n, r, o, a), this }, forceZero: function () { return this.current && this.current.forceZero }, setMulti: function () { return this.set(this.MULTI_PIPELINE) }, setUtility: function (t) { return this.UTILITY_PIPELINE.bind(t) }, setFX: function () { return this.set(this.FX_PIPELINE) }, restoreContext: function () { this.rebind(), this.pipelines.each(function (t, e) { e.restoreContext() }), w(this.postPipelineInstances, function (t) { t.restoreContext() }) }, rebind: function (t) { void 0 === t && this.previous && (t = this.previous); const e = this.renderer; const i = e.gl; i.disable(i.DEPTH_TEST), i.disable(i.CULL_FACE), e.hasActiveStencilMask() ? i.clear(i.DEPTH_BUFFER_BIT) : (i.disable(i.STENCIL_TEST), i.clear(i.DEPTH_BUFFER_BIT | i.STENCIL_BUFFER_BIT)), i.viewport(0, 0, e.width, e.height), e.currentProgram = null, e.setBlendMode(0, !0); const s = e.vaoExtension; s && s.bindVertexArrayOES(null); const n = this.pipelines.entries; for (const r in n) n[r].glReset = !0; t && (this.current = t, t.rebind()) }, clear: function () { const t = this.renderer; this.flush(), this.current ? (this.current.unbind(), this.previous = this.current, this.current = null) : this.previous = null, t.currentProgram = null, t.setBlendMode(0, !0); const e = t.vaoExtension; e && e.bindVertexArrayOES(null) }, getRenderTarget: function (t) { const e = this.renderTargets; if (t > this.maxDimension) return this.targetIndex = e.length - 3, e[this.targetIndex]; const i = 3 * (l(t, this.frameInc, 0, !0) - 1); return this.targetIndex = i, e[i] }, getSwapRenderTarget: function () { return this.renderTargets[this.targetIndex + 1] }, getAltSwapRenderTarget: function () { return this.renderTargets[this.targetIndex + 2] }, destroy: function () { this.flush(), this.classes.clear(), this.postPipelineClasses.clear(), this.pipelines.clear(), this.renderer = null, this.game = null, this.classes = null, this.postPipelineClasses = null, this.pipelines = null, this.default = null, this.current = null, this.previous = null } }); t.exports = S }, 32302: (t, e, i) => { const s = i(83419); const n = i(92503); const r = new s({ initialize: function (t, e, i, s, n, r, o, a, h) { void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = !0), void 0 === h && (h = !0), this.renderer = t, this.framebuffer = null, this.texture = null, this.width = 0, this.height = 0, this.scale = s, this.minFilter = n, this.autoClear = r, this.autoResize = !0, this.hasDepthBuffer = a, this.forceClamp = h, this.resize(e, i), o ? this.setAutoResize(!0) : this.autoResize = !1 }, setAutoResize: function (t) { return t && !this.autoResize ? (this.renderer.on(n.RESIZE, this.resize, this), this.autoResize = !0) : !t && this.autoResize && (this.renderer.off(n.RESIZE, this.resize, this), this.autoResize = !1), this }, resize: function (t, e) { if ((t = Math.round(t * this.scale)) <= 0 && (t = 1), (e = Math.round(e * this.scale)) <= 0 && (e = 1), this.autoResize && (t !== this.width || e !== this.height)) { const i = this.renderer; i.deleteFramebuffer(this.framebuffer), i.deleteTexture(this.texture), this.texture = i.createTextureFromSource(null, t, e, this.minFilter, this.forceClamp), this.framebuffer = i.createFramebuffer(t, e, this.texture, this.hasDepthBuffer), this.width = t, this.height = e } return this }, willResize: function (t, e) { return (t = Math.round(t * this.scale)) <= 0 && (t = 1), (e = Math.round(e * this.scale)) <= 0 && (e = 1), t !== this.width || e !== this.height }, bind: function (t, e, i) { void 0 === t && (t = !1); const s = this.renderer; if (t && s.flush(), e && i && this.resize(e, i), s.pushFramebuffer(this.framebuffer, !1, !1), t && this.adjustViewport(), this.autoClear) { const n = this.renderer.gl; n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT) } s.clearStencilMask() }, adjustViewport: function () { const t = this.renderer.gl; t.viewport(0, 0, this.width, this.height), t.disable(t.SCISSOR_TEST) }, clear: function () { const t = this.renderer; const e = t.gl; t.pushFramebuffer(this.framebuffer), e.disable(e.SCISSOR_TEST), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t.popFramebuffer(), t.resetScissor() }, unbind: function (t) { void 0 === t && (t = !1); const e = this.renderer; return t && e.flush(), e.popFramebuffer() }, destroy: function () { const t = this.renderer; t.off(n.RESIZE, this.resize, this), t.deleteFramebuffer(this.framebuffer), t.deleteTexture(this.texture), this.renderer = null, this.framebuffer = null, this.texture = null } }); t.exports = r }, 70554: t => { t.exports = { getTintFromFloats: function (t, e, i, s) { return ((255 & (255 * s | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0 }, getTintAppendFloatAlpha: function (t, e) { return ((255 & (255 * e | 0)) << 24 | t) >>> 0 }, getTintAppendFloatAlphaAndSwap: function (t, e) { return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0 }, getFloatsFromUintRGB: function (t) { return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255] }, checkShaderMax: function (t, e) { const i = Math.min(16, t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)); return e && e !== -1 ? Math.min(i, e) : i }, parseFragmentShaderMaxTextures: function (t, e) { if (!t) return ''; for (var i = '', s = 0; s < e; s++)s > 0 && (i += '\n\telse '), s < e - 1 && (i += 'if (outTexId < ' + s + '.5)'), i += '\n\t{', i += '\n\t\ttexture = texture2D(uMainSampler[' + s + '], outTexCoord);', i += '\n\t}'; return (t = t.replace(/%count%/gi, e.toString())).replace(/%forloop%/gi, i) }, setGlowQuality: function (t, e, i, s) { return void 0 === i && (i = e.config.glowFXQuality), void 0 === s && (s = e.config.glowFXDistance), t = (t = t.replace(/__SIZE__/gi, (1 / i / s).toFixed(7))).replace(/__DIST__/gi, s.toFixed(0) + '.0') } } }, 29100: (t, e, i) => { const s = i(83419); const n = i(62644); const r = i(50792); const o = i(77085); const a = i(95540); const h = i(37867); const l = i(92503); const u = i(32302); const c = i(70554); const d = i(38683); const f = new s({ Extends: r, initialize: function (t) { r.call(this); const e = t.game; const i = e.renderer; const s = i.gl; this.name = a(t, 'name', 'WebGLPipeline'), this.game = e, this.renderer = i, this.manager, this.gl = s, this.view = e.canvas, this.width = 0, this.height = 0, this.vertexCount = 0, this.vertexCapacity = 0, this.vertexData, this.vertexBuffer, this.activeBuffer, this.topology = a(t, 'topology', s.TRIANGLES), this.bytes, this.vertexViewF32, this.vertexViewU32, this.active = !0, this.forceZero = a(t, 'forceZero', !1), this.hasBooted = !1, this.isPostFX = !1, this.isPreFX = !1, this.renderTargets = [], this.currentRenderTarget, this.shaders = [], this.currentShader, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.config = t, this.glReset = !1, this.batch = [], this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, this.activeTextures = [], this.resizeUniform = a(t, 'resizeUniform', '') }, boot: function () { let t; const e = this.gl; const i = this.config; const s = this.renderer; this.isPostFX || (this.projectionMatrix = (new h()).identity()); const n = this.renderTargets; let r = a(i, 'renderTarget', !1); typeof r === 'boolean' && r && (r = 1); const c = s.width; const d = s.height; if (typeof r === 'number') for (t = 0; t < r; t++)n.push(new u(s, c, d, 1, 0, !0)); else if (Array.isArray(r)) for (t = 0; t < r.length; t++) { const f = a(r[t], 'scale', 1); const p = a(r[t], 'minFilter', 0); const v = a(r[t], 'autoClear', 1); const g = a(r[t], 'autoResize', !1); const m = a(r[t], 'width', null); const y = a(r[t], 'height', m); m ? n.push(new u(s, m, y, 1, p, v, g)) : n.push(new u(s, c, d, f, p, v, g)) } n.length && (this.currentRenderTarget = n[0]), this.setShadersFromConfig(i); const x = this.shaders; let T = 0; for (t = 0; t < x.length; t++)x[t].vertexSize > T && (T = x[t].vertexSize); const w = a(i, 'batchSize', s.config.batchSize); this.vertexCapacity = 6 * w; const b = new ArrayBuffer(this.vertexCapacity * T); this.vertexData = b, this.bytes = new Uint8Array(b), this.vertexViewF32 = new Float32Array(b), this.vertexViewU32 = new Uint32Array(b); const S = a(i, 'vertices', null); for (S ? (this.vertexViewF32.set(S), this.vertexBuffer = s.createVertexBuffer(b, e.STATIC_DRAW)) : this.vertexBuffer = s.createVertexBuffer(b.byteLength, e.DYNAMIC_DRAW), this.setVertexBuffer(), t = x.length - 1; t >= 0; t--)x[t].rebind(); this.hasBooted = !0, s.on(l.RESIZE, this.resize, this), s.on(l.PRE_RENDER, this.onPreRender, this), s.on(l.RENDER, this.onRender, this), s.on(l.POST_RENDER, this.onPostRender, this), this.emit(o.BOOT, this), this.onBoot() }, onBoot: function () { }, onResize: function () { }, setShader: function (t, e, i) { const s = this.renderer; t === this.currentShader && s.currentProgram === this.currentShader.program || (this.flush(), this.setVertexBuffer(i) && !e && (e = !0), t.bind(e, !1), this.currentShader = t); return this }, getShaderByName: function (t) { for (let e = this.shaders, i = 0; i < e.length; i++) if (e[i].name === t) return e[i] }, setShadersFromConfig: function (t) { let e; const i = this.shaders; const s = this.renderer; for (e = 0; e < i.length; e++)i[e].destroy(); const r = 'vertShader'; const o = 'fragShader'; const h = 'attributes'; const l = a(t, r, null); const u = c.parseFragmentShaderMaxTextures(a(t, o, null), s.maxTextures); const f = a(t, h, null); const p = a(t, 'shaders', []); const v = p.length; if (v === 0) l && u && (this.shaders = [new d(this, 'default', l, u, n(f))]); else { const g = []; for (e = 0; e < v; e++) { var m; var y; var x; var T; const w = p[e]; if (typeof w === 'string' ? (m = 'default', y = l, x = c.parseFragmentShaderMaxTextures(w, s.maxTextures), T = f) : (m = a(w, 'name', 'default'), y = a(w, r, l), x = c.parseFragmentShaderMaxTextures(a(w, o, u), s.maxTextures), T = a(w, h, f)), m === 'default') { const b = x.split('\n')[0].trim(); b.indexOf('#define SHADER_NAME') > -1 && (m = b.substring(20)) } y && x && g.push(new d(this, m, y, x, n(T))) } this.shaders = g } return this.shaders.length === 0 ? console.warn('Pipeline: ' + this.name + ' - Invalid shader config') : this.currentShader = this.shaders[0], this }, createBatch: function (t) { return this.currentBatch = { start: this.vertexCount, count: 0, texture: [t], unit: 0, maxUnit: 0 }, this.currentUnit = 0, this.currentTexture = t, this.batch.push(this.currentBatch), 0 }, addTextureToBatch: function (t) { const e = this.currentBatch; e && (e.texture.push(t), e.unit++, e.maxUnit++) }, pushBatch: function (t) { if (!this.currentBatch || this.forceZero && t !== this.currentTexture) return this.createBatch(t); if (t === this.currentTexture) return this.currentUnit; const e = this.currentBatch; const i = e.texture.indexOf(t); return i === -1 ? e.texture.length === this.renderer.maxTextures ? this.createBatch(t) : (e.unit++, e.maxUnit++, e.texture.push(t), this.currentUnit = e.unit, this.currentTexture = t, e.unit) : (this.currentUnit = i, this.currentTexture = t, i) }, setGameObject: function (t, e) { return void 0 === e && (e = t.frame), this.pushBatch(e.source.glTexture) }, shouldFlush: function (t) { return void 0 === t && (t = 0), this.vertexCount + t > this.vertexCapacity }, vertexAvailable: function () { return this.vertexCapacity - this.vertexCount }, resize: function (t, e) { t === this.width && e === this.height || this.flush(), this.width = t, this.height = e; for (let i = this.renderTargets, s = 0; s < i.length; s++)i[s].resize(t, e); return this.setProjectionMatrix(t, e), this.resizeUniform && this.set2f(this.resizeUniform, t, e), this.emit(o.RESIZE, t, e, this), this.onResize(t, e), this }, setProjectionMatrix: function (t, e) { const i = this.projectionMatrix; if (!i) return this; this.projectionWidth = t, this.projectionHeight = e, i.ortho(0, t, e, 0, -1e3, 1e3); for (let s = this.shaders, n = 'uProjectionMatrix', r = 0; r < s.length; r++) { const o = s[r]; o.hasUniform(n) && (o.resetUniform(n), o.setMatrix4fv(n, !1, i.val, o)) } return this }, flipProjectionMatrix: function (t) { void 0 === t && (t = !0); const e = this.projectionMatrix; if (!e) return this; const i = this.projectionWidth; const s = this.projectionHeight; t ? e.ortho(0, i, 0, s, -1e3, 1e3) : e.ortho(0, i, s, 0, -1e3, 1e3), this.setMatrix4fv('uProjectionMatrix', !1, e.val) }, updateProjectionMatrix: function () { if (this.projectionMatrix) { const t = this.renderer.projectionWidth; const e = this.renderer.projectionHeight; this.projectionWidth === t && this.projectionHeight === e || this.setProjectionMatrix(t, e) } }, bind: function (t) { if (void 0 === t && (t = this.currentShader), this.glReset) return this.rebind(t); let e = !1; const i = this.gl; return i.getParameter(i.ARRAY_BUFFER_BINDING) !== this.vertexBuffer && (i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer.webGLBuffer), this.activeBuffer = this.vertexBuffer, e = !0), t.bind(e), this.currentShader = t, this.activeTextures.length = 0, this.emit(o.BIND, this, t), this.onActive(t), this }, rebind: function (t) { this.activeBuffer = null, this.setVertexBuffer(); for (let e = this.shaders, i = e.length - 1; i >= 0; i--) { const s = e[i].rebind(); t && s !== t || (this.currentShader = s) } return this.activeTextures.length = 0, this.emit(o.REBIND, this.currentShader), this.onActive(this.currentShader), this.onRebind(), this.glReset = !1, this }, restoreContext: function () { const t = this.shaders; const e = !!this.vertexBuffer; this.activeBuffer = null, this.activeTextures.length = 0, this.batch.length = 0, this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, e && this.setVertexBuffer(); for (let i = 0; i < t.length; i++) { const s = t[i]; s.syncUniforms(), e && s.rebind() } }, setVertexBuffer: function (t) { if (void 0 === t && (t = this.vertexBuffer), t !== this.activeBuffer) { const e = this.gl; return this.gl.bindBuffer(e.ARRAY_BUFFER, t.webGLBuffer), this.activeBuffer = t, !0 } return !1 }, preBatch: function (t) { return this.currentRenderTarget && this.currentRenderTarget.bind(), this.onPreBatch(t), this }, postBatch: function (t) { return this.onDraw(this.currentRenderTarget), this.onPostBatch(t), this }, onDraw: function () { }, unbind: function () { this.currentRenderTarget && this.currentRenderTarget.unbind() }, flush: function (t) { if (void 0 === t && (t = !1), this.vertexCount > 0) { this.emit(o.BEFORE_FLUSH, this, t), this.onBeforeFlush(t); const e = this.gl; const i = this.vertexCount; const s = this.currentShader.vertexSize; const n = this.topology; if (this.active) { let r, a, h; this.setVertexBuffer(), i === this.vertexCapacity ? e.bufferData(e.ARRAY_BUFFER, this.vertexData, e.DYNAMIC_DRAW) : e.bufferSubData(e.ARRAY_BUFFER, 0, this.bytes.subarray(0, i * s)); const l = this.batch; const u = this.activeTextures; if (this.forceZero) for (u[0] || e.activeTexture(e.TEXTURE0), r = 0; r < l.length; r++)h = (a = l[r]).texture[0], u[0] !== h && (e.bindTexture(e.TEXTURE_2D, h.webGLTexture), u[0] = h), e.drawArrays(n, a.start, a.count); else for (r = 0; r < l.length; r++) { a = l[r]; for (let c = 0; c <= a.maxUnit; c++)h = a.texture[c], u[c] !== h && (e.activeTexture(e.TEXTURE0 + c), e.bindTexture(e.TEXTURE_2D, h.webGLTexture), u[c] = h); e.drawArrays(n, a.start, a.count) } } this.vertexCount = 0, this.batch.length = 0, this.currentBatch = null, this.currentTexture = null, this.currentUnit = 0, this.emit(o.AFTER_FLUSH, this, t), this.onAfterFlush(t) } return this }, onActive: function () { }, onBind: function () { }, onRebind: function () { }, onBatch: function () { }, onPreBatch: function () { }, onPostBatch: function () { }, onPreRender: function () { }, onRender: function () { }, onPostRender: function () { }, onBeforeFlush: function () { }, onAfterFlush: function () { }, batchVert: function (t, e, i, s, n, r, o) { const a = this.vertexViewF32; const h = this.vertexViewU32; let l = this.vertexCount * this.currentShader.vertexComponentCount - 1; a[++l] = t, a[++l] = e, a[++l] = i, a[++l] = s, a[++l] = n, a[++l] = r, h[++l] = o, this.vertexCount++, this.currentBatch.count = this.vertexCount - this.currentBatch.start }, batchQuad: function (t, e, i, s, n, r, o, a, h, l, u, c, d, f, p, v, g, m, y, x) { void 0 === x && (x = this.currentUnit); let T = !1; this.shouldFlush(6) && (this.flush(), T = !0), this.currentBatch || (x = this.setTexture2D(y)); const w = this.vertexViewF32; const b = this.vertexViewU32; let S = this.vertexCount * this.currentShader.vertexComponentCount - 1; return w[++S] = e, w[++S] = i, w[++S] = l, w[++S] = u, w[++S] = x, w[++S] = m, b[++S] = f, w[++S] = s, w[++S] = n, w[++S] = l, w[++S] = d, w[++S] = x, w[++S] = m, b[++S] = v, w[++S] = r, w[++S] = o, w[++S] = c, w[++S] = d, w[++S] = x, w[++S] = m, b[++S] = g, w[++S] = e, w[++S] = i, w[++S] = l, w[++S] = u, w[++S] = x, w[++S] = m, b[++S] = f, w[++S] = r, w[++S] = o, w[++S] = c, w[++S] = d, w[++S] = x, w[++S] = m, b[++S] = g, w[++S] = a, w[++S] = h, w[++S] = c, w[++S] = u, w[++S] = x, w[++S] = m, b[++S] = p, this.vertexCount += 6, this.currentBatch.count = this.vertexCount - this.currentBatch.start, this.onBatch(t), T }, batchTri: function (t, e, i, s, n, r, o, a, h, l, u, c, d, f, p, v, g) { void 0 === g && (g = this.currentUnit); let m = !1; this.shouldFlush(3) && (this.flush(), m = !0), this.currentBatch || (g = this.setTexture2D(v)); const y = this.vertexViewF32; const x = this.vertexViewU32; let T = this.vertexCount * this.currentShader.vertexComponentCount - 1; return y[++T] = e, y[++T] = i, y[++T] = a, y[++T] = h, y[++T] = g, y[++T] = p, x[++T] = c, y[++T] = s, y[++T] = n, y[++T] = a, y[++T] = u, y[++T] = g, y[++T] = p, x[++T] = d, y[++T] = r, y[++T] = o, y[++T] = l, y[++T] = u, y[++T] = g, y[++T] = p, x[++T] = f, this.vertexCount += 3, this.currentBatch.count = this.vertexCount - this.currentBatch.start, this.onBatch(t), m }, drawFillRect: function (t, e, i, s, n, r, o, a) { void 0 === o && (o = this.renderer.whiteTexture), void 0 === a && (a = !0), t = Math.floor(t), e = Math.floor(e); const h = Math.floor(t + i); const l = Math.floor(e + s); const u = this.setTexture2D(o); const d = c.getTintAppendFloatAlphaAndSwap(n, r); let f = 0; let p = 1; a && (f = 1, p = 0), this.batchQuad(null, t, e, t, l, h, l, h, e, 0, f, 1, p, d, d, d, d, 0, o, u) }, setTexture2D: function (t) { return void 0 === t && (t = this.renderer.whiteTexture), this.pushBatch(t) }, bindTexture: function (t, e) { void 0 === e && (e = 0); const i = this.gl; return i.activeTexture(i.TEXTURE0 + e), i.bindTexture(i.TEXTURE_2D, t.webGLTexture), this }, bindRenderTarget: function (t, e) { return this.bindTexture(t.texture, e) }, setTime: function (t, e) { return this.set1f(t, this.game.loop.getDuration(), e), this }, setBoolean: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.setBoolean(t, e), this }, set1f: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set1f(t, e), this }, set2f: function (t, e, i, s) { return void 0 === s && (s = this.currentShader), s.set2f(t, e, i), this }, set3f: function (t, e, i, s, n) { return void 0 === n && (n = this.currentShader), n.set3f(t, e, i, s), this }, set4f: function (t, e, i, s, n, r) { return void 0 === r && (r = this.currentShader), r.set4f(t, e, i, s, n), this }, set1fv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set1fv(t, e), this }, set2fv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set2fv(t, e), this }, set3fv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set3fv(t, e), this }, set4fv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set4fv(t, e), this }, set1iv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set1iv(t, e), this }, set2iv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set2iv(t, e), this }, set3iv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set3iv(t, e), this }, set4iv: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set4iv(t, e), this }, set1i: function (t, e, i) { return void 0 === i && (i = this.currentShader), i.set1i(t, e), this }, set2i: function (t, e, i, s) { return void 0 === s && (s = this.currentShader), s.set2i(t, e, i), this }, set3i: function (t, e, i, s, n) { return void 0 === n && (n = this.currentShader), n.set3i(t, e, i, s), this }, set4i: function (t, e, i, s, n, r) { return void 0 === r && (r = this.currentShader), r.set4i(t, e, i, s, n), this }, setMatrix2fv: function (t, e, i, s) { return void 0 === s && (s = this.currentShader), s.setMatrix2fv(t, e, i), this }, setMatrix3fv: function (t, e, i, s) { return void 0 === s && (s = this.currentShader), s.setMatrix3fv(t, e, i), this }, setMatrix4fv: function (t, e, i, s) { return void 0 === s && (s = this.currentShader), s.setMatrix4fv(t, e, i), this }, destroy: function () { let t; this.emit(o.DESTROY, this); const e = this.shaders; for (t = 0; t < e.length; t++)e[t].destroy(); const i = this.renderTargets; for (t = 0; t < i.length; t++)i[t].destroy(); const s = this.renderer; return s.deleteBuffer(this.vertexBuffer), s.off(l.RESIZE, this.resize, this), s.off(l.PRE_RENDER, this.onPreRender, this), s.off(l.RENDER, this.onRender, this), s.off(l.POST_RENDER, this.onPostRender, this), this.removeAllListeners(), this.game = null, this.renderer = null, this.manager = null, this.gl = null, this.view = null, this.shaders = null, this.renderTargets = null, this.bytes = null, this.vertexViewF32 = null, this.vertexViewU32 = null, this.vertexData = null, this.vertexBuffer = null, this.currentShader = null, this.currentRenderTarget = null, this.activeTextures = null, this } }); t.exports = f }, 74797: (t, e, i) => { const s = i(95428); const n = i(72905); const r = i(19715); const o = i(83419); const a = i(8054); const h = i(50792); const l = i(92503); const u = i(50030); const c = i(37867); const d = i(29747); const f = i(7530); const p = i(32302); const v = i(97480); const g = i(69442); const m = i(70554); const y = i(88815); const x = i(26128); const T = i(1482); const w = i(82751); const b = i(84387); const S = i(93567); const E = i(57183); const A = !1; const C = new o({ Extends: h, initialize: function (t) { h.call(this); const e = t.config; const i = { alpha: e.transparent, desynchronized: e.desynchronized, depth: !0, antialias: e.antialiasGL, premultipliedAlpha: e.premultipliedAlpha, stencil: !0, failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat, powerPreference: e.powerPreference, preserveDrawingBuffer: e.preserveDrawingBuffer, willReadFrequently: !1 }; this.config = { clearBeforeRender: e.clearBeforeRender, antialias: e.antialias, backgroundColor: e.backgroundColor, contextCreation: i, roundPixels: e.roundPixels, maxTextures: e.maxTextures, maxTextureSize: e.maxTextureSize, batchSize: e.batchSize, maxLights: e.maxLights, mipmapFilter: e.mipmapFilter }, this.game = t, this.type = a.WEBGL, this.pipelines = null, this.width = 0, this.height = 0, this.canvas = t.canvas, this.blendModes = [], this.contextLost = !1, this.snapshotState = { x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92, isFramebuffer: !1, bufferWidth: 0, bufferHeight: 0 }, this.maxTextures = 0, this.textureIndexes, this.glBufferWrappers = [], this.glProgramWrappers = [], this.glTextureWrappers = [], this.glFramebufferWrappers = [], this.glAttribLocationWrappers = [], this.glUniformLocationWrappers = [], this.currentFramebuffer = null, this.fboStack = [], this.currentProgram = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = d, this.contextRestoredHandler = d, this.gl = null, this.supportedExtensions = null, this.instancedArraysExtension = null, this.vaoExtension = null, this.extensions = {}, this.glFormats, this.compression, this.drawingBufferHeight = 0, this.blankTexture = null, this.normalTexture = null, this.whiteTexture = null, this.maskCount = 0, this.maskStack = [], this.currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null }, this.glFuncMap = null, this.currentType = '', this.newType = !1, this.nextTypeMatch = !1, this.finalType = !1, this.mipmapFilter = null, this.defaultScissor = [0, 0, 0, 0], this.isBooted = !1, this.renderTarget = null, this.projectionMatrix, this.projectionWidth = 0, this.projectionHeight = 0, this.maskSource = null, this.maskTarget = null, this.spector = null, this._debugCapture = !1, this.init(this.config) }, init: function (t) { let e; const i = this.game; const n = this.canvas; const r = t.backgroundColor; if (!(e = i.config.context ? i.config.context : n.getContext('webgl', t.contextCreation) || n.getContext('experimental-webgl', t.contextCreation)) || e.isContextLost()) throw this.contextLost = !0, new Error('WebGL unsupported'); this.gl = e; const o = this; const h = function () { const t = e.getSupportedExtensions(); o.supportedExtensions = t; const i = 'ANGLE_instanced_arrays'; o.instancedArraysExtension = t.indexOf(i) > -1 ? e.getExtension(i) : null; const s = 'OES_vertex_array_object'; o.vaoExtension = t.indexOf(s) > -1 ? e.getExtension(s) : null }; h(), this.contextLostHandler = function (t) { o.contextLost = !0, console && console.warn('WebGL Context lost. Renderer disabled'), o.emit(l.LOSE_WEBGL, o), t.preventDefault() }, n.addEventListener('webglcontextlost', this.contextLostHandler, !1), this.contextRestoredHandler = function (t) { if (e.isContextLost()) console && console.log('WebGL Context restored, but context is still lost'); else { o.currentProgram = null, o.currentFramebuffer = null, o.setBlendMode(a.BlendModes.NORMAL), e.disable(e.BLEND), e.disable(e.DEPTH_TEST), e.enable(e.CULL_FACE), o.compression = o.getCompressedTextures(); const i = function (t) { t.createResource() }; s(o.glTextureWrappers, i), s(o.glBufferWrappers, i), s(o.glFramebufferWrappers, i), s(o.glProgramWrappers, i), s(o.glAttribLocationWrappers, i), s(o.glUniformLocationWrappers, i), o.createTemporaryTextures(), o.pipelines.restoreContext(), o.resize(o.game.scale.baseSize.width, o.game.scale.baseSize.height), h(), o.contextLost = !1, console && console.warn('WebGL Context restored. Renderer running again.'), o.emit(l.RESTORE_WEBGL, o), t.preventDefault() } }, n.addEventListener('webglcontextrestored', this.contextRestoredHandler, !1), i.context = e; for (let u = 0; u <= 27; u++) this.blendModes.push({ func: [e.ONE, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_ADD }); this.blendModes[1].func = [e.ONE, e.DST_ALPHA], this.blendModes[2].func = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [e.ONE, e.ONE_MINUS_SRC_COLOR], this.blendModes[17] = { func: [e.ZERO, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_REVERSE_SUBTRACT }, this.glFormats = [e.BYTE, e.SHORT, e.UNSIGNED_BYTE, e.UNSIGNED_SHORT, e.FLOAT], this.glFuncMap = { mat2: { func: e.uniformMatrix2fv, length: 1, matrix: !0 }, mat3: { func: e.uniformMatrix3fv, length: 1, matrix: !0 }, mat4: { func: e.uniformMatrix4fv, length: 1, matrix: !0 }, '1f': { func: e.uniform1f, length: 1 }, '1fv': { func: e.uniform1fv, length: 1 }, '1i': { func: e.uniform1i, length: 1 }, '1iv': { func: e.uniform1iv, length: 1 }, '2f': { func: e.uniform2f, length: 2 }, '2fv': { func: e.uniform2fv, length: 1 }, '2i': { func: e.uniform2i, length: 2 }, '2iv': { func: e.uniform2iv, length: 1 }, '3f': { func: e.uniform3f, length: 3 }, '3fv': { func: e.uniform3fv, length: 1 }, '3i': { func: e.uniform3i, length: 3 }, '3iv': { func: e.uniform3iv, length: 1 }, '4f': { func: e.uniform4f, length: 4 }, '4fv': { func: e.uniform4fv, length: 1 }, '4i': { func: e.uniform4i, length: 4 }, '4iv': { func: e.uniform4iv, length: 1 } }, t.maxTextures && t.maxTextures !== -1 || (t.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)), this.compression = this.getCompressedTextures(), e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), e.enable(e.BLEND), e.clearColor(r.redGL, r.greenGL, r.blueGL, r.alphaGL); return ['NEAREST', 'LINEAR', 'NEAREST_MIPMAP_NEAREST', 'LINEAR_MIPMAP_NEAREST', 'NEAREST_MIPMAP_LINEAR', 'LINEAR_MIPMAP_LINEAR'].indexOf(t.mipmapFilter) !== -1 && (this.mipmapFilter = e[t.mipmapFilter]), this.maxTextures = m.checkShaderMax(e, t.maxTextures), this.textureIndexes = [], this.createTemporaryTextures(), this.pipelines = new f(this), this.setBlendMode(a.BlendModes.NORMAL), this.projectionMatrix = (new c()).identity(), i.textures.once(g.READY, this.boot, this), this }, boot: function () { const t = this.game; const e = this.pipelines; const i = t.scale.baseSize; const s = i.width; const n = i.height; this.width = s, this.height = n, this.isBooted = !0, this.renderTarget = new p(this, s, n, 1, 0, !0, !0), this.maskTarget = new p(this, s, n, 1, 0, !0, !0), this.maskSource = new p(this, s, n, 1, 0, !0, !0); const r = t.config; e.boot(r.pipeline, r.defaultPipeline, r.autoMobilePipeline), this.blankTexture = t.textures.getFrame('__DEFAULT').glTexture, this.normalTexture = t.textures.getFrame('__NORMAL').glTexture, this.whiteTexture = t.textures.getFrame('__WHITE').glTexture; const o = this.gl; o.bindFramebuffer(o.FRAMEBUFFER, null), o.enable(o.SCISSOR_TEST), t.scale.on(v.RESIZE, this.onResize, this), this.resize(s, n) }, createTemporaryTextures: function () { for (let t = this.gl, e = 0; e < this.maxTextures; e++) { const i = t.createTexture(); t.activeTexture(t.TEXTURE0 + e), t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])), this.textureIndexes.push(e) } }, captureFrame: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1) }, captureNextFrame: function () { A }, getFps: function () { A }, log: function () { }, startCapture: function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === i && (i = !1) }, stopCapture: function () { A }, onCapture: function (t) { }, onResize: function (t, e) { e.width === this.width && e.height === this.height || this.resize(e.width, e.height) }, beginCapture: function (t, e) { void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.renderTarget.bind(!0, t, e), this.setProjectionMatrix(t, e) }, endCapture: function () { return this.renderTarget.unbind(!0), this.resetProjectionMatrix(), this.renderTarget }, resize: function (t, e) { const i = this.gl; return this.width = t, this.height = e, this.setProjectionMatrix(t, e), i.viewport(0, 0, t, e), this.drawingBufferHeight = i.drawingBufferHeight, i.scissor(0, i.drawingBufferHeight - e, t, e), this.defaultScissor[2] = t, this.defaultScissor[3] = e, this.emit(l.RESIZE, t, e), this }, getCompressedTextures: function () { const t = 'WEBGL_compressed_texture_'; const e = 'WEBKIT_' + t; const i = function (i, s) { const n = i.getExtension(t + s) || i.getExtension(e + s) || i.getExtension('EXT_texture_compression_' + s); if (n) { const r = {}; for (const o in n) r[n[o]] = o; return r } }; const s = this.gl; return { ETC: i(s, 'etc'), ETC1: i(s, 'etc1'), ATC: i(s, 'atc'), ASTC: i(s, 'astc'), BPTC: i(s, 'bptc'), RGTC: i(s, 'rgtc'), PVRTC: i(s, 'pvrtc'), S3TC: i(s, 's3tc'), S3TCSRGB: i(s, 's3tc_srgb'), IMG: !0 } }, getCompressedTextureName: function (t, e) { const i = this.compression[t.toUpperCase()]; if (e in i) return i[e] }, supportsCompressedTexture: function (t, e) { const i = this.compression[t.toUpperCase()]; return !!i && (!e || e in i) }, getAspectRatio: function () { return this.width / this.height }, setProjectionMatrix: function (t, e) { return t === this.projectionWidth && e === this.projectionHeight || (this.projectionWidth = t, this.projectionHeight = e, this.projectionMatrix.ortho(0, t, e, 0, -1e3, 1e3)), this }, resetProjectionMatrix: function () { return this.setProjectionMatrix(this.width, this.height) }, hasExtension: function (t) { return !!this.supportedExtensions && this.supportedExtensions.indexOf(t) }, getExtension: function (t) { return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null }, flush: function () { this.pipelines.flush() }, pushScissor: function (t, e, i, s, n) { void 0 === n && (n = this.drawingBufferHeight); const r = [t, e, i, s]; return this.scissorStack.push(r), this.setScissor(t, e, i, s, n), this.currentScissor = r, r }, setScissor: function (t, e, i, s, n) { void 0 === n && (n = this.drawingBufferHeight); const r = this.gl; const o = this.currentScissor; let a = i > 0 && s > 0; if (o && a) { const h = o[0]; const l = o[1]; const u = o[2]; const c = o[3]; a = h !== t || l !== e || u !== i || c !== s } a && (this.flush(), r.scissor(t, n - e - s, i, s)) }, resetScissor: function () { const t = this.gl; t.enable(t.SCISSOR_TEST); const e = this.currentScissor; if (e) { const i = e[0]; const s = e[1]; const n = e[2]; const r = e[3]; n > 0 && r > 0 && t.scissor(i, this.drawingBufferHeight - s - r, n, r) } }, popScissor: function () { const t = this.scissorStack; t.pop(); const e = t[t.length - 1]; e && this.setScissor(e[0], e[1], e[2], e[3]), this.currentScissor = e }, hasActiveStencilMask: function () { const t = this.currentMask.mask; const e = this.currentCameraMask.mask; return t && t.isStencil || e && e.isStencil }, resetViewport: function () { const t = this.gl; t.viewport(0, 0, this.width, this.height), this.drawingBufferHeight = t.drawingBufferHeight }, setBlendMode: function (t, e) { void 0 === e && (e = !1); const i = this.gl; const s = this.blendModes[t]; return !!(e || t !== a.BlendModes.SKIP_CHECK && this.currentBlendMode !== t) && (this.flush(), i.enable(i.BLEND), i.blendEquation(s.equation), s.func.length > 2 ? i.blendFuncSeparate(s.func[0], s.func[1], s.func[2], s.func[3]) : i.blendFunc(s.func[0], s.func[1]), this.currentBlendMode = t, !0) }, addBlendMode: function (t, e) { return this.blendModes.push({ func: t, equation: e }) - 1 }, updateBlendMode: function (t, e, i) { return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this }, removeBlendMode: function (t) { return t > 17 && this.blendModes[t] && this.blendModes.splice(t, 1), this }, pushFramebuffer: function (t, e, i, s, n) { return t === this.currentFramebuffer ? this : (this.fboStack.push(t), this.setFramebuffer(t, e, i, s, n)) }, setFramebuffer: function (t, e, i, s, n) { if (void 0 === e && (e = !1), void 0 === i && (i = !0), void 0 === s && (s = null), void 0 === n && (n = !1), t === this.currentFramebuffer) return this; const r = this.gl; let o = this.width; let a = this.height; return t && t.renderTexture && i ? (o = t.renderTexture.width, a = t.renderTexture.height) : this.flush(), t ? r.bindFramebuffer(r.FRAMEBUFFER, t.webGLFramebuffer) : r.bindFramebuffer(r.FRAMEBUFFER, null), i && r.viewport(0, 0, o, a), s && r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, s.webGLTexture, 0), n && (r.clearColor(0, 0, 0, 0), r.clear(r.COLOR_BUFFER_BIT)), e && (t ? (this.drawingBufferHeight = a, this.pushScissor(0, 0, o, a)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = t, this }, popFramebuffer: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !0); const i = this.fboStack; i.pop(); let s = i[i.length - 1]; return s || (s = null), this.setFramebuffer(s, t, e), s }, restoreFramebuffer: function (t, e) { void 0 === t && (t = !1), void 0 === e && (e = !0); const i = this.fboStack; let s = i[i.length - 1]; s || (s = null), this.currentFramebuffer = null, this.setFramebuffer(s, t, e) }, setProgram: function (t) { return t !== this.currentProgram && (this.flush(), this.gl.useProgram(t.webGLProgram), this.currentProgram = t, !0) }, resetProgram: function () { return this.gl.useProgram(this.currentProgram.webGLProgramWrapper), this }, createTextureFromSource: function (t, e, i, s, n) { void 0 === n && (n = !1); const r = this.gl; let o = r.NEAREST; let h = r.NEAREST; let l = r.CLAMP_TO_EDGE; e = t ? t.width : e, i = t ? t.height : i; const c = u(e, i); if (c && !n && (l = r.REPEAT), s === a.ScaleModes.LINEAR && this.config.antialias) { const d = t && t.compressed; const f = !d && c || d && t.mipmaps.length > 1; o = this.mipmapFilter && f ? this.mipmapFilter : r.LINEAR, h = r.LINEAR } return t || typeof e !== 'number' || typeof i !== 'number' ? this.createTexture2D(0, o, h, l, l, r.RGBA, t) : this.createTexture2D(0, o, h, l, l, r.RGBA, null, e, i) }, createTexture2D: function (t, e, i, s, n, r, o, a, h, l, u, c) { typeof a !== 'number' && (a = o ? o.width : 1), typeof h !== 'number' && (h = o ? o.height : 1); const d = new w(this.gl, t, e, i, s, n, r, o, a, h, l, u, c); return this.glTextureWrappers.push(d), d }, createFramebuffer: function (t, e, i, s) { this.currentFramebuffer = null; const n = new b(this.gl, t, e, i, s); return this.glFramebufferWrappers.push(n), n }, beginBitmapMask: function (t, e) { this.gl && (this.flush(), this.maskTarget.bind(!0), this.currentCameraMask.mask !== t && (this.currentMask.mask = t, this.currentMask.camera = e)) }, drawBitmapMask: function (t, e, i) { this.flush(), this.maskSource.bind(), this.setBlendMode(0, !0), t.renderWebGL(this, t, e), this.maskSource.unbind(!0), this.maskTarget.unbind(); const s = this.gl; const n = this.getCurrentStencilMask(); n ? (s.enable(s.STENCIL_TEST), n.mask.applyStencil(this, n.camera, !0)) : this.currentMask.mask = null, this.pipelines.set(i), s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, this.maskTarget.texture.webGLTexture), s.activeTexture(s.TEXTURE1), s.bindTexture(s.TEXTURE_2D, this.maskSource.texture.webGLTexture) }, createProgram: function (t, e) { const i = new T(this.gl, t, e); return this.glProgramWrappers.push(i), i }, createVertexBuffer: function (t, e) { const i = this.gl; const s = new x(i, t, i.ARRAY_BUFFER, e); return this.glBufferWrappers.push(s), s }, createAttribLocation: function (t, e) { const i = new S(this.gl, t, e); return this.glAttribLocationWrappers.push(i), i }, createUniformLocation: function (t, e) { const i = new E(this.gl, t, e); return this.glUniformLocationWrappers.push(i), i }, createIndexBuffer: function (t, e) { const i = this.gl; const s = new x(i, t, i.ELEMENT_ARRAY_BUFFER, e); return this.glBufferWrappers.push(s), s }, deleteTexture: function (t) { if (t) return n(this.glTextureWrappers, t), t.destroy(), this }, deleteFramebuffer: function (t) { return t ? (n(this.fboStack, t), n(this.glFramebufferWrappers, t), t.destroy(), this) : this }, deleteProgram: function (t) { return t && (n(this.glProgramWrappers, t), t.destroy()), this }, deleteAttribLocation: function (t) { return t && (n(this.glAttribLocationWrappers, t), t.destroy()), this }, deleteUniformLocation: function (t) { return t && (n(this.glUniformLocationWrappers, t), t.destroy()), this }, deleteBuffer: function (t) { return t ? (n(this.glBufferWrappers, t), t.destroy(), this) : this }, preRenderCamera: function (t) { const e = t.x; const i = t.y; const s = t.width; const n = t.height; const o = t.backgroundColor; (t.emit(r.PRE_RENDER, t), this.pipelines.preBatchCamera(t), this.pushScissor(e, i, s, n), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), o.alphaGL > 0) && this.pipelines.setMulti().drawFillRect(e, i, s, n, m.getTintFromFloats(o.blueGL, o.greenGL, o.redGL, 1), o.alphaGL) }, getCurrentStencilMask: function () { let t = null; const e = this.maskStack; const i = this.currentCameraMask; return e.length > 0 ? t = e[e.length - 1] : i.mask && i.mask.isStencil && (t = i), t }, postRenderCamera: function (t) { const e = t.flashEffect; const i = t.fadeEffect; if (e.isRunning || i.isRunning || i.isComplete) { const s = this.pipelines.setMulti(); e.postRenderWebGL(s, m.getTintFromFloats), i.postRenderWebGL(s, m.getTintFromFloats) } t.dirty = !1, this.popScissor(), t.mask && (this.currentCameraMask.mask = null, t.mask.postRenderWebGL(this, t._maskCamera)), this.pipelines.postBatchCamera(t), t.emit(r.POST_RENDER, t) }, preRender: function () { if (!this.contextLost) { const t = this.gl; if (t.bindFramebuffer(t.FRAMEBUFFER, null), this.config.clearBeforeRender) { const e = this.config.backgroundColor; t.clearColor(e.redGL, e.greenGL, e.blueGL, e.alphaGL), t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT) } t.enable(t.SCISSOR_TEST), this.currentScissor = this.defaultScissor, this.scissorStack.length = 0, this.scissorStack.push(this.currentScissor), this.game.scene.customViewports && t.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.emit(l.PRE_RENDER) } }, render: function (t, e, i) { if (!this.contextLost) { const s = e.length; if (this.emit(l.RENDER, t, i), this.preRenderCamera(i), s === 0) return this.setBlendMode(a.BlendModes.NORMAL), void this.postRenderCamera(i); this.currentType = ''; for (var n = this.currentMask, r = 0; r < s; r++) { this.finalType = r === s - 1; const o = e[r]; const h = o.mask; (n = this.currentMask).mask && n.mask !== h && n.mask.postRenderWebGL(this, n.camera), h && n.mask !== h && h.preRenderWebGL(this, o, i), o.blendMode !== this.currentBlendMode && this.setBlendMode(o.blendMode); const u = o.type; u !== this.currentType && (this.newType = !0, this.currentType = u), this.finalType ? this.nextTypeMatch = !1 : this.nextTypeMatch = e[r + 1].type === this.currentType, o.renderWebGL(this, o, i), this.newType = !1 } (n = this.currentMask).mask && n.mask.postRenderWebGL(this, n.camera), this.setBlendMode(a.BlendModes.NORMAL), this.postRenderCamera(i) } }, postRender: function () { if (!this.contextLost) { this.flush(), this.emit(l.POST_RENDER); const t = this.snapshotState; t.callback && (y(this.gl, t), t.callback = null) } }, clearStencilMask: function () { this.gl.disable(this.gl.STENCIL_TEST) }, restoreStencilMask: function () { const t = this.gl; const e = this.getCurrentStencilMask(); if (e) { const i = e.mask; t.enable(t.STENCIL_TEST), i.invertAlpha ? t.stencilFunc(t.NOTEQUAL, i.level, 255) : t.stencilFunc(t.EQUAL, i.level, 255) } }, snapshot: function (t, e, i) { return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, t, e, i) }, snapshotArea: function (t, e, i, s, n, r, o) { const a = this.snapshotState; return a.callback = n, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = i, a.height = s, this }, snapshotPixel: function (t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this }, snapshotFramebuffer: function (t, e, i, s, n, r, o, a, h, l, u) { void 0 === n && (n = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = e), void 0 === h && (h = i), l === 'pixel' && (n = !0, l = 'image/png'); const c = this.currentFramebuffer; this.snapshotArea(r, o, a, h, s, l, u); const d = this.snapshotState; return d.getPixel = n, d.isFramebuffer = !0, d.bufferWidth = e, d.bufferHeight = i, d.width = Math.min(d.width, e), d.height = Math.min(d.height, i), this.setFramebuffer(t), y(this.gl, d), this.setFramebuffer(c), d.callback = null, d.isFramebuffer = !1, this }, canvasToTexture: function (t, e, i, s) { void 0 === i && (i = !1), void 0 === s && (s = !1); const n = this.gl; let r = n.NEAREST; let o = n.NEAREST; const a = t.width; const h = t.height; let l = n.CLAMP_TO_EDGE; const c = u(a, h); return !i && c && (l = n.REPEAT), this.config.antialias && (r = c && this.mipmapFilter ? this.mipmapFilter : n.LINEAR, o = n.LINEAR), e ? (e.update(t, a, h, s, l, l, r, o, e.format), e) : this.createTexture2D(0, r, o, l, l, n.RGBA, t, a, h, !0, !1, s) }, createCanvasTexture: function (t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.canvasToTexture(t, null, e, i) }, updateCanvasTexture: function (t, e, i, s) { return void 0 === i && (i = !1), void 0 === s && (s = !1), this.canvasToTexture(t, e, s, i) }, videoToTexture: function (t, e, i, s) { void 0 === i && (i = !1), void 0 === s && (s = !1); const n = this.gl; let r = n.NEAREST; let o = n.NEAREST; const a = t.videoWidth; const h = t.videoHeight; let l = n.CLAMP_TO_EDGE; const c = u(a, h); return !i && c && (l = n.REPEAT), this.config.antialias && (r = c && this.mipmapFilter ? this.mipmapFilter : n.LINEAR, o = n.LINEAR), e ? (e.update(t, a, h, s, l, l, r, o, e.format), e) : this.createTexture2D(0, r, o, l, l, n.RGBA, t, a, h, !0, !0, s) }, createVideoTexture: function (t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.videoToTexture(t, null, e, i) }, updateVideoTexture: function (t, e, i, s) { return void 0 === i && (i = !1), void 0 === s && (s = !1), this.videoToTexture(t, e, s, i) }, createUint8ArrayTexture: function (t, e, i) { const s = this.gl; const n = s.NEAREST; const r = s.NEAREST; let o = s.CLAMP_TO_EDGE; return u(e, i) && (o = s.REPEAT), this.createTexture2D(0, n, r, o, o, s.RGBA, t, e, i) }, setTextureFilter: function (t, e) { const i = this.gl; const s = e === 0 ? i.LINEAR : i.NEAREST; i.activeTexture(i.TEXTURE0); const n = i.getParameter(i.TEXTURE_BINDING_2D); return i.bindTexture(i.TEXTURE_2D, t.webGLTexture), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, s), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, s), t.minFilter = s, t.magFilter = s, n && i.bindTexture(i.TEXTURE_2D, n), this }, getMaxTextureSize: function () { return this.config.maxTextureSize }, destroy: function () { this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, !1), this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, !1); const t = function (t) { t.destroy() }; s(this.glAttribLocationWrappers, t), s(this.glBufferWrappers, t), s(this.glFramebufferWrappers, t), s(this.glProgramWrappers, t), s(this.glTextureWrappers, t), s(this.glUniformLocationWrappers, t), this.maskTarget.destroy(), this.maskSource.destroy(), this.pipelines.destroy(), this.removeAllListeners(), this.fboStack = [], this.maskStack = [], this.extensions = {}, this.textureIndexes = [], this.gl = null, this.game = null, this.canvas = null, this.contextLost = !0, this.currentMask = null, this.currentCameraMask = null } }); t.exports = C }, 38683: (t, e, i) => { const s = i(83419); const n = i(95428); const r = i(95540); const o = i(14500); const a = new s({ initialize: function (t, e, i, s, n) { this.pipeline = t, this.name = e, this.renderer = t.renderer, this.gl = this.renderer.gl, this.fragSrc = s, this.vertSrc = i, this.program = this.renderer.createProgram(i, s), this.attributes, this.vertexComponentCount = 0, this.vertexSize = 0, this.uniforms = {}, this.createAttributes(n), this.createUniforms() }, createAttributes: function (t) { let e = 0; let i = 0; const s = []; this.vertexComponentCount = 0; for (let n = 0; n < t.length; n++) { const a = t[n]; const h = a.name; const l = r(a, 'size', 1); const u = r(a, 'type', o.FLOAT); const c = u.enum; const d = u.size; const f = !!a.normalized; s.push({ name: h, size: l, type: c, normalized: f, offset: i, enabled: !1, location: -1 }), d === 4 ? e += l : e++, i += l * d } this.vertexSize = i, this.vertexComponentCount = e, this.attributes = s }, bind: function (t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), e && this.pipeline.flush(), this.renderer.setProgram(this.program), t && this.setAttribPointers(), this }, rebind: function () { return this.renderer.setProgram(this.program), this.setAttribPointers(!0), this }, setAttribPointers: function (t) { void 0 === t && (t = !1); for (let e = this.gl, i = this.renderer, s = this.vertexSize, n = this.attributes, r = this.program, o = 0; o < n.length; o++) { const a = n[o]; const h = a.size; const l = a.type; const u = a.offset; const c = a.enabled; const d = a.location; const f = !!a.normalized; if (t) { d !== -1 && i.deleteAttribLocation(d); const p = this.renderer.createAttribLocation(r, a.name); p.webGLAttribLocation >= 0 ? (e.enableVertexAttribArray(p.webGLAttribLocation), e.vertexAttribPointer(p.webGLAttribLocation, h, l, f, s, u), a.enabled = !0, a.location = p) : p.webGLAttribLocation !== -1 && e.disableVertexAttribArray(p.webGLAttribLocation) } else c ? e.vertexAttribPointer(d.webGLAttribLocation, h, l, f, s, u) : !c && d !== -1 && d.webGLAttribLocation > -1 && (e.disableVertexAttribArray(d.webGLAttribLocation), a.location = -1) } return this }, createUniforms: function () { let t; let e; let i; const s = this.gl; const n = this.program; const r = this.uniforms; const o = s.getProgramParameter(n.webGLProgram, s.ACTIVE_UNIFORMS); for (t = 0; t < o; t++) { const a = s.getActiveUniform(n.webGLProgram, t); if (a) { e = a.name, (i = this.renderer.createUniformLocation(n, e)) !== null && (r[e] = { name: e, location: i, setter: null, value1: null, value2: null, value3: null, value4: null }); const h = e.indexOf('['); h > 0 && (e = e.substr(0, h), r.hasOwnProperty(e) || (i = this.renderer.createUniformLocation(n, e)) !== null && (r[e] = { name: e, location: i, setter: null, value1: null, value2: null, value3: null, value4: null })) } } return this }, syncUniforms: function () { const t = this.gl; for (const e in this.renderer.setProgram(this.program), this.uniforms) { const i = this.uniforms[e]; i.setter && i.setter.call(t, i.location.webGLUniformLocation, i.value1, i.value2, i.value3, i.value4) } }, hasUniform: function (t) { return this.uniforms.hasOwnProperty(t) }, resetUniform: function (t) { const e = this.uniforms[t]; return e && (e.value1 = null, e.value2 = null, e.value3 = null, e.value4 = null), this }, setUniform1: function (t, e, i, s) { const n = this.uniforms[e]; return n ? ((s || n.value1 !== i) && (n.setter || (n.setter = t), n.value1 = i, this.renderer.setProgram(this.program), t.call(this.gl, n.location.webGLUniformLocation, i), this.pipeline.currentShader = this), this) : this }, setUniform2: function (t, e, i, s, n) { const r = this.uniforms[e]; return r ? ((n || r.value1 !== i || r.value2 !== s) && (r.setter || (r.setter = t), r.value1 = i, r.value2 = s, this.renderer.setProgram(this.program), t.call(this.gl, r.location.webGLUniformLocation, i, s), this.pipeline.currentShader = this), this) : this }, setUniform3: function (t, e, i, s, n, r) { const o = this.uniforms[e]; return o ? ((r || o.value1 !== i || o.value2 !== s || o.value3 !== n) && (o.setter || (o.setter = t), o.value1 = i, o.value2 = s, o.value3 = n, this.renderer.setProgram(this.program), t.call(this.gl, o.location.webGLUniformLocation, i, s, n), this.pipeline.currentShader = this), this) : this }, setUniform4: function (t, e, i, s, n, r, o) { const a = this.uniforms[e]; return a ? ((o || a.value1 !== i || a.value2 !== s || a.value3 !== n || a.value4 !== r) && (a.setter || (a.setter = t), a.value1 = i, a.value2 = s, a.value3 = n, a.value4 = r, this.renderer.setProgram(this.program), t.call(this.gl, a.location.webGLUniformLocation, i, s, n, r), this.pipeline.currentShader = this), this) : this }, setBoolean: function (t, e) { return this.setUniform1(this.gl.uniform1i, t, Number(e)) }, set1f: function (t, e) { return this.setUniform1(this.gl.uniform1f, t, e) }, set2f: function (t, e, i) { return this.setUniform2(this.gl.uniform2f, t, e, i) }, set3f: function (t, e, i, s) { return this.setUniform3(this.gl.uniform3f, t, e, i, s) }, set4f: function (t, e, i, s, n) { return this.setUniform4(this.gl.uniform4f, t, e, i, s, n) }, set1fv: function (t, e) { return this.setUniform1(this.gl.uniform1fv, t, e, !0) }, set2fv: function (t, e) { return this.setUniform1(this.gl.uniform2fv, t, e, !0) }, set3fv: function (t, e) { return this.setUniform1(this.gl.uniform3fv, t, e, !0) }, set4fv: function (t, e) { return this.setUniform1(this.gl.uniform4fv, t, e, !0) }, set1iv: function (t, e) { return this.setUniform1(this.gl.uniform1iv, t, e, !0) }, set2iv: function (t, e) { return this.setUniform1(this.gl.uniform2iv, t, e, !0) }, set3iv: function (t, e) { return this.setUniform1(this.gl.uniform3iv, t, e, !0) }, set4iv: function (t, e) { return this.setUniform1(this.gl.uniform4iv, t, e, !0) }, set1i: function (t, e) { return this.setUniform1(this.gl.uniform1i, t, e) }, set2i: function (t, e, i) { return this.setUniform2(this.gl.uniform2i, t, e, i) }, set3i: function (t, e, i, s) { return this.setUniform3(this.gl.uniform3i, t, e, i, s) }, set4i: function (t, e, i, s, n) { return this.setUniform4(this.gl.uniform4i, t, e, i, s, n) }, setMatrix2fv: function (t, e, i) { return this.setUniform2(this.gl.uniformMatrix2fv, t, e, i, !0) }, setMatrix3fv: function (t, e, i) { return this.setUniform2(this.gl.uniformMatrix3fv, t, e, i, !0) }, setMatrix4fv: function (t, e, i) { return this.setUniform2(this.gl.uniformMatrix4fv, t, e, i, !0) }, createProgram: function (t, e) { return void 0 === t && (t = this.vertSrc), void 0 === e && (e = this.fragSrc), this.program && this.renderer.deleteProgram(this.program), this.vertSrc = t, this.fragSrc = e, this.program = this.renderer.createProgram(t, e), this.createUniforms(), this.rebind() }, destroy: function () { const t = this.renderer; n(this.uniforms, function (e) { t.deleteUniformLocation(e.location) }), this.uniforms = null, n(this.attributes, function (e) { t.deleteAttribLocation(e.location) }), this.attributes = null, t.deleteProgram(this.program), this.pipeline = null, this.renderer = null, this.gl = null, this.program = null } }); t.exports = a }, 14500: t => { t.exports = { BYTE: { enum: 5120, size: 1 }, UNSIGNED_BYTE: { enum: 5121, size: 1 }, SHORT: { enum: 5122, size: 2 }, UNSIGNED_SHORT: { enum: 5123, size: 2 }, INT: { enum: 5124, size: 4 }, UNSIGNED_INT: { enum: 5125, size: 4 }, FLOAT: { enum: 5126, size: 4 } } }, 4159: (t, e, i) => { const s = i(14500); const n = i(79291); let r = { PipelineManager: i(7530), Pipelines: i(96615), RenderTarget: i(32302), Utils: i(70554), WebGLPipeline: i(29100), WebGLRenderer: i(74797), WebGLShader: i(38683), Wrappers: i(9503) }; r = n(!1, r, s), t.exports = r }, 31302: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(78908); const o = i(85191); const a = i(14500); const h = i(29100); const l = new s({ Extends: h, initialize: function (t) { t.fragShader = n(t, 'fragShader', r), t.vertShader = n(t, 'vertShader', o), t.batchSize = n(t, 'batchSize', 1), t.vertices = n(t, 'vertices', [-1, 1, -1, -7, 7, 1]), t.attributes = n(t, 'attributes', [{ name: 'inPosition', size: 2, type: a.FLOAT }]), h.call(this, t) }, boot: function () { h.prototype.boot.call(this), this.set1i('uMainSampler', 0), this.set1i('uMaskSampler', 1) }, resize: function (t, e) { h.prototype.resize.call(this, t, e), this.set2f('uResolution', t, e) }, beginMask: function (t, e, i) { this.renderer.beginBitmapMask(t, i) }, endMask: function (t, e, i) { const s = this.gl; const n = this.renderer; const r = t.bitmapMask; r && s && (n.drawBitmapMask(r, e, this), i && this.set2f('uResolution', i.width, i.height), this.set1i('uInvertMaskAlpha', t.invertAlpha), s.drawArrays(this.topology, 0, 3), i && this.set2f('uResolution', this.width, this.height), s.bindTexture(s.TEXTURE_2D, null)) } }); t.exports = l }, 92651: (t, e, i) => { const s = i(83419); const n = i(58918); const r = i(14811); const o = i(95540); const a = i(43558); const h = i(89350); const l = i(70554); const u = new s({ Extends: a, initialize: function (t) { t.shaders = [l.setGlowQuality(h.FXGlowFrag, t.game), h.FXShadowFrag, h.FXPixelateFrag, h.FXVignetteFrag, h.FXShineFrag, h.FXBlurLowFrag, h.FXBlurMedFrag, h.FXBlurHighFrag, h.FXGradientFrag, h.FXBloomFrag, h.ColorMatrixFrag, h.FXCircleFrag, h.FXBarrelFrag, h.FXDisplacementFrag, h.FXWipeFrag, h.FXBokehFrag], a.call(this, t); const e = this.game; this.glow = new n.Glow(e), this.shadow = new n.Shadow(e), this.pixelate = new n.Pixelate(e), this.vignette = new n.Vignette(e), this.shine = new n.Shine(e), this.gradient = new n.Gradient(e), this.circle = new n.Circle(e), this.barrel = new n.Barrel(e), this.wipe = new n.Wipe(e), this.bokeh = new n.Bokeh(e); const i = []; i[r.GLOW] = this.onGlow, i[r.SHADOW] = this.onShadow, i[r.PIXELATE] = this.onPixelate, i[r.VIGNETTE] = this.onVignette, i[r.SHINE] = this.onShine, i[r.BLUR] = this.onBlur, i[r.GRADIENT] = this.onGradient, i[r.BLOOM] = this.onBloom, i[r.COLOR_MATRIX] = this.onColorMatrix, i[r.CIRCLE] = this.onCircle, i[r.BARREL] = this.onBarrel, i[r.DISPLACEMENT] = this.onDisplacement, i[r.WIPE] = this.onWipe, i[r.BOKEH] = this.onBokeh, this.fxHandlers = i, this.source, this.target, this.swap }, onDraw: function (t, e, i) { this.source = t, this.target = e, this.swap = i; const s = t.width; const n = t.height; const r = this.tempSprite; const o = this.fxHandlers; if (r && r.preFX) for (let a = r.preFX.list, h = 0; h < a.length; h++) { const l = a[h]; l.active && o[l.type].call(this, l, s, n) } this.drawToGame(this.source) }, runDraw: function () { const t = this.source; const e = this.target; this.copy(t, e), this.source = e, this.target = t }, onGlow: function (t, e, i) { const s = this.shaders[r.GLOW]; this.setShader(s), this.glow.onPreRender(t, s, e, i), this.runDraw() }, onShadow: function (t) { const e = this.shaders[r.SHADOW]; this.setShader(e), this.shadow.onPreRender(t, e), this.runDraw() }, onPixelate: function (t, e, i) { const s = this.shaders[r.PIXELATE]; this.setShader(s), this.pixelate.onPreRender(t, s, e, i), this.runDraw() }, onVignette: function (t) { const e = this.shaders[r.VIGNETTE]; this.setShader(e), this.vignette.onPreRender(t, e), this.runDraw() }, onShine: function (t, e, i) { const s = this.shaders[r.SHINE]; this.setShader(s), this.shine.onPreRender(t, s, e, i), this.runDraw() }, onBlur: function (t, e, i) { const s = o(t, 'quality'); const n = this.shaders[r.BLUR + s]; this.setShader(n), this.set1i('uMainSampler', 0), this.set2f('resolution', e, i), this.set1f('strength', o(t, 'strength')), this.set3fv('color', o(t, 'glcolor')); for (let a = o(t, 'x'), h = o(t, 'y'), l = o(t, 'steps'), u = 0; u < l; u++) this.set2f('offset', a, 0), this.runDraw(), this.set2f('offset', 0, h), this.runDraw() }, onGradient: function (t) { const e = this.shaders[r.GRADIENT]; this.setShader(e), this.gradient.onPreRender(t, e), this.runDraw() }, onBloom: function (t, e, i) { const s = this.shaders[r.BLOOM]; this.copySprite(this.source, this.swap), this.setShader(s), this.set1i('uMainSampler', 0), this.set1f('strength', o(t, 'blurStrength')), this.set3fv('color', o(t, 'glcolor')); for (let n = 2 / e * o(t, 'offsetX'), a = 2 / i * o(t, 'offsetY'), h = o(t, 'steps'), l = 0; l < h; l++) this.set2f('offset', n, 0), this.runDraw(), this.set2f('offset', 0, a), this.runDraw(); this.blendFrames(this.swap, this.source, this.target, o(t, 'strength')), this.copySprite(this.target, this.source) }, onColorMatrix: function (t) { this.setShader(this.colorMatrixShader), this.set1fv('uColorMatrix', t.getData()), this.set1f('uAlpha', t.alpha), this.runDraw() }, onCircle: function (t, e, i) { const s = this.shaders[r.CIRCLE]; this.setShader(s), this.circle.onPreRender(t, s, e, i), this.runDraw() }, onBarrel: function (t) { const e = this.shaders[r.BARREL]; this.setShader(e), this.barrel.onPreRender(t, e), this.runDraw() }, onDisplacement: function (t) { this.setShader(this.shaders[r.DISPLACEMENT]), this.set1i('uDisplacementSampler', 1), this.set2f('amount', t.x, t.y), this.bindTexture(t.glTexture, 1), this.runDraw() }, onWipe: function (t) { const e = this.shaders[r.WIPE]; this.setShader(e), this.wipe.onPreRender(t, e), this.runDraw() }, onBokeh: function (t, e, i) { const s = this.shaders[r.BOKEH]; this.setShader(s), this.bokeh.onPreRender(t, s, e, i), this.runDraw() }, destroy: function () { return this.glow.destroy(), this.shadow.destroy(), this.pixelate.destroy(), this.vignette.destroy(), this.shine.destroy(), this.gradient.destroy(), this.circle.destroy(), this.barrel.destroy(), this.wipe.destroy(), this.bokeh.destroy(), this.fxHandlers = null, this.source = null, this.target = null, this.swap = null, a.prototype.destroy.call(this), this } }); t.exports = u }, 96569: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(31063); const o = i(57516); const a = i(61340); const h = i(26099); const l = i(29100); const u = new s({ Extends: o, initialize: function (t) { const e = n(t, 'fragShader', r); t.fragShader = e.replace('%LIGHT_COUNT%', t.game.renderer.config.maxLights), o.call(this, t), this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), this.currentNormalMap, this.lightsActive = !0, this.tempVec2 = new h(), this._tempMatrix = new a(), this._tempMatrix2 = new a() }, boot: function () { l.prototype.boot.call(this) }, onRender: function (t, e) { const i = t.sys.lights; if (this.lightsActive = !1, i && i.active) { let s; const n = i.getLights(e); const r = n.length; this.lightsActive = !0; const o = this.renderer.height; const a = e.matrix; const h = this.tempVec2; for (this.set1i('uMainSampler', 0), this.set1i('uNormSampler', 1), this.set2f('uResolution', this.width / 2, this.height / 2), this.set4f('uCamera', e.x, e.y, e.rotation, e.zoom), this.set3f('uAmbientLightColor', i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), this.set1i('uLightCount', r), s = 0; s < r; s++) { const l = n[s].light; const u = l.color; const c = 'uLights[' + s + '].'; a.transformPoint(l.x, l.y, h), this.set2f(c + 'position', h.x - e.scrollX * l.scrollFactorX * e.zoom, o - (h.y - e.scrollY * l.scrollFactorY * e.zoom)), this.set3f(c + 'color', u.r, u.g, u.b), this.set1f(c + 'intensity', l.intensity), this.set1f(c + 'radius', l.radius) } this.currentNormalMapRotation = null } }, setNormalMapRotation: function (t) { if (t !== this.currentNormalMapRotation || this.vertexCount === 0) { this.vertexCount > 0 && this.flush(); const e = this.inverseRotationMatrix; if (t) { const i = -t; const s = Math.cos(i); const n = Math.sin(i); e[1] = n, e[3] = -n, e[0] = e[4] = s } else e[0] = e[4] = 1, e[1] = e[3] = 0; this.setMatrix3fv('uInverseRotationMatrix', !1, e), this.currentNormalMapRotation = t } }, setTexture2D: function (t, e) { const i = this.renderer; void 0 === t && (t = i.whiteTexture); const s = this.getNormalMap(e); this.isNewNormalMap(t, s) && (this.flush(), this.createBatch(t), this.addTextureToBatch(s), this.currentNormalMap = s); let n = 0; e && e.parentContainer ? n = e.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2).rotationNormalized : e && (n = e.rotation); return this.setNormalMapRotation(n), 0 }, setGameObject: function (t, e) { void 0 === e && (e = t.frame); const i = e.glTexture; const s = this.getNormalMap(t); if (this.isNewNormalMap(i, s) && (this.flush(), this.createBatch(i), this.addTextureToBatch(s), this.currentNormalMap = s), t.parentContainer) { const n = t.getWorldTransformMatrix(this._tempMatrix, this._tempMatrix2); this.setNormalMapRotation(n.rotationNormalized) } else this.setNormalMapRotation(t.rotation); return 0 }, isNewNormalMap: function (t, e) { return this.currentTexture !== t || this.currentNormalMap !== e }, getNormalMap: function (t) { let e; return t ? (t.displayTexture ? e = t.displayTexture.dataSource[t.displayFrame.sourceIndex] : t.texture ? e = t.texture.dataSource[t.frame.sourceIndex] : t.tileset && (e = Array.isArray(t.tileset) ? t.tileset[0].image.dataSource[0] : t.tileset.image.dataSource[0]), e ? e.glTexture : this.renderer.normalTexture) : this.renderer.normalTexture }, batchSprite: function (t, e, i) { this.lightsActive && o.prototype.batchSprite.call(this, t, e, i) }, batchTexture: function (t, e, i, s, n, r, a, h, l, u, c, d, f, p, v, g, m, y, x, T, w, b, S, E, A, C, _, M, P, R, L, O) { this.lightsActive && o.prototype.batchTexture.call(this, t, e, i, s, n, r, a, h, l, u, c, d, f, p, v, g, m, y, x, T, w, b, S, E, A, C, _, M, P, R, L, O) }, batchTextureFrame: function (t, e, i, s, n, r, a) { this.lightsActive && o.prototype.batchTextureFrame.call(this, t, e, i, s, n, r, a) } }); t.exports = u }, 56527: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(57516); const o = i(45561); const a = i(60722); const h = i(14500); const l = i(29100); const u = new s({ Extends: r, initialize: function (t) { t.fragShader = n(t, 'fragShader', o), t.vertShader = n(t, 'vertShader', a), t.attributes = n(t, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }, { name: 'inTexId' }, { name: 'inTintEffect' }, { name: 'inTint', size: 4, type: h.UNSIGNED_BYTE, normalized: !0 }]), t.forceZero = !0, t.resizeUniform = 'uResolution', r.call(this, t) }, boot: function () { l.prototype.boot.call(this); const t = this.renderer; this.set1i('uMainSampler', 0), this.set2f('uResolution', t.width, t.height), this.set1i('uRoundPixels', t.config.roundPixels) } }); t.exports = u }, 57516: (t, e, i) => { const s = i(83419); const n = i(94811); const r = i(95540); const o = i(98840); const a = i(44667); const h = i(61340); const l = i(70554); const u = i(14500); const c = i(29100); const d = new s({ Extends: c, initialize: function (t) { const e = t.game.renderer; const i = r(t, 'fragShader', o); t.fragShader = l.parseFragmentShaderMaxTextures(i, e.maxTextures), t.vertShader = r(t, 'vertShader', a), t.attributes = r(t, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }, { name: 'inTexId' }, { name: 'inTintEffect' }, { name: 'inTint', size: 4, type: u.UNSIGNED_BYTE, normalized: !0 }]), t.resizeUniform = 'uResolution', c.call(this, t), this._tempMatrix1 = new h(), this._tempMatrix2 = new h(), this._tempMatrix3 = new h(), this.calcMatrix = new h(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.strokeTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.fillTint = { TL: 0, TR: 0, BL: 0, BR: 0 }, this.currentFrame = { u0: 0, v0: 0, u1: 1, v1: 1 }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [] }, boot: function () { c.prototype.boot.call(this); const t = this.renderer; this.set1iv('uMainSampler', t.textureIndexes), this.set2f('uResolution', t.width, t.height), this.set1i('uRoundPixels', t.config.roundPixels) }, batchSprite: function (t, e, i) { this.manager.set(this, t); const s = this._tempMatrix1; const n = this._tempMatrix2; const r = this._tempMatrix3; const o = t.frame; const a = o.glTexture; let h = o.u0; let u = o.v0; let c = o.u1; let d = o.v1; let f = o.x; let p = o.y; let v = o.cutWidth; let g = o.cutHeight; const m = o.customPivot; const y = t.displayOriginX; const x = t.displayOriginY; let T = -y + f; let w = -x + p; if (t.isCropped) { const b = t._crop; b.flipX === t.flipX && b.flipY === t.flipY || o.updateCropUVs(b, t.flipX, t.flipY), h = b.u0, u = b.v0, c = b.u1, d = b.v1, v = b.width, g = b.height, T = -y + (f = b.x), w = -x + (p = b.y) } let S = 1; let E = 1; t.flipX && (m || (T += -o.realWidth + 2 * y), S = -1), t.flipY && (m || (w += -o.realHeight + 2 * x), E = -1); const A = t.x; const C = t.y; n.applyITRS(A, C, t.rotation, t.scaleX * S, t.scaleY * E), s.copyFrom(e.matrix), i ? (s.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), n.e = A, n.f = C) : (n.e -= e.scrollX * t.scrollFactorX, n.f -= e.scrollY * t.scrollFactorY), s.multiply(n, r); const _ = r.setQuad(T, w, T + v, w + g); const M = l.getTintAppendFloatAlpha; const P = e.alpha; const R = M(t.tintTopLeft, P * t._alphaTL); const L = M(t.tintTopRight, P * t._alphaTR); const O = M(t.tintBottomLeft, P * t._alphaBL); const F = M(t.tintBottomRight, P * t._alphaBR); this.shouldFlush(6) && this.flush(); const D = this.setGameObject(t, o); this.manager.preBatch(t), this.currentShader.set1i('uRoundPixels', e.roundPixels), this.batchQuad(t, _[0], _[1], _[2], _[3], _[4], _[5], _[6], _[7], h, u, c, d, R, L, O, F, t.tintFill, a, D), this.manager.postBatch(t) }, batchTexture: function (t, e, i, s, n, r, o, a, h, l, u, c, d, f, p, v, g, m, y, x, T, w, b, S, E, A, C, _, M, P, R, L, O) { void 0 === O && (O = !1), this.manager.set(this, t); const F = this._tempMatrix1; const D = this._tempMatrix2; const k = this._tempMatrix3; let I = m / i + C; let B = y / s + _; let N = (m + x) / i + C; let U = (y + T) / s + _; let X = o; let Y = a; let z = -v; let G = -g; if (t.isCropped) { const V = t._crop; const W = V.width; const H = V.height; X = W, Y = H, o = W, a = H; let j = m = V.x; let q = y = V.y; c && (j = x - V.x - W), d && (q = T - V.y - H), I = j / i + C, B = q / s + _, N = (j + W) / i + C, U = (q + H) / s + _, z = -v + m, G = -g + y } c && (X *= -1, z += o), (d ^= !R && e.isRenderTexture ? 1 : 0) && (Y *= -1, G += a), D.applyITRS(n, r, u, h, l), F.copyFrom(M.matrix), P ? (F.multiplyWithOffset(P, -M.scrollX * f, -M.scrollY * p), D.e = n, D.f = r) : (D.e -= M.scrollX * f, D.f -= M.scrollY * p), F.multiply(D, k); const K = k.setQuad(z, G, z + X, G + Y); L == null && (L = this.setTexture2D(e)), t && !O && this.manager.preBatch(t), this.currentShader.set1i('uRoundPixels', M.roundPixels), this.batchQuad(t, K[0], K[1], K[2], K[3], K[4], K[5], K[6], K[7], I, B, N, U, w, b, S, E, A, e, L), t && !O && this.manager.postBatch(t) }, batchTextureFrame: function (t, e, i, s, n, r, o) { this.manager.set(this); const a = this._tempMatrix1.copyFrom(r); let h = this._tempMatrix2; o ? a.multiply(o, h) : h = a; const u = h.setQuad(e, i, e + t.width, i + t.height); const c = this.setTexture2D(t.source.glTexture); s = l.getTintAppendFloatAlpha(s, n), this.batchQuad(null, u[0], u[1], u[2], u[3], u[4], u[5], u[6], u[7], t.u0, t.v0, t.u1, t.v1, s, s, s, s, 0, t.glTexture, c) }, batchFillRect: function (t, e, i, s, n, r) { this.renderer.pipelines.set(this); const o = this.calcMatrix; r && r.multiply(n, o); const a = o.setQuad(t, e, t + i, e + s); const h = this.fillTint; this.batchQuad(null, a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], 0, 0, 1, 1, h.TL, h.TR, h.BL, h.BR, 2) }, batchFillTriangle: function (t, e, i, s, n, r, o, a) { this.renderer.pipelines.set(this); const h = this.calcMatrix; a && a.multiply(o, h); const l = h.getX(t, e); const u = h.getY(t, e); const c = h.getX(i, s); const d = h.getY(i, s); const f = h.getX(n, r); const p = h.getY(n, r); const v = this.fillTint; this.currentShader.set1i('uRoundPixels', !1), this.batchTri(null, l, u, c, d, f, p, 0, 0, 1, 1, v.TL, v.TR, v.BL, 2) }, batchStrokeTriangle: function (t, e, i, s, n, r, o, a, h) { const l = this.tempTriangle; l[0].x = t, l[0].y = e, l[0].width = o, l[1].x = i, l[1].y = s, l[1].width = o, l[2].x = n, l[2].y = r, l[2].width = o, l[3].x = t, l[3].y = e, l[3].width = o, this.batchStrokePath(l, o, !1, a, h) }, batchFillPath: function (t, e, i) { this.renderer.pipelines.set(this); const s = this.calcMatrix; i && i.multiply(e, s); for (var r, o, a = t.length, h = this.polygonCache, l = this.fillTint.TL, u = this.fillTint.TR, c = this.fillTint.BL, d = 0; d < a; ++d)o = t[d], h.push(o.x, o.y); a = (r = n(h)).length, this.currentShader.set1i('uRoundPixels', !1); for (let f = 0; f < a; f += 3) { const p = 2 * r[f + 0]; const v = 2 * r[f + 1]; const g = 2 * r[f + 2]; const m = h[p + 0]; const y = h[p + 1]; const x = h[v + 0]; const T = h[v + 1]; const w = h[g + 0]; const b = h[g + 1]; const S = s.getX(m, y); const E = s.getY(m, y); const A = s.getX(x, T); const C = s.getY(x, T); const _ = s.getX(w, b); const M = s.getY(w, b); this.batchTri(null, S, E, A, C, _, M, 0, 0, 1, 1, l, u, c, 2) } h.length = 0 }, batchStrokePath: function (t, e, i, s, n) { this.renderer.pipelines.set(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let r = t.length - 1, o = 0; o < r; o++) { const a = t[o]; const h = t[o + 1]; this.batchLine(a.x, a.y, h.x, h.y, a.width / 2, h.width / 2, e, o, !i && o === r - 1, s, n) } }, batchLine: function (t, e, i, s, n, r, o, a, h, l, u) { this.renderer.pipelines.set(this); const c = this.calcMatrix; u && u.multiply(l, c); const d = i - t; const f = s - e; const p = Math.sqrt(d * d + f * f); if (p !== 0) { const v = n * (s - e) / p; const g = n * (t - i) / p; const m = r * (s - e) / p; const y = r * (t - i) / p; const x = i - m; const T = s - y; const w = t - v; const b = e - g; const S = i + m; const E = s + y; const A = t + v; const C = e + g; const _ = c.getX(x, T); const M = c.getY(x, T); const P = c.getX(w, b); const R = c.getY(w, b); const L = c.getX(S, E); const O = c.getY(S, E); const F = c.getX(A, C); const D = c.getY(A, C); const k = this.strokeTint; const I = k.TL; const B = k.TR; const N = k.BL; const U = k.BR; if (this.currentShader.set1i('uRoundPixels', !1), this.batchQuad(null, F, D, P, R, _, M, L, O, 0, 0, 1, 1, I, B, N, U, 2), !(o <= 2)) { const X = this.prevQuad; const Y = this.firstQuad; a > 0 && X[4] ? this.batchQuad(null, F, D, P, R, X[0], X[1], X[2], X[3], 0, 0, 1, 1, I, B, N, U, 2) : (Y[0] = F, Y[1] = D, Y[2] = P, Y[3] = R, Y[4] = 1), h && Y[4] ? this.batchQuad(null, _, M, L, O, Y[0], Y[1], Y[2], Y[3], 0, 0, 1, 1, I, B, N, U, 2) : (X[0] = _, X[1] = M, X[2] = L, X[3] = O, X[4] = 1) } } }, destroy: function () { return this._tempMatrix1.destroy(), this._tempMatrix2.destroy(), this._tempMatrix3.destroy(), this._tempMatrix1 = null, this._tempMatrix1 = null, this._tempMatrix1 = null, c.prototype.destroy.call(this), this } }); t.exports = d }, 43439: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(4127); const o = i(89924); const a = i(29100); const h = new s({ Extends: a, initialize: function (t) { t.vertShader = n(t, 'vertShader', o), t.fragShader = n(t, 'fragShader', r), t.attributes = n(t, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inLightPosition', size: 2 }, { name: 'inLightRadius' }, { name: 'inLightAttenuation' }, { name: 'inLightColor', size: 4 }]), a.call(this, t) }, onRender: function (t, e) { this.set2f('uResolution', this.width, this.height), this.set1f('uCameraZoom', e.zoom) }, batchPointLight: function (t, e, i, s, n, r, o, a, h, l, u, c) { const d = t.color; const f = t.intensity; const p = t.radius; const v = t.attenuation; const g = d.r * f; const m = d.g * f; const y = d.b * f; const x = e.alpha * t.alpha; this.shouldFlush(6) && this.flush(), this.currentBatch || this.setTexture2D(), this.batchLightVert(i, s, u, c, p, v, g, m, y, x), this.batchLightVert(n, r, u, c, p, v, g, m, y, x), this.batchLightVert(o, a, u, c, p, v, g, m, y, x), this.batchLightVert(i, s, u, c, p, v, g, m, y, x), this.batchLightVert(o, a, u, c, p, v, g, m, y, x), this.batchLightVert(h, l, u, c, p, v, g, m, y, x), this.currentBatch.count = this.vertexCount - this.currentBatch.start }, batchLightVert: function (t, e, i, s, n, r, o, a, h, l) { const u = this.vertexViewF32; let c = this.vertexCount * this.currentShader.vertexComponentCount - 1; u[++c] = t, u[++c] = e, u[++c] = i, u[++c] = s, u[++c] = n, u[++c] = r, u[++c] = o, u[++c] = a, u[++c] = h, u[++c] = l, this.vertexCount++ } }); t.exports = h }, 84057: (t, e, i) => { const s = i(83419); const n = i(89422); const r = i(95540); const o = i(27681); const a = i(49627); const h = i(29100); const l = new s({ Extends: h, initialize: function (t) { t.renderTarget = r(t, 'renderTarget', 1), t.fragShader = r(t, 'fragShader', o), t.vertShader = r(t, 'vertShader', a), t.attributes = r(t, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }]), t.batchSize = 1, t.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], h.call(this, t), this.isPostFX = !0, this.gameObject, this.controller, this.colorMatrix = new n(), this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2, this.renderer.isBooted && (this.manager = this.renderer.pipelines) }, bootFX: function () { h.prototype.boot.call(this); const t = this.manager.UTILITY_PIPELINE; this.fullFrame1 = t.fullFrame1, this.fullFrame2 = t.fullFrame2, this.halfFrame1 = t.halfFrame1, this.halfFrame2 = t.halfFrame2; const e = this.renderer; this.set1i('uMainSampler', 0), this.set2f('uResolution', e.width, e.height), this.set1i('uRoundPixels', e.config.roundPixels); for (let i = this.renderTargets, s = 0; s < i.length; s++)i[s].autoResize = !0 }, postBatch: function (t) { return this.hasBooted || (this.bootFX(), this.currentRenderTarget && this.currentRenderTarget.bind()), this.onDraw(this.currentRenderTarget), this.onPostBatch(t), this }, onDraw: function (t) { this.bindAndDraw(t) }, getController: function (t) { return void 0 !== t ? t : this.controller ? this.controller : this }, copySprite: function (t, e, i) { void 0 === i && (i = !1); const s = this.gl; s.activeTexture(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, t.texture.webGLTexture); const n = s.getParameter(s.FRAMEBUFFER_BINDING); s.bindFramebuffer(s.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, e.texture.webGLTexture, 0), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT), s.bufferData(s.ARRAY_BUFFER, this.vertexData, s.STATIC_DRAW), s.drawArrays(s.TRIANGLES, 0, 6), i && (s.bindTexture(s.TEXTURE_2D, null), s.bindFramebuffer(s.FRAMEBUFFER, n)) }, copyFrame: function (t, e, i, s, n) { this.manager.copyFrame(t, e, i, s, n) }, copyToGame: function (t) { this.manager.copyToGame(t) }, drawFrame: function (t, e, i) { this.manager.drawFrame(t, e, i, this.colorMatrix) }, blendFrames: function (t, e, i, s, n) { this.manager.blendFrames(t, e, i, s, n) }, blendFramesAdditive: function (t, e, i, s, n) { this.manager.blendFramesAdditive(t, e, i, s, n) }, clearFrame: function (t, e) { this.manager.clearFrame(t, e) }, blitFrame: function (t, e, i, s, n, r) { this.manager.blitFrame(t, e, i, s, n, r) }, copyFrameRect: function (t, e, i, s, n, r, o, a) { this.manager.copyFrameRect(t, e, i, s, n, r, o, a) }, bindAndDraw: function (t, e, i, s, n) { void 0 === i && (i = !0), void 0 === s && (s = !0); const r = this.gl; const o = this.renderer; this.bind(n), this.set1i('uMainSampler', 0), e ? (r.viewport(0, 0, e.width, e.height), r.bindFramebuffer(r.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e.texture.webGLTexture, 0), i && (s ? r.clearColor(0, 0, 0, 0) : r.clearColor(0, 0, 0, 1), r.clear(r.COLOR_BUFFER_BIT))) : (o.popFramebuffer(!1, !1), o.currentFramebuffer || r.viewport(0, 0, o.width, o.height)), o.restoreStencilMask(), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, t.texture.webGLTexture), r.bufferData(r.ARRAY_BUFFER, this.vertexData, r.STATIC_DRAW), r.drawArrays(r.TRIANGLES, 0, 6), e && (r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(r.FRAMEBUFFER, o.currentFramebuffer.webGLFramebuffer)) }, destroy: function () { return this.controller && this.controller.destroy(), this.gameObject = null, this.controller = null, this.colorMatrix = null, this.fullFrame1 = null, this.fullFrame2 = null, this.halfFrame1 = null, this.halfFrame2 = null, this.manager.removePostPipeline(this), h.prototype.destroy.call(this), this } }); t.exports = l }, 43558: (t, e, i) => { const s = i(10312); const n = i(67502); const r = i(83419); const o = i(96293); const a = i(95540); const h = i(57516); const l = i(27681); const u = i(87841); const c = i(32302); const d = i(45561); const f = i(60722); const p = i(29100); const v = new r({ Extends: h, initialize: function (t) { const e = a(t, 'fragShader', l); const i = a(t, 'vertShader', f); const s = a(t, 'drawShader', l); const n = [{ name: 'DrawSprite', fragShader: d, vertShader: f }, { name: 'CopySprite', fragShader: e, vertShader: i }, { name: 'DrawGame', fragShader: s, vertShader: f }, { name: 'ColorMatrix', fragShader: o }]; const r = a(t, 'shaders', []); t.shaders = n.concat(r), t.vertShader || (t.vertShader = i), t.batchSize = 1, h.call(this, t), this.isPreFX = !0, this.customMainSampler = null, this.drawSpriteShader, this.copyShader, this.gameShader, this.colorMatrixShader, this.quadVertexData, this.quadVertexBuffer, this.quadVertexViewF32, this.spriteBounds = new u(), this.targetBounds = new u(), this.fsTarget, this.tempSprite, this.renderer.isBooted && (this.manager = this.renderer.pipelines, this.boot()) }, boot: function () { p.prototype.boot.call(this); const t = this.shaders; const e = this.renderer; this.drawSpriteShader = t[0], this.copyShader = t[1], this.gameShader = t[2], this.colorMatrixShader = t[3], this.fsTarget = new c(e, e.width, e.height, 1, 0, !0, !0), this.renderTargets = this.manager.renderTargets.concat(this.fsTarget); const i = new ArrayBuffer(168); this.quadVertexData = i, this.quadVertexViewF32 = new Float32Array(i), this.quadVertexBuffer = e.createVertexBuffer(i, this.gl.STATIC_DRAW), this.onResize(e.width, e.height), this.currentShader = this.copyShader, this.set2f('uResolution', e.width, e.height), this.set1i('uRoundPixels', e.config.roundPixels) }, onResize: function (t, e) { const i = this.quadVertexViewF32; i[1] = e, i[22] = e, i[14] = t, i[28] = t, i[35] = t, i[36] = e }, batchQuad: function (t, e, i, s, r, o, a, h, l, u, c, d, f, p, v, g, m, y, x) { const T = Math.min(e, s, o, h); const w = Math.min(i, r, a, l); const b = Math.max(e, s, o, h) - T; const S = Math.max(i, r, a, l) - w; const E = this.spriteBounds.setTo(T, w, b, S); const A = t ? t.preFX.padding : 0; const C = b + 2 * A; const _ = S + 2 * A; const M = Math.abs(Math.max(C, _)); const P = this.manager.getRenderTarget(M); const R = this.targetBounds.setTo(0, 0, P.width, P.height); n(R, E.centerX, E.centerY), this.tempSprite = t; const L = this.gl; const O = this.renderer; O.clearStencilMask(), this.setShader(this.drawSpriteShader), this.set1i('uMainSampler', 0), this.set2f('uResolution', O.width, O.height), this.set1i('uRoundPixels', O.config.roundPixels), this.flipProjectionMatrix(!0), t && (this.onDrawSprite(t, P), t.preFX.onFX(this)); const F = this.fsTarget; return this.flush(), L.viewport(0, 0, O.width, O.height), L.bindFramebuffer(L.FRAMEBUFFER, F.framebuffer.webGLFramebuffer), L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_2D, F.texture.webGLTexture, 0), L.clearColor(0, 0, 0, 0), L.clear(L.COLOR_BUFFER_BIT), this.setTexture2D(x), this.batchVert(e, i, u, c, 0, y, p), this.batchVert(s, r, u, f, 0, y, g), this.batchVert(o, a, d, f, 0, y, m), this.batchVert(e, i, u, c, 0, y, p), this.batchVert(o, a, d, f, 0, y, m), this.batchVert(h, l, d, c, 0, y, v), this.flush(), this.flipProjectionMatrix(!1), L.activeTexture(L.TEXTURE0), L.bindTexture(L.TEXTURE_2D, P.texture.webGLTexture), L.copyTexSubImage2D(L.TEXTURE_2D, 0, 0, 0, R.x, R.y, R.width, R.height), L.bindFramebuffer(L.FRAMEBUFFER, null), L.bindTexture(L.TEXTURE_2D, null), this.onBatch(t), this.currentShader = this.copyShader, this.onDraw(P, this.manager.getSwapRenderTarget(), this.manager.getAltSwapRenderTarget()), !0 }, onDrawSprite: function () { }, onCopySprite: function () { }, copySprite: function (t, e, i, n, r, o, a) { void 0 === i && (i = !0), void 0 === n && (n = !0), void 0 === r && (r = !1), void 0 === a && (a = this.copyShader); const h = this.gl; const l = this.tempSprite; o && (a = this.colorMatrixShader), this.currentShader = a; const u = this.setVertexBuffer(this.quadVertexBuffer); a.bind(u, !1); const c = this.renderer; if (this.set1i('uMainSampler', 0), this.set2f('uResolution', c.width, c.height), this.set1i('uRoundPixels', c.config.roundPixels), l.preFX.onFXCopy(this), this.onCopySprite(t, e, l), o && (this.set1fv('uColorMatrix', o.getData()), this.set1f('uAlpha', o.alpha)), h.activeTexture(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, t.texture.webGLTexture), t.height > e.height) h.viewport(0, 0, t.width, t.height), this.setTargetUVs(t, e); else { const d = e.height - t.height; h.viewport(0, d, t.width, t.height), this.resetUVs() } if (h.bindFramebuffer(h.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, e.texture.webGLTexture, 0), i && (h.clearColor(0, 0, 0, Number(!n)), h.clear(h.COLOR_BUFFER_BIT)), r) { var f = this.renderer.currentBlendMode; this.renderer.setBlendMode(s.ERASE) } h.bufferData(h.ARRAY_BUFFER, this.quadVertexData, h.STATIC_DRAW), h.drawArrays(h.TRIANGLES, 0, 6), r && this.renderer.setBlendMode(f), h.bindFramebuffer(h.FRAMEBUFFER, null) }, copy: function (t, e) { const i = this.gl; this.set1i('uMainSampler', 0), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, t.texture.webGLTexture), i.viewport(0, 0, t.width, t.height), this.setUVs(0, 0, 0, 1, 1, 1, 1, 0), i.bindFramebuffer(i.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e.texture.webGLTexture, 0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), i.bufferData(i.ARRAY_BUFFER, this.quadVertexData, i.STATIC_DRAW), i.drawArrays(i.TRIANGLES, 0, 6), i.bindFramebuffer(i.FRAMEBUFFER, null) }, blendFrames: function (t, e, i, s, n) { this.manager.blendFrames(t, e, i, s, n) }, blendFramesAdditive: function (t, e, i, s, n) { this.manager.blendFramesAdditive(t, e, i, s, n) }, drawToGame: function (t) { this.currentShader = null, this.setShader(this.copyShader), this.bindAndDraw(t) }, copyToGame: function (t) { this.currentShader = null, this.setShader(this.gameShader), this.bindAndDraw(t) }, bindAndDraw: function (t) { const e = this.gl; const i = this.renderer; this.set1i('uMainSampler', 0), this.customMainSampler ? this.setTexture2D(this.customMainSampler) : this.setTexture2D(t.texture); const s = this._tempMatrix1.loadIdentity(); const n = this.targetBounds.x; const r = this.targetBounds.y; const o = n + t.width; const a = r + t.height; const h = s.getX(n, r); const l = s.getX(n, a); const u = s.getX(o, a); const c = s.getX(o, r); const d = s.getY(n, r); const f = s.getY(n, a); const p = s.getY(o, a); const v = s.getY(o, r); const g = 16777215; this.batchVert(h, d, 0, 0, 0, 0, g), this.batchVert(l, f, 0, 1, 0, 0, g), this.batchVert(u, p, 1, 1, 0, 0, g), this.batchVert(h, d, 0, 0, 0, 0, g), this.batchVert(u, p, 1, 1, 0, 0, g), this.batchVert(c, v, 1, 0, 0, 0, g), i.restoreFramebuffer(!1, !0), i.currentFramebuffer || e.viewport(0, 0, i.width, i.height), i.restoreStencilMask(), this.flush(), this.tempSprite = null }, onDraw: function (t) { this.drawToGame(t) }, setUVs: function (t, e, i, s, n, r, o, a) { const h = this.quadVertexViewF32; h[2] = t, h[3] = e, h[9] = i, h[10] = s, h[16] = n, h[17] = r, h[23] = t, h[24] = e, h[30] = n, h[31] = r, h[37] = o, h[38] = a }, setTargetUVs: function (t, e) { let i = e.height / t.height; i = i > 0.5 ? 0.5 - (i - 0.5) : 0.5 - i + 0.5, this.setUVs(0, i, 0, 1 + i, 1, 1 + i, 1, i) }, resetUVs: function () { this.setUVs(0, 0, 0, 1, 1, 1, 1, 0) }, destroy: function () { return this.renderer.deleteBuffer(this.quadVertexBuffer), this.drawSpriteShader = null, this.copyShader = null, this.gameShader = null, this.colorMatrixShader = null, this.quadVertexData = null, this.quadVertexBuffer = null, this.quadVertexViewF32 = null, this.fsTarget = null, this.tempSprite = null, h.prototype.destroy.call(this), this } }); t.exports = v }, 81041: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(57516); const o = new s({ Extends: r, initialize: function (t) { t.topology = 5, t.batchSize = n(t, 'batchSize', 256), r.call(this, t) } }); t.exports = o }, 12385: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(57516); const o = i(45561); const a = i(60722); const h = i(29100); const l = new s({ Extends: r, initialize: function (t) { t.fragShader = n(t, 'fragShader', o), t.vertShader = n(t, 'vertShader', a), t.forceZero = !0, r.call(this, t) }, boot: function () { h.prototype.boot.call(this); const t = this.renderer; this.set1i('uMainSampler', 0), this.set2f('uResolution', t.width, t.height), this.set1i('uRoundPixels', t.config.roundPixels) } }); t.exports = l }, 7589: (t, e, i) => { const s = i(35407); const n = i(10312); const r = i(83419); const o = i(89422); const a = i(96293); const h = i(36682); const l = i(95540); const u = i(48247); const c = i(49627); const d = i(29100); const f = new r({ Extends: d, initialize: function (t) { t.renderTarget = l(t, 'renderTarget', [{ scale: 1, autoResize: !0 }, { scale: 1, autoResize: !0 }, { scale: 0.5, autoResize: !0 }, { scale: 0.5, autoResize: !0 }]), t.vertShader = l(t, 'vertShader', c), t.shaders = l(t, 'shaders', [{ name: 'Copy', fragShader: h }, { name: 'AddBlend', fragShader: s }, { name: 'LinearBlend', fragShader: u }, { name: 'ColorMatrix', fragShader: a }]), t.attributes = l(t, 'attributes', [{ name: 'inPosition', size: 2 }, { name: 'inTexCoord', size: 2 }]), t.vertices = [-1, -1, 0, 0, -1, 1, 0, 1, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0], t.batchSize = 1, d.call(this, t), this.colorMatrix = new o(), this.copyShader, this.addShader, this.linearShader, this.colorMatrixShader, this.fullFrame1, this.fullFrame2, this.halfFrame1, this.halfFrame2 }, boot: function () { d.prototype.boot.call(this); const t = this.shaders; const e = this.renderTargets; this.copyShader = t[0], this.addShader = t[1], this.linearShader = t[2], this.colorMatrixShader = t[3], this.fullFrame1 = e[0], this.fullFrame2 = e[1], this.halfFrame1 = e[2], this.halfFrame2 = e[3] }, copyFrame: function (t, e, i, s, n) { void 0 === i && (i = 1), void 0 === s && (s = !0), void 0 === n && (n = !0); const r = this.gl; this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', i), r.activeTexture(r.TEXTURE0), r.bindTexture(r.TEXTURE_2D, t.texture.webGLTexture), e ? (r.viewport(0, 0, e.width, e.height), r.bindFramebuffer(r.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, e.texture.webGLTexture, 0)) : r.viewport(0, 0, t.width, t.height), s && (n ? r.clearColor(0, 0, 0, 0) : r.clearColor(0, 0, 0, 1), r.clear(r.COLOR_BUFFER_BIT)), r.bufferData(r.ARRAY_BUFFER, this.vertexData, r.STATIC_DRAW), r.drawArrays(r.TRIANGLES, 0, 6), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindTexture(r.TEXTURE_2D, null) }, blitFrame: function (t, e, i, s, r, o, a) { void 0 === i && (i = 1), void 0 === s && (s = !0), void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = !1); const h = this.gl; if (this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', i), h.activeTexture(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, t.texture.webGLTexture), t.height > e.height) h.viewport(0, 0, t.width, t.height), this.setTargetUVs(t, e); else { const l = e.height - t.height; h.viewport(0, l, t.width, t.height) } if (h.bindFramebuffer(h.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, e.texture.webGLTexture, 0), s && (r ? h.clearColor(0, 0, 0, 0) : h.clearColor(0, 0, 0, 1), h.clear(h.COLOR_BUFFER_BIT)), o) { var u = this.renderer.currentBlendMode; this.renderer.setBlendMode(n.ERASE) } a && this.flipY(), h.bufferData(h.ARRAY_BUFFER, this.vertexData, h.STATIC_DRAW), h.drawArrays(h.TRIANGLES, 0, 6), o && this.renderer.setBlendMode(u), h.bindFramebuffer(h.FRAMEBUFFER, null), h.bindTexture(h.TEXTURE_2D, null), this.resetUVs() }, copyFrameRect: function (t, e, i, s, n, r, o, a) { void 0 === o && (o = !0), void 0 === a && (a = !0); const h = this.gl; h.bindFramebuffer(h.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, t.texture.webGLTexture, 0), o && (a ? h.clearColor(0, 0, 0, 0) : h.clearColor(0, 0, 0, 1), h.clear(h.COLOR_BUFFER_BIT)), h.activeTexture(h.TEXTURE0), h.bindTexture(h.TEXTURE_2D, e.texture.webGLTexture), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, i, s, n, r), h.bindFramebuffer(h.FRAMEBUFFER, null), h.bindTexture(h.TEXTURE_2D, null) }, copyToGame: function (t) { const e = this.gl; this.setShader(this.copyShader), this.set1i('uMainSampler', 0), this.set1f('uBrightness', 1), this.renderer.popFramebuffer(), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, t.texture.webGLTexture), e.bufferData(e.ARRAY_BUFFER, this.vertexData, e.STATIC_DRAW), e.drawArrays(e.TRIANGLES, 0, 6) }, drawFrame: function (t, e, i, s) { void 0 === i && (i = !0), void 0 === s && (s = this.colorMatrix); const n = this.gl; this.setShader(this.colorMatrixShader), this.set1i('uMainSampler', 0), this.set1fv('uColorMatrix', s.getData()), this.set1f('uAlpha', s.alpha), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, t.texture.webGLTexture), e ? (n.viewport(0, 0, e.width, e.height), n.bindFramebuffer(n.FRAMEBUFFER, e.framebuffer.webGLFramebuffer), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.texture.webGLTexture, 0)) : n.viewport(0, 0, t.width, t.height), i ? n.clearColor(0, 0, 0, 0) : n.clearColor(0, 0, 0, 1), n.clear(n.COLOR_BUFFER_BIT), n.bufferData(n.ARRAY_BUFFER, this.vertexData, n.STATIC_DRAW), n.drawArrays(n.TRIANGLES, 0, 6), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindTexture(n.TEXTURE_2D, null) }, blendFrames: function (t, e, i, s, n, r) { void 0 === s && (s = 1), void 0 === n && (n = !0), void 0 === r && (r = this.linearShader); const o = this.gl; this.setShader(r), this.set1i('uMainSampler1', 0), this.set1i('uMainSampler2', 1), this.set1f('uStrength', s), o.activeTexture(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, t.texture.webGLTexture), o.activeTexture(o.TEXTURE1), o.bindTexture(o.TEXTURE_2D, e.texture.webGLTexture), i ? (o.bindFramebuffer(o.FRAMEBUFFER, i.framebuffer.webGLFramebuffer), o.framebufferTexture2D(o.FRAMEBUFFER, o.COLOR_ATTACHMENT0, o.TEXTURE_2D, i.texture.webGLTexture, 0), o.viewport(0, 0, i.width, i.height)) : o.viewport(0, 0, t.width, t.height), n ? o.clearColor(0, 0, 0, 0) : o.clearColor(0, 0, 0, 1), o.clear(o.COLOR_BUFFER_BIT), o.bufferData(o.ARRAY_BUFFER, this.vertexData, o.STATIC_DRAW), o.drawArrays(o.TRIANGLES, 0, 6), o.bindFramebuffer(o.FRAMEBUFFER, null), o.bindTexture(o.TEXTURE_2D, null) }, blendFramesAdditive: function (t, e, i, s, n) { this.blendFrames(t, e, i, s, n, this.addShader) }, clearFrame: function (t, e) { void 0 === e && (e = !0); const i = this.gl; i.viewport(0, 0, t.width, t.height), i.bindFramebuffer(i.FRAMEBUFFER, t.framebuffer.webGLFramebuffer), e ? i.clearColor(0, 0, 0, 0) : i.clearColor(0, 0, 0, 1), i.clear(i.COLOR_BUFFER_BIT); const s = this.renderer.currentFramebuffer; i.bindFramebuffer(i.FRAMEBUFFER, s.webGLFramebuffer) }, setUVs: function (t, e, i, s, n, r, o, a) { const h = this.vertexViewF32; h[2] = t, h[3] = e, h[6] = i, h[7] = s, h[10] = n, h[11] = r, h[14] = t, h[15] = e, h[18] = n, h[19] = r, h[22] = o, h[23] = a }, setTargetUVs: function (t, e) { let i = e.height / t.height; i = i > 0.5 ? 0.5 - (i - 0.5) : 0.5 - i + 0.5, this.setUVs(0, i, 0, 1 + i, 1, 1 + i, 1, i) }, flipX: function () { this.setUVs(1, 0, 1, 1, 0, 1, 0, 0) }, flipY: function () { this.setUVs(0, 1, 0, 0, 1, 0, 1, 1) }, resetUVs: function () { this.setUVs(0, 0, 0, 1, 1, 1, 1, 0) } }); t.exports = f }, 36060: t => { t.exports = { BITMAPMASK_PIPELINE: 'BitmapMaskPipeline', LIGHT_PIPELINE: 'Light2D', POINTLIGHT_PIPELINE: 'PointLightPipeline', SINGLE_PIPELINE: 'SinglePipeline', MULTI_PIPELINE: 'MultiPipeline', ROPE_PIPELINE: 'RopePipeline', GRAPHICS_PIPELINE: 'GraphicsPipeline', POSTFX_PIPELINE: 'PostFXPipeline', UTILITY_PIPELINE: 'UtilityPipeline', MOBILE_PIPELINE: 'MobilePipeline', FX_PIPELINE: 'FxPipeline' } }, 84817: t => { t.exports = 'pipelineafterflush' }, 36712: t => { t.exports = 'pipelinebeforeflush' }, 40285: t => { t.exports = 'pipelinebind' }, 65918: t => { t.exports = 'pipelineboot' }, 92852: t => { t.exports = 'pipelinedestroy' }, 56072: t => { t.exports = 'pipelinerebind' }, 57566: t => { t.exports = 'pipelineresize' }, 77085: (t, e, i) => { t.exports = { AFTER_FLUSH: i(84817), BEFORE_FLUSH: i(36712), BIND: i(40285), BOOT: i(65918), DESTROY: i(92852), REBIND: i(56072), RESIZE: i(57566) } }, 54812: (t, e, i) => { const s = i(83419); const n = i(99155); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.amount = 1 }, onPreRender: function (t, e) { t = this.getController(t), this.set1f('amount', t.amount, e) } }); t.exports = o }, 67329: (t, e, i) => { const s = i(83419); const n = i(24400); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.steps = 4, this.offsetX = 1, this.offsetY = 1, this.blurStrength = 1, this.strength = 1, this.glcolor = [1, 1, 1] }, onPreRender: function (t) { t = this.getController(t), this.set1f('strength', t.blurStrength), this.set3fv('color', t.glcolor) }, onDraw: function (t) { const e = this.getController(); const i = this.fullFrame1; const s = this.fullFrame2; this.copyFrame(t, s); for (let n = 2 / t.width * e.offsetX, r = 2 / t.height * e.offsetY, o = 0; o < e.steps; o++) this.set2f('offset', n, 0), this.copySprite(t, i), this.set2f('offset', 0, r), this.copySprite(i, t); this.blendFrames(s, t, i, e.strength), this.copyToGame(i) } }); t.exports = o }, 8861: (t, e, i) => { const s = i(83419); const n = i(41514); const r = i(51078); const o = i(94328); const a = i(84057); const h = new s({ Extends: a, initialize: function (t) { a.call(this, { game: t, shaders: [{ name: 'Gaussian5', fragShader: n }, { name: 'Gaussian9', fragShader: r }, { name: 'Gaussian13', fragShader: o }] }), this.activeShader = this.shaders[0], this.x = 2, this.y = 2, this.steps = 4, this.strength = 1, this.glcolor = [1, 1, 1] }, setQualityLow: function () { return this.activeShader = this.shaders[0], this }, setQualityMedium: function () { return this.activeShader = this.shaders[1], this }, setQualityHigh: function () { return this.activeShader = this.shaders[2], this }, onDraw: function (t) { const e = this.getController(); const i = this.gl; const s = this.fullFrame1; const n = i.getParameter(i.FRAMEBUFFER_BINDING); this.bind(this.shaders[e.quality]), i.activeTexture(i.TEXTURE0), i.viewport(0, 0, t.width, t.height), this.set1i('uMainSampler', 0), this.set2f('resolution', t.width, t.height), this.set1f('strength', e.strength), this.set3fv('color', e.glcolor); for (let r = 0; r < e.steps; r++) this.set2f('offset', e.x, 0), this.copySprite(t, s), this.set2f('offset', 0, e.y), this.copySprite(s, t); i.bindFramebuffer(i.FRAMEBUFFER, n), i.bindTexture(i.TEXTURE_2D, null), this.copyToGame(t) } }); t.exports = h }, 51051: (t, e, i) => { const s = i(83419); const n = i(90610); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.isTiltShift = !1, this.strength = 1, this.blurX = 1, this.blurY = 1, this.radius = 0.5, this.amount = 1, this.contrast = 0.2 }, onPreRender: function (t, e, i, s) { t = this.getController(t), this.set1f('radius', t.radius, e), this.set1f('amount', t.amount, e), this.set1f('contrast', t.contrast, e), this.set1f('strength', t.strength, e), this.set2f('blur', t.blurX, t.blurY, e), this.setBoolean('isTiltShift', t.isTiltShift, e), i && s && this.set2f('resolution', i, s, e) }, onDraw: function (t) { this.set2f('resolution', t.width, t.height), this.bindAndDraw(t) } }); t.exports = o }, 89428: (t, e, i) => { const s = i(83419); const n = i(91899); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.scale = 1, this.feather = 0.005, this.thickness = 8, this.glcolor = [1, 0.2, 0.7], this.glcolor2 = [1, 0, 0, 0.4] }, onPreRender: function (t, e, i, s) { t = this.getController(t), this.set1f('scale', t.scale, e), this.set1f('feather', t.feather, e), this.set1f('thickness', t.thickness, e), this.set3fv('color', t.glcolor, e), this.set4fv('backgroundColor', t.glcolor2, e), i && s && this.set2f('resolution', i, s, e) }, onDraw: function (t) { this.set2f('resolution', t.width, t.height), this.bindAndDraw(t) } }); t.exports = o }, 88904: (t, e, i) => { const s = i(83419); const n = i(84057); const r = new s({ Extends: n, initialize: function (t) { n.call(this, { game: t }) }, onDraw: function (t) { const e = this.fullFrame1; this.controller ? this.manager.drawFrame(t, e, !0, this.controller) : this.drawFrame(t, e), this.copyToGame(e) } }); t.exports = r }, 63563: (t, e, i) => { const s = i(83419); const n = i(47838); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.x = 0.005, this.y = 0.005, this.glTexture }, onBoot: function () { this.setTexture('__WHITE') }, setTexture: function (t) { const e = this.game.textures.getFrame(t); e && (this.glTexture = e.glTexture) }, onDraw: function (t) { const e = this.getController(); const i = this.fullFrame1; this.bind(), this.set1i('uMainSampler', 0), this.set1i('uDisplacementSampler', 1), this.set2f('amount', e.x, e.y), this.bindTexture(e.glTexture, 1), this.copySprite(t, i), this.copyToGame(i) } }); t.exports = o }, 94045: (t, e, i) => { const s = i(83419); const n = i(95540); const r = i(98656); const o = i(84057); const a = i(70554); const h = new s({ Extends: o, initialize: function (t, e) { const i = n(e, 'quality', 0.1); const s = n(e, 'distance', 10); o.call(this, { game: t, fragShader: a.setGlowQuality(r, t, i, s) }), this.outerStrength = 4, this.innerStrength = 0, this.knockout = !1, this.glcolor = [1, 1, 1, 1] }, onPreRender: function (t, e, i, s) { t = this.getController(t), this.set1f('outerStrength', t.outerStrength, e), this.set1f('innerStrength', t.innerStrength, e), this.set4fv('glowColor', t.glcolor, e), this.setBoolean('knockout', t.knockout, e), i && s && this.set2f('resolution', i, s, e) }, onDraw: function (t) { this.set2f('resolution', t.width, t.height), this.bindAndDraw(t) } }); t.exports = h }, 74088: (t, e, i) => { const s = i(83419); const n = i(70463); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.alpha = 0.2, this.size = 0, this.fromX = 0, this.fromY = 0, this.toX = 0, this.toY = 1, this.glcolor1 = [255, 0, 0], this.glcolor2 = [0, 255, 0] }, onPreRender: function (t, e) { t = this.getController(t), this.set1f('alpha', t.alpha, e), this.set1i('size', t.size, e), this.set3fv('color1', t.glcolor1, e), this.set3fv('color2', t.glcolor2, e), this.set2f('positionFrom', t.fromX, t.fromY, e), this.set2f('positionTo', t.toX, t.toY, e) } }); t.exports = o }, 99636: (t, e, i) => { const s = i(83419); const n = i(50831); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.amount = 1 }, onPreRender: function (t, e, i, s) { t = this.getController(t), this.set1f('amount', t.amount, e), i && s && this.set2f('resolution', i, s, e) }, onDraw: function (t) { this.set2f('resolution', t.width, t.height), this.bindAndDraw(t) } }); t.exports = o }, 34700: (t, e, i) => { const s = i(83419); const n = i(92595); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.x = 0, this.y = 0, this.decay = 0.1, this.power = 1, this.glcolor = [0, 0, 0, 1], this.samples = 6, this.intensity = 1 }, onPreRender: function (t, e) { const i = (t = this.getController(t)).samples; this.set1i('samples', i, e), this.set1f('intensity', t.intensity, e), this.set1f('decay', t.decay, e), this.set1f('power', t.power / i, e), this.set2f('lightPosition', t.x, t.y, e), this.set4fv('color', t.glcolor, e) } }); t.exports = o }, 91157: (t, e, i) => { const s = i(83419); const n = i(72464); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.speed = 0.5, this.lineWidth = 0.5, this.gradient = 3, this.reveal = !1 }, onPreRender: function (t, e, i, s) { t = this.getController(t), this.setTime('time', e), this.set1f('speed', t.speed, e), this.set1f('lineWidth', t.lineWidth, e), this.set1f('gradient', t.gradient, e), this.setBoolean('reveal', t.reveal, e), i && s && this.set2f('resolution', i, s, e) }, onDraw: function (t) { this.set2f('resolution', t.width, t.height), this.bindAndDraw(t) } }); t.exports = o }, 27797: (t, e, i) => { const s = i(83419); const n = i(39249); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.x = 0.5, this.y = 0.5, this.radius = 0.5, this.strength = 0.5 }, onPreRender: function (t, e) { t = this.getController(t), this.set1f('radius', t.radius, e), this.set1f('strength', t.strength, e), this.set2f('position', t.x, t.y, e) } }); t.exports = o }, 67603: (t, e, i) => { const s = i(83419); const n = i(2878); const r = i(84057); const o = new s({ Extends: r, initialize: function (t) { r.call(this, { game: t, fragShader: n }), this.progress = 0, this.wipeWidth = 0.1, this.direction = 0, this.axis = 0, this.reveal = !1 }, onPreRender: function (t, e) { const i = (t = this.getController(t)).progress; const s = t.wipeWidth; const n = t.direction; const r = t.axis; this.set4f('config', i, s, n, r, e), this.setBoolean('reveal', t.reveal, e) } }); t.exports = o }, 58918: (t, e, i) => { const s = { Barrel: i(54812), Bloom: i(67329), Blur: i(8861), Bokeh: i(51051), Circle: i(89428), ColorMatrix: i(88904), Displacement: i(63563), Glow: i(94045), Gradient: i(74088), Pixelate: i(99636), Shadow: i(34700), Shine: i(91157), Vignette: i(27797), Wipe: i(67603) }; t.exports = s }, 96615: (t, e, i) => { const s = i(36060); const n = i(79291); let r = { FX: i(58918), BitmapMaskPipeline: i(31302), Events: i(77085), FXPipeline: i(92651), LightPipeline: i(96569), MobilePipeline: i(56527), MultiPipeline: i(57516), PointLightPipeline: i(43439), PostFXPipeline: i(84057), PreFXPipeline: i(43558), RopePipeline: i(81041), SinglePipeline: i(12385), UtilityPipeline: i(7589) }; r = n(!1, r, s), t.exports = r }, 35407: t => { t.exports = ['#define SHADER_NAME PHASER_ADD_BLEND_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler1;', 'uniform sampler2D uMainSampler2;', 'uniform float uStrength;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);', '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);', '    gl_FragColor = frame1 + frame2 * uStrength;', '}'].join('\n') }, 78908: t => { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', 'precision mediump float;', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', 'void main ()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    if (!uInvertMaskAlpha)', '    {', '        mainColor *= maskColor.a;', '    }', '    else', '    {', '        mainColor *= (1.0 - maskColor.a);', '    }', '    gl_FragColor = mainColor;', '}'].join('\n') }, 85191: t => { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', 'precision mediump float;', 'attribute vec2 inPosition;', 'void main ()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}'].join('\n') }, 96293: t => { t.exports = ['#define SHADER_NAME PHASER_COLORMATRIX_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform float uColorMatrix[20];', 'uniform float uAlpha;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 c = texture2D(uMainSampler, outTexCoord);', '    if (uAlpha == 0.0)', '    {', '        gl_FragColor = c;', '        return;', '    }', '    if (c.a > 0.0)', '    {', '        c.rgb /= c.a;', '    }', '    vec4 result;', '    result.r = (uColorMatrix[0] * c.r) + (uColorMatrix[1] * c.g) + (uColorMatrix[2] * c.b) + (uColorMatrix[3] * c.a) + uColorMatrix[4];', '    result.g = (uColorMatrix[5] * c.r) + (uColorMatrix[6] * c.g) + (uColorMatrix[7] * c.b) + (uColorMatrix[8] * c.a) + uColorMatrix[9];', '    result.b = (uColorMatrix[10] * c.r) + (uColorMatrix[11] * c.g) + (uColorMatrix[12] * c.b) + (uColorMatrix[13] * c.a) + uColorMatrix[14];', '    result.a = (uColorMatrix[15] * c.r) + (uColorMatrix[16] * c.g) + (uColorMatrix[17] * c.b) + (uColorMatrix[18] * c.a) + uColorMatrix[19];', '    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);', '    rgb *= result.a;', '    gl_FragColor = vec4(rgb, result.a);', '}'].join('\n') }, 36682: t => { t.exports = ['#define SHADER_NAME PHASER_COPY_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform float uBrightness;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    gl_FragColor = texture2D(uMainSampler, outTexCoord) * uBrightness;', '}'].join('\n') }, 99155: t => { t.exports = ['#define SHADER_NAME BARREL_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform float amount;', 'varying vec2 outTexCoord;', 'vec2 Distort(vec2 p)', '{', '    float theta  = atan(p.y, p.x);', '    float radius = length(p);', '    radius = pow(radius, amount);', '    p.x = radius * cos(theta);', '    p.y = radius * sin(theta);', '    return 0.5 * (p + 1.0);', '}', 'void main()', '{', '    vec2 xy = 2.0 * outTexCoord - 1.0;', '    vec2 texCoord = outTexCoord;', '    if (length(xy) < 1.0)', '    {', '        texCoord = Distort(xy);', '    }', '    gl_FragColor = texture2D(uMainSampler, texCoord);', '}'].join('\n') }, 24400: t => { t.exports = ['#define SHADER_NAME BLOOM_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 offset;', 'uniform float strength;', 'uniform vec3 color;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 sum = texture2D(uMainSampler, outTexCoord) * 0.204164 * strength;', '    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 1.407333) * 0.304005;', '    sum = sum + texture2D(uMainSampler, outTexCoord - offset * 1.407333) * 0.304005;', '    sum = sum + texture2D(uMainSampler, outTexCoord + offset * 3.294215) * 0.093913;', '    gl_FragColor = (sum + texture2D(uMainSampler, outTexCoord - offset * 3.294215) * 0.093913) * vec4(color, 1);', '}'].join('\n') }, 94328: t => { t.exports = ['#define SHADER_NAME BLUR_HIGH_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform vec2 offset;', 'uniform float strength;', 'uniform vec3 color;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec2 uv = outTexCoord;', '    vec4 col = vec4(0.0);', '    vec2 off1 = vec2(1.411764705882353) * offset * strength;', '    vec2 off2 = vec2(3.2941176470588234) * offset * strength;', '    vec2 off3 = vec2(5.176470588235294) * offset * strength;', '    col += texture2D(uMainSampler, uv) * 0.1964825501511404;', '    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.2969069646728344;', '    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.2969069646728344;', '    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.09447039785044732;', '    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.09447039785044732;', '    col += texture2D(uMainSampler, uv + (off3 / resolution)) * 0.010381362401148057;', '    col += texture2D(uMainSampler, uv - (off3 / resolution)) * 0.010381362401148057;', '    gl_FragColor = col * vec4(color, 1.0);', '}'].join('\n') }, 41514: t => { t.exports = ['#define SHADER_NAME BLUR_LOW_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform vec2 offset;', 'uniform float strength;', 'uniform vec3 color;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec2 uv = outTexCoord;', '    vec4 col = vec4(0.0);', '    vec2 offset = vec2(1.333) * offset * strength;', '    col += texture2D(uMainSampler, uv) * 0.29411764705882354;', '    col += texture2D(uMainSampler, uv + (offset / resolution)) * 0.35294117647058826;', '    col += texture2D(uMainSampler, uv - (offset / resolution)) * 0.35294117647058826;', '    gl_FragColor = col * vec4(color, 1.0);', '}'].join('\n') }, 51078: t => { t.exports = ['#define SHADER_NAME BLUR_MED_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform vec2 offset;', 'uniform float strength;', 'uniform vec3 color;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec2 uv = outTexCoord;', '    vec4 col = vec4(0.0);', '    vec2 off1 = vec2(1.3846153846) * offset * strength;', '    vec2 off2 = vec2(3.2307692308) * offset * strength;', '    col += texture2D(uMainSampler, uv) * 0.2270270270;', '    col += texture2D(uMainSampler, uv + (off1 / resolution)) * 0.3162162162;', '    col += texture2D(uMainSampler, uv - (off1 / resolution)) * 0.3162162162;', '    col += texture2D(uMainSampler, uv + (off2 / resolution)) * 0.0702702703;', '    col += texture2D(uMainSampler, uv - (off2 / resolution)) * 0.0702702703;', '    gl_FragColor = col * vec4(color, 1.0);', '}'].join('\n') }, 90610: t => { t.exports = ['#define SHADER_NAME BOKEH_FS', 'precision mediump float;', '#define ITERATIONS 100.0', '#define ONEOVER_ITR 1.0 / ITERATIONS', '#define PI 3.141596', '#define GOLDEN_ANGLE 2.39996323', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform float radius;', 'uniform float amount;', 'uniform float contrast;', 'uniform bool isTiltShift;', 'uniform float strength;', 'uniform vec2 blur;', 'varying vec2 outTexCoord;', 'vec2 Sample (in float theta, inout float r)', '{', '    r += 1.0 / r;', '    return (r - 1.0) * vec2(cos(theta), sin(theta)) * 0.06;', '}', 'vec3 Bokeh (sampler2D tex, vec2 uv, float radius)', '{', '    vec3 acc = vec3(0.0);', '    vec3 div = vec3(0.0);', '    vec2 pixel = vec2(resolution.y / resolution.x, 1.0) * radius * .025;', '    float r = 1.0;', '    for (float j = 0.0; j < GOLDEN_ANGLE * ITERATIONS; j += GOLDEN_ANGLE)', '    {', '        vec3 col = texture2D(tex, uv + pixel * Sample(j, r)).xyz;', '        col = contrast > 0.0 ? col * col * (1.0 + contrast) : col;', '        vec3 bokeh = vec3(0.5) + pow(col, vec3(10.0)) * amount;', '        acc += col * bokeh;', '        div += bokeh;', '    }', '    return acc / div;', '}', 'void main ()', '{', '    float shift = 1.0;', '    if (isTiltShift)', '    {', '        vec2 uv = vec2(gl_FragCoord.xy / resolution + vec2(-0.5, -0.5)) * 2.0;', '        float centerStrength = 1.0;', '        shift = length(uv * blur * strength) * centerStrength;', '    }', '    gl_FragColor = vec4(Bokeh(uMainSampler, outTexCoord * vec2(1.0, 1.0), radius * shift), 0.0);', '}'].join('\n') }, 91899: t => { t.exports = ['#define SHADER_NAME CIRCLE_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform vec3 color;', 'uniform vec4 backgroundColor;', 'uniform float thickness;', 'uniform float scale;', 'uniform float feather;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec2 position = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;', '    float aspectRatio = resolution.x / resolution.y;', '    position.x *= aspectRatio;', '    float grad = length(position);', '    float outer = aspectRatio;', '    float inner = outer - (thickness * 2.0 / resolution.y);', '    if (aspectRatio >= 1.0)', '    {', '        float f = 2.0 + (resolution.y / resolution.x);', '        outer = 1.0;', '        inner = 1.0 - (thickness * f / resolution.x);', '    }', '    outer *= scale;', '    inner *= scale;', '    float circle = smoothstep(outer, outer - 0.01, grad);', '    float ring = circle - smoothstep(inner, inner - feather, grad);', '    texture = mix(backgroundColor * backgroundColor.a, texture, texture.a);', '    texture = (texture * (circle - ring));', '    gl_FragColor = vec4(texture.rgb + (ring * color), texture.a);', '}'].join('\n') }, 47838: t => { t.exports = ['#define SHADER_NAME DISPLACEMENT_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uDisplacementSampler;', 'uniform vec2 amount;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec2 disp = (-vec2(0.5, 0.5) + texture2D(uDisplacementSampler, outTexCoord).rr) * amount;', '    gl_FragColor = texture2D(uMainSampler, outTexCoord + disp).rgba;', '}'].join('\n') }, 98656: t => { t.exports = ['#define SHADER_NAME GLOW_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'varying vec2 outTexCoord;', 'uniform float outerStrength;', 'uniform float innerStrength;', 'uniform vec2 resolution;', 'uniform vec4 glowColor;', 'uniform bool knockout;', 'const float PI = 3.14159265358979323846264;', 'const float DIST = __DIST__;', 'const float SIZE = min(__SIZE__, PI * 2.0);', 'const float STEP = ceil(PI * 2.0 / SIZE);', 'const float MAX_ALPHA = STEP * DIST * (DIST + 1.0) / 2.0;', 'void main ()', '{', '    vec2 px = vec2(1.0 / resolution.x, 1.0 / resolution.y);', '    float totalAlpha = 0.0;', '    vec2 direction;', '    vec2 displaced;', '    vec4 color;', '    for (float angle = 0.0; angle < PI * 2.0; angle += SIZE)', '    {', '        direction = vec2(cos(angle), sin(angle)) * px;', '        for (float curDistance = 0.0; curDistance < DIST; curDistance++)', '        {', '            displaced = outTexCoord + direction * (curDistance + 1.0);', '            color = texture2D(uMainSampler, displaced);', '            totalAlpha += (DIST - curDistance) * color.a;', '        }', '    }', '    color = texture2D(uMainSampler, outTexCoord);', '    float alphaRatio = (totalAlpha / MAX_ALPHA);', '    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * color.a;', '    float innerGlowStrength = min(1.0, innerGlowAlpha);', '    vec4 innerColor = mix(color, glowColor, innerGlowStrength);', '    float outerGlowAlpha = alphaRatio * outerStrength * (1.0 - color.a);', '    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);', '    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;', '    if (knockout)', '    {', '        float resultAlpha = outerGlowAlpha + innerGlowAlpha;', '        gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);', '    }', '    else', '    {', '        gl_FragColor = innerColor + outerGlowColor;', '    }', '}'].join('\n') }, 70463: t => { t.exports = ['#define SHADER_NAME GRADIENT_FS', '#define SRGB_TO_LINEAR(c) pow((c), vec3(2.2))', '#define LINEAR_TO_SRGB(c) pow((c), vec3(1.0 / 2.2))', '#define SRGB(r, g, b) SRGB_TO_LINEAR(vec3(float(r), float(g), float(b)) / 255.0)', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 positionFrom;', 'uniform vec2 positionTo;', 'uniform vec3 color1;', 'uniform vec3 color2;', 'uniform float alpha;', 'uniform int size;', 'varying vec2 outTexCoord;', 'float gradientNoise(in vec2 uv)', '{', '    const vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);', '    return fract(magic.z * fract(dot(uv, magic.xy)));', '}', 'float stepped (in float s, in float scale, in int steps)', '{', '    return steps > 0 ? floor( s / ((1.0 * scale) / float(steps))) * 1.0 / float(steps - 1) : s;', '}', 'void main ()', '{', '    vec2 a = positionFrom;', '    vec2 b = positionTo;', '    vec2 ba = b - a;', '    float d = dot(outTexCoord - a, ba) / dot(ba, ba);', '    float t = size > 0 ? stepped(d, 1.0, size) : d;', '    t = smoothstep(0.0, 1.0, clamp(t, 0.0, 1.0));', '    vec3 color = mix(SRGB(color1.r, color1.g, color1.b), SRGB(color2.r, color2.g, color2.b), t);', '    color = LINEAR_TO_SRGB(color);', '    color += (1.0 / 255.0) * gradientNoise(outTexCoord) - (0.5 / 255.0);', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    gl_FragColor = vec4(mix(color.rgb, texture.rgb, alpha), 1.0) * texture.a;', '}'].join('\n') }, 50831: t => { t.exports = ['#define SHADER_NAME PIXELATE_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform float amount;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    float pixelSize = floor(2.0 + amount);', '    vec2 center = pixelSize * floor(outTexCoord * resolution / pixelSize) + pixelSize * vec2(0.5, 0.5);', '    vec2 corner1 = center + pixelSize * vec2(-0.5, -0.5);', '    vec2 corner2 = center + pixelSize * vec2(+0.5, -0.5);', '    vec2 corner3 = center + pixelSize * vec2(+0.5, +0.5);', '    vec2 corner4 = center + pixelSize * vec2(-0.5, +0.5);', '    vec4 pixel = 0.4 * texture2D(uMainSampler, center / resolution);', '    pixel += 0.15 * texture2D(uMainSampler, corner1 / resolution);', '    pixel += 0.15 * texture2D(uMainSampler, corner2 / resolution);', '    pixel += 0.15 * texture2D(uMainSampler, corner3 / resolution);', '    pixel += 0.15 * texture2D(uMainSampler, corner4 / resolution);', '    gl_FragColor = pixel;', '}'].join('\n') }, 92595: t => { t.exports = ['#define SHADER_NAME SHADOW_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'varying vec2 outTexCoord;', 'uniform vec2 lightPosition;', 'uniform vec4 color;', 'uniform float decay;', 'uniform float power;', 'uniform float intensity;', 'uniform int samples;', 'const int MAX = 12;', 'void main ()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec2 pc = (lightPosition - outTexCoord) * intensity;', '    float shadow = 0.0;', '    float limit = max(float(MAX), float(samples));', '    for (int i = 0; i < MAX; ++i)', '    {', '        if (i >= samples)', '        {', '            break;', '        }', '        shadow += texture2D(uMainSampler, outTexCoord + float(i) * decay / limit * pc).a * power;', '    }', '    float mask = 1.0 - texture.a;', '    gl_FragColor = mix(texture, color, shadow * mask);', '}'].join('\n') }, 72464: t => { t.exports = ['#define SHADER_NAME SHINE_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec2 resolution;', 'uniform bool reveal;', 'uniform float speed;', 'uniform float time;', 'uniform float lineWidth;', 'uniform float gradient;', 'varying vec2 outTexCoord;', 'void main ()', '{', '\tvec2 uv = gl_FragCoord.xy / resolution.xy;', '    vec4 tex = texture2D(uMainSampler, outTexCoord);', '    vec4 col1 = vec4(0.3, 0.0, 0.0, 1.0);', '    vec4 col2 = vec4(0.85, 0.85, 0.85, 1.0);', '    uv.x = uv.x - mod(time * speed, 2.0) + 0.5;', '    float y = uv.x * gradient;', '    float s = smoothstep(y - lineWidth, y, uv.y) - smoothstep(y, y + lineWidth, uv.y);', '    gl_FragColor = (((s * col1) + (s * col2)) * tex);', '    if (!reveal)', '    {', '        gl_FragColor += tex;', '    }', '}'].join('\n') }, 39249: t => { t.exports = ['#define SHADER_NAME VIGNETTE_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform float radius;', 'uniform float strength;', 'uniform vec2 position;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 col = vec4(1.0);', '    float d = length(outTexCoord - position);', '    if (d <= radius)', '    {', '        float g = d / radius;', '        g = sin(g * 3.14 * strength);', '    \tcol = vec4(g * g * g);', '    }', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    gl_FragColor = texture * (1.0 - col);', '}'].join('\n') }, 2878: t => { t.exports = ['#define SHADER_NAME WIPE_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'uniform vec4 config;', 'uniform bool reveal;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec2 uv = outTexCoord;', '    vec4 color0;', '    vec4 color1;', '    if (reveal)', '    {', '        color0 = vec4(0);', '        color1 = texture2D(uMainSampler, uv);', '    }', '    else', '    {', '        color0 = texture2D(uMainSampler, uv);', '        color1 = vec4(0);', '    }', '    float distance = config.x;', '    float width = config.y;', '    float direction = config.z;', '    float axis = uv.x;', '    if (config.w == 1.0)', '    {', '        axis = uv.y;', '    }', '    float adjust = mix(width, -width, distance);', '    float value = smoothstep(distance - width, distance + width, abs(direction - axis) + adjust);', '    gl_FragColor = mix(color1, color0, value);', '}'].join('\n') }, 31063: t => { t.exports = ['#define SHADER_NAME PHASER_LIGHT_FS', 'precision mediump float;', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', 'const int kMaxLights = %LIGHT_COUNT%;', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', 'uniform mat3 uInverseRotationMatrix;', 'uniform int uLightCount;', 'varying vec2 outTexCoord;', 'varying float outTexId;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 color = texture * texel;', '    if (outTintEffect == 1.0)', '    {', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        color = texel;', '    }', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        if (index < uLightCount)', '        {', '            Light light = uLights[index];', '            vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '            vec3 lightNormal = normalize(lightDir);', '            float distToSurf = length(lightDir) * uCamera.w;', '            float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '            float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '            float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '            vec3 diffuse = light.color * diffuseFactor;', '            finalColor += (attenuation * diffuse) * light.intensity;', '        }', '    }', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '}'].join('\n') }, 48247: t => { t.exports = ['#define SHADER_NAME PHASER_LINEAR_BLEND_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler1;', 'uniform sampler2D uMainSampler2;', 'uniform float uStrength;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    vec4 frame1 = texture2D(uMainSampler1, outTexCoord);', '    vec4 frame2 = texture2D(uMainSampler2, outTexCoord);', '    gl_FragColor = mix(frame1, frame2 * uStrength, 0.5);', '}'].join('\n') }, 41214: t => { t.exports = ['#define SHADER_NAME PHASER_MESH_FS', 'precision mediump float;', 'uniform vec3 uLightPosition;', 'uniform vec3 uLightAmbient;', 'uniform vec3 uLightDiffuse;', 'uniform vec3 uLightSpecular;', 'uniform vec3 uFogColor;', 'uniform float uFogNear;', 'uniform float uFogFar;', 'uniform vec3 uMaterialAmbient;', 'uniform vec3 uMaterialDiffuse;', 'uniform vec3 uMaterialSpecular;', 'uniform float uMaterialShine;', 'uniform vec3 uCameraPosition;', 'uniform sampler2D uTexture;', 'varying vec2 vTextureCoord;', 'varying vec3 vNormal;', 'varying vec3 vPosition;', 'void main (void)', '{', '    vec4 color = texture2D(uTexture, vTextureCoord);', '    vec3 ambient = uLightAmbient * uMaterialAmbient;', '    vec3 norm = normalize(vNormal);', '    vec3 lightDir = normalize(uLightPosition - vPosition);', '    float diff = max(dot(norm, lightDir), 0.0);', '    vec3 diffuse = uLightDiffuse * (diff * uMaterialDiffuse);', '    vec3 viewDir = normalize(uCameraPosition - vPosition);', '    vec3 reflectDir = reflect(-lightDir, norm);', '    float spec = pow(max(dot(viewDir, reflectDir), 0.0), uMaterialShine);', '    vec3 specular = uLightSpecular * (spec * uMaterialSpecular);', '    vec3 result = (ambient + diffuse + specular) * color.rgb;', '    float depth = gl_FragCoord.z / gl_FragCoord.w;', '    float fogFactor = smoothstep(uFogNear, uFogFar, depth);', '    gl_FragColor.rgb = mix(result.rgb, uFogColor, fogFactor);', '    gl_FragColor.a = color.a;', '}'].join('\n') }, 39653: t => { t.exports = ['#define SHADER_NAME PHASER_MESH_VS', 'precision mediump float;', 'attribute vec3 aVertexPosition;', 'attribute vec3 aVertexNormal;', 'attribute vec2 aTextureCoord;', 'uniform mat4 uViewProjectionMatrix;', 'uniform mat4 uModelMatrix;', 'uniform mat4 uNormalMatrix;', 'varying vec2 vTextureCoord;', 'varying vec3 vNormal;', 'varying vec3 vPosition;', 'void main ()', '{', '    vTextureCoord = aTextureCoord;', '    vPosition = vec3(uModelMatrix * vec4(aVertexPosition, 1.0));', '    vNormal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));', '    gl_Position = uViewProjectionMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);', '}'].join('\n') }, 62143: t => { t.exports = ['#define SHADER_NAME PHASER_MOBILE_FS', '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', '#else', 'precision mediump float;', '#endif', 'uniform sampler2D uMainSampler;', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 color = texture * texel;', '    if (outTintEffect == 1.0)', '    {', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        color = texel;', '    }', '    gl_FragColor = color;', '}'].join('\n') }, 47940: t => { t.exports = ['#define SHADER_NAME PHASER_MOBILE_VS', 'precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform int uRoundPixels;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTexId;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '    if (uRoundPixels == 1)', '    {', '        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;', '    }', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}'].join('\n') }, 98840: t => { t.exports = ['#define SHADER_NAME PHASER_MULTI_FS', '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', '#else', 'precision mediump float;', '#endif', 'uniform sampler2D uMainSampler[%count%];', 'varying vec2 outTexCoord;', 'varying float outTexId;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    vec4 texture;', '    %forloop%', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '    vec4 color = texture * texel;', '    if (outTintEffect == 1.0)', '    {', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        color = texel;', '    }', '    gl_FragColor = color;', '}'].join('\n') }, 44667: t => { t.exports = ['#define SHADER_NAME PHASER_MULTI_VS', 'precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform int uRoundPixels;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTexId;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', 'varying vec2 outTexCoord;', 'varying float outTexId;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '    if (uRoundPixels == 1)', '    {', '        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;', '    }', '    outTexCoord = inTexCoord;', '    outTexId = inTexId;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}'].join('\n') }, 4127: t => { t.exports = ['#define SHADER_NAME PHASER_POINTLIGHT_FS', 'precision mediump float;', 'uniform vec2 uResolution;', 'uniform float uCameraZoom;', 'varying vec4 lightPosition;', 'varying vec4 lightColor;', 'varying float lightRadius;', 'varying float lightAttenuation;', 'void main ()', '{', '    vec2 center = (lightPosition.xy + 1.0) * (uResolution.xy * 0.5);', '    float distToSurf = length(center - gl_FragCoord.xy);', '    float radius = 1.0 - distToSurf / (lightRadius * uCameraZoom);', '    float intensity = smoothstep(0.0, 1.0, radius * lightAttenuation);', '    vec4 color = vec4(intensity, intensity, intensity, 0.0) * lightColor;', '    gl_FragColor = vec4(color.rgb * lightColor.a, color.a);', '}'].join('\n') }, 89924: t => { t.exports = ['#define SHADER_NAME PHASER_POINTLIGHT_VS', 'precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'attribute vec2 inPosition;', 'attribute vec2 inLightPosition;', 'attribute vec4 inLightColor;', 'attribute float inLightRadius;', 'attribute float inLightAttenuation;', 'varying vec4 lightPosition;', 'varying vec4 lightColor;', 'varying float lightRadius;', 'varying float lightAttenuation;', 'void main ()', '{', '    lightColor = inLightColor;', '    lightRadius = inLightRadius;', '    lightAttenuation = inLightAttenuation;', '    lightPosition = uProjectionMatrix * vec4(inLightPosition, 1.0, 1.0);', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '}'].join('\n') }, 27681: t => { t.exports = ['#define SHADER_NAME PHASER_POSTFX_FS', 'precision mediump float;', 'uniform sampler2D uMainSampler;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    gl_FragColor = texture2D(uMainSampler, outTexCoord);', '}'].join('\n') }, 49627: t => { t.exports = ['#define SHADER_NAME PHASER_QUAD_VS', 'precision mediump float;', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'varying vec2 outFragCoord;', 'varying vec2 outTexCoord;', 'void main ()', '{', '    outFragCoord = inPosition.xy * 0.5 + 0.5;', '    outTexCoord = inTexCoord;', '    gl_Position = vec4(inPosition, 0, 1);', '}'].join('\n') }, 45561: t => { t.exports = ['#define SHADER_NAME PHASER_SINGLE_FS', '#ifdef GL_FRAGMENT_PRECISION_HIGH', 'precision highp float;', '#else', 'precision mediump float;', '#endif', 'uniform sampler2D uMainSampler;', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 texel = vec4(outTint.bgr * outTint.a, outTint.a);', '    vec4 color = texture * texel;', '    if (outTintEffect == 1.0)', '    {', '        color.rgb = mix(texture.rgb, outTint.bgr * outTint.a, texture.a);', '    }', '    else if (outTintEffect == 2.0)', '    {', '        color = texel;', '    }', '    gl_FragColor = color;', '}'].join('\n') }, 60722: t => { t.exports = ['#define SHADER_NAME PHASER_SINGLE_VS', 'precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform int uRoundPixels;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTexId;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', 'void main ()', '{', '    gl_Position = uProjectionMatrix * vec4(inPosition, 1.0, 1.0);', '    if (uRoundPixels == 1)', '    {', '        gl_Position.xy = floor(((gl_Position.xy + 1.0) * 0.5 * uResolution) + 0.5) / uResolution * 2.0 - 1.0;', '    }', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}'].join('\n') }, 89350: (t, e, i) => { t.exports = { AddBlendFrag: i(35407), BitmapMaskFrag: i(78908), BitmapMaskVert: i(85191), ColorMatrixFrag: i(96293), CopyFrag: i(36682), FXBarrelFrag: i(99155), FXBloomFrag: i(24400), FXBlurHighFrag: i(94328), FXBlurLowFrag: i(41514), FXBlurMedFrag: i(51078), FXBokehFrag: i(90610), FXCircleFrag: i(91899), FXDisplacementFrag: i(47838), FXGlowFrag: i(98656), FXGradientFrag: i(70463), FXPixelateFrag: i(50831), FXShadowFrag: i(92595), FXShineFrag: i(72464), FXVignetteFrag: i(39249), FXWipeFrag: i(2878), LightFrag: i(31063), LinearBlendFrag: i(48247), MeshFrag: i(41214), MeshVert: i(39653), MobileFrag: i(62143), MobileVert: i(47940), MultiFrag: i(98840), MultiVert: i(44667), PointLightFrag: i(4127), PointLightVert: i(89924), PostFXFrag: i(27681), QuadVert: i(49627), SingleFrag: i(45561), SingleVert: i(60722) } }, 93567: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i) { this.webGLAttribLocation = -1, this.gl = t, this.program = e, this.name = i, this.createResource() }, createResource: function () { if (this.program.webGLProgram !== null) { const t = this.gl; t.isContextLost() || (this.webGLAttribLocation = t.getAttribLocation(this.program.webGLProgram, this.name)) } else this.webGLAttribLocation = -1 }, destroy: function () { this.gl = null, this.program = null, this.name = null, this.webGLAttribLocation = -1 } }); t.exports = s }, 26128: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s) { this.webGLBuffer = null, this.gl = t, this.initialDataOrSize = e, this.bufferType = i, this.bufferUsage = s, this.createResource() }, createResource: function () { if (this.initialDataOrSize !== null) { const t = this.gl; if (!t.isContextLost()) { const e = this.bufferType; const i = t.createBuffer(); this.webGLBuffer = i, t.bindBuffer(e, this.webGLBuffer), t.bufferData(e, this.initialDataOrSize, this.bufferUsage), t.bindBuffer(e, null) } } }, destroy: function () { const t = this.gl; t.isContextLost() || t.deleteBuffer(this.webGLBuffer), this.webGLBuffer = null, this.initialDataOrSize = null, this.gl = null } }); t.exports = s }, 84387: (t, e, i) => { const s = i(83419); const n = { 36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported' }; const r = new s({ initialize: function (t, e, i, s, n) { this.webGLFramebuffer = null, this.gl = t, this.width = e, this.height = i, this.renderTexture = s, this.addDepthStencilBuffer = !!n, this.createResource() }, createResource: function () { const t = this.gl; if (!t.isContextLost()) { let e; const i = this.renderTexture; const s = t.createFramebuffer(); if (this.webGLFramebuffer = s, t.bindFramebuffer(t.FRAMEBUFFER, s), i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i.webGLTexture, 0), (e = t.checkFramebufferStatus(t.FRAMEBUFFER)) !== t.FRAMEBUFFER_COMPLETE) throw new Error('Framebuffer status: ' + (n[e] || e)); if (this.addDepthStencilBuffer) { const r = t.createRenderbuffer(); t.bindRenderbuffer(t.RENDERBUFFER, r), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, this.width, this.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, r) } t.bindFramebuffer(t.FRAMEBUFFER, null) } }, destroy: function () { if (this.webGLFramebuffer !== null) { const t = this.gl; if (!t.isContextLost()) { t.bindFramebuffer(t.FRAMEBUFFER, this.webGLFramebuffer); const e = t.getFramebufferAttachmentParameter(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME); e !== null && (t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0), t.deleteTexture(e)); const i = t.getFramebufferAttachmentParameter(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME); i !== null && t.deleteRenderbuffer(i), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteFramebuffer(this.webGLFramebuffer) } this.renderTexture = null, this.webGLFramebuffer = null, this.gl = null } } }); t.exports = r }, 1482: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i) { this.webGLProgram = null, this.gl = t, this.vertexSource = e, this.fragmentSource = i, this.createResource() }, createResource: function () { const t = this.gl; if (!t.isContextLost()) { const e = t.createProgram(); const i = t.createShader(t.VERTEX_SHADER); const s = t.createShader(t.FRAGMENT_SHADER); t.shaderSource(i, this.vertexSource), t.shaderSource(s, this.fragmentSource), t.compileShader(i), t.compileShader(s); const n = 'Shader failed:\n'; if (!t.getShaderParameter(i, t.COMPILE_STATUS)) throw new Error('Vertex ' + n + t.getShaderInfoLog(i)); if (!t.getShaderParameter(s, t.COMPILE_STATUS)) throw new Error('Fragment ' + n + t.getShaderInfoLog(s)); if (t.attachShader(e, i), t.attachShader(e, s), t.linkProgram(e), !t.getProgramParameter(e, t.LINK_STATUS)) throw new Error('Link ' + n + t.getProgramInfoLog(e)); t.useProgram(e), this.webGLProgram = e } }, destroy: function () { this.webGLProgram && (this.gl.isContextLost() || this.gl.deleteProgram(this.webGLProgram), this.webGLProgram = null, this.gl = null) } }); t.exports = s }, 82751: (t, e, i) => { const s = i(83419); const n = i(50030); var r = new s({ initialize: function (t, e, i, s, n, r, o, a, h, l, u, c, d) { this.webGLTexture = null, this.isRenderTexture = !1, this.gl = t, this.mipLevel = e, this.minFilter = i, this.magFilter = s, this.wrapT = n, this.wrapS = r, this.format = o, this.pixels = a, this.width = h, this.height = l, this.pma = u == null || u, this.forceSize = !!c, this.flipY = !!d, this.__SPECTOR_Metadata = {}, this.createResource() }, createResource: function () { const t = this.gl; if (!t.isContextLost()) if (this.pixels instanceof r) this.webGLTexture = this.pixels.webGLTexture; else { const e = t.createTexture(); e.__SPECTOR_Metadata = this.__SPECTOR_Metadata, this.webGLTexture = e, this._processTexture() } }, update: function (t, e, i, s, n, r, o, a, h) { e !== 0 && i !== 0 && (this.pixels = t, this.width = e, this.height = i, this.flipY = s, this.wrapS = n, this.wrapT = r, this.minFilter = o, this.magFilter = a, this.format = h, this.gl.isContextLost() || this._processTexture()) }, _processTexture: function () { const t = this.gl; t.activeTexture(t.TEXTURE0); const e = t.getParameter(t.TEXTURE_BINDING_2D); t.bindTexture(t.TEXTURE_2D, this.webGLTexture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, this.minFilter), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, this.magFilter), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this.wrapS), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this.wrapT), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.pma), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, this.flipY); const i = this.pixels; const s = this.mipLevel; let r = this.width; let o = this.height; const a = this.format; let h = !1; if (i == null) t.texImage2D(t.TEXTURE_2D, s, a, r, o, 0, a, t.UNSIGNED_BYTE, null), h = n(r, o); else if (i.compressed) { r = i.width, o = i.height, h = i.generateMipmap; for (let l = 0; l < i.mipmaps.length; l++)t.compressedTexImage2D(t.TEXTURE_2D, l, i.internalFormat, i.mipmaps[l].width, i.mipmaps[l].height, 0, i.mipmaps[l].data) } else i instanceof Uint8Array ? (t.texImage2D(t.TEXTURE_2D, s, a, r, o, 0, a, t.UNSIGNED_BYTE, i), h = n(r, o)) : (this.forceSize || (r = i.width, o = i.height), t.texImage2D(t.TEXTURE_2D, s, a, a, t.UNSIGNED_BYTE, i), h = n(r, o)); h && t.generateMipmap(t.TEXTURE_2D), e ? t.bindTexture(t.TEXTURE_2D, e) : t.bindTexture(t.TEXTURE_2D, null) }, spectorMetadata: { get: function () { return this.__SPECTOR_Metadata }, set: function (t) { this.__SPECTOR_Metadata = t, this.gl.isContextLost() || (this.webGLTexture.__SPECTOR_Metadata = t) } }, destroy: function () { this.webGLTexture !== null && (this.gl.isContextLost() || this.pixels instanceof r || this.gl.deleteTexture(this.webGLTexture), this.pixels = null, this.webGLTexture = null, this.gl = null) } }); t.exports = r }, 57183: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i) { this.webGLUniformLocation = null, this.gl = t, this.program = e, this.name = i, this.createResource() }, createResource: function () { if (this.program.webGLProgram !== null) { const t = this.gl; t.isContextLost() || (this.webGLUniformLocation = t.getUniformLocation(this.program.webGLProgram, this.name)) } else this.webGLUniformLocation = null }, destroy: function () { this.gl = null, this.program = null, this.name = null, this.webGLUniformLocation = null } }); t.exports = s }, 9503: (t, e, i) => { const s = { WebGLAttribLocationWrapper: i(93567), WebGLBufferWrapper: i(26128), WebGLProgramWrapper: i(1482), WebGLTextureWrapper: i(82751), WebGLFramebufferWrapper: i(84387), WebGLUniformLocationWrapper: i(57183) }; t.exports = s }, 76531: (t, e, i) => { const s = i(13560); const n = i(83419); const r = i(50792); const o = i(97480); const a = i(8443); const h = i(57811); const l = i(74403); const u = i(45818); const c = i(29747); const d = i(87841); const f = i(86555); const p = i(56583); const v = i(26099); const g = i(38058); const m = new n({ Extends: r, initialize: function (t) { r.call(this), this.game = t, this.canvas, this.canvasBounds = new d(), this.parent = null, this.parentIsWindow = !1, this.parentSize = new f(), this.gameSize = new f(), this.baseSize = new f(), this.displaySize = new f(), this.scaleMode = s.SCALE_MODE.NONE, this.zoom = 1, this._resetZoom = !1, this.displayScale = new v(1, 1), this.autoRound = !1, this.autoCenter = s.CENTER.NO_CENTER, this.orientation = s.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.domlisteners = { orientationChange: c, windowResize: c, fullScreenChange: c, fullScreenError: c } }, preBoot: function () { this.parseConfig(this.game.config), this.game.events.once(a.BOOT, this.boot, this) }, boot: function () { const t = this.game; this.canvas = t.canvas, this.fullscreen = t.device.fullscreen, this.scaleMode !== s.SCALE_MODE.RESIZE && this.scaleMode !== s.SCALE_MODE.EXPAND && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === s.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.parentSize), this.refresh()), t.events.on(a.PRE_STEP, this.step, this), t.events.once(a.READY, this.refresh, this), t.events.once(a.DESTROY, this.destroy, this), this.startListeners() }, parseConfig: function (t) { this.getParent(t), this.getParentBounds(); let e = t.width; let i = t.height; const n = t.scaleMode; let r = t.zoom; const o = t.autoRound; if (typeof e === 'string') if (e.substr(-1) !== '%') e = parseInt(e, 10); else { let a = this.parentSize.width; a === 0 && (a = window.innerWidth); const h = parseInt(e, 10) / 100; e = Math.floor(a * h) } if (typeof i === 'string') if (i.substr(-1) !== '%') i = parseInt(i, 10); else { let l = this.parentSize.height; l === 0 && (l = window.innerHeight); const c = parseInt(i, 10) / 100; i = Math.floor(l * c) } this.scaleMode = n, this.autoRound = o, this.autoCenter = t.autoCenter, this.resizeInterval = t.resizeInterval, o && (e = Math.floor(e), i = Math.floor(i)), this.gameSize.setSize(e, i), r === s.ZOOM.MAX_ZOOM && (r = this.getMaxZoom()), this.zoom = r, r !== 1 && (this._resetZoom = !0), this.baseSize.setSize(e, i), o && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), t.minWidth > 0 && this.displaySize.setMin(t.minWidth * r, t.minHeight * r), t.maxWidth > 0 && this.displaySize.setMax(t.maxWidth * r, t.maxHeight * r), this.displaySize.setSize(e, i), (t.snapWidth > 0 || t.snapHeight > 0) && this.displaySize.setSnap(t.snapWidth, t.snapHeight), this.orientation = u(e, i) }, getParent: function (t) { const e = t.parent; if (e !== null) { if (this.parent = l(e), this.parentIsWindow = this.parent === document.body, t.expandParent && t.scaleMode !== s.SCALE_MODE.NONE) { let i = this.parent.getBoundingClientRect(); (this.parentIsWindow || i.height === 0) && (document.documentElement.style.height = '100%', document.body.style.height = '100%', i = this.parent.getBoundingClientRect(), this.parentIsWindow || i.height !== 0 || (this.parent.style.overflow = 'hidden', this.parent.style.width = '100%', this.parent.style.height = '100%')) } t.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = l(t.fullscreenTarget)) } }, getParentBounds: function () { if (!this.parent) return !1; const t = this.parentSize; const e = this.parent.getBoundingClientRect(); this.parentIsWindow && this.game.device.os.iOS && (e.height = h(!0)); const i = e.width; const s = e.height; if (t.width !== i || t.height !== s) return t.setSize(i, s), !0; if (this.canvas) { const n = this.canvasBounds; const r = this.canvas.getBoundingClientRect(); if (r.x !== n.x || r.y !== n.y) return !0 } return !1 }, lockOrientation: function (t) { const e = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation; return !!e && e.call(screen, t) }, setParentSize: function (t, e) { return this.parentSize.setSize(t, e), this.refresh() }, setGameSize: function (t, e) { const i = this.autoRound; i && (t = Math.floor(t), e = Math.floor(e)); const s = this.width; const n = this.height; return this.gameSize.resize(t, e), this.baseSize.resize(t, e), i && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(t / e), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(s, n) }, resize: function (t, e) { const i = this.zoom; const s = this.autoRound; s && (t = Math.floor(t), e = Math.floor(e)); const n = this.width; const r = this.height; this.gameSize.resize(t, e), this.baseSize.resize(t, e), s && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(t * i, e * i), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height; const o = this.canvas.style; let a = t * i; let h = e * i; return s && (a = Math.floor(a), h = Math.floor(h)), a === t && h === e || (o.width = a + 'px', o.height = h + 'px'), this.refresh(n, r) }, setZoom: function (t) { return this.zoom = t, this._resetZoom = !0, this.refresh() }, setMaxZoom: function () { return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh() }, setSnap: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displaySize.setSnap(t, e), this.refresh() }, refresh: function (t, e) { void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height); const i = this.game.domContainer; if (i) { this.baseSize.setCSS(i); const s = this.canvas.style; const n = i.style; n.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')', n.marginLeft = s.marginLeft, n.marginTop = s.marginTop } return this.emit(o.RESIZE, this.gameSize, this.baseSize, this.displaySize, t, e), this }, updateOrientation: function () { if (this._checkOrientation) { this._checkOrientation = !1; const t = u(this.width, this.height); t !== this.orientation && (this.orientation = t, this.emit(o.ORIENTATION_CHANGE, t)) } }, updateScale: function () { let t; let e; const i = this.canvas.style; const n = this.gameSize.width; const r = this.gameSize.height; const o = this.zoom; const a = this.autoRound; if (this.scaleMode === s.SCALE_MODE.NONE) this.displaySize.setSize(n * o, r * o), t = this.displaySize.width, e = this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), this._resetZoom && (i.width = t + 'px', i.height = e + 'px', this._resetZoom = !1); else if (this.scaleMode === s.SCALE_MODE.RESIZE) this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(this.displaySize.width, this.displaySize.height), t = this.displaySize.width, e = this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), this.canvas.width = t, this.canvas.height = e; else if (this.scaleMode === s.SCALE_MODE.EXPAND) { this.displaySize.setSize(this.parentSize.width, this.parentSize.height), t = this.displaySize.width, e = this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), i.width = t + 'px', i.height = e + 'px'; const h = this.parentSize.width / this.gameSize.width; const l = this.parentSize.height / this.gameSize.height; h < l ? this.baseSize.setSize(this.gameSize.width, this.parentSize.height / h) : this.baseSize.setSize(this.displaySize.width / l, this.gameSize.height), t = this.baseSize.width, e = this.baseSize.height, a && (t = Math.floor(t), e = Math.floor(e)), this.canvas.width = t, this.canvas.height = e } else this.displaySize.setSize(this.parentSize.width, this.parentSize.height), t = this.displaySize.width, e = this.displaySize.height, a && (t = Math.floor(t), e = Math.floor(e)), i.width = t + 'px', i.height = e + 'px'; this.getParentBounds(), this.updateCenter() }, getMaxZoom: function () { const t = p(this.parentSize.width, this.gameSize.width, 0, !0); const e = p(this.parentSize.height, this.gameSize.height, 0, !0); return Math.max(Math.min(t, e), 1) }, updateCenter: function () { const t = this.autoCenter; if (t !== s.CENTER.NO_CENTER) { const e = this.canvas; const i = e.style; const n = e.getBoundingClientRect(); const r = n.width; const o = n.height; let a = Math.floor((this.parentSize.width - r) / 2); let h = Math.floor((this.parentSize.height - o) / 2); t === s.CENTER.CENTER_HORIZONTALLY ? h = 0 : t === s.CENTER.CENTER_VERTICALLY && (a = 0), i.marginLeft = a + 'px', i.marginTop = h + 'px' } }, updateBounds: function () { const t = this.canvasBounds; const e = this.canvas.getBoundingClientRect(); t.x = e.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), t.y = e.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), t.width = e.width, t.height = e.height }, transformX: function (t) { return (t - this.canvasBounds.left) * this.displayScale.x }, transformY: function (t) { return (t - this.canvasBounds.top) * this.displayScale.y }, startFullscreen: function (t) { void 0 === t && (t = { navigationUI: 'hide' }); const e = this.fullscreen; if (e.available) { if (!e.active) { const i = this.getFullscreenTarget(); e.keyboard ? i[e.request](Element.ALLOW_KEYBOARD_INPUT) : i[e.request](t) } } else this.emit(o.FULLSCREEN_UNSUPPORTED) }, fullscreenSuccessHandler: function () { this.getParentBounds(), this.refresh(), this.emit(o.ENTER_FULLSCREEN) }, fullscreenErrorHandler: function (t) { this.removeFullscreenTarget(), this.emit(o.FULLSCREEN_FAILED, t) }, getFullscreenTarget: function () { if (!this.fullscreenTarget) { const t = document.createElement('div'); t.style.margin = '0', t.style.padding = '0', t.style.width = '100%', t.style.height = '100%', this.fullscreenTarget = t, this._createdFullscreenTarget = !0 } this._createdFullscreenTarget && (this.canvas.parentNode.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas)); return this.fullscreenTarget }, removeFullscreenTarget: function () { if (this._createdFullscreenTarget) { const t = this.fullscreenTarget; if (t && t.parentNode) { const e = t.parentNode; e.insertBefore(this.canvas, t), e.removeChild(t) } } }, stopFullscreen: function () { const t = this.fullscreen; if (!t.available) return this.emit(o.FULLSCREEN_UNSUPPORTED), !1; t.active && document[t.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(o.LEAVE_FULLSCREEN), this.refresh() }, toggleFullscreen: function (t) { this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(t) }, startListeners: function () { const t = this; const e = this.domlisteners; if (e.orientationChange = function () { t.updateBounds(), t._checkOrientation = !0, t.dirty = !0, t.refresh() }, e.windowResize = function () { t.updateBounds(), t.dirty = !0 }, window.addEventListener('orientationchange', e.orientationChange, !1), window.addEventListener('resize', e.windowResize, !1), this.fullscreen.available) { e.fullScreenChange = function (e) { return t.onFullScreenChange(e) }, e.fullScreenError = function (e) { return t.onFullScreenError(e) }; ['webkit', 'moz', ''].forEach(function (t) { document.addEventListener(t + 'fullscreenchange', e.fullScreenChange, !1), document.addEventListener(t + 'fullscreenerror', e.fullScreenError, !1) }), document.addEventListener('MSFullscreenChange', e.fullScreenChange, !1), document.addEventListener('MSFullscreenError', e.fullScreenError, !1) } }, onFullScreenChange: function () { document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement ? this.fullscreenSuccessHandler() : this.stopFullscreen() }, onFullScreenError: function () { this.removeFullscreenTarget() }, getViewPort: function (t, e) { t instanceof g || (e = t, t = void 0), void 0 === e && (e = new d()); let i; let s; const n = this.baseSize; const r = this.parentSize; const o = this.canvasBounds; const a = this.displayScale; const h = o.x >= 0 ? 0 : -o.x * a.x; const l = o.y >= 0 ? 0 : -o.y * a.y; return i = r.width >= o.width ? n.width : n.width - (o.width - r.width) * a.x, s = r.height >= o.height ? n.height : n.height - (o.height - r.height) * a.y, e.setTo(h, l, i, s), t && (e.width /= t.zoomX, e.height /= t.zoomY, e.centerX = t.centerX + t.scrollX, e.centerY = t.centerY + t.scrollY), e }, step: function (t, e) { this.parent && (this._lastCheck += e, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0)) }, stopListeners: function () { const t = this.domlisteners; window.removeEventListener('orientationchange', t.orientationChange, !1), window.removeEventListener('resize', t.windowResize, !1); ['webkit', 'moz', ''].forEach(function (e) { document.removeEventListener(e + 'fullscreenchange', t.fullScreenChange, !1), document.removeEventListener(e + 'fullscreenerror', t.fullScreenError, !1) }), document.removeEventListener('MSFullscreenChange', t.fullScreenChange, !1), document.removeEventListener('MSFullscreenError', t.fullScreenError, !1) }, destroy: function () { this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy() }, isFullscreen: { get: function () { return this.fullscreen.active } }, width: { get: function () { return this.gameSize.width } }, height: { get: function () { return this.gameSize.height } }, isPortrait: { get: function () { return this.orientation === s.ORIENTATION.PORTRAIT } }, isLandscape: { get: function () { return this.orientation === s.ORIENTATION.LANDSCAPE } }, isGamePortrait: { get: function () { return this.height > this.width } }, isGameLandscape: { get: function () { return this.width > this.height } } }); t.exports = m }, 64743: t => { t.exports = { NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3 } }, 39218: t => { t.exports = { LANDSCAPE: 'landscape-primary', PORTRAIT: 'portrait-primary' } }, 81050: t => { t.exports = { NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4, RESIZE: 5, EXPAND: 6 } }, 80805: t => { t.exports = { NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1 } }, 13560: (t, e, i) => { const s = { CENTER: i(64743), ORIENTATION: i(39218), SCALE_MODE: i(81050), ZOOM: i(80805) }; t.exports = s }, 56139: t => { t.exports = 'enterfullscreen' }, 2336: t => { t.exports = 'fullscreenfailed' }, 47412: t => { t.exports = 'fullscreenunsupported' }, 51452: t => { t.exports = 'leavefullscreen' }, 20666: t => { t.exports = 'orientationchange' }, 47945: t => { t.exports = 'resize' }, 97480: (t, e, i) => { t.exports = { ENTER_FULLSCREEN: i(56139), FULLSCREEN_FAILED: i(2336), FULLSCREEN_UNSUPPORTED: i(47412), LEAVE_FULLSCREEN: i(51452), ORIENTATION_CHANGE: i(20666), RESIZE: i(47945) } }, 93364: (t, e, i) => { const s = i(79291); const n = i(13560); let r = { Center: i(64743), Events: i(97480), Orientation: i(39218), ScaleManager: i(76531), ScaleModes: i(81050), Zoom: i(80805) }; r = s(!1, r, n.CENTER), r = s(!1, r, n.ORIENTATION), r = s(!1, r, n.SCALE_MODE), r = s(!1, r, n.ZOOM), t.exports = r }, 27397: (t, e, i) => { const s = i(95540); const n = i(35355); t.exports = function (t) { const e = t.game.config.defaultPhysicsSystem; const i = s(t.settings, 'physics', !1); if (e || i) { const r = []; if (e && r.push(n(e + 'Physics')), i) for (let o in i) o = n(o.concat('Physics')), r.indexOf(o) === -1 && r.push(o); return r } } }, 52106: (t, e, i) => { const s = i(95540); t.exports = function (t) { const e = t.plugins.getDefaultScenePlugins(); const i = s(t.settings, 'plugins', !1); return Array.isArray(i) ? i : e || [] } }, 87033: t => { t.exports = { game: 'game', renderer: 'renderer', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', scale: 'scale', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter' } }, 97482: (t, e, i) => { const s = i(83419); const n = i(2368); const r = new s({ initialize: function (t) { this.sys = new n(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.scale, this.plugins, this.renderer }, update: function () { } }); t.exports = r }, 60903: (t, e, i) => { const s = i(83419); const n = i(89993); const r = i(44594); const o = i(8443); const a = i(35154); const h = i(54899); const l = i(29747); const u = i(97482); const c = i(2368); const d = new s({ initialize: function (t, e) { if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, this.systemScene, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) this._pending.push({ key: 'default', scene: e[i], autoStart: i === 0, data: {} }) } t.events.once(o.READY, this.bootQueue, this) }, bootQueue: function () { if (!this.isBooted) { let t, e, i, s; for (this.systemScene = this.createSceneFromInstance('__SYSTEM', new u()), this.game.events.emit(o.SYSTEM_READY, this.systemScene, this), t = 0; t < this._pending.length; t++) { var n; i = (e = this._pending[t]).key, (s = e.scene) instanceof u ? n = this.createSceneFromInstance(i, s) : typeof s === 'object' ? n = this.createSceneFromObject(i, s) : typeof s === 'function' && (n = this.createSceneFromFunction(i, s)), i = n.sys.settings.key, this.keys[i] = n, this.scenes.push(n), this._data[i] && (n.sys.settings.data = this._data[i].data, this._data[i].autoStart && (e.autoStart = !0)), (e.autoStart || n.sys.settings.active) && this._start.push(i) } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++)e = this._start[t], this.start(e); this._start.length = 0 } }, processQueue: function () { const t = this._pending.length; const e = this._queue.length; if (t !== 0 || e !== 0) { let i, s; if (t) { for (i = 0; i < t; i++)s = this._pending[i], this.add(s.key, s.scene, s.autoStart, s.data); for (i = 0; i < this._start.length; i++)s = this._start[i], this.start(s); this._start.length = 0, this._pending.length = 0 } for (i = 0; i < this._queue.length; i++) this[(s = this._queue[i]).op](s.keyA, s.keyB); this._queue.length = 0 } }, add: function (t, e, i, s) { return void 0 === i && (i = !1), void 0 === s && (s = {}), this.isProcessing || !this.isBooted ? (this._pending.push({ key: t, scene: e, autoStart: i, data: s }), this.isBooted || (this._data[t] = { data: s }), null) : (t = this.getKey(t, e), e instanceof u ? n = this.createSceneFromInstance(t, e) : typeof e === 'object' ? (e.key = t, n = this.createSceneFromObject(t, e)) : typeof e === 'function' && (n = this.createSceneFromFunction(t, e)), n.sys.settings.data = s, t = n.sys.settings.key, this.keys[t] = n, this.scenes.push(n), (i || n.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), n); let n }, remove: function (t) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: t, keyB: null }); else { const e = this.getScene(t); if (!e || e.sys.isTransitioning()) return this; let i = this.scenes.indexOf(e); const s = e.sys.settings.key; i > -1 && (delete this.keys[s], this.scenes.splice(i, 1), this._start.indexOf(s) > -1 && (i = this._start.indexOf(s), this._start.splice(i, 1)), e.sys.destroy()) } return this }, bootScene: function (t) { let e; const i = t.sys; const s = i.settings; i.sceneUpdate = l, t.init && (t.init.call(t, s.data), s.status = n.INIT, s.isTransition && i.events.emit(r.TRANSITION_INIT, s.transitionFrom, s.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), s.status = n.LOADING, e.once(h.COMPLETE, this.loadComplete, this), e.start()) : this.create(t) }, loadComplete: function (t) { this.game.sound && this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(t.scene) }, payloadComplete: function (t) { this.bootScene(t.scene) }, update: function (t, e) { this.processQueue(), this.isProcessing = !0; for (let i = this.scenes.length - 1; i >= 0; i--) { const s = this.scenes[i].sys; s.settings.status > n.START && s.settings.status <= n.RUNNING && s.step(t, e), s.scenePlugin && s.scenePlugin._target && s.scenePlugin.step(t, e) } }, render: function (t) { for (let e = 0; e < this.scenes.length; e++) { const i = this.scenes[e].sys; i.settings.visible && i.settings.status >= n.LOADING && i.settings.status < n.SLEEPING && i.render(t) } this.isProcessing = !1 }, create: function (t) { const e = t.sys; const i = e.settings; t.create && (i.status = n.CREATING, t.create.call(t, i.data), i.status === n.DESTROYED) || (i.isTransition && e.events.emit(r.TRANSITION_START, i.transitionFrom, i.transitionDuration), t.update && (e.sceneUpdate = t.update), i.status = n.RUNNING, e.events.emit(r.CREATE, t)) }, createSceneFromFunction: function (t, e) { const i = new e(); if (i instanceof u) { const s = i.sys.settings.key; if (s !== '' && (t = s), this.keys.hasOwnProperty(t)) throw new Error('Cannot add a Scene with duplicate key: ' + t); return this.createSceneFromInstance(t, i) } return i.sys = new c(i), i.sys.settings.key = t, i.sys.init(this.game), i }, createSceneFromInstance: function (t, e) { return e.sys.settings.key === '' && (e.sys.settings.key = t), e.sys.init(this.game), e }, createSceneFromObject: function (t, e) { const i = new u(e); const s = i.sys.settings.key; s !== '' ? t = s : i.sys.settings.key = t, i.sys.init(this.game); for (let n = ['init', 'preload', 'create', 'update', 'render'], r = 0; r < n.length; r++) { const o = a(e, n[r], null); o && (i[n[r]] = o) } if (e.hasOwnProperty('extend')) for (const h in e.extend) if (e.extend.hasOwnProperty(h)) { const l = e.extend[h]; h === 'data' && i.hasOwnProperty('data') && typeof l === 'object' ? i.data.merge(l) : h !== 'sys' && (i[h] = l) } return i }, getKey: function (t, e) { if (t || (t = 'default'), typeof e === 'function') return t; if (e instanceof u ? t = e.sys.settings.key : typeof e === 'object' && e.hasOwnProperty('key') && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error('Cannot add a Scene with duplicate key: ' + t); return t }, getScenes: function (t, e) { void 0 === t && (t = !0), void 0 === e && (e = !1); for (var i = [], s = this.scenes, n = 0; n < s.length; n++) { const r = s[n]; r && (!t || t && r.sys.isActive()) && i.push(r) } return e ? i.reverse() : i }, getScene: function (t) { if (typeof t === 'string') { if (this.keys[t]) return this.keys[t] } else for (let e = 0; e < this.scenes.length; e++) if (t === this.scenes[e]) return t; return null }, isActive: function (t) { const e = this.getScene(t); return e ? e.sys.isActive() : null }, isPaused: function (t) { const e = this.getScene(t); return e ? e.sys.isPaused() : null }, isVisible: function (t) { const e = this.getScene(t); return e ? e.sys.isVisible() : null }, isSleeping: function (t) { const e = this.getScene(t); return e ? e.sys.isSleeping() : null }, pause: function (t, e) { const i = this.getScene(t); return i && i.sys.pause(e), this }, resume: function (t, e) { const i = this.getScene(t); return i && i.sys.resume(e), this }, sleep: function (t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.sleep(e), this }, wake: function (t, e) { const i = this.getScene(t); return i && i.sys.wake(e), this }, run: function (t, e) { const i = this.getScene(t); if (!i) { for (let s = 0; s < this._pending.length; s++) if (this._pending[s].key === t) { this.queueOp('start', t, e); break } return this } i.sys.isSleeping() ? i.sys.wake(e) : i.sys.isPaused() ? i.sys.resume(e) : this.start(t, e) }, start: function (t, e) { if (!this.isBooted) return this._data[t] = { autoStart: !0, data: e }, this; const i = this.getScene(t); if (!i) return console.warn('Scene not found for key: ' + t), this; let s; const r = i.sys; const o = r.settings.status; if (o >= n.START && o <= n.CREATING) return this; if (o >= n.RUNNING && o <= n.SLEEPING) r.shutdown(), r.sceneUpdate = l, r.start(e); else if (r.sceneUpdate = l, r.start(e), r.load && (s = r.load), s && r.settings.hasOwnProperty('pack') && (s.reset(), s.addPack({ payload: r.settings.pack }))) return r.settings.status = n.LOADING, s.once(h.COMPLETE, this.payloadComplete, this), s.start(), this; return this.bootScene(i), this }, stop: function (t, e) { const i = this.getScene(t); if (i && !i.sys.isTransitioning() && i.sys.settings.status !== n.SHUTDOWN) { const s = i.sys.load; s && (s.off(h.COMPLETE, this.loadComplete, this), s.off(h.COMPLETE, this.payloadComplete, this)), i.sys.shutdown(e) } return this }, switch: function (t, e) { const i = this.getScene(t); const s = this.getScene(e); return i && s && i !== s && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this }, getAt: function (t) { return this.scenes[t] }, getIndex: function (t) { const e = this.getScene(t); return this.scenes.indexOf(e) }, bringToTop: function (t) { if (this.isProcessing) this._queue.push({ op: 'bringToTop', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e < this.scenes.length) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.push(i) } } return this }, sendToBack: function (t) { if (this.isProcessing) this._queue.push({ op: 'sendToBack', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e > 0) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.unshift(i) } } return this }, moveDown: function (t) { if (this.isProcessing) this._queue.push({ op: 'moveDown', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e > 0) { const i = e - 1; const s = this.getScene(t); const n = this.getAt(i); this.scenes[e] = n, this.scenes[i] = s } } return this }, moveUp: function (t) { if (this.isProcessing) this._queue.push({ op: 'moveUp', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e < this.scenes.length - 1) { const i = e + 1; const s = this.getScene(t); const n = this.getAt(i); this.scenes[e] = n, this.scenes[i] = s } } return this }, moveAbove: function (t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveAbove', keyA: t, keyB: e }); else { const i = this.getIndex(t); const s = this.getIndex(e); if (i !== -1 && s !== -1 && s < i) { const n = this.getAt(s); this.scenes.splice(s, 1), this.scenes.splice(i + (s > i), 0, n) } } return this }, moveBelow: function (t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveBelow', keyA: t, keyB: e }); else { const i = this.getIndex(t); const s = this.getIndex(e); if (i !== -1 && s !== -1 && s > i) { const n = this.getAt(s); this.scenes.splice(s, 1), i === 0 ? this.scenes.unshift(n) : this.scenes.splice(i - (s < i), 0, n) } } return this }, queueOp: function (t, e, i) { return this._queue.push({ op: t, keyA: e, keyB: i }), this }, swapPosition: function (t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'swapPosition', keyA: t, keyB: e }); else { const i = this.getIndex(t); const s = this.getIndex(e); if (i !== s && i !== -1 && s !== -1) { const n = this.getAt(i); this.scenes[i] = this.scenes[s], this.scenes[s] = n } } return this }, dump: function () { for (var t = [], e = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], i = 0; i < this.scenes.length; i++) { const s = this.scenes[i].sys; let r = !s.settings.visible || s.settings.status !== n.RUNNING && s.settings.status !== n.PAUSED ? '[-] ' : '[*] '; r += s.settings.key + ' (' + e[s.settings.status] + ')', t.push(r) } console.log(t.join('\n')) }, destroy: function () { for (let t = 0; t < this.scenes.length; t++) { this.scenes[t].sys.destroy() } this.systemScene.sys.destroy(), this.update = l, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null, this.systemScene = null } }); t.exports = d }, 52209: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(44594); const o = i(95540); const a = i(37277); const h = new n({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.pluginStart, this) }, boot: function () { this.systems.events.once(r.DESTROY, this.destroy, this) }, pluginStart: function () { this._target = null, this.systems.events.once(r.SHUTDOWN, this.shutdown, this) }, start: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', this.key), this.manager.queueOp('start', t, e), this }, restart: function (t) { const e = this.key; return this.manager.queueOp('stop', e), this.manager.queueOp('start', e, t), this }, transition: function (t) { void 0 === t && (t = {}); const e = o(t, 'target', !1); const i = this.manager.getScene(e); if (!e || !this.checkValidTransition(i)) return !1; const s = o(t, 'duration', 1e3); this._elapsed = 0, this._target = i, this._duration = s, this._willSleep = o(t, 'sleep', !1), this._willRemove = o(t, 'remove', !1); const n = o(t, 'onUpdate', null); n && (this._onUpdate = n, this._onUpdateScope = o(t, 'onUpdateScope', this.scene)); const a = o(t, 'allowInput', !1); this.settings.transitionAllowInput = a; const h = i.sys.settings; h.isTransition = !0, h.transitionFrom = this.scene, h.transitionDuration = s, h.transitionAllowInput = a, o(t, 'moveAbove', !1) ? this.manager.moveAbove(this.key, e) : o(t, 'moveBelow', !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake(o(t, 'data')) : this.manager.start(e, o(t, 'data')); const l = o(t, 'onStart', null); const u = o(t, 'onStartScope', this.scene); return l && l.call(u, this.scene, i, s), this.systems.events.emit(r.TRANSITION_OUT, i, s), !0 }, checkValidTransition: function (t) { return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning()) }, step: function (t, e) { this._elapsed += e, this.transitionProgress = s(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete() }, transitionComplete: function () { const t = this._target.sys; const e = this._target.sys.settings; t.events.emit(r.TRANSITION_COMPLETE, this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key) }, add: function (t, e, i, s) { return this.manager.add(t, e, i, s) }, launch: function (t, e) { return t && t !== this.key && this.manager.queueOp('start', t, e), this }, run: function (t, e) { return t && t !== this.key && this.manager.queueOp('run', t, e), this }, pause: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('pause', t, e), this }, resume: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('resume', t, e), this }, sleep: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('sleep', t, e), this }, wake: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('wake', t, e), this }, switch: function (t) { return t !== this.key && this.manager.queueOp('switch', this.key, t), this }, stop: function (t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', t, e), this }, setActive: function (t, e, i) { void 0 === e && (e = this.key); const s = this.manager.getScene(e); return s && s.sys.setActive(t, i), this }, setVisible: function (t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setVisible(t), this }, isSleeping: function (t) { return void 0 === t && (t = this.key), this.manager.isSleeping(t) }, isActive: function (t) { return void 0 === t && (t = this.key), this.manager.isActive(t) }, isPaused: function (t) { return void 0 === t && (t = this.key), this.manager.isPaused(t) }, isVisible: function (t) { return void 0 === t && (t = this.key), this.manager.isVisible(t) }, swapPosition: function (t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this }, moveAbove: function (t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this }, moveBelow: function (t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this }, remove: function (t) { return void 0 === t && (t = this.key), this.manager.remove(t), this }, moveUp: function (t) { return void 0 === t && (t = this.key), this.manager.moveUp(t), this }, moveDown: function (t) { return void 0 === t && (t = this.key), this.manager.moveDown(t), this }, bringToTop: function (t) { return void 0 === t && (t = this.key), this.manager.bringToTop(t), this }, sendToBack: function (t) { return void 0 === t && (t = this.key), this.manager.sendToBack(t), this }, get: function (t) { return this.manager.getScene(t) }, getStatus: function (t) { const e = this.manager.getScene(t); if (e) return e.sys.getStatus() }, getIndex: function (t) { return void 0 === t && (t = this.key), this.manager.getIndex(t) }, shutdown: function () { const t = this.systems.events; t.off(r.SHUTDOWN, this.shutdown, this), t.off(r.TRANSITION_OUT) }, destroy: function () { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null } }); a.register('ScenePlugin', h, 'scenePlugin'), t.exports = h }, 55681: (t, e, i) => { const s = i(89993); const n = i(35154); const r = i(46975); const o = i(87033); const a = { create: function (t) { return typeof t === 'string' ? t = { key: t } : void 0 === t && (t = {}), { status: s.PENDING, key: n(t, 'key', ''), active: n(t, 'active', !1), visible: n(t, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: n(t, 'pack', !1), cameras: n(t, 'cameras', null), map: n(t, 'map', r(o, n(t, 'mapAdd', {}))), physics: n(t, 'physics', {}), loader: n(t, 'loader', {}), plugins: n(t, 'plugins', !1), input: n(t, 'input', {}) } } }; t.exports = a }, 2368: (t, e, i) => { const s = i(83419); const n = i(89993); const r = i(42363); const o = i(44594); const a = i(27397); const h = i(52106); const l = i(29747); const u = i(55681); const c = new s({ initialize: function (t, e) { this.scene = t, this.game, this.renderer, this.config = e, this.settings = u.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = l }, init: function (t) { this.settings.status = n.INIT, this.sceneUpdate = l, this.game = t, this.renderer = t.renderer, this.canvas = t.canvas, this.context = t.context; const e = t.plugins; this.plugins = e, e.addToScene(this, r.Global, [r.CoreScene, h(this), a(this)]), this.events.emit(o.BOOT, this), this.settings.isBooted = !0 }, step: function (t, e) { const i = this.events; i.emit(o.PRE_UPDATE, t, e), i.emit(o.UPDATE, t, e), this.sceneUpdate.call(this.scene, t, e), i.emit(o.POST_UPDATE, t, e) }, render: function (t) { const e = this.displayList; e.depthSort(), this.events.emit(o.PRE_RENDER, t), this.cameras.render(t, e), this.events.emit(o.RENDER, t) }, queueDepthSort: function () { this.displayList.queueDepthSort() }, depthSort: function () { this.displayList.depthSort() }, pause: function (t) { const e = this.settings; const i = this.getStatus(); return i !== n.CREATING && i !== n.RUNNING ? console.warn('Cannot pause non-running Scene', e.key) : this.settings.active && (e.status = n.PAUSED, e.active = !1, this.events.emit(o.PAUSE, this, t)), this }, resume: function (t) { const e = this.events; const i = this.settings; return this.settings.active || (i.status = n.RUNNING, i.active = !0, e.emit(o.RESUME, this, t)), this }, sleep: function (t) { const e = this.settings; const i = this.getStatus(); return i !== n.CREATING && i !== n.RUNNING ? console.warn('Cannot sleep non-running Scene', e.key) : (e.status = n.SLEEPING, e.active = !1, e.visible = !1, this.events.emit(o.SLEEP, this, t)), this }, wake: function (t) { const e = this.events; const i = this.settings; return i.status = n.RUNNING, i.active = !0, i.visible = !0, e.emit(o.WAKE, this, t), i.isTransition && e.emit(o.TRANSITION_WAKE, i.transitionFrom, i.transitionDuration), this }, getData: function () { return this.settings.data }, getStatus: function () { return this.settings.status }, canInput: function () { const t = this.settings.status; return t > n.PENDING && t <= n.RUNNING }, isSleeping: function () { return this.settings.status === n.SLEEPING }, isActive: function () { return this.settings.status === n.RUNNING }, isPaused: function () { return this.settings.status === n.PAUSED }, isTransitioning: function () { return this.settings.isTransition || this.scenePlugin._target !== null }, isTransitionOut: function () { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0 }, isTransitionIn: function () { return this.settings.isTransition }, isVisible: function () { return this.settings.visible }, setVisible: function (t) { return this.settings.visible = t, this }, setActive: function (t, e) { return t ? this.resume(e) : this.pause(e) }, start: function (t) { const e = this.events; const i = this.settings; t && (i.data = t), i.status = n.START, i.active = !0, i.visible = !0, e.emit(o.START, this), e.emit(o.READY, this, t) }, shutdown: function (t) { const e = this.events; const i = this.settings; e.off(o.TRANSITION_INIT), e.off(o.TRANSITION_START), e.off(o.TRANSITION_COMPLETE), e.off(o.TRANSITION_OUT), i.status = n.SHUTDOWN, i.active = !1, i.visible = !1, e.emit(o.SHUTDOWN, this, t) }, destroy: function () { const t = this.events; const e = this.settings; e.status = n.DESTROYED, e.active = !1, e.visible = !1, t.emit(o.DESTROY, this), t.removeAllListeners(); for (let i = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], s = 0; s < i.length; s++) this[i[s]] = null } }); t.exports = c }, 89993: t => { t.exports = { PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9 } }, 69830: t => { t.exports = 'addedtoscene' }, 7919: t => { t.exports = 'boot' }, 46763: t => { t.exports = 'create' }, 11763: t => { t.exports = 'destroy' }, 71555: t => { t.exports = 'pause' }, 36735: t => { t.exports = 'postupdate' }, 3809: t => { t.exports = 'prerender' }, 90716: t => { t.exports = 'preupdate' }, 58262: t => { t.exports = 'ready' }, 91633: t => { t.exports = 'removedfromscene' }, 10319: t => { t.exports = 'render' }, 87132: t => { t.exports = 'resume' }, 81961: t => { t.exports = 'shutdown' }, 90194: t => { t.exports = 'sleep' }, 6265: t => { t.exports = 'start' }, 33178: t => { t.exports = 'transitioncomplete' }, 43063: t => { t.exports = 'transitioninit' }, 11259: t => { t.exports = 'transitionout' }, 61611: t => { t.exports = 'transitionstart' }, 45209: t => { t.exports = 'transitionwake' }, 22966: t => { t.exports = 'update' }, 21747: t => { t.exports = 'wake' }, 44594: (t, e, i) => { t.exports = { ADDED_TO_SCENE: i(69830), BOOT: i(7919), CREATE: i(46763), DESTROY: i(11763), PAUSE: i(71555), POST_UPDATE: i(36735), PRE_RENDER: i(3809), PRE_UPDATE: i(90716), READY: i(58262), REMOVED_FROM_SCENE: i(91633), RENDER: i(10319), RESUME: i(87132), SHUTDOWN: i(81961), SLEEP: i(90194), START: i(6265), TRANSITION_COMPLETE: i(33178), TRANSITION_INIT: i(43063), TRANSITION_OUT: i(11259), TRANSITION_START: i(61611), TRANSITION_WAKE: i(45209), UPDATE: i(22966), WAKE: i(21747) } }, 62194: (t, e, i) => { const s = i(89993); const n = i(79291); let r = { Events: i(44594), GetPhysicsPlugins: i(27397), GetScenePlugins: i(52106), SceneManager: i(60903), ScenePlugin: i(52209), Settings: i(55681), Systems: i(2368) }; r = n(!1, r, s), t.exports = r }, 30341: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(14463); const o = i(79291); const a = i(29747); const h = new s({ Extends: n, initialize: function (t, e, i) { n.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = { mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 }, this.currentConfig = this.config, this.config = o(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1 }, addMarker: function (t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (console.error('addMarker ' + t.name + ' already exists in Sound'), !1) : (t = o(!0, { name: '', start: 0, duration: this.totalDuration - (t.start || 0), config: { mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 } }, t), this.markers[t.name] = t, !0)) }, updateMarker: function (t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (this.markers[t.name] = o(!0, this.markers[t.name], t), !0) : (console.warn('Audio Marker: ' + t.name + ' missing in Sound: ' + this.key), !1)) }, removeMarker: function (t) { const e = this.markers[t]; return e ? (this.markers[t] = null, e) : null }, play: function (t, e) { if (void 0 === t && (t = ''), typeof t === 'object' && (e = t, t = ''), typeof t !== 'string') return !1; if (t) { if (!this.markers[t]) return console.warn('Marker: ' + t + ' missing in Sound: ' + this.key), !1; this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; return this.resetConfig(), this.currentConfig = o(this.currentConfig, e), this.isPlaying = !0, this.isPaused = !1, !0 }, pause: function () { return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0, !0) }, resume: function () { return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, this.isPaused = !1, !0) }, stop: function () { return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0) }, applyConfig: function () { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop, this.pan = this.currentConfig.pan }, resetConfig: function () { this.currentConfig.seek = 0, this.currentConfig.delay = 0 }, update: a, calculateRate: function () { const t = this.currentConfig.detune + this.manager.detune; const e = Math.pow(1.0005777895065548, t); this.totalRate = this.currentConfig.rate * this.manager.rate * e }, destroy: function () { this.pendingRemove || (this.stop(), this.emit(r.DESTROY, this), this.removeAllListeners(), this.pendingRemove = !0, this.manager = null, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null) } }); t.exports = h }, 85034: (t, e, i) => { const s = i(83419); const n = i(41786); const r = i(50792); const o = i(14463); const a = i(8443); const h = i(46710); const l = i(58731); const u = i(29747); const c = i(26099); const d = new s({ Extends: r, initialize: function (t) { r.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, this.gameLostFocus = !1, this.listenerPosition = new c(), t.events.on(a.BLUR, this.onGameBlur, this), t.events.on(a.FOCUS, this.onGameFocus, this), t.events.on(a.PRE_STEP, this.update, this), t.events.once(a.DESTROY, this.destroy, this) }, add: u, addAudioSprite: function (t, e) { void 0 === e && (e = {}); const i = this.add(t, e); for (const s in i.spritemap = this.jsonCache.get(t).spritemap, i.spritemap) if (i.spritemap.hasOwnProperty(s)) { const r = n(e); const o = i.spritemap[s]; r.loop = !!o.hasOwnProperty('loop') && o.loop, i.addMarker({ name: s, start: o.start, duration: o.end - o.start, config: r }) } return i }, get: function (t) { return l(this.sounds, 'key', t) }, getAll: function (t) { return t ? h(this.sounds, 'key', t) : h(this.sounds) }, getAllPlaying: function () { return h(this.sounds, 'isPlaying', !0) }, play: function (t, e) { const i = this.add(t); return i.once(o.COMPLETE, i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play() }, playAudioSprite: function (t, e, i) { const s = this.addAudioSprite(t); return s.once(o.COMPLETE, s.destroy, s), s.play(e, i) }, remove: function (t) { const e = this.sounds.indexOf(t); return e !== -1 && (t.destroy(), this.sounds.splice(e, 1), !0) }, removeAll: function () { this.sounds.forEach(function (t) { t.destroy() }), this.sounds.length = 0 }, removeByKey: function (t) { for (var e = 0, i = this.sounds.length - 1; i >= 0; i--) { const s = this.sounds[i]; s.key === t && (s.destroy(), this.sounds.splice(i, 1), e++) } return e }, pauseAll: function () { this.forEachActiveSound(function (t) { t.pause() }), this.emit(o.PAUSE_ALL, this) }, resumeAll: function () { this.forEachActiveSound(function (t) { t.resume() }), this.emit(o.RESUME_ALL, this) }, setListenerPosition: u, stopAll: function () { this.forEachActiveSound(function (t) { t.stop() }), this.emit(o.STOP_ALL, this) }, stopByKey: function (t) { let e = 0; return this.getAll(t).forEach(function (t) { t.stop() && e++ }), e }, unlock: u, onBlur: u, onFocus: u, onGameBlur: function () { this.gameLostFocus = !0, this.pauseOnBlur && this.onBlur() }, onGameFocus: function () { this.gameLostFocus = !1, this.pauseOnBlur && this.onFocus() }, update: function (t, e) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(o.UNLOCKED, this)); for (let i = this.sounds.length - 1; i >= 0; i--) this.sounds[i].pendingRemove && this.sounds.splice(i, 1); this.sounds.forEach(function (i) { i.update(t, e) }) }, destroy: function () { this.game.events.off(a.BLUR, this.onGameBlur, this), this.game.events.off(a.FOCUS, this.onGameFocus, this), this.game.events.off(a.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.listenerPosition = null, this.game = null }, forEachActiveSound: function (t, e) { const i = this; this.sounds.forEach(function (s, n) { s && !s.pendingRemove && t.call(e || i, s, n, i.sounds) }) }, setRate: function (t) { return this.rate = t, this }, rate: { get: function () { return this._rate }, set: function (t) { this._rate = t, this.forEachActiveSound(function (t) { t.calculateRate() }), this.emit(o.GLOBAL_RATE, this, t) } }, setDetune: function (t) { return this.detune = t, this }, detune: { get: function () { return this._detune }, set: function (t) { this._detune = t, this.forEachActiveSound(function (t) { t.calculateRate() }), this.emit(o.GLOBAL_DETUNE, this, t) } } }); t.exports = d }, 14747: (t, e, i) => { const s = i(33684); const n = i(25960); const r = i(57490); const o = { create: function (t) { const e = t.config.audio; const i = t.device.audio; return e.noAudio || !i.webAudio && !i.audioData ? new n(t) : i.webAudio && !e.disableWebAudio ? new r(t) : new s(t) } }; t.exports = o }, 19723: t => { t.exports = 'complete' }, 98882: t => { t.exports = 'decodedall' }, 57506: t => { t.exports = 'decoded' }, 73146: t => { t.exports = 'destroy' }, 11305: t => { t.exports = 'detune' }, 40577: t => { t.exports = 'detune' }, 30333: t => { t.exports = 'mute' }, 20394: t => { t.exports = 'rate' }, 21802: t => { t.exports = 'volume' }, 1299: t => { t.exports = 'looped' }, 99190: t => { t.exports = 'loop' }, 97125: t => { t.exports = 'mute' }, 89259: t => { t.exports = 'pan' }, 79986: t => { t.exports = 'pauseall' }, 17586: t => { t.exports = 'pause' }, 19618: t => { t.exports = 'play' }, 42306: t => { t.exports = 'rate' }, 10387: t => { t.exports = 'resumeall' }, 48959: t => { t.exports = 'resume' }, 9960: t => { t.exports = 'seek' }, 19180: t => { t.exports = 'stopall' }, 98328: t => { t.exports = 'stop' }, 50401: t => { t.exports = 'unlocked' }, 52498: t => { t.exports = 'volume' }, 14463: (t, e, i) => { t.exports = { COMPLETE: i(19723), DECODED: i(57506), DECODED_ALL: i(98882), DESTROY: i(73146), DETUNE: i(11305), GLOBAL_DETUNE: i(40577), GLOBAL_MUTE: i(30333), GLOBAL_RATE: i(20394), GLOBAL_VOLUME: i(21802), LOOP: i(99190), LOOPED: i(1299), MUTE: i(97125), PAN: i(89259), PAUSE_ALL: i(79986), PAUSE: i(17586), PLAY: i(19618), RATE: i(42306), RESUME_ALL: i(10387), RESUME: i(48959), SEEK: i(9960), STOP_ALL: i(19180), STOP: i(98328), UNLOCKED: i(50401), VOLUME: i(52498) } }, 64895: (t, e, i) => { const s = i(30341); const n = i(83419); const r = i(14463); const o = i(45319); const a = new n({ Extends: s, initialize: function (t, e, i) { if (void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), !this.tags) throw new Error('No cached audio asset with key "' + e); this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, s.call(this, t, e, i) }, play: function (t, e) { return !this.manager.isLocked(this, 'play', [t, e]) && (!!s.prototype.play.call(this, t, e) && (!!this.pickAndPlayAudioTag() && (this.emit(r.PLAY, this), !0))) }, pause: function () { return !this.manager.isLocked(this, 'pause') && (!(this.startTime > 0) && (!!s.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(r.PAUSE, this), !0))) }, resume: function () { return !this.manager.isLocked(this, 'resume') && (!(this.startTime > 0) && (!!s.prototype.resume.call(this) && (!!this.pickAndPlayAudioTag() && (this.emit(r.RESUME, this), !0)))) }, stop: function () { return !this.manager.isLocked(this, 'stop') && (!!s.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit(r.STOP, this), !0)) }, pickAndPlayAudioTag: function () { if (!this.pickAudioTag()) return this.reset(), !1; const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = (this.currentMarker ? this.currentMarker.start : 0) + t; return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), e === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0 }, pickAudioTag: function () { if (this.audio) return !0; for (let t = 0; t < this.tags.length; t++) { const e = this.tags[t]; if (e.dataset.used === 'false') return e.dataset.used = 'true', this.audio = e, !0 } if (!this.manager.override) return !1; const i = []; this.manager.forEachActiveSound(function (t) { t.key === this.key && t.audio && i.push(t) }, this), i.sort(function (t, e) { return t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1 }); const s = i[0]; return this.audio = s.audio, s.reset(), s.audio = null, s.startTime = 0, s.previousTime = 0, !0 }, playCatchPromise: function () { const t = this.audio.play(); t && t.catch(function (t) { console.warn(t) }) }, stopAndReleaseAudioTag: function () { this.startTime = 0, this.previousTime = 0, this.audio && (this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null) }, reset: function () { s.prototype.stop.call(this) }, onBlur: function () { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag() }, onFocus: function () { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag() }, update: function (t) { if (this.isPlaying) if (this.startTime > 0) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); else { const e = this.currentMarker ? this.currentMarker.start : 0; const i = e + this.duration; let s = this.audio.currentTime; if (this.currentConfig.loop) s >= i - this.manager.loopEndOffset ? (this.audio.currentTime = e + Math.max(0, s - i), s = this.audio.currentTime) : s < e && (this.audio.currentTime += e, s = this.audio.currentTime), s < this.previousTime && this.emit(r.LOOPED, this); else if (s >= i) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit(r.COMPLETE, this); this.previousTime = s } }, destroy: function () { s.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag() }, updateMute: function () { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute) }, updateVolume: function () { this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1)) }, calculateRate: function () { s.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate) }, mute: { get: function () { return this.currentConfig.mute }, set: function (t) { this.currentConfig.mute = t, this.manager.isLocked(this, 'mute', t) || (this.updateMute(), this.emit(r.MUTE, this, t)) } }, setMute: function (t) { return this.mute = t, this }, volume: { get: function () { return this.currentConfig.volume }, set: function (t) { this.currentConfig.volume = t, this.manager.isLocked(this, 'volume', t) || (this.updateVolume(), this.emit(r.VOLUME, this, t)) } }, setVolume: function (t) { return this.volume = t, this }, rate: { get: function () { return this.currentConfig.rate }, set: function (t) { this.currentConfig.rate = t, this.manager.isLocked(this, r.RATE, t) || (this.calculateRate(), this.emit(r.RATE, this, t)) } }, setRate: function (t) { return this.rate = t, this }, detune: { get: function () { return this.currentConfig.detune }, set: function (t) { this.currentConfig.detune = t, this.manager.isLocked(this, r.DETUNE, t) || (this.calculateRate(), this.emit(r.DETUNE, this, t)) } }, setDetune: function (t) { return this.detune = t, this }, seek: { get: function () { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0 }, set: function (t) { this.manager.isLocked(this, 'seek', t) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit(r.SEEK, this, t)) } }, setSeek: function (t) { return this.seek = t, this }, loop: { get: function () { return this.currentConfig.loop }, set: function (t) { this.currentConfig.loop = t, this.manager.isLocked(this, 'loop', t) || (this.audio && (this.audio.loop = t), this.emit(r.LOOP, this, t)) } }, setLoop: function (t) { return this.loop = t, this }, pan: { get: function () { return this.currentConfig.pan }, set: function (t) { this.currentConfig.pan = t, this.emit(r.PAN, this, t) } }, setPan: function (t) { return this.pan = t, this } }); t.exports = a }, 33684: (t, e, i) => { const s = i(85034); const n = i(83419); const r = i(14463); const o = i(64895); const a = new n({ Extends: s, initialize: function (t) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, s.call(this, t) }, add: function (t, e) { const i = new o(this, t, e); return this.sounds.push(i), i }, unlock: function () { this.locked = !1; const t = this; if (this.game.cache.audio.entries.each(function (e, i) { for (let s = 0; s < i.length; s++) if (i[s].dataset.locked === 'true') return t.locked = !0, !1; return !0 }), this.locked) { let e = !1; const i = function () { e = !0 }; const s = function () { if (e) e = !1; else { document.body.removeEventListener('touchmove', i), document.body.removeEventListener('touchend', s); const n = []; if (t.game.cache.audio.entries.each(function (t, e) { for (let i = 0; i < e.length; i++) { const s = e[i]; s.dataset.locked === 'true' && n.push(s) } return !0 }), n.length !== 0) { const r = n[n.length - 1]; r.oncanplaythrough = function () { r.oncanplaythrough = null, n.forEach(function (t) { t.dataset.locked = 'false' }), t.unlocked = !0 }, n.forEach(function (t) { t.load() }) } } }; this.once(r.UNLOCKED, function () { for (this.forEachActiveSound(function (t) { t.currentMarker === null && t.duration === 0 && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration }); this.lockedActionsQueue.length;) { const t = this.lockedActionsQueue.shift(); t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value } }, this), document.body.addEventListener('touchmove', i, !1), document.body.addEventListener('touchend', s, !1) } }, onBlur: function () { this.forEachActiveSound(function (t) { t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur()) }) }, onFocus: function () { this.onBlurPausedSounds.forEach(function (t) { t.onFocus() }), this.onBlurPausedSounds.length = 0 }, destroy: function () { s.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null }, isLocked: function (t, e, i) { return t.tags[0].dataset.locked === 'true' && (this.lockedActionsQueue.push({ sound: t, prop: e, value: i }), !0) }, setMute: function (t) { return this.mute = t, this }, mute: { get: function () { return this._mute }, set: function (t) { this._mute = t, this.forEachActiveSound(function (t) { t.updateMute() }), this.emit(r.GLOBAL_MUTE, this, t) } }, setVolume: function (t) { return this.volume = t, this }, volume: { get: function () { return this._volume }, set: function (t) { this._volume = t, this.forEachActiveSound(function (t) { t.updateVolume() }), this.emit(r.GLOBAL_VOLUME, this, t) } } }); t.exports = a }, 23717: (t, e, i) => { t.exports = { SoundManagerCreator: i(14747), Events: i(14463), BaseSound: i(30341), BaseSoundManager: i(85034), WebAudioSound: i(71741), WebAudioSoundManager: i(57490), HTML5AudioSound: i(64895), HTML5AudioSoundManager: i(33684), NoAudioSound: i(4603), NoAudioSoundManager: i(25960) } }, 4603: (t, e, i) => { const s = i(30341); const n = i(83419); const r = i(50792); const o = i(79291); const a = i(29747); const h = function () { return !1 }; const l = function () { return null }; const u = function () { return this }; const c = new n({ Extends: r, initialize: function (t, e, i) { void 0 === i && (i = {}), r.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = o({ mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0, pan: 0 }, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.pan = 0, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1 }, addMarker: h, updateMarker: h, removeMarker: l, play: h, pause: h, resume: h, stop: h, setMute: u, setVolume: u, setRate: u, setDetune: u, setSeek: u, setLoop: u, setPan: u, applyConfig: l, resetConfig: l, update: a, calculateRate: l, destroy: function () { s.prototype.destroy.call(this) } }); t.exports = c }, 25960: (t, e, i) => { const s = i(85034); const n = i(83419); const r = i(50792); const o = i(4603); const a = i(29747); const h = new n({ Extends: r, initialize: function (t) { r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1 }, add: function (t, e) { const i = new o(this, t, e); return this.sounds.push(i), i }, addAudioSprite: function (t, e) { const i = this.add(t, e); return i.spritemap = {}, i }, get: function (t) { return s.prototype.get.call(this, t) }, getAll: function (t) { return s.prototype.getAll.call(this, t) }, play: function (t, e) { return !1 }, playAudioSprite: function (t, e, i) { return !1 }, remove: function (t) { return s.prototype.remove.call(this, t) }, removeAll: function () { return s.prototype.removeAll.call(this) }, removeByKey: function (t) { return s.prototype.removeByKey.call(this, t) }, stopByKey: function (t) { return s.prototype.stopByKey.call(this, t) }, onBlur: a, onFocus: a, onGameBlur: a, onGameFocus: a, pauseAll: a, resumeAll: a, stopAll: a, update: a, setRate: a, setDetune: a, setMute: a, setVolume: a, unlock: a, forEachActiveSound: function (t, e) { s.prototype.forEachActiveSound.call(this, t, e) }, destroy: function () { s.prototype.destroy.call(this) } }); t.exports = h }, 71741: (t, e, i) => { const s = i(30341); const n = i(83419); const r = i(14463); const o = i(95540); const a = new n({ Extends: s, initialize: function (t, e, i) { if (void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), !this.audioBuffer) throw new Error('Audio key "' + e + '" missing from cache'); this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.pannerNode = null, this.spatialNode = null, this.spatialSource = null, this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), t.context.createPanner && (this.spatialNode = t.context.createPanner(), this.volumeNode.connect(this.spatialNode)), t.context.createStereoPanner ? (this.pannerNode = t.context.createStereoPanner(), t.context.createPanner ? this.spatialNode.connect(this.pannerNode) : this.volumeNode.connect(this.pannerNode), this.pannerNode.connect(t.destination)) : t.context.createPanner ? this.spatialNode.connect(t.destination) : this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, s.call(this, t, e, i) }, play: function (t, e) { return !!s.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(r.PLAY, this), !0) }, pause: function () { return !(this.manager.context.currentTime < this.startTime) && (!!s.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(r.PAUSE, this), !0)) }, resume: function () { return !(this.manager.context.currentTime < this.startTime) && (!!s.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit(r.RESUME, this), !0)) }, stop: function () { return !!s.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit(r.STOP, this), !0) }, createAndStartBufferSource: function () { const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = this.manager.context.currentTime + e; const s = (this.currentMarker ? this.currentMarker.start : 0) + t; const n = this.duration - t; this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, s), Math.max(0, n)), this.resetConfig() }, createAndStartLoopBufferSource: function () { const t = this.getLoopTime(); const e = this.currentMarker ? this.currentMarker.start : 0; const i = this.duration; this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i)) }, createBufferSource: function () { const t = this; const e = this.manager.context.createBufferSource(); return e.buffer = this.audioBuffer, e.connect(this.muteNode), e.onended = function (e) { e.target === t.source && (t.currentConfig.loop ? t.hasLooped = !0 : t.hasEnded = !0) }, e }, stopAndRemoveBufferSource: function () { if (this.source) { const t = this.source; this.source = null, t.stop(), t.disconnect() } this.playTime = 0, this.startTime = 0, this.hasEnded = !1, this.stopAndRemoveLoopBufferSource() }, stopAndRemoveLoopBufferSource: function () { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0 }, applyConfig: function () { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }); const t = this.currentConfig.source; if (t && this.manager.context.createPanner) { const e = this.spatialNode; e.panningModel = o(t, 'panningModel', 'equalpower'), e.distanceModel = o(t, 'distanceModel', 'inverse'), e.orientationX.value = o(t, 'orientationX', 0), e.orientationY.value = o(t, 'orientationY', 0), e.orientationZ.value = o(t, 'orientationZ', -1), e.refDistance = o(t, 'refDistance', 1), e.maxDistance = o(t, 'maxDistance', 1e4), e.rolloffFactor = o(t, 'rolloffFactor', 1), e.coneInnerAngle = o(t, 'coneInnerAngle', 360), e.coneOuterAngle = o(t, 'coneOuterAngle', 0), e.coneOuterGain = o(t, 'coneOuterGain', 0), this.spatialSource = o(t, 'follow', null), this.spatialSource || (e.positionX.value = o(t, 'x', 0), e.positionY.value = o(t, 'y', 0), e.positionZ.value = o(t, 'z', 0)) } s.prototype.applyConfig.call(this) }, x: { get: function () { return this.spatialNode ? this.spatialNode.positionX : 0 }, set: function (t) { this.spatialNode && (this.spatialNode.positionX.value = t) } }, y: { get: function () { return this.spatialNode ? this.spatialNode.positionY : 0 }, set: function (t) { this.spatialNode && (this.spatialNode.positionY.value = t) } }, update: function () { if (this.isPlaying && this.spatialSource) { const t = o(this.spatialSource, 'x', null); const e = o(this.spatialSource, 'y', null); t && t !== this._spatialx && (this._spatialx = this.spatialNode.positionX.value = t), e && e !== this._spatialy && (this._spatialy = this.spatialNode.positionY.value = e) } this.hasEnded ? (s.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(r.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit(r.LOOPED, this)) }, destroy: function () { this.pendingRemove || (s.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.pannerNode && (this.pannerNode.disconnect(), this.pannerNode = null), this.spatialNode && (this.spatialNode.disconnect(), this.spatialNode = null, this.spatialSource = null), this.rateUpdates.length = 0, this.rateUpdates = null) }, calculateRate: function () { s.prototype.calculateRate.call(this); const t = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, t) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())) }, getCurrentTime: function () { for (var t = 0, e = 0; e < this.rateUpdates.length; e++) { t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate } return t }, getLoopTime: function () { for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++)t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate; const i = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + i.time + (this.duration - t) / i.rate }, rate: { get: function () { return this.currentConfig.rate }, set: function (t) { this.currentConfig.rate = t, this.calculateRate(), this.emit(r.RATE, this, t) } }, setRate: function (t) { return this.rate = t, this }, detune: { get: function () { return this.currentConfig.detune }, set: function (t) { this.currentConfig.detune = t, this.calculateRate(), this.emit(r.DETUNE, this, t) } }, setDetune: function (t) { return this.detune = t, this }, mute: { get: function () { return this.muteNode.gain.value === 0 }, set: function (t) { this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(r.MUTE, this, t) } }, setMute: function (t) { return this.mute = t, this }, volume: { get: function () { return this.volumeNode.gain.value }, set: function (t) { this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit(r.VOLUME, this, t) } }, setVolume: function (t) { return this.volume = t, this }, seek: { get: function () { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0 }, set: function (t) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(r.SEEK, this, t)) } }, setSeek: function (t) { return this.seek = t, this }, loop: { get: function () { return this.currentConfig.loop }, set: function (t) { this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit(r.LOOP, this, t) } }, setLoop: function (t) { return this.loop = t, this }, pan: { get: function () { return this.pannerNode ? this.pannerNode.pan.value : 0 }, set: function (t) { this.currentConfig.pan = t, this.pannerNode && this.pannerNode.pan.setValueAtTime(t, this.manager.context.currentTime), this.emit(r.PAN, this, t) } }, setPan: function (t) { return this.pan = t, this } }); t.exports = a }, 57490: (t, e, i) => { const s = i(53134); const n = i(85034); const r = i(83419); const o = i(14463); const a = i(8443); const h = i(71741); const l = i(95540); const u = new r({ Extends: n, initialize: function (t) { this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), n.call(this, t), this.locked && t.isBooted ? this.unlock() : t.events.once(a.BOOT, this.unlock, this) }, createAudioContext: function (t) { const e = t.config.audio; return e.context ? (e.context.resume(), e.context) : window.hasOwnProperty('AudioContext') ? new AudioContext() : window.hasOwnProperty('webkitAudioContext') ? new window.webkitAudioContext() : void 0 }, setAudioContext: function (t) { return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = t, this.masterMuteNode = t.createGain(), this.masterVolumeNode = t.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(t.destination), this.destination = this.masterMuteNode, this }, add: function (t, e) { const i = new h(this, t, e); return this.sounds.push(i), i }, decodeAudio: function (t, e) { let i; i = Array.isArray(t) ? t : [{ key: t, data: e }]; for (var n = this.game.cache.audio, r = i.length, a = 0; a < i.length; a++) { const h = i[a]; const l = h.key; let u = h.data; typeof u === 'string' && (u = s(u)); const c = function (t, e) { n.add(t, e), this.emit(o.DECODED, t), --r === 0 && this.emit(o.DECODED_ALL) }.bind(this, l); const d = function (t, e) { console.error('Error decoding audio: ' + t + ' - ', e ? e.message : ''), --r === 0 && this.emit(o.DECODED_ALL) }.bind(this, l); this.context.decodeAudioData(u, c, d) } }, setListenerPosition: function (t, e) { return void 0 === t && (t = this.game.scale.width / 2), void 0 === e && (e = this.game.scale.height / 2), this.listenerPosition.set(t, e), this }, unlock: function () { const t = this; const e = document.body; const i = function i () { if (t.context && e) { const s = e.removeEventListener.bind(e); t.context.resume().then(function () { s('touchstart', i), s('touchend', i), s('click', i), s('keydown', i), t.unlocked = !0 }, function () { s('touchstart', i), s('touchend', i), s('click', i), s('keydown', i) }) } }; e && (e.addEventListener('touchstart', i, !1), e.addEventListener('touchend', i, !1), e.addEventListener('click', i, !1), e.addEventListener('keydown', i, !1)) }, onBlur: function () { this.locked || this.context.suspend() }, onFocus: function () { const t = this.context; !t || this.locked || t.state !== 'suspended' && t.state !== 'interrupted' || t.resume() }, update: function (t, e) { const i = this.context.listener; if (i && void 0 !== i.positionX) { const s = l(this.listenerPosition, 'x', null); const r = l(this.listenerPosition, 'y', null); s && s !== this._spatialx && (this._spatialx = i.positionX.value = s), r && r !== this._spatialy && (this._spatialy = i.positionY.value = r) } n.prototype.update.call(this, t, e), this.gameLostFocus || this.onFocus() }, destroy: function () { if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio.context) this.context.suspend(); else { const t = this; this.context.close().then(function () { t.context = null }) } n.prototype.destroy.call(this) }, setMute: function (t) { return this.mute = t, this }, mute: { get: function () { return this.masterMuteNode.gain.value === 0 }, set: function (t) { this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(o.GLOBAL_MUTE, this, t) } }, setVolume: function (t) { return this.volume = t, this }, volume: { get: function () { return this.masterVolumeNode.gain.value }, set: function (t) { this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit(o.GLOBAL_VOLUME, this, t) } } }); t.exports = u }, 73162: (t, e, i) => { const s = i(37105); const n = i(83419); const r = i(29747); const o = i(19186); const a = new n({ initialize: function (t) { this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = '' }, add: function (t, e) { return e ? s.Add(this.list, t) : s.Add(this.list, t, 0, this.addCallback, this) }, addAt: function (t, e, i) { return i ? s.AddAt(this.list, t, e) : s.AddAt(this.list, t, e, 0, this.addCallback, this) }, getAt: function (t) { return this.list[t] }, getIndex: function (t) { return this.list.indexOf(t) }, sort: function (t, e) { return t ? (void 0 === e && (e = function (e, i) { return e[t] - i[t] }), o(this.list, e), this) : this }, getByName: function (t) { return s.GetFirst(this.list, 'name', t) }, getRandom: function (t, e) { return s.GetRandom(this.list, t, e) }, getFirst: function (t, e, i, n) { return s.GetFirst(this.list, t, e, i, n) }, getAll: function (t, e, i, n) { return s.GetAll(this.list, t, e, i, n) }, count: function (t, e) { return s.CountAllMatching(this.list, t, e) }, swap: function (t, e) { s.Swap(this.list, t, e) }, moveTo: function (t, e) { return s.MoveTo(this.list, t, e) }, moveAbove: function (t, e) { return s.MoveAbove(this.list, t, e) }, moveBelow: function (t, e) { return s.MoveBelow(this.list, t, e) }, remove: function (t, e) { return e ? s.Remove(this.list, t) : s.Remove(this.list, t, this.removeCallback, this) }, removeAt: function (t, e) { return e ? s.RemoveAt(this.list, t) : s.RemoveAt(this.list, t, this.removeCallback, this) }, removeBetween: function (t, e, i) { return i ? s.RemoveBetween(this.list, t, e) : s.RemoveBetween(this.list, t, e, this.removeCallback, this) }, removeAll: function (t) { for (let e = this.list.length; e--;) this.remove(this.list[e], t); return this }, bringToTop: function (t) { return s.BringToTop(this.list, t) }, sendToBack: function (t) { return s.SendToBack(this.list, t) }, moveUp: function (t) { return s.MoveUp(this.list, t), t }, moveDown: function (t) { return s.MoveDown(this.list, t), t }, reverse: function () { return this.list.reverse(), this }, shuffle: function () { return s.Shuffle(this.list), this }, replace: function (t, e) { return s.Replace(this.list, t, e) }, exists: function (t) { return this.list.indexOf(t) > -1 }, setAll: function (t, e, i, n) { return s.SetAll(this.list, t, e, i, n), this }, each: function (t, e) { for (var i = [null], s = 2; s < arguments.length; s++)i.push(arguments[s]); for (s = 0; s < this.list.length; s++)i[0] = this.list[s], t.apply(e, i) }, shutdown: function () { this.removeAll(), this.list = [] }, destroy: function () { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null }, length: { get: function () { return this.list.length } }, first: { get: function () { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }, last: { get: function () { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null } }, next: { get: function () { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }, previous: { get: function () { return this.position > 0 ? (this.position--, this.list[this.position]) : null } } }); t.exports = a }, 90330: (t, e, i) => { const s = new (i(83419))({ initialize: function (t) { this.entries = {}, this.size = 0, this.setAll(t) }, setAll: function (t) { if (Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]); return this }, set: function (t, e) { return this.has(t) || this.size++, this.entries[t] = e, this }, get: function (t) { if (this.has(t)) return this.entries[t] }, getArray: function () { const t = []; const e = this.entries; for (const i in e) t.push(e[i]); return t }, has: function (t) { return this.entries.hasOwnProperty(t) }, delete: function (t) { return this.has(t) && (delete this.entries[t], this.size--), this }, clear: function () { return Object.keys(this.entries).forEach(function (t) { delete this.entries[t] }, this), this.size = 0, this }, keys: function () { return Object.keys(this.entries) }, values: function () { const t = []; const e = this.entries; for (const i in e) t.push(e[i]); return t }, dump: function () { const t = this.entries; for (const e in console.group('Map'), t) console.log(e, t[e]); console.groupEnd() }, each: function (t) { const e = this.entries; for (const i in e) if (!1 === t(i, e[i])) break; return this }, contains: function (t) { const e = this.entries; for (const i in e) if (e[i] === t) return !0; return !1 }, merge: function (t, e) { void 0 === e && (e = !1); const i = this.entries; const s = t.entries; for (const n in s) i.hasOwnProperty(n) && e ? i[n] = s[n] : this.set(n, s[n]); return this } }); t.exports = s }, 25774: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(82348); const o = new s({ Extends: n, initialize: function () { n.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, this.checkQueue = !1 }, isActive: function (t) { return this._active.indexOf(t) > -1 }, isPending: function (t) { return this._toProcess > 0 && this._pending.indexOf(t) > -1 }, isDestroying: function (t) { return this._destroy.indexOf(t) > -1 }, add: function (t) { return this.checkQueue && this.isActive(t) && !this.isDestroying(t) || this.isPending(t) || (this._pending.push(t), this._toProcess++), t }, remove: function (t) { if (this.isPending(t)) { const e = this._pending; const i = e.indexOf(t); i !== -1 && e.splice(i, 1) } else this.isActive(t) && (this._destroy.push(t), this._toProcess++); return t }, removeAll: function () { for (let t = this._active, e = this._destroy, i = t.length; i--;)e.push(t[i]), this._toProcess++; return this }, update: function () { if (this._toProcess === 0) return this._active; let t; let e; let i = this._destroy; const s = this._active; for (t = 0; t < i.length; t++) { e = i[t]; const n = s.indexOf(e); n !== -1 && (s.splice(n, 1), this.emit(r.PROCESS_QUEUE_REMOVE, e)) } for (i.length = 0, i = this._pending, t = 0; t < i.length; t++)e = i[t], (!this.checkQueue || this.checkQueue && s.indexOf(e) === -1) && (s.push(e), this.emit(r.PROCESS_QUEUE_ADD, e)); return i.length = 0, this._toProcess = 0, s }, getActive: function () { return this._active }, length: { get: function () { return this._active.length } }, destroy: function () { this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [] } }); t.exports = o }, 59542: (t, e, i) => { const s = i(43886); function n (t) { if (!(this instanceof n)) return new n(t, ['.left', '.top', '.right', '.bottom']); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear() } function r (t, e, i) { if (!i) return e.indexOf(t); for (let s = 0; s < e.length; s++) if (i(t, e[s])) return s; return -1 } function o (t, e) { a(t, 0, t.children.length, e, t) } function a (t, e, i, s, n) { n || (n = v(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0; for (var r, o = e; o < i; o++)r = t.children[o], h(n, t.leaf ? s(r) : r); return n } function h (t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function l (t, e) { return t.minX - e.minX } function u (t, e) { return t.minY - e.minY } function c (t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function d (t) { return t.maxX - t.minX + (t.maxY - t.minY) } function f (t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function p (t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function v (t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function g (t, e, i, n, r) { for (var o, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= n || (o = e + Math.ceil((i - e) / n / 2) * n, s(t, o, e, i, r), a.push(e, o, o, i)) } n.prototype = { all: function () { return this._all(this.data, []) }, search: function (t) { let e = this.data; const i = []; const s = this.toBBox; if (!p(t, e)) return i; for (var n, r, o, a, h = []; e;) { for (n = 0, r = e.children.length; n < r; n++)o = e.children[n], p(t, a = e.leaf ? s(o) : o) && (e.leaf ? i.push(o) : f(t, a) ? this._all(o, i) : h.push(o)); e = h.pop() } return i }, collides: function (t) { let e = this.data; const i = this.toBBox; if (!p(t, e)) return !1; for (var s, n, r, o, a = []; e;) { for (s = 0, n = e.children.length; s < n; s++) if (r = e.children[s], p(t, o = e.leaf ? i(r) : r)) { if (e.leaf || f(t, o)) return !0; a.push(r) } e = a.pop() } return !1 }, load: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, i = t.length; e < i; e++) this.insert(t[e]); return this } let s = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === s.height) this._splitRoot(this.data, s); else { if (this.data.height < s.height) { const n = this.data; this.data = s, s = n } this._insert(s, this.data.height - s.height - 1, !0) } else this.data = s; return this }, insert: function (t) { return t && this._insert(t, this.data.height - 1), this }, clear: function () { return this.data = v([]), this }, remove: function (t, e) { if (!t) return this; for (var i, s, n, o, a = this.data, h = this.toBBox(t), l = [], u = []; a || l.length;) { if (a || (a = l.pop(), s = l[l.length - 1], i = u.pop(), o = !0), a.leaf && (n = r(t, a.children, e)) !== -1) return a.children.splice(n, 1), l.push(a), this._condense(l), this; o || a.leaf || !f(a, h) ? s ? (i++, a = s.children[i], o = !1) : a = null : (l.push(a), u.push(i), i = 0, s = a, a = a.children[0]) } return this }, toBBox: function (t) { return t }, compareMinX: l, compareMinY: u, toJSON: function () { return this.data }, fromJSON: function (t) { return this.data = t, this }, _all: function (t, e) { for (let i = []; t;)t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e }, _build: function (t, e, i, s) { let n; const r = i - e + 1; let a = this._maxEntries; if (r <= a) return o(n = v(t.slice(e, i + 1)), this.toBBox), n; s || (s = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, s - 1))), (n = v([])).leaf = !1, n.height = s; let h; let l; let u; let c; const d = Math.ceil(r / a); const f = d * Math.ceil(Math.sqrt(a)); for (g(t, e, i, f, this.compareMinX), h = e; h <= i; h += f) for (g(t, h, u = Math.min(h + f - 1, i), d, this.compareMinY), l = h; l <= u; l += d)c = Math.min(l + d - 1, u), n.children.push(this._build(t, l, c, s - 1)); return o(n, this.toBBox), n }, _chooseSubtree: function (t, e, i, s) { for (var n, r, o, a, h, l, u, d, f, p; s.push(e), !e.leaf && s.length - 1 !== i;) { for (u = d = 1 / 0, n = 0, r = e.children.length; n < r; n++)h = c(o = e.children[n]), f = t, p = o, (l = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h) < d ? (d = l, u = h < u ? h : u, a = o) : l === d && h < u && (u = h, a = o); e = a || e.children[0] } return e }, _insert: function (t, e, i) { const s = this.toBBox; const n = i ? t : s(t); const r = []; const o = this._chooseSubtree(n, this.data, e, r); for (o.children.push(t), h(o, n); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--; this._adjustParentBBoxes(n, r, e) }, _split: function (t, e) { const i = t[e]; const s = i.children.length; const n = this._minEntries; this._chooseSplitAxis(i, n, s); const r = this._chooseSplitIndex(i, n, s); const a = v(i.children.splice(r, i.children.length - r)); a.height = i.height, a.leaf = i.leaf, o(i, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a) }, _splitRoot: function (t, e) { this.data = v([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox) }, _chooseSplitIndex: function (t, e, i) { let s, n, r, o, h, l, u, d, f, p, v, g, m, y; for (l = u = 1 / 0, s = e; s <= i - e; s++)n = a(t, 0, s, this.toBBox), r = a(t, s, i, this.toBBox), f = n, p = r, v = void 0, g = void 0, m = void 0, y = void 0, v = Math.max(f.minX, p.minX), g = Math.max(f.minY, p.minY), m = Math.min(f.maxX, p.maxX), y = Math.min(f.maxY, p.maxY), o = Math.max(0, m - v) * Math.max(0, y - g), h = c(n) + c(r), o < l ? (l = o, d = s, u = h < u ? h : u) : o === l && h < u && (u = h, d = s); return d }, _chooseSplitAxis: function (t, e, i) { const s = t.leaf ? this.compareMinX : l; const n = t.leaf ? this.compareMinY : u; this._allDistMargin(t, e, i, s) < this._allDistMargin(t, e, i, n) && t.children.sort(s) }, _allDistMargin: function (t, e, i, s) { t.children.sort(s); let n; let r; const o = this.toBBox; const l = a(t, 0, e, o); const u = a(t, i - e, i, o); let c = d(l) + d(u); for (n = e; n < i - e; n++)r = t.children[n], h(l, t.leaf ? o(r) : r), c += d(l); for (n = i - e - 1; n >= e; n--)r = t.children[n], h(u, t.leaf ? o(r) : r), c += d(u); return c }, _adjustParentBBoxes: function (t, e, i) { for (let s = i; s >= 0; s--)h(e[s], t) }, _condense: function (t) { for (var e, i = t.length - 1; i >= 0; i--)t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : o(t[i], this.toBBox) }, compareMinX: function (t, e) { return t.left - e.left }, compareMinY: function (t, e) { return t.top - e.top }, toBBox: function (t) { return { minX: t.left, minY: t.top, maxX: t.right, maxY: t.bottom } } }, t.exports = n }, 35072: (t, e, i) => { var s = new (i(83419))({ initialize: function (t) { if (this.entries = [], Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e]) }, set: function (t) { return this.entries.indexOf(t) === -1 && this.entries.push(t), this }, get: function (t, e) { for (let i = 0; i < this.entries.length; i++) { const s = this.entries[i]; if (s[t] === e) return s } }, getArray: function () { return this.entries.slice(0) }, delete: function (t) { const e = this.entries.indexOf(t); return e > -1 && this.entries.splice(e, 1), this }, dump: function () { console.group('Set'); for (let t = 0; t < this.entries.length; t++) { const e = this.entries[t]; console.log(e) } console.groupEnd() }, each: function (t, e) { let i; const s = this.entries.slice(); const n = s.length; if (e) for (i = 0; i < n && !1 !== t.call(e, s[i], i); i++); else for (i = 0; i < n && !1 !== t(s[i], i); i++); return this }, iterate: function (t, e) { let i; const s = this.entries.length; if (e) for (i = 0; i < s && !1 !== t.call(e, this.entries[i], i); i++); else for (i = 0; i < s && !1 !== t(this.entries[i], i); i++); return this }, iterateLocal: function (t) { let e; const i = []; for (e = 1; e < arguments.length; e++)i.push(arguments[e]); const s = this.entries.length; for (e = 0; e < s; e++) { const n = this.entries[e]; n[t].apply(n, i) } return this }, clear: function () { return this.entries.length = 0, this }, contains: function (t) { return this.entries.indexOf(t) > -1 }, union: function (t) { const e = new s(); return t.entries.forEach(function (t) { e.set(t) }), this.entries.forEach(function (t) { e.set(t) }), e }, intersect: function (t) { const e = new s(); return this.entries.forEach(function (i) { t.contains(i) && e.set(i) }), e }, difference: function (t) { const e = new s(); return this.entries.forEach(function (i) { t.contains(i) || e.set(i) }), e }, size: { get: function () { return this.entries.length }, set: function (t) { return t < this.entries.length ? this.entries.length = t : this.entries.length } } }); t.exports = s }, 86555: (t, e, i) => { const s = i(45319); const n = i(83419); const r = i(56583); const o = i(26099); var a = new n({ initialize: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === s && (s = null), this._width = t, this._height = e, this._parent = s, this.aspectMode = i, this.aspectRatio = e === 0 ? 1 : t / e, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new o() }, setAspectMode: function (t) { return void 0 === t && (t = 0), this.aspectMode = t, this.setSize(this._width, this._height) }, setSnap: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.snapTo.set(t, e), this.setSize(this._width, this._height) }, setParent: function (t) { return this._parent = t, this.setSize(this._width, this._height) }, setMin: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.minWidth = s(t, 0, this.maxWidth), this.minHeight = s(e, 0, this.maxHeight), this.setSize(this._width, this._height) }, setMax: function (t, e) { return void 0 === t && (t = Number.MAX_VALUE), void 0 === e && (e = t), this.maxWidth = s(t, this.minWidth, Number.MAX_VALUE), this.maxHeight = s(e, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height) }, setSize: function (t, e) { switch (void 0 === t && (t = 0), void 0 === e && (e = t), this.aspectMode) { case a.NONE: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height; break; case a.WIDTH_CONTROLS_HEIGHT: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1); break; case a.HEIGHT_CONTROLS_WIDTH: this._height = this.getNewHeight(r(e, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1); break; case a.FIT: this.constrain(t, e, !0); break; case a.ENVELOP: this.constrain(t, e, !1) } return this }, setAspectRatio: function (t) { return this.aspectRatio = t, this.setSize(this._width, this._height) }, resize: function (t, e) { return this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height, this }, getNewWidth: function (t, e) { return void 0 === e && (e = !0), t = s(t, this.minWidth, this.maxWidth), e && this._parent && t > this._parent.width && (t = Math.max(this.minWidth, this._parent.width)), t }, getNewHeight: function (t, e) { return void 0 === e && (e = !0), t = s(t, this.minHeight, this.maxHeight), e && this._parent && t > this._parent.height && (t = Math.max(this.minHeight, this._parent.height)), t }, constrain: function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = !0), t = this.getNewWidth(t), e = this.getNewHeight(e); const s = this.snapTo; const n = e === 0 ? 1 : t / e; return i && this.aspectRatio > n || !i && this.aspectRatio < n ? (e = (t = r(t, s.x)) / this.aspectRatio, s.y > 0 && (t = (e = r(e, s.y)) * this.aspectRatio)) : (i && this.aspectRatio < n || !i && this.aspectRatio > n) && (t = (e = r(e, s.y)) * this.aspectRatio, s.x > 0 && (e = (t = r(t, s.x)) * (1 / this.aspectRatio))), this._width = t, this._height = e, this }, fitTo: function (t, e) { return this.constrain(t, e, !0) }, envelop: function (t, e) { return this.constrain(t, e, !1) }, setWidth: function (t) { return this.setSize(t, this._height) }, setHeight: function (t) { return this.setSize(this._width, t) }, toString: function () { return '[{ Size (width=' + this._width + ' height=' + this._height + ' aspectRatio=' + this.aspectRatio + ' aspectMode=' + this.aspectMode + ') }]' }, setCSS: function (t) { t && t.style && (t.style.width = this._width + 'px', t.style.height = this._height + 'px') }, copy: function (t) { return t.setAspectMode(this.aspectMode), t.aspectRatio = this.aspectRatio, t.setSize(this.width, this.height) }, destroy: function () { this._parent = null, this.snapTo = null }, width: { get: function () { return this._width }, set: function (t) { this.setSize(t, this._height) } }, height: { get: function () { return this._height }, set: function (t) { this.setSize(this._width, t) } } }); a.NONE = 0, a.WIDTH_CONTROLS_HEIGHT = 1, a.HEIGHT_CONTROLS_WIDTH = 2, a.FIT = 3, a.ENVELOP = 4, t.exports = a }, 15238: t => { t.exports = 'add' }, 56187: t => { t.exports = 'remove' }, 82348: (t, e, i) => { t.exports = { PROCESS_QUEUE_ADD: i(15238), PROCESS_QUEUE_REMOVE: i(56187) } }, 41392: (t, e, i) => { t.exports = { Events: i(82348), List: i(73162), Map: i(90330), ProcessQueue: i(25774), RTree: i(59542), Set: i(35072), Size: i(86555) } }, 57382: (t, e, i) => { const s = i(83419); const n = i(45319); const r = i(40987); const o = i(8054); const a = i(50030); const h = i(79237); const l = new s({ Extends: h, initialize: function (t, e, i, s, n) { h.call(this, t, e, i, s, n), this.add('__BASE', 0, 0, 0, s, n), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d', { willReadFrequently: !0 }), this.width = s, this.height = n, this.imageData = this.context.getImageData(0, 0, s, n), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data) }, update: function () { return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === o.WEBGL && this.refresh(), this }, draw: function (t, e, i, s) { return void 0 === s && (s = !0), this.context.drawImage(i, t, e), s && this.update(), this }, drawFrame: function (t, e, i, s, n) { void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = !0); const r = this.manager.getFrame(t, e); if (r) { const o = r.canvasData; const a = r.cutWidth; const h = r.cutHeight; const l = r.source.resolution; this.context.drawImage(r.source.image, o.x, o.y, a, h, i, s, a / l, h / l), n && this.update() } return this }, setPixel: function (t, e, i, s, n, r) { if (void 0 === r && (r = 255), t = Math.abs(Math.floor(t)), e = Math.abs(Math.floor(e)), this.getIndex(t, e) > -1) { const o = this.context.getImageData(t, e, 1, 1); o.data[0] = i, o.data[1] = s, o.data[2] = n, o.data[3] = r, this.context.putImageData(o, t, e) } return this }, putData: function (t, e, i, s, n, r, o) { return void 0 === s && (s = 0), void 0 === n && (n = 0), void 0 === r && (r = t.width), void 0 === o && (o = t.height), this.context.putImageData(t, e, i, s, n, r, o), this }, getData: function (t, e, i, s) { return t = n(Math.floor(t), 0, this.width - 1), e = n(Math.floor(e), 0, this.height - 1), i = n(i, 1, this.width - t), s = n(s, 1, this.height - e), this.context.getImageData(t, e, i, s) }, getPixel: function (t, e, i) { i || (i = new r()); const s = this.getIndex(t, e); if (s > -1) { const n = this.data; const o = n[s + 0]; const a = n[s + 1]; const h = n[s + 2]; const l = n[s + 3]; i.setTo(o, a, h, l) } return i }, getPixels: function (t, e, i, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = i), t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)); for (var o = n(t, 0, this.width), a = n(t + i, 0, this.width), h = n(e, 0, this.height), l = n(e + s, 0, this.height), u = new r(), c = [], d = h; d < l; d++) { for (var f = [], p = o; p < a; p++)u = this.getPixel(p, d, u), f.push({ x: p, y: d, color: u.color, alpha: u.alphaGL }); c.push(f) } return c }, getIndex: function (t, e) { return t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)), t < this.width && e < this.height ? 4 * (t + e * this.width) : -1 }, refresh: function () { return this._source.update(), this }, getCanvas: function () { return this.canvas }, getContext: function () { return this.context }, clear: function (t, e, i, s, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), void 0 === n && (n = !0), this.context.clearRect(t, e, i, s), n && this.update(), this }, setSize: function (t, e) { return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = a(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.width = t, this.height = e, this.refresh()), this }, destroy: function () { h.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null } }); t.exports = l }, 81320: (t, e, i) => { const s = i(10312); const n = i(71911); const r = i(27919); const o = i(83419); const a = i(8054); const h = i(4327); const l = i(95540); const u = i(36060); const c = i(32302); const d = i(79237); const f = i(70554); const p = new o({ Extends: d, initialize: function (t, e, i, s) { void 0 === i && (i = 256), void 0 === s && (s = 256), this.type = 'DynamicTexture'; const o = t.game.renderer; const h = o && o.type === a.CANVAS; const l = h ? r.create2D(this, i, s) : [this]; d.call(this, t, e, l, i, s), this.add('__BASE', 0, 0, 0, i, s), this.renderer = o, this.width = -1, this.height = -1, this.isDrawing = !1, this.canvas = h ? l : null, this.context = h ? l.getContext('2d', { willReadFrequently: !0 }) : null, this.dirty = !1, this.isSpriteTexture = !0, this._eraseMode = !1, this.camera = new n(0, 0, i, s).setScene(t.game.scene.systemScene, !1), this.renderTarget = h ? null : new c(o, i, s, 1, 0, !1, !0, !0, !1), this.pipeline = h ? null : o.pipelines.get(u.SINGLE_PIPELINE), this.setSize(i, s) }, setSize: function (t, e) { void 0 === e && (e = t); const i = this.get(); const s = i.source; if (t !== this.width || e !== this.height) { this.canvas && (this.canvas.width = t, this.canvas.height = e); const n = this.renderTarget; n && (n.willResize(t, e) && n.resize(t, e), n.texture !== s.glTexture && this.renderer.deleteTexture(s.glTexture), this.setFromRenderTarget()), this.camera.setSize(t, e), s.width = t, s.height = e, i.setSize(t, e), this.width = t, this.height = e } else { const r = this.getSourceImage(); i.cutX + t > r.width && (t = r.width - i.cutX), i.cutY + e > r.height && (e = r.height - i.cutY), i.setSize(t, e, i.cutX, i.cutY) } return this }, setFromRenderTarget: function () { const t = this.get().source; const e = this.renderTarget; return t.isRenderTexture = !0, t.isGLTexture = !0, t.glTexture = e.texture, this }, setIsSpriteTexture: function (t) { return this.isSpriteTexture = t, this }, fill: function (t, e, i, s, n, r) { const o = this.camera; const a = this.renderer; void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height); const h = t >> 16 & 255; const l = t >> 8 & 255; const u = 255 & t; const c = this.renderTarget; if (o.preRender(), c) { c.bind(!0); const d = this.pipeline.manager.set(this.pipeline); const p = a.width / c.width; const v = a.height / c.height; const g = c.height - (s + r); d.drawFillRect(i * p, g * v, n * p, r * v, f.getTintFromFloats(u / 255, l / 255, h / 255, 1), e), c.unbind(!0) } else { const m = this.context; a.setContext(m), m.globalCompositeOperation = 'source-over', m.fillStyle = 'rgba(' + h + ',' + l + ',' + u + ',' + e + ')', m.fillRect(i, s, n, r), a.setContext() } return this.dirty = !0, this }, clear: function () { if (this.dirty) { const t = this.context; const e = this.renderTarget; e ? e.clear() : t && (t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, this.width, this.height), t.restore()), this.dirty = !1 } return this }, stamp: function (t, e, i, s, n) { void 0 === i && (i = 0), void 0 === s && (s = 0); const r = l(n, 'alpha', 1); const o = l(n, 'tint', 16777215); const a = l(n, 'angle', 0); const h = l(n, 'rotation', 0); const u = l(n, 'scale', 1); const c = l(n, 'scaleX', u); const d = l(n, 'scaleY', u); const f = l(n, 'originX', 0.5); const p = l(n, 'originY', 0.5); const v = l(n, 'blendMode', 0); const g = l(n, 'erase', !1); const m = l(n, 'skipBatch', !1); const y = this.manager.resetStamp(r, o); return y.setAngle(0), a !== 0 ? y.setAngle(a) : h !== 0 && y.setRotation(h), y.setScale(c, d), y.setTexture(t, e), y.setOrigin(f, p), y.setBlendMode(v), g && (this._eraseMode = !0), m ? this.batchGameObject(y, i, s) : this.draw(y, i, s), g && (this._eraseMode = !1), this }, erase: function (t, e, i) { return this._eraseMode = !0, this.draw(t, e, i), this._eraseMode = !1, this }, draw: function (t, e, i, s, n) { return this.beginDraw(), this.batchDraw(t, e, i, s, n), this.endDraw(), this }, drawFrame: function (t, e, i, s, n, r) { return this.beginDraw(), this.batchDrawFrame(t, e, i, s, n, r), this.endDraw(), this }, repeat: function (t, e, i, s, n, r, o, a, l) { if (void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height), void 0 === o && (o = 1), void 0 === a && (a = 16777215), void 0 === l && (l = !1), !(e = t instanceof h ? t : this.manager.getFrame(t, e))) return this; const u = this.manager.resetStamp(o, a); u.setFrame(e), u.setOrigin(0); const c = e.width; const d = e.height; n = Math.floor(n), r = Math.floor(r); let f = Math.ceil(n / c); let p = Math.ceil(r / d); let v = f * c - n; let g = p * d - r; v > 0 && (v = c - v), g > 0 && (g = d - g), i < 0 && (f += Math.ceil(Math.abs(i) / c)), s < 0 && (p += Math.ceil(Math.abs(s) / d)); let m = i; let y = s; let x = !1; const T = this.manager.stampCrop.setTo(0, 0, c, d); l || this.beginDraw(); for (let w = 0; w < p; w++) if (y + d < 0) y += d; else { for (let b = 0; b < f; b++)x = !1, m + c < 0 || (m < 0 && (x = !0, T.width = c + m, T.x = c - T.width), y < 0 && (x = !0, T.height = d + y, T.y = d - T.height), v > 0 && b === f - 1 && (x = !0, T.width = v), g > 0 && w === p - 1 && (x = !0, T.height = g), x && u.setCrop(T), this.batchGameObject(u, m, y), u.isCropped = !1, T.setTo(0, 0, c, d)), m += c; m = i, y += d } return l || this.endDraw(), this }, beginDraw: function () { if (!this.isDrawing) { const t = this.camera; const e = this.renderer; const i = this.renderTarget; t.preRender(), i ? e.beginCapture(i.width, i.height) : e.setContext(this.context), this.isDrawing = !0 } return this }, batchDraw: function (t, e, i, s, n) { return Array.isArray(t) || (t = [t]), this.batchList(t, e, i, s, n), this }, batchDrawFrame: function (t, e, i, s, n, r) { void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 1), void 0 === r && (r = 16777215); const o = this.manager.getFrame(t, e); return o && (this.renderTarget ? this.pipeline.batchTextureFrame(o, i, s, r, n, this.camera.matrix, null) : this.batchTextureFrame(o, i, s, n, r)), this }, endDraw: function (t) { if (void 0 === t && (t = this._eraseMode), this.isDrawing) { const e = this.renderer; const i = this.renderTarget; if (i) { const s = e.endCapture(); e.pipelines.setUtility().blitFrame(s, i, 1, !1, !1, t, this.isSpriteTexture), e.resetScissor(), e.resetViewport() } else e.setContext(); this.dirty = !0, this.isDrawing = !1 } return this }, batchList: function (t, e, i, s, n) { const r = t.length; if (r !== 0) for (let o = 0; o < r; o++) { const a = t[o]; a && a !== this && (a.renderWebGL || a.renderCanvas ? this.batchGameObject(a, e, i) : a.isParent || a.list ? this.batchGroup(a.getChildren(), e, i) : typeof a === 'string' ? this.batchTextureFrameKey(a, null, e, i, s, n) : a instanceof h ? this.batchTextureFrame(a, e, i, s, n) : Array.isArray(a) && this.batchList(a, e, i, s, n)) } }, batchGroup: function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); for (let s = 0; s < t.length; s++) { const n = t[s]; n.willRender(this.camera) && this.batchGameObject(n, n.x + e, n.y + i) } }, batchGameObject: function (t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const n = t.x; const r = t.y; const o = this.camera; const a = this.renderer; const h = this._eraseMode; const l = t.mask; if (t.setPosition(e, i), this.canvas) { if (h) { var u = t.blendMode; t.blendMode = s.ERASE } l && l.preRenderCanvas(a, t, o), t.renderCanvas(a, t, o, null), l && l.postRenderCanvas(a, t, o), h && (t.blendMode = u) } else a && (l && l.preRenderWebGL(a, t, o), h || a.setBlendMode(t.blendMode), t.renderWebGL(a, t, o), l && l.postRenderWebGL(a, o, this.renderTarget)); t.setPosition(n, r) }, batchTextureFrameKey: function (t, e, i, s, n, r) { const o = this.manager.getFrame(t, e); o && this.batchTextureFrame(o, i, s, n, r) }, batchTextureFrame: function (t, e, i, s, n) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 1), void 0 === n && (n = 16777215); const r = this.camera.matrix; if (this.renderTarget) this.pipeline.batchTextureFrame(t, e, i, n, s, r, null); else { const o = this.context; const a = t.canvasData; const h = t.source.image; o.save(), o.globalCompositeOperation = this._eraseMode ? 'destination-out' : 'source-over', o.globalAlpha = s, r.setToContext(o), a.width > 0 && a.height > 0 && o.drawImage(h, a.x, a.y, a.width, a.height, e, i, a.width, a.height), o.restore() } }, snapshotArea: function (t, e, i, s, n, r, o) { return this.renderTarget ? this.renderer.snapshotFramebuffer(this.renderTarget.framebuffer, this.width, this.height, n, !1, t, e, i, s, r, o) : this.renderer.snapshotCanvas(this.canvas, n, !1, t, e, i, s, r, o), this }, snapshot: function (t, e, i) { return this.snapshotArea(0, 0, this.width, this.height, t, e, i) }, snapshotPixel: function (t, e, i) { return this.snapshotArea(t, e, 1, 1, i, 'pixel') }, getWebGLTexture: function () { if (this.renderTarget) return this.renderTarget.texture }, renderWebGL: function (t, e, i, s) { const n = this.manager.resetStamp(); n.setTexture(this), n.setOrigin(0), n.renderWebGL(t, n, i, s) }, renderCanvas: function () { }, destroy: function () { const t = this.manager.stamp; t && t.texture === this && this.manager.resetStamp(), d.prototype.destroy.call(this), r.remove(this.canvas), this.renderTarget && this.renderTarget.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.renderer = null } }); t.exports = p }, 4327: (t, e, i) => { const s = i(83419); const n = i(45319); const r = i(79291); var o = new s({ initialize: function (t, e, i, s, n, r, o) { this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = { cut: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, trim: !1, sourceSize: { w: 0, h: 0 }, spriteSourceSize: { x: 0, y: 0, w: 0, h: 0, r: 0, b: 0 }, radius: 0, drawImage: { x: 0, y: 0, width: 0, height: 0 }, is3Slice: !1, scale9: !1, scale9Borders: { x: 0, y: 0, w: 0, h: 0 } }, this.setSize(r, o, s, n) }, setSize: function (t, e, i, s) { void 0 === i && (i = 0), void 0 === s && (s = 0), this.cutX = i, this.cutY = s, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(0.5 * t), this.halfHeight = Math.floor(0.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2); const n = this.data; const r = n.cut; r.x = i, r.y = s, r.w = t, r.h = e, r.r = i + t, r.b = s + e, n.sourceSize.w = t, n.sourceSize.h = e, n.spriteSourceSize.w = t, n.spriteSourceSize.h = e, n.radius = 0.5 * Math.sqrt(t * t + e * e); const o = n.drawImage; return o.x = i, o.y = s, o.width = t, o.height = e, this.updateUVs() }, setTrim: function (t, e, i, s, n, r) { const o = this.data; const a = o.spriteSourceSize; return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = s, a.w = n, a.h = r, a.r = i + n, a.b = s + r, this.x = i, this.y = s, this.width = n, this.height = r, this.halfWidth = 0.5 * n, this.halfHeight = 0.5 * r, this.centerX = Math.floor(n / 2), this.centerY = Math.floor(r / 2), this.updateUVs() }, setScale9: function (t, e, i, s) { const n = this.data; return n.scale9 = !0, n.is3Slice = e === 0 && s === this.height, n.scale9Borders.x = t, n.scale9Borders.y = e, n.scale9Borders.w = i, n.scale9Borders.h = s, this }, setCropUVs: function (t, e, i, s, r, o, a) { const h = this.cutX; const l = this.cutY; const u = this.cutWidth; const c = this.cutHeight; const d = this.realWidth; const f = this.realHeight; let p = h + (e = n(e, 0, d)); let v = l + (i = n(i, 0, f)); let g = s = n(s, 0, d - e); let m = r = n(r, 0, f - i); const y = this.data; if (y.trim) { const x = y.spriteSourceSize; const T = e + (s = n(s, 0, u - e)); const w = i + (r = n(r, 0, c - i)); if (!(x.r < e || x.b < i || x.x > T || x.y > w)) { const b = Math.max(x.x, e); const S = Math.max(x.y, i); const E = Math.min(x.r, T) - b; const A = Math.min(x.b, w) - S; g = E, m = A, p = o ? h + (u - (b - x.x) - E) : h + (b - x.x), v = a ? l + (c - (S - x.y) - A) : l + (S - x.y), e = b, i = S, s = E, r = A } else p = 0, v = 0, g = 0, m = 0 } else o && (p = h + (u - e - s)), a && (v = l + (c - i - r)); const C = this.source.width; const _ = this.source.height; return t.u0 = Math.max(0, p / C), t.v0 = Math.max(0, v / _), t.u1 = Math.min(1, (p + g) / C), t.v1 = Math.min(1, (v + m) / _), t.x = e, t.y = i, t.cx = p, t.cy = v, t.cw = g, t.ch = m, t.width = s, t.height = r, t.flipX = o, t.flipY = a, t }, updateCropUVs: function (t, e, i) { return this.setCropUVs(t, t.x, t.y, t.width, t.height, e, i) }, setUVs: function (t, e, i, s, n, r) { const o = this.data.drawImage; return o.width = t, o.height = e, this.u0 = i, this.v0 = s, this.u1 = n, this.v1 = r, this }, updateUVs: function () { const t = this.cutX; const e = this.cutY; const i = this.cutWidth; const s = this.cutHeight; const n = this.data.drawImage; n.width = i, n.height = s; const r = this.source.width; const o = this.source.height; return this.u0 = t / r, this.v0 = e / o, this.u1 = (t + i) / r, this.v1 = (e + s) / o, this }, updateUVsInverted: function () { const t = this.source.width; const e = this.source.height; return this.u0 = (this.cutX + this.cutHeight) / t, this.v0 = this.cutY / e, this.u1 = this.cutX / t, this.v1 = (this.cutY + this.cutWidth) / e, this }, clone: function () { const t = new o(this.texture, this.name, this.sourceIndex); return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = r(!0, t.data, this.data), t.updateUVs(), t }, destroy: function () { this.texture = null, this.source = null, this.customData = null, this.data = null }, glTexture: { get: function () { return this.source.glTexture } }, realWidth: { get: function () { return this.data.sourceSize.w } }, realHeight: { get: function () { return this.data.sourceSize.h } }, radius: { get: function () { return this.data.radius } }, trimmed: { get: function () { return this.data.trim } }, scale9: { get: function () { return this.data.scale9 } }, is3Slice: { get: function () { return this.data.is3Slice } }, canvasData: { get: function () { return this.data.drawImage } } }); t.exports = o }, 79237: (t, e, i) => { const s = i(83419); const n = i(4327); const r = i(11876); const o = 'Texture "%s" has no frame "%s"'; const a = new s({ initialize: function (t, e, i, s, n) { Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE', this.frameTotal = 0; for (let o = 0; o < i.length; o++) this.source.push(new r(this, i[o], s, n)) }, add: function (t, e, i, s, r, o) { if (this.has(t)) return null; const a = new n(this, t, e, i, s, r, o); return this.frames[t] = a, this.firstFrame === '__BASE' && (this.firstFrame = t), this.frameTotal++, a }, remove: function (t) { return !!this.has(t) && (this.get(t).destroy(), delete this.frames[t], !0) }, has: function (t) { return this.frames.hasOwnProperty(t) }, get: function (t) { t || (t = this.firstFrame); let e = this.frames[t]; return e || (console.warn(o, this.key, t), e = this.frames[this.firstFrame]), e }, getTextureSourceIndex: function (t) { for (let e = 0; e < this.source.length; e++) if (this.source[e] === t) return e; return -1 }, getFramesFromTextureSource: function (t, e) { void 0 === e && (e = !1); const i = []; for (const s in this.frames) if (s !== '__BASE' || e) { const n = this.frames[s]; n.sourceIndex === t && i.push(n) } return i }, getFrameBounds: function (t) { void 0 === t && (t = 0); for (var e = this.getFramesFromTextureSource(t), i = 1 / 0, s = 1 / 0, n = 0, r = 0, o = 0; o < e.length; o++) { const a = e[o]; a.cutX < i && (i = a.cutX), a.cutY < s && (s = a.cutY), a.cutX + a.cutWidth > n && (n = a.cutX + a.cutWidth), a.cutY + a.cutHeight > r && (r = a.cutY + a.cutHeight) } return { x: i, y: s, width: n - i, height: r - s } }, getFrameNames: function (t) { void 0 === t && (t = !1); const e = Object.keys(this.frames); if (!t) { const i = e.indexOf('__BASE'); i !== -1 && e.splice(i, 1) } return e }, getSourceImage: function (t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; return e ? e.source.image : (console.warn(o, this.key, t), this.frames.__BASE.source.image) }, getDataSourceImage: function (t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); let e; const i = this.frames[t]; return i ? e = i.sourceIndex : (console.warn(o, this.key, t), e = this.frames.__BASE.sourceIndex), this.dataSource[e].image }, setDataSource: function (t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = this.source[e]; this.dataSource.push(new r(this, t[e], i.width, i.height)) } }, setFilter: function (t) { let e; for (e = 0; e < this.source.length; e++) this.source[e].setFilter(t); for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t) }, destroy: function () { let t; const e = this.source; const i = this.dataSource; for (t = 0; t < e.length; t++)e[t] && e[t].destroy(); for (t = 0; t < i.length; t++)i[t] && i[t].destroy(); for (const s in this.frames) { const n = this.frames[s]; n && n.destroy() } this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key), this.manager = null } }); t.exports = a }, 17130: (t, e, i) => { const s = i(27919); const n = i(57382); const r = i(83419); const o = i(40987); const a = i(8054); const h = i(81320); const l = i(50792); const u = i(69442); const c = i(4327); const d = i(8443); const f = i(99584); const p = i(35154); const v = i(88571); const g = i(41212); const m = i(61309); const y = i(87841); const x = i(79237); const T = new r({ Extends: l, initialize: function (t) { l.call(this), this.game = t, this.name = 'TextureManager', this.list = {}, this._tempCanvas = s.create2D(this), this._tempContext = this._tempCanvas.getContext('2d', { willReadFrequently: !0 }), this._pending = 0, this.stamp, this.stampCrop = new y(), this.silentWarnings = !1, t.events.once(d.BOOT, this.boot, this) }, boot: function () { this._pending = 3, this.on(u.LOAD, this.updatePending, this), this.on(u.ERROR, this.updatePending, this); const t = this.game.config; this.addBase64('__DEFAULT', t.defaultImage), this.addBase64('__MISSING', t.missingImage), this.addBase64('__WHITE', t.whiteImage), this.game.renderer && this.game.renderer.gl && this.addUint8Array('__NORMAL', new Uint8Array([127, 127, 255, 255]), 1, 1), this.game.events.once(d.DESTROY, this.destroy, this), this.game.events.once(d.SYSTEM_READY, function (t) { this.stamp = new v(t).setOrigin(0) }, this) }, updatePending: function () { this._pending--, this._pending === 0 && (this.off(u.LOAD), this.off(u.ERROR), this.emit(u.READY)) }, checkKey: function (t) { return !this.exists(t) || (this.silentWarnings || console.error('Texture key already in use: ' + t), !1) }, remove: function (t) { if (typeof t === 'string') { if (!this.exists(t)) return this.silentWarnings || console.warn('No texture found matching key: ' + t), this; t = this.get(t) } const e = t.key; return this.list.hasOwnProperty(e) && (t.destroy(), this.emit(u.REMOVE, e), this.emit(u.REMOVE_KEY + e)), this }, removeKey: function (t) { return this.list.hasOwnProperty(t) && delete this.list[t], this }, addBase64: function (t, e) { if (this.checkKey(t)) { const i = this; const s = new Image(); s.onerror = function () { i.emit(u.ERROR, t) }, s.onload = function () { const e = i.create(t, s); m.Image(e, 0), i.emit(u.ADD, t, e), i.emit(u.ADD_KEY + t, e), i.emit(u.LOAD, t, e) }, s.src = e } return this }, getBase64: function (t, e, i, n) { void 0 === i && (i = 'image/png'), void 0 === n && (n = 0.92); let r = ''; const o = this.getFrame(t, e); if (o && (o.source.isRenderTexture || o.source.isGLTexture)) this.silentWarnings || console.warn('Cannot getBase64 from WebGL Texture'); else if (o) { const a = o.canvasData; const h = s.create2D(this, a.width, a.height); const l = h.getContext('2d', { willReadFrequently: !0 }); a.width > 0 && a.height > 0 && l.drawImage(o.source.image, a.x, a.y, a.width, a.height, 0, 0, a.width, a.height), r = h.toDataURL(i, n), s.remove(h) } return r }, addImage: function (t, e, i) { let s = null; return this.checkKey(t) && (s = this.create(t, e), m.Image(s, 0), i && s.setDataSource(i), this.emit(u.ADD, t, s), this.emit(u.ADD_KEY + t, s)), s }, addGLTexture: function (t, e) { let i = null; if (this.checkKey(t)) { const s = e.width; const n = e.height; (i = this.create(t, e, s, n)).add('__BASE', 0, 0, 0, s, n), this.emit(u.ADD, t, i), this.emit(u.ADD_KEY + t, i) } return i }, addCompressedTexture: function (t, e, i) { let s = null; if (this.checkKey(t)) { if ((s = this.create(t, e)).add('__BASE', 0, 0, 0, e.width, e.height), i) { const n = function (t, e, i) { Array.isArray(i.textures) || Array.isArray(i.frames) ? m.JSONArray(t, e, i) : m.JSONHash(t, e, i) }; if (Array.isArray(i)) for (let r = 0; r < i.length; r++)n(s, r, i[r]); else n(s, 0, i) } this.emit(u.ADD, t, s), this.emit(u.ADD_KEY + t, s) } return s }, addRenderTexture: function (t, e) { let i = null; return this.checkKey(t) && ((i = this.create(t, e)).add('__BASE', 0, 0, 0, e.width, e.height), this.emit(u.ADD, t, i), this.emit(u.ADD_KEY + t, i)), i }, generate: function (t, e) { if (this.checkKey(t)) { const i = s.create(this, 1, 1); return e.canvas = i, f(e), this.addCanvas(t, i) } return null }, createCanvas: function (t, e, i) { if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) { const n = s.create(this, e, i, a.CANVAS, !0); return this.addCanvas(t, n) } return null }, addCanvas: function (t, e, i) { void 0 === i && (i = !1); let s = null; return i ? s = new n(this, t, e, e.width, e.height) : this.checkKey(t) && (s = new n(this, t, e, e.width, e.height), this.list[t] = s, this.emit(u.ADD, t, s), this.emit(u.ADD_KEY + t, s)), s }, addDynamicTexture: function (t, e, i) { let s = null; return typeof t !== 'string' || this.exists(t) ? t = (s = t).key : s = new h(this, t, e, i), this.checkKey(t) ? (this.list[t] = s, this.emit(u.ADD, t, s), this.emit(u.ADD_KEY + t, s)) : s = null, s }, addAtlas: function (t, e, i, s) { return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, s) : this.addAtlasJSONHash(t, e, i, s) }, addAtlasJSONArray: function (t, e, i, s) { let n = null; if (e instanceof x ? (t = e.key, n = e) : this.checkKey(t) && (n = this.create(t, e)), n) { if (Array.isArray(i)) for (let r = i.length === 1, o = 0; o < n.source.length; o++) { const a = r ? i[0] : i[o]; m.JSONArray(n, o, a) } else m.JSONArray(n, 0, i); s && n.setDataSource(s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n) } return n }, addAtlasJSONHash: function (t, e, i, s) { let n = null; if (e instanceof x ? (t = e.key, n = e) : this.checkKey(t) && (n = this.create(t, e)), n) { if (Array.isArray(i)) for (let r = 0; r < i.length; r++)m.JSONHash(n, r, i[r]); else m.JSONHash(n, 0, i); s && n.setDataSource(s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n) } return n }, addAtlasXML: function (t, e, i, s) { let n = null; return e instanceof x ? (t = e.key, n = e) : this.checkKey(t) && (n = this.create(t, e)), n && (m.AtlasXML(n, 0, i), s && n.setDataSource(s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n)), n }, addUnityAtlas: function (t, e, i, s) { let n = null; return e instanceof x ? (t = e.key, n = e) : this.checkKey(t) && (n = this.create(t, e)), n && (m.UnityYAML(n, 0, i), s && n.setDataSource(s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n)), n }, addSpriteSheet: function (t, e, i, s) { let n = null; if (e instanceof x ? (t = e.key, n = e) : this.checkKey(t) && (n = this.create(t, e)), n) { const r = n.source[0].width; const o = n.source[0].height; m.SpriteSheet(n, 0, 0, 0, r, o, i), s && n.setDataSource(s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n) } return n }, addSpriteSheetFromAtlas: function (t, e) { if (!this.checkKey(t)) return null; const i = p(e, 'atlas', null); const s = p(e, 'frame', null); if (i && s) { const n = this.get(i).get(s); if (n) { let r = n.source.image; r || (r = n.source.glTexture); const o = this.create(t, r); return n.trimmed ? m.SpriteSheetFromAtlas(o, n, e) : m.SpriteSheet(o, 0, n.cutX, n.cutY, n.cutWidth, n.cutHeight, e), this.emit(u.ADD, t, o), this.emit(u.ADD_KEY + t, o), o } } }, addUint8Array: function (t, e, i, s) { if (!this.checkKey(t) || e.length / 4 != i * s) return null; const n = this.create(t, e, i, s); return n.add('__BASE', 0, 0, 0, i, s), this.emit(u.ADD, t, n), this.emit(u.ADD_KEY + t, n), n }, create: function (t, e, i, s) { let n = null; return this.checkKey(t) && (n = new x(this, t, e, i, s), this.list[t] = n), n }, exists: function (t) { return this.list.hasOwnProperty(t) }, get: function (t) { return void 0 === t && (t = '__DEFAULT'), this.list[t] ? this.list[t] : t instanceof x ? t : t instanceof c ? t.texture : this.list.__MISSING }, cloneFrame: function (t, e) { if (this.list[t]) return this.list[t].get(e).clone() }, getFrame: function (t, e) { if (this.list[t]) return this.list[t].get(e) }, parseFrame: function (t) { if (t) return typeof t === 'string' ? this.getFrame(t) : Array.isArray(t) && t.length === 2 ? this.getFrame(t[0], t[1]) : g(t) ? this.getFrame(t.key, t.frame) : t instanceof x ? t.get() : t instanceof c ? t : void 0 }, getTextureKeys: function () { const t = []; for (const e in this.list) e !== '__DEFAULT' && e !== '__MISSING' && e !== '__WHITE' && e !== '__NORMAL' && t.push(e); return t }, getPixel: function (t, e, i, s) { const n = this.getFrame(i, s); if (n) { t -= n.x, e -= n.y; const r = n.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const a = this._tempContext; a.clearRect(0, 0, 1, 1), a.drawImage(n.source.image, t, e, 1, 1, 0, 0, 1, 1); const h = a.getImageData(0, 0, 1, 1); return new o(h.data[0], h.data[1], h.data[2], h.data[3]) } } return null }, getPixelAlpha: function (t, e, i, s) { const n = this.getFrame(i, s); if (n) { t -= n.x, e -= n.y; const r = n.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const o = this._tempContext; return o.clearRect(0, 0, 1, 1), o.drawImage(n.source.image, t, e, 1, 1, 0, 0, 1, 1), o.getImageData(0, 0, 1, 1).data[3] } } return null }, setTexture: function (t, e, i) { return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t }, renameTexture: function (t, e) { const i = this.get(t); return !(!i || t === e) && (i.key = e, this.list[e] = i, delete this.list[t], !0) }, each: function (t, e) { for (var i = [null], s = 1; s < arguments.length; s++)i.push(arguments[s]); for (const n in this.list) i[0] = this.list[n], t.apply(e, i) }, resetStamp: function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 16777215); const i = this.stamp; return i.setCrop(), i.setPosition(0), i.setAngle(0), i.setScale(1), i.setAlpha(t), i.setTint(e), i.setTexture('__WHITE'), i }, destroy: function () { for (const t in this.list) this.list[t].destroy(); this.list = {}, this.stamp.destroy(), this.game = null, this.stamp = null, s.remove(this._tempCanvas) } }); t.exports = T }, 11876: (t, e, i) => { const s = i(27919); const n = i(83419); const r = i(50030); const o = i(29795); const a = i(82751); const h = new n({ initialize: function (t, e, i, s, n) { void 0 === n && (n = !1); const h = t.manager.game; this.renderer = h.renderer, this.texture = t, this.source = e, this.image = e.compressed ? null : e, this.compressionAlgorithm = e.compressed ? e.format : null, this.resolution = 1, this.width = i || e.naturalWidth || e.videoWidth || e.width || 0, this.height = s || e.naturalHeight || e.videoHeight || e.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty('HTMLVideoElement') && e instanceof HTMLVideoElement, this.isRenderTexture = e.type === 'RenderTexture' || e.type === 'DynamicTexture', this.isGLTexture = e instanceof a, this.isPowerOf2 = r(this.width, this.height), this.glTexture = null, this.flipY = n, this.init(h) }, init: function (t) { const e = this.renderer; if (e) { const i = this.source; if (e.gl) { const s = this.image; const n = this.flipY; const r = this.width; const o = this.height; const a = this.scaleMode; this.isCanvas ? this.glTexture = e.createCanvasTexture(s, !1, n) : this.isVideo ? this.glTexture = e.createVideoTexture(s, !1, n) : this.isRenderTexture ? this.glTexture = e.createTextureFromSource(null, r, o, a) : this.isGLTexture ? this.glTexture = i : this.compressionAlgorithm ? this.glTexture = e.createTextureFromSource(i, void 0, void 0, a) : i instanceof Uint8Array ? this.glTexture = e.createUint8ArrayTexture(i, r, o, a) : this.glTexture = e.createTextureFromSource(s, r, o, a) } else this.isRenderTexture && (this.image = i.canvas) } t.config.antialias || this.setFilter(1) }, setFilter: function (t) { this.renderer && this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t), this.scaleMode = t }, setFlipY: function (t) { return void 0 === t && (t = !0), t === this.flipY || (this.flipY = t, this.update()), this }, update: function () { const t = this.renderer; const e = this.image; const i = this.flipY; const s = t.gl; s && this.isCanvas ? t.updateCanvasTexture(e, this.glTexture, i) : s && this.isVideo && t.updateVideoTexture(e, this.glTexture, i) }, destroy: function () { this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && s.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null } }); t.exports = h }, 19673: t => { t.exports = { LINEAR: 0, NEAREST: 1 } }, 44538: t => { t.exports = 'addtexture' }, 63486: t => { t.exports = 'addtexture-' }, 94851: t => { t.exports = 'onerror' }, 29099: t => { t.exports = 'onload' }, 8678: t => { t.exports = 'ready' }, 86415: t => { t.exports = 'removetexture' }, 30879: t => { t.exports = 'removetexture-' }, 69442: (t, e, i) => { t.exports = { ADD: i(44538), ADD_KEY: i(63486), ERROR: i(94851), LOAD: i(29099), READY: i(8678), REMOVE: i(86415), REMOVE_KEY: i(30879) } }, 27458: (t, e, i) => { const s = i(79291); const n = i(19673); let r = { CanvasTexture: i(57382), DynamicTexture: i(81320), Events: i(69442), FilterMode: n, Frame: i(4327), Parsers: i(61309), Texture: i(79237), TextureManager: i(17130), TextureSource: i(11876) }; r = s(!1, r, n), t.exports = r }, 89905: t => { t.exports = function (t, e, i) { if (i.getElementsByTagName('TextureAtlas')) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); for (var n, r = i.getElementsByTagName('SubTexture'), o = 0; o < r.length; o++) { const a = r[o].attributes; const h = a.name.value; const l = parseInt(a.x.value, 10); const u = parseInt(a.y.value, 10); const c = parseInt(a.width.value, 10); const d = parseInt(a.height.value, 10); if (n = t.add(h, e, l, u, c, d), a.frameX) { const f = Math.abs(parseInt(a.frameX.value, 10)); const p = Math.abs(parseInt(a.frameY.value, 10)); const v = parseInt(a.frameWidth.value, 10); const g = parseInt(a.frameHeight.value, 10); n.setTrim(c, d, f, p, v, g) } } return t } console.warn('Invalid Texture Atlas XML given') } }, 72893: t => { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t } }, 4832: t => { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t } }, 78566: (t, e, i) => { const s = i(41786); t.exports = function (t, e, i) { if (i.frames || i.textures) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (var r, o = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, a = 0; a < o.length; a++) { const h = o[a]; if (r = t.add(h.filename, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h)) { h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()); const l = h.anchor || h.pivot; l && (r.customPivot = !0, r.pivotX = l.x, r.pivotY = l.y), h.scale9Borders && r.setScale9(h.scale9Borders.x, h.scale9Borders.y, h.scale9Borders.w, h.scale9Borders.h), r.customData = s(h) } else console.warn('Invalid atlas json, frame already exists: ' + h.filename) } for (const u in i) u !== 'frames' && (Array.isArray(i[u]) ? t.customData[u] = i[u].slice(0) : t.customData[u] = i[u]); return t } console.warn('Invalid Texture Atlas JSON Array') } }, 39711: (t, e, i) => { const s = i(41786); t.exports = function (t, e, i) { if (i.frames) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); let r; const o = i.frames; for (const a in o) if (o.hasOwnProperty(a)) { const h = o[a]; if (r = t.add(a, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h)) { h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()); const l = h.anchor || h.pivot; l && (r.customPivot = !0, r.pivotX = l.x, r.pivotY = l.y), h.scale9Borders && r.setScale9(h.scale9Borders.x, h.scale9Borders.y, h.scale9Borders.w, h.scale9Borders.h), r.customData = s(h) } else console.warn('Invalid atlas json, frame already exists: ' + a) } for (const u in i) u !== 'frames' && (Array.isArray(i[u]) ? t.customData[u] = i[u].slice(0) : t.customData[u] = i[u]); return t } console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object") } }, 31403: t => { t.exports = function (t) { let e; const i = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]; const s = new Uint8Array(t, 0, 12); for (e = 0; e < s.length; e++) if (s[e] !== i[e]) return void console.warn('KTXParser - Invalid file format'); const n = Uint32Array.BYTES_PER_ELEMENT; const r = new DataView(t, 12, 13 * n); const o = r.getUint32(0, !0) === 67305985; if (r.getUint32(1 * n, o) === 0) { const a = r.getUint32(4 * n, o); const h = r.getUint32(6 * n, o); const l = r.getUint32(7 * n, o); const u = Math.max(1, r.getUint32(11 * n, o)); const c = r.getUint32(12 * n, o); const d = new Array(u); let f = 64 + c; let p = h; let v = l; for (e = 0; e < u; e++) { const g = new Int32Array(t, f, 1)[0]; f += 4, d[e] = { data: new Uint8Array(t, f, g), width: p, height: v }, p = Math.max(1, p >> 1), v = Math.max(1, v >> 1), f += g } return { mipmaps: d, width: h, height: l, internalFormat: a, compressed: !0, generateMipmap: !1 } } console.warn('KTXParser - Only compressed formats supported') } }, 82038: t => { function e (t, e, i, s, n, r, o) { return void 0 === o && (o = 16), Math.floor((t + i) / n) * Math.floor((e + s) / r) * o } function i (t, e) { return (t = Math.max(t, 16)) * (e = Math.max(e, 8)) / 4 } function s (t, e) { return (t = Math.max(t, 8)) * (e = Math.max(e, 8)) / 2 } function n (t, e) { return Math.ceil(t / 4) * Math.ceil(e / 4) * 16 } function r (t, i) { return e(t, i, 3, 3, 4, 4, 8) } function o (t, i) { return e(t, i, 3, 3, 4, 4) } const a = { 0: { sizeFunc: i, glFormat: [35841] }, 1: { sizeFunc: i, glFormat: [35843] }, 2: { sizeFunc: s, glFormat: [35840] }, 3: { sizeFunc: s, glFormat: [35842] }, 6: { sizeFunc: r, glFormat: [36196] }, 7: { sizeFunc: r, glFormat: [33776, 35916] }, 8: { sizeFunc: o, glFormat: [33777, 35917] }, 9: { sizeFunc: o, glFormat: [33778, 35918] }, 11: { sizeFunc: o, glFormat: [33779, 35919] }, 14: { sizeFunc: n, glFormat: [36494, 36495] }, 15: { sizeFunc: n, glFormat: [36492, 36493] }, 22: { sizeFunc: r, glFormat: [37492, 37493] }, 23: { sizeFunc: o, glFormat: [37496, 37497] }, 24: { sizeFunc: r, glFormat: [37494, 37495] }, 25: { sizeFunc: r, glFormat: [37488] }, 26: { sizeFunc: o, glFormat: [37490] }, 27: { sizeFunc: o, glFormat: [37808, 37840] }, 28: { sizeFunc: function (t, i) { return e(t, i, 4, 3, 5, 4) }, glFormat: [37809, 37841] }, 29: { sizeFunc: function (t, i) { return e(t, i, 4, 4, 5, 5) }, glFormat: [37810, 37842] }, 30: { sizeFunc: function (t, i) { return e(t, i, 5, 4, 6, 5) }, glFormat: [37811, 37843] }, 31: { sizeFunc: function (t, i) { return e(t, i, 5, 5, 6, 6) }, glFormat: [37812, 37844] }, 32: { sizeFunc: function (t, i) { return e(t, i, 7, 4, 8, 5) }, glFormat: [37813, 37845] }, 33: { sizeFunc: function (t, i) { return e(t, i, 7, 5, 8, 6) }, glFormat: [37814, 37846] }, 34: { sizeFunc: function (t, i) { return e(t, i, 7, 7, 8, 8) }, glFormat: [37815, 37847] }, 35: { sizeFunc: function (t, i) { return e(t, i, 9, 4, 10, 5) }, glFormat: [37816, 37848] }, 36: { sizeFunc: function (t, i) { return e(t, i, 9, 5, 10, 6) }, glFormat: [37817, 37849] }, 37: { sizeFunc: function (t, i) { return e(t, i, 9, 7, 10, 8) }, glFormat: [37818, 37850] }, 38: { sizeFunc: function (t, i) { return e(t, i, 9, 9, 10, 10) }, glFormat: [37819, 37851] }, 39: { sizeFunc: function (t, i) { return e(t, i, 11, 9, 12, 10) }, glFormat: [37820, 37852] }, 40: { sizeFunc: function (t, i) { return e(t, i, 11, 11, 12, 12) }, glFormat: [37821, 37853] } }; t.exports = function (t) { for (var e = new Uint32Array(t, 0, 13), i = e[0] === 55727696 ? e[2] : e[3], s = e[4], n = a[i].glFormat[s], r = a[i].sizeFunc, o = e[11], h = e[7], l = e[6], u = 52 + e[12], c = new Uint8Array(t, u), d = new Array(o), f = 0, p = h, v = l, g = 0; g < o; g++) { const m = r(p, v); d[g] = { data: new Uint8Array(c.buffer, c.byteOffset + f, m), width: p, height: v }, p = Math.max(1, p >> 1), v = Math.max(1, v >> 1), f += m } return { mipmaps: d, width: h, height: l, internalFormat: n, compressed: !0, generateMipmap: !1 } } }, 75549: (t, e, i) => { const s = i(95540); t.exports = function (t, e, i, n, r, o, a) { const h = s(a, 'frameWidth', null); const l = s(a, 'frameHeight', h); if (h === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const u = t.source[e]; t.add('__BASE', e, 0, 0, u.width, u.height); let c = s(a, 'startFrame', 0); let d = s(a, 'endFrame', -1); const f = s(a, 'margin', 0); const p = s(a, 'spacing', 0); const v = Math.floor((r - f + p) / (h + p)) * Math.floor((o - f + p) / (l + p)); v === 0 && console.warn('SpriteSheet frame dimensions will result in zero frames for texture:', t.key), (c > v || c < -v) && (c = 0), c < 0 && (c = v + c), (d === -1 || d > v || d < c) && (d = v); for (let g = f, m = f, y = 0, x = 0, T = 0, w = 0; w < v; w++) { y = 0, x = 0; const b = g + h; const S = m + l; b > r && (y = b - r), S > o && (x = S - o), w >= c && w <= d && (t.add(T, e, i + g, n + m, h - y, l - x), T++), (g += h + p) + h > r && (g = f, m += l + p) } return t } }, 47534: (t, e, i) => { const s = i(95540); t.exports = function (t, e, i) { const n = s(i, 'frameWidth', null); const r = s(i, 'frameHeight', n); if (!n) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); const o = t.source[0]; t.add('__BASE', 0, 0, 0, o.width, o.height); let a; let h = s(i, 'startFrame', 0); const l = s(i, 'endFrame', -1); const u = s(i, 'margin', 0); const c = s(i, 'spacing', 0); const d = e.cutX; const f = e.cutY; const p = e.cutWidth; const v = e.cutHeight; const g = e.realWidth; const m = e.realHeight; const y = Math.floor((g - u + c) / (n + c)); const x = Math.floor((m - u + c) / (r + c)); let T = y * x; const w = e.x; const b = n - w; const S = n - (g - p - w); const E = e.y; const A = r - E; const C = r - (m - v - E); (h > T || h < -T) && (h = 0), h < 0 && (h = T + h), l !== -1 && (T = h + (l + 1)); for (let _ = u, M = u, P = 0, R = 0; R < x; R++) { for (var L = R === 0, O = R === x - 1, F = 0; F < y; F++) { const D = F === 0; const k = F === y - 1; if (a = t.add(P, 0, d + _, f + M, n, r), D || L || k || O) { const I = D ? w : 0; const B = L ? E : 0; let N = 0; let U = 0; D && (N += n - b), k && (N += n - S), L && (U += r - A), O && (U += r - C); const X = n - N; const Y = r - U; a.cutWidth = X, a.cutHeight = Y, a.setTrim(n, r, I, B, X, Y) } _ += c, _ += D ? b : k ? S : n, P++ } _ = u, M += c, M += L ? A : O ? C : r } return t } }, 86147: t => { let e = 0; const i = function (t, i, s, n) { const r = e - n.y - n.height; t.add(s, i, n.x, r, n.width, n.height) }; t.exports = function (t, s, n) { const r = t.source[s]; t.add('__BASE', s, 0, 0, r.width, r.height), e = r.height; for (var o = n.split('\n'), a = /^[ ]*(- )*(\w+)+[: ]+(.*)/, h = '', l = '', u = { x: 0, y: 0, width: 0, height: 0 }, c = 0; c < o.length; c++) { const d = o[c].match(a); if (d) { const f = d[1] === '- '; const p = d[2]; const v = d[3]; if (f && (l !== h && (i(t, s, l, u), h = l), u = { x: 0, y: 0, width: 0, height: 0 }), p !== 'name') switch (p) { case 'x': case 'y': case 'width': case 'height': u[p] = parseInt(v, 10) } else l = v } } return l !== h && i(t, s, l, u), t } }, 55222: (t, e, i) => { const s = i(50030); function n (t) { for (let e = t.mipmaps, i = 0; i < e.length; i++) { const s = e[i].width; const n = e[i].height; if ((s << i) % 4 != 0 || (n << i) % 4 != 0) return console.warn('BPTC, RGTC, and S3TC dimensions must be a multiple of 4 pixels, and each successive mip level must be half the size of the previous level, rounded down. Mip level ' + i + ' is ' + s + 'x' + n), !1 } return !0 } function r () { return !0 } function o (t) { const e = t.mipmaps[0]; return !!s(e.width, e.height) || (console.warn('PVRTC base dimensions must be power of two. Base level is ' + e.width + 'x' + e.height), !1) } function a (t) { const e = t.mipmaps[0]; return e.width % 4 == 0 && e.height % 4 == 0 || (console.warn('S3TC SRGB base dimensions must be a multiple of 4 pixels. Base level is ' + e.width + 'x' + e.height + ' pixels'), !1) } const h = { 37488: r, 37489: r, 37490: r, 37491: r, 37492: r, 37493: r, 37494: r, 37495: r, 37496: r, 37497: r, 36196: r, 37808: r, 37809: r, 37810: r, 37811: r, 37812: r, 37813: r, 37814: r, 37815: r, 37816: r, 37817: r, 37818: r, 37819: r, 37820: r, 37821: r, 37840: r, 37841: r, 37842: r, 37843: r, 37844: r, 37845: r, 37846: r, 37847: r, 37848: r, 37849: r, 37850: r, 37851: r, 37852: r, 37853: r, 36492: n, 36493: n, 36494: n, 36495: n, 36283: n, 36284: n, 36285: n, 36286: n, 35840: o, 35841: o, 35842: o, 35843: o, 33776: n, 33777: n, 33778: n, 33779: n, 35916: a, 35917: a, 35918: a, 35919: a }; t.exports = function (t) { for (let e = t.mipmaps, i = 1; i < e.length; i++) { const n = e[i].width; const r = e[i].height; if (!s(n, r)) return console.warn('Mip level ' + i + ' is not a power-of-two size: ' + n + 'x' + r), !1 } const o = h[t.internalFormat]; return o ? o(t) : (console.warn('No format checker found for internal format ' + t.internalFormat + '. Assuming valid.'), !0) } }, 61309: (t, e, i) => { t.exports = { AtlasXML: i(89905), Canvas: i(72893), Image: i(4832), JSONArray: i(78566), JSONHash: i(39711), KTXParser: i(31403), PVRParser: i(82038), SpriteSheet: i(75549), SpriteSheetFromAtlas: i(47534), UnityYAML: i(86147) } }, 80341: t => { t.exports = { CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3 } }, 16536: (t, e, i) => { const s = new (i(83419))({ initialize: function (t, e, i, s, n, r, o) { (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | n, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0 }, containsImageIndex: function (t) { return t >= this.firstgid && t < this.firstgid + this.total }, addImage: function (t, e) { return this.images.push({ gid: t, image: e }), this.total++, this } }); t.exports = s }, 27462: (t, e, i) => { const s = new (i(83419))({ initialize: function (t) { if (this.gids = [], void 0 !== t) for (let e = 0; e < t.length; ++e) for (let i = t[e], s = 0; s < i.total; ++s) this.gids[i.firstgid + s] = i; this._gids = this.gids }, enabled: { get: function () { return !!this.gids }, set: function (t) { this.gids = t ? this._gids : void 0 } }, getTypeIncludingTile: function (t) { if (void 0 !== t.type && t.type !== '') return t.type; if (this.gids && void 0 !== t.gid) { const e = this.gids[t.gid]; if (e) { const i = e.getTileData(t.gid); if (i) return i.type } } }, setTextureAndFrame: function (t, e, i, s) { if (e === null && this.gids && void 0 !== s.gid) { const n = this.gids[s.gid]; n && (e === null && void 0 !== n.image && (e = n.image.key), i === null && (i = s.gid - n.firstgid), t.scene.textures.getFrame(e, i) || (e = null, i = null)) } t.setTexture(e, i) }, setPropertiesFromTiledObject: function (t, e) { if (void 0 !== this.gids && void 0 !== e.gid) { const i = this.gids[e.gid]; void 0 !== i && this.setFromJSON(t, i.getTileProperties(e.gid)) } this.setFromJSON(t, e.properties) }, setFromJSON: function (t, e) { if (e) if (Array.isArray(e)) for (let i = 0; i < e.length; i++) { const s = e[i]; void 0 !== t[s.name] ? t[s.name] = s.value : t.setData(s.name, s.value) } else for (const n in e) void 0 !== t[n] ? t[n] = e[n] : t.setData(n, e[n]) } }); t.exports = s }, 31989: (t, e, i) => { const s = i(80341); const n = i(87010); const r = i(46177); const o = i(49075); t.exports = function (t, e, i, a, h, l, u, c) { void 0 === i && (i = 32), void 0 === a && (a = 32), void 0 === h && (h = 10), void 0 === l && (l = 10), void 0 === c && (c = !1); let d = null; if (Array.isArray(u)) d = r(void 0 !== e ? e : 'map', s.ARRAY_2D, u, i, a, c); else if (void 0 !== e) { const f = t.cache.tilemap.get(e); f ? d = r(e, f.format, f.data, i, a, c) : console.warn('No map data found for key ' + e) } return d === null && (d = new n({ tileWidth: i, tileHeight: a, width: h, height: l })), new o(t, d) } }, 23029: (t, e, i) => { const s = i(83419); const n = i(31401); const r = i(91907); const o = i(62644); const a = i(93232); const h = new s({ Mixins: [n.AlphaSingle, n.Flip, n.Visible], initialize: function (t, e, i, s, n, r, o, a) { this.layer = t, this.index = e, this.x = i, this.y = s, this.width = n, this.height = r, this.right, this.bottom, this.baseWidth = void 0 !== o ? o : n, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = void 0, this.collisionCallbackContext = this, this.tint = 16777215, this.tintFill = !1, this.physics = {} }, containsPoint: function (t, e) { return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom) }, copy: function (t) { return this.index = t.index, this.alpha = t.alpha, this.properties = o(t.properties), this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this }, getCollisionGroup: function () { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null }, getTileData: function () { return this.tileset ? this.tileset.getTileData(this.index) : null }, getLeft: function (t) { const e = this.tilemapLayer; return e ? e.tileToWorldXY(this.x, this.y, void 0, t).x : this.x * this.baseWidth }, getRight: function (t) { const e = this.tilemapLayer; return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width }, getTop: function (t) { const e = this.tilemapLayer; return e ? e.tileToWorldXY(this.x, this.y, void 0, t).y : this.y * this.baseWidth - (this.height - this.baseHeight) }, getBottom: function (t) { const e = this.tilemapLayer; return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height }, getBounds: function (t, e) { return void 0 === e && (e = new a()), e.x = this.getLeft(t), e.y = this.getTop(t), e.width = this.getRight(t) - e.x, e.height = this.getBottom(t) - e.y, e }, getCenterX: function (t) { return (this.getLeft(t) + this.getRight(t)) / 2 }, getCenterY: function (t) { return (this.getTop(t) + this.getBottom(t)) / 2 }, intersects: function (t, e, i, s) { return !(i <= this.pixelX || s <= this.pixelY || t >= this.right || e >= this.bottom) }, isInteresting: function (t, e) { return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace }, resetCollision: function (t) { (void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this }, resetFaces: function () { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this }, setCollision: function (t, e, i, s, n) { (void 0 === e && (e = t), void 0 === i && (i = t), void 0 === s && (s = t), void 0 === n && (n = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s, n) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this }, setCollisionCallback: function (t, e) { return t === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this }, setSize: function (t, e, i, s) { return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== s && (this.baseHeight = s), this.updatePixelXY(), this }, updatePixelXY: function () { const t = this.layer.orientation; if (t === r.ORTHOGONAL) this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight; else if (t === r.ISOMETRIC) this.pixelX = (this.x - this.y) * this.baseWidth * 0.5, this.pixelY = (this.x + this.y) * this.baseHeight * 0.5; else if (t === r.STAGGERED) this.pixelX = this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * (this.baseHeight / 2); else if (t === r.HEXAGONAL) { let e; let i; const s = this.layer.staggerAxis; const n = this.layer.staggerIndex; const o = this.layer.hexSideLength; s === 'y' ? (i = (this.baseHeight - o) / 2 + o, this.pixelX = n === 'odd' ? this.x * this.baseWidth + this.y % 2 * (this.baseWidth / 2) : this.x * this.baseWidth - this.y % 2 * (this.baseWidth / 2), this.pixelY = this.y * i) : s === 'x' && (e = (this.baseWidth - o) / 2 + o, this.pixelX = this.x * e, this.pixelY = n === 'odd' ? this.y * this.baseHeight + this.x % 2 * (this.baseHeight / 2) : this.y * this.baseHeight - this.x % 2 * (this.baseHeight / 2)) } return this.right = this.pixelX + this.baseWidth, this.bottom = this.pixelY + this.baseHeight, this }, destroy: function () { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0 }, canCollide: { get: function () { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || void 0 !== this.collisionCallback } }, collides: { get: function () { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown } }, hasInterestingFace: { get: function () { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight } }, tileset: { get: function () { const t = this.layer.tilemapLayer; if (t) { const e = t.gidMap[this.index]; if (e) return e } return null } }, tilemapLayer: { get: function () { return this.layer.tilemapLayer } }, tilemap: { get: function () { const t = this.tilemapLayer; return t ? t.tilemap : null } } }); t.exports = h }, 49075: (t, e, i) => { const s = i(84101); const n = i(83419); const r = i(39506); const o = i(80341); const a = i(95540); const h = i(14977); const l = i(27462); const u = i(91907); const c = i(36305); const d = i(19133); const f = i(68287); const p = i(23029); const v = i(81086); const g = i(20442); const m = i(33629); const y = new n({ initialize: function (t, e) { this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.renderOrder = e.renderOrder, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tiles = e.tiles, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0, this.hexSideLength = e.hexSideLength; const i = this.orientation; this._convert = { WorldToTileXY: v.GetWorldToTileXYFunction(i), WorldToTileX: v.GetWorldToTileXFunction(i), WorldToTileY: v.GetWorldToTileYFunction(i), TileToWorldXY: v.GetTileToWorldXYFunction(i), TileToWorldX: v.GetTileToWorldXFunction(i), TileToWorldY: v.GetTileToWorldYFunction(i), GetTileCorners: v.GetTileCornersFunction(i) } }, setRenderOrder: function (t) { const e = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof t === 'number' && (t = e[t]), e.indexOf(t) > -1 && (this.renderOrder = t), this }, addTilesetImage: function (t, e, i, n, r, a, h, l) { if (void 0 === t) return null; e == null && (e = t); const u = this.scene.sys.textures; if (!u.exists(e)) return console.warn('Texture key "%s" not found', e), null; const c = u.get(e); const d = this.getTilesetIndex(t); if (d === null && this.format === o.TILED_JSON) return console.warn('Tilemap has no tileset "%s". Its tilesets are %o', t, this.tilesets), null; let f = this.tilesets[d]; return f ? (f.setTileSize(i, n), f.setSpacing(r, a), f.setImage(c), f) : (void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = { x: 0, y: 0 }), (f = new m(t, h, i, n, r, a, void 0, void 0, l)).setImage(c), this.tilesets.push(f), this.tiles = s(this), f) }, copy: function (t, e, i, s, n, r, o, a) { return (a = this.getLayer(a)) !== null ? (v.Copy(t, e, i, s, n, r, o, a), this) : null }, createBlankLayer: function (t, e, i, s, n, r, o, a) { if (void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === r && (r = this.height), void 0 === o && (o = this.tileWidth), void 0 === a && (a = this.tileHeight), this.getLayerIndex(t) !== null) return console.warn('Invalid Tilemap Layer ID: ' + t), null; for (var l, u = new h({ name: t, tileWidth: o, tileHeight: a, width: n, height: r, orientation: this.orientation }), c = 0; c < r; c++) { l = []; for (let d = 0; d < n; d++)l.push(new p(u, -1, d, c, o, a, this.tileWidth, this.tileHeight)); u.data.push(l) } this.layers.push(u), this.currentLayerIndex = this.layers.length - 1; const f = new g(this.scene, this, this.currentLayerIndex, e, i, s); return f.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(f), f }, createLayer: function (t, e, i, s) { const n = this.getLayerIndex(t); if (n === null) return console.warn('Invalid Tilemap Layer ID: ' + t), typeof t === 'string' && console.warn('Valid tilelayer names: %o', this.getTileLayerNames()), null; const r = this.layers[n]; if (r.tilemapLayer) return console.warn('Tilemap Layer ID already exists:' + t), null; this.currentLayerIndex = n, void 0 === i && (i = r.x), void 0 === s && (s = r.y); const o = new g(this.scene, this, n, e, i, s); return o.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(o), o }, createFromObjects: function (t, e, i) { void 0 === i && (i = !0); const s = []; const n = this.getObjectLayer(t); if (!n) return console.warn('createFromObjects: Invalid objectLayerName given: ' + t), s; const o = new l(i ? this.tilesets : void 0); Array.isArray(e) || (e = [e]); for (let h = n.objects, d = 0; d < e.length; d++) { var p; const v = e[d]; const g = a(v, 'id', null); const m = a(v, 'gid', null); const y = a(v, 'name', null); const x = a(v, 'type', null); o.enabled = !a(v, 'ignoreTileset', null); for (var T = [], w = 0; w < h.length; w++)p = h[w], (g === null && m === null && y === null && x === null || g !== null && p.id === g || m !== null && p.gid === m || y !== null && p.name === y || x !== null && o.getTypeIncludingTile(p) === x) && T.push(p); for (let b = a(v, 'classType', f), S = a(v, 'scene', this.scene), E = a(v, 'container', null), A = a(v, 'key', null), C = a(v, 'frame', null), _ = 0; _ < T.length; _++) { p = T[_]; const M = new b(S); if (M.setName(p.name), M.setPosition(p.x, p.y), o.setTextureAndFrame(M, A, C, p), p.width && (M.displayWidth = p.width), p.height && (M.displayHeight = p.height), this.orientation === u.ISOMETRIC) { const P = this.tileWidth / this.tileHeight; const R = { x: M.x - M.y, y: (M.x + M.y) / P }; M.x = R.x, M.y = R.y } const L = { x: M.originX * p.width, y: (M.originY - (p.gid ? 1 : 0)) * p.height }; if (p.rotation) { const O = r(p.rotation); c(L, O), M.rotation = O } M.x += L.x, M.y += L.y, void 0 === p.flippedHorizontal && void 0 === p.flippedVertical || M.setFlip(p.flippedHorizontal, p.flippedVertical), p.visible || (M.visible = !1), o.setPropertiesFromTiledObject(M, p), E ? E.add(M) : S.add.existing(M), s.push(M) } } return s }, createFromTiles: function (t, e, i, s, n, r) { return (r = this.getLayer(r)) === null ? null : v.CreateFromTiles(t, e, i, s, n, r) }, fill: function (t, e, i, s, n, r, o) { return void 0 === r && (r = !0), (o = this.getLayer(o)) === null ? null : (v.Fill(t, e, i, s, n, r, o), this) }, filterObjects: function (t, e, i) { if (typeof t === 'string') { const s = t; if (!(t = this.getObjectLayer(t))) return console.warn('No object layer found with the name: ' + s), null } return t.objects.filter(e, i) }, filterTiles: function (t, e, i, s, n, r, o, a) { return (a = this.getLayer(a)) === null ? null : v.FilterTiles(t, e, i, s, n, r, o, a) }, findByIndex: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : v.FindByIndex(t, e, i, s) }, findObject: function (t, e, i) { if (typeof t === 'string') { const s = t; if (!(t = this.getObjectLayer(t))) return console.warn('No object layer found with the name: ' + s), null } return t.objects.find(e, i) || null }, findTile: function (t, e, i, s, n, r, o, a) { return (a = this.getLayer(a)) === null ? null : v.FindTile(t, e, i, s, n, r, o, a) }, forEachTile: function (t, e, i, s, n, r, o, a) { return (a = this.getLayer(a)) === null ? null : (v.ForEachTile(t, e, i, s, n, r, o, a), this) }, getImageIndex: function (t) { return this.getIndex(this.images, t) }, getImageLayerNames: function () { return this.images && Array.isArray(this.images) ? this.images.map(function (t) { return t.name }) : [] }, getIndex: function (t, e) { for (let i = 0; i < t.length; i++) if (t[i].name === e) return i; return null }, getLayer: function (t) { const e = this.getLayerIndex(t); return e !== null ? this.layers[e] : null }, getObjectLayer: function (t) { const e = this.getIndex(this.objects, t); return e !== null ? this.objects[e] : null }, getObjectLayerNames: function () { return this.objects && Array.isArray(this.objects) ? this.objects.map(function (t) { return t.name }) : [] }, getLayerIndex: function (t) { return void 0 === t ? this.currentLayerIndex : typeof t === 'string' ? this.getLayerIndexByName(t) : typeof t === 'number' && t < this.layers.length ? t : t instanceof g && t.tilemap === this ? t.layerIndex : null }, getLayerIndexByName: function (t) { return this.getIndex(this.layers, t) }, getTileAt: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : v.GetTileAt(t, e, i, s) }, getTileAtWorldXY: function (t, e, i, s, n) { return (n = this.getLayer(n)) === null ? null : v.GetTileAtWorldXY(t, e, i, s, n) }, getTileLayerNames: function () { return this.layers && Array.isArray(this.layers) ? this.layers.map(function (t) { return t.name }) : [] }, getTilesWithin: function (t, e, i, s, n, r) { return (r = this.getLayer(r)) === null ? null : v.GetTilesWithin(t, e, i, s, n, r) }, getTilesWithinShape: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : v.GetTilesWithinShape(t, e, i, s) }, getTilesWithinWorldXY: function (t, e, i, s, n, r, o) { return (o = this.getLayer(o)) === null ? null : v.GetTilesWithinWorldXY(t, e, i, s, n, r, o) }, getTileset: function (t) { const e = this.getIndex(this.tilesets, t); return e !== null ? this.tilesets[e] : null }, getTilesetIndex: function (t) { return this.getIndex(this.tilesets, t) }, hasTileAt: function (t, e, i) { return (i = this.getLayer(i)) === null ? null : v.HasTileAt(t, e, i) }, hasTileAtWorldXY: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : v.HasTileAtWorldXY(t, e, i, s) }, layer: { get: function () { return this.layers[this.currentLayerIndex] }, set: function (t) { this.setLayer(t) } }, putTileAt: function (t, e, i, s, n) { return void 0 === s && (s = !0), (n = this.getLayer(n)) === null ? null : v.PutTileAt(t, e, i, s, n) }, putTileAtWorldXY: function (t, e, i, s, n, r) { return void 0 === s && (s = !0), (r = this.getLayer(r)) === null ? null : v.PutTileAtWorldXY(t, e, i, s, n, r) }, putTilesAt: function (t, e, i, s, n) { return void 0 === s && (s = !0), (n = this.getLayer(n)) === null ? null : (v.PutTilesAt(t, e, i, s, n), this) }, randomize: function (t, e, i, s, n, r) { return (r = this.getLayer(r)) === null ? null : (v.Randomize(t, e, i, s, n, r), this) }, calculateFacesAt: function (t, e, i) { return (i = this.getLayer(i)) === null ? null : (v.CalculateFacesAt(t, e, i), this) }, calculateFacesWithin: function (t, e, i, s, n) { return (n = this.getLayer(n)) === null ? null : (v.CalculateFacesWithin(t, e, i, s, n), this) }, removeLayer: function (t) { const e = this.getLayerIndex(t); if (e !== null) { d(this.layers, e); for (let i = e; i < this.layers.length; i++) this.layers[i].tilemapLayer && this.layers[i].tilemapLayer.layerIndex--; return this.currentLayerIndex === e && (this.currentLayerIndex = 0), this } return null }, destroyLayer: function (t) { const e = this.getLayerIndex(t); return e !== null ? ((t = this.layers[e]).tilemapLayer.destroy(), d(this.layers, e), this.currentLayerIndex === e && (this.currentLayerIndex = 0), this) : null }, removeAllLayers: function () { for (var t = this.layers, e = 0; e < t.length; e++)t[e].tilemapLayer && t[e].tilemapLayer.destroy(!1); return t.length = 0, this.currentLayerIndex = 0, this }, removeTile: function (t, e, i) { void 0 === e && (e = -1), void 0 === i && (i = !0); const s = []; Array.isArray(t) || (t = [t]); for (let n = 0; n < t.length; n++) { const r = t[n]; s.push(this.removeTileAt(r.x, r.y, !0, i, r.tilemapLayer)), e > -1 && this.putTileAt(e, r.x, r.y, i, r.tilemapLayer) } return s }, removeTileAt: function (t, e, i, s, n) { return void 0 === i && (i = !0), void 0 === s && (s = !0), (n = this.getLayer(n)) === null ? null : v.RemoveTileAt(t, e, i, s, n) }, removeTileAtWorldXY: function (t, e, i, s, n, r) { return void 0 === i && (i = !0), void 0 === s && (s = !0), (r = this.getLayer(r)) === null ? null : v.RemoveTileAtWorldXY(t, e, i, s, n, r) }, renderDebug: function (t, e, i) { return (i = this.getLayer(i)) === null ? null : (this.orientation === u.ORTHOGONAL && v.RenderDebug(t, e, i), this) }, renderDebugFull: function (t, e) { for (let i = this.layers, s = 0; s < i.length; s++)v.RenderDebug(t, e, i[s]); return this }, replaceByIndex: function (t, e, i, s, n, r, o) { return (o = this.getLayer(o)) === null ? null : (v.ReplaceByIndex(t, e, i, s, n, r, o), this) }, setCollision: function (t, e, i, s, n) { return void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), (s = this.getLayer(s)) === null ? null : (v.SetCollision(t, e, i, s, n), this) }, setCollisionBetween: function (t, e, i, s, n) { return void 0 === i && (i = !0), void 0 === s && (s = !0), (n = this.getLayer(n)) === null ? null : (v.SetCollisionBetween(t, e, i, s, n), this) }, setCollisionByProperty: function (t, e, i, s) { return void 0 === e && (e = !0), void 0 === i && (i = !0), (s = this.getLayer(s)) === null ? null : (v.SetCollisionByProperty(t, e, i, s), this) }, setCollisionByExclusion: function (t, e, i, s) { return void 0 === e && (e = !0), void 0 === i && (i = !0), (s = this.getLayer(s)) === null ? null : (v.SetCollisionByExclusion(t, e, i, s), this) }, setCollisionFromCollisionGroup: function (t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), (i = this.getLayer(i)) === null ? null : (v.SetCollisionFromCollisionGroup(t, e, i), this) }, setTileIndexCallback: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : (v.SetTileIndexCallback(t, e, i, s), this) }, setTileLocationCallback: function (t, e, i, s, n, r, o) { return (o = this.getLayer(o)) === null ? null : (v.SetTileLocationCallback(t, e, i, s, n, r, o), this) }, setLayer: function (t) { const e = this.getLayerIndex(t); return e !== null && (this.currentLayerIndex = e), this }, setBaseTileSize: function (t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e; for (let i = 0; i < this.layers.length; i++) { this.layers[i].baseTileWidth = t, this.layers[i].baseTileHeight = e; for (let s = this.layers[i].data, n = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; o++) for (let a = 0; a < n; a++) { const h = s[o][a]; h !== null && h.setSize(void 0, void 0, t, e) } } return this }, setLayerTileSize: function (t, e, i) { if ((i = this.getLayer(i)) === null) return this; i.tileWidth = t, i.tileHeight = e; for (let s = i.data, n = i.width, r = i.height, o = 0; o < r; o++) for (let a = 0; a < n; a++) { const h = s[o][a]; h !== null && h.setSize(t, e) } return this }, shuffle: function (t, e, i, s, n) { return (n = this.getLayer(n)) === null ? null : (v.Shuffle(t, e, i, s, n), this) }, swapByIndex: function (t, e, i, s, n, r, o) { return (o = this.getLayer(o)) === null ? null : (v.SwapByIndex(t, e, i, s, n, r, o), this) }, tileToWorldX: function (t, e, i) { return (i = this.getLayer(i)) === null ? null : this._convert.TileToWorldX(t, e, i) }, tileToWorldY: function (t, e, i) { return (i = this.getLayer(i)) === null ? null : this._convert.TileToWorldY(t, e, i) }, tileToWorldXY: function (t, e, i, s, n) { return (n = this.getLayer(n)) === null ? null : this._convert.TileToWorldXY(t, e, i, s, n) }, getTileCorners: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : this._convert.GetTileCorners(t, e, i, s) }, weightedRandomize: function (t, e, i, s, n, r) { return (r = this.getLayer(r)) === null ? null : (v.WeightedRandomize(e, i, s, n, t, r), this) }, worldToTileX: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : this._convert.WorldToTileX(t, e, i, s) }, worldToTileY: function (t, e, i, s) { return (s = this.getLayer(s)) === null ? null : this._convert.WorldToTileY(t, e, i, s) }, worldToTileXY: function (t, e, i, s, n, r) { return (r = this.getLayer(r)) === null ? null : this._convert.WorldToTileXY(t, e, i, s, n, r) }, destroy: function () { this.removeAllLayers(), this.tiles.length = 0, this.tilesets.length = 0, this.objects.length = 0, this.scene = null } }); t.exports = y }, 45939: (t, e, i) => { const s = i(44603); const n = i(31989); s.register('tilemap', function (t) { const e = void 0 !== t ? t : {}; return n(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull) }) }, 46029: (t, e, i) => { const s = i(39429); const n = i(31989); s.register('tilemap', function (t, e, i, s, r, o, a) { return t === null && (t = void 0), e === null && (e = void 0), i === null && (i = void 0), s === null && (s = void 0), r === null && (r = void 0), n(this.scene, t, e, i, s, r, o, a) }) }, 20442: (t, e, i) => { const s = i(83419); const n = i(78389); const r = i(31401); const o = i(95643); const a = i(81086); const h = i(19218); const l = i(26099); const u = new s({ Extends: o, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.PostPipeline, r.Transform, r.Visible, r.ScrollFactor, n, h], initialize: function (t, e, i, s, n, r) { o.call(this, t, 'TilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = [], this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.culledTiles = [], this.skipCull = !1, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = a.GetCullTilesFunction(this.layer.orientation), this._renderOrder = 0, this.gidMap = [], this.tempVec = new l(), this.collisionCategory = 1, this.collisionMask = 1, this.setTilesets(s), this.setAlpha(this.layer.alpha), this.setPosition(n, r), this.setOrigin(0, 0), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.initPipeline(), this.initPostPipeline(!1) }, setTilesets: function (t) { const e = []; const i = []; const s = this.tilemap; Array.isArray(t) || (t = [t]); for (let n = 0; n < t.length; n++) { let r = t[n]; if (typeof r === 'string' && (r = s.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r } } this.gidMap = e, this.tileset = i }, setRenderOrder: function (t) { return typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4 && (this._renderOrder = t), this }, calculateFacesAt: function (t, e) { return a.CalculateFacesAt(t, e, this.layer), this }, calculateFacesWithin: function (t, e, i, s) { return a.CalculateFacesWithin(t, e, i, s, this.layer), this }, createFromTiles: function (t, e, i, s, n) { return a.CreateFromTiles(t, e, i, s, n, this.layer) }, cull: function (t) { return this.cullCallback(this.layer, t, this.culledTiles, this._renderOrder) }, copy: function (t, e, i, s, n, r, o) { return a.Copy(t, e, i, s, n, r, o, this.layer), this }, fill: function (t, e, i, s, n, r) { return a.Fill(t, e, i, s, n, r, this.layer), this }, filterTiles: function (t, e, i, s, n, r, o) { return a.FilterTiles(t, e, i, s, n, r, o, this.layer) }, findByIndex: function (t, e, i) { return a.FindByIndex(t, e, i, this.layer) }, findTile: function (t, e, i, s, n, r, o) { return a.FindTile(t, e, i, s, n, r, o, this.layer) }, forEachTile: function (t, e, i, s, n, r, o) { return a.ForEachTile(t, e, i, s, n, r, o, this.layer), this }, setTint: function (t, e, i, s, n, r) { void 0 === t && (t = 16777215); return this.forEachTile(function (e) { e.tint = t, e.tintFill = !1 }, this, e, i, s, n, r) }, setTintFill: function (t, e, i, s, n, r) { void 0 === t && (t = 16777215); return this.forEachTile(function (e) { e.tint = t, e.tintFill = !0 }, this, e, i, s, n, r) }, getTileAt: function (t, e, i) { return a.GetTileAt(t, e, i, this.layer) }, getTileAtWorldXY: function (t, e, i, s) { return a.GetTileAtWorldXY(t, e, i, s, this.layer) }, getIsoTileAtWorldXY: function (t, e, i, s, n) { void 0 === i && (i = !0); const r = this.tempVec; return a.IsometricWorldToTileXY(t, e, !0, r, n, this.layer, i), this.getTileAt(r.x, r.y, s) }, getTilesWithin: function (t, e, i, s, n) { return a.GetTilesWithin(t, e, i, s, n, this.layer) }, getTilesWithinShape: function (t, e, i) { return a.GetTilesWithinShape(t, e, i, this.layer) }, getTilesWithinWorldXY: function (t, e, i, s, n, r) { return a.GetTilesWithinWorldXY(t, e, i, s, n, r, this.layer) }, hasTileAt: function (t, e) { return a.HasTileAt(t, e, this.layer) }, hasTileAtWorldXY: function (t, e, i) { return a.HasTileAtWorldXY(t, e, i, this.layer) }, putTileAt: function (t, e, i, s) { return a.PutTileAt(t, e, i, s, this.layer) }, putTileAtWorldXY: function (t, e, i, s, n) { return a.PutTileAtWorldXY(t, e, i, s, n, this.layer) }, putTilesAt: function (t, e, i, s) { return a.PutTilesAt(t, e, i, s, this.layer), this }, randomize: function (t, e, i, s, n) { return a.Randomize(t, e, i, s, n, this.layer), this }, removeTileAt: function (t, e, i, s) { return a.RemoveTileAt(t, e, i, s, this.layer) }, removeTileAtWorldXY: function (t, e, i, s, n) { return a.RemoveTileAtWorldXY(t, e, i, s, n, this.layer) }, renderDebug: function (t, e) { return a.RenderDebug(t, e, this.layer), this }, replaceByIndex: function (t, e, i, s, n, r) { return a.ReplaceByIndex(t, e, i, s, n, r, this.layer), this }, setSkipCull: function (t) { return void 0 === t && (t = !0), this.skipCull = t, this }, setCullPadding: function (t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this }, setCollision: function (t, e, i, s) { return a.SetCollision(t, e, i, this.layer, s), this }, setCollisionBetween: function (t, e, i, s) { return a.SetCollisionBetween(t, e, i, s, this.layer), this }, setCollisionByProperty: function (t, e, i) { return a.SetCollisionByProperty(t, e, i, this.layer), this }, setCollisionByExclusion: function (t, e, i) { return a.SetCollisionByExclusion(t, e, i, this.layer), this }, setCollisionFromCollisionGroup: function (t, e) { return a.SetCollisionFromCollisionGroup(t, e, this.layer), this }, setTileIndexCallback: function (t, e, i) { return a.SetTileIndexCallback(t, e, i, this.layer), this }, setTileLocationCallback: function (t, e, i, s, n, r) { return a.SetTileLocationCallback(t, e, i, s, n, r, this.layer), this }, shuffle: function (t, e, i, s) { return a.Shuffle(t, e, i, s, this.layer), this }, swapByIndex: function (t, e, i, s, n, r) { return a.SwapByIndex(t, e, i, s, n, r, this.layer), this }, tileToWorldX: function (t, e) { return this.tilemap.tileToWorldX(t, e, this) }, tileToWorldY: function (t, e) { return this.tilemap.tileToWorldY(t, e, this) }, tileToWorldXY: function (t, e, i, s) { return this.tilemap.tileToWorldXY(t, e, i, s, this) }, getTileCorners: function (t, e, i) { return this.tilemap.getTileCorners(t, e, i, this) }, weightedRandomize: function (t, e, i, s, n) { return a.WeightedRandomize(e, i, s, n, t, this.layer), this }, worldToTileX: function (t, e, i) { return this.tilemap.worldToTileX(t, e, i, this) }, worldToTileY: function (t, e, i) { return this.tilemap.worldToTileY(t, e, i, this) }, worldToTileXY: function (t, e, i, s, n) { return this.tilemap.worldToTileXY(t, e, i, s, n, this) }, destroy: function (t) { void 0 === t && (t = !0), this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this)) } }); t.exports = u }, 16153: (t, e, i) => { const s = i(61340); const n = new s(); const r = new s(); const o = new s(); t.exports = function (t, e, i, s) { const a = e.cull(i); const h = a.length; const l = i.alpha * e.alpha; if (!(h === 0 || l <= 0)) { const u = n; const c = r; const d = o; c.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), u.copyFrom(i.matrix); const f = t.currentContext; const p = e.gidMap; f.save(), s ? (u.multiplyWithOffset(s, -i.scrollX * e.scrollFactorX, -i.scrollY * e.scrollFactorY), c.e = e.x, c.f = e.y, u.multiply(c, d), d.copyToContext(f)) : (c.e -= i.scrollX * e.scrollFactorX, c.f -= i.scrollY * e.scrollFactorY, c.copyToContext(f)), (!t.antialias || e.scaleX > 1 || e.scaleY > 1) && (f.imageSmoothingEnabled = !1); for (let v = 0; v < h; v++) { const g = a[v]; const m = p[g.index]; if (m) { const y = m.image.getSourceImage(); const x = m.getTileTextureCoordinates(g.index); const T = m.tileWidth; const w = m.tileHeight; if (x !== null && T !== 0 && w !== 0) { const b = 0.5 * T; const S = 0.5 * w; x.x += m.tileOffset.x, x.y += m.tileOffset.y, f.save(), f.translate(g.pixelX + b, g.pixelY + S), g.rotation !== 0 && f.rotate(g.rotation), (g.flipX || g.flipY) && f.scale(g.flipX ? -1 : 1, g.flipY ? -1 : 1), f.globalAlpha = l * g.alpha, f.drawImage(y, x.x, x.y, T, w, -b, -S, T, w), f.restore() } } } f.restore() } } }, 19218: (t, e, i) => { const s = i(29747); let n = s; let r = s; n = i(99558), r = i(16153), t.exports = { renderWebGL: n, renderCanvas: r } }, 99558: (t, e, i) => { const s = i(70554); t.exports = function (t, e, i) { const n = e.cull(i); const r = n.length; const o = i.alpha * e.alpha; if (!(r === 0 || o <= 0)) { const a = e.gidMap; const h = t.pipelines.set(e.pipeline, e); const l = s.getTintAppendFloatAlpha; const u = e.scrollFactorX; const c = e.scrollFactorY; const d = e.x; const f = e.y; const p = e.scaleX; const v = e.scaleY; t.pipelines.preBatch(e); for (let g = 0; g < r; g++) { const m = n[g]; const y = a[m.index]; if (y) { const x = y.getTileTextureCoordinates(m.index); const T = y.tileWidth; const w = y.tileHeight; if (x && T !== 0 && w !== 0) { const b = 0.5 * T; const S = 0.5 * w; const E = y.glTexture; const A = h.setTexture2D(E, e); const C = T; const _ = w; const M = x.x; const P = x.y; const R = y.tileOffset.x; const L = y.tileOffset.y; const O = l(m.tint, o * m.alpha); h.batchTexture(e, E, E.width, E.height, d + m.pixelX * p + (b * p - R), f + m.pixelY * v + (S * v - L), T, w, p, v, m.rotation, m.flipX, m.flipY, u, c, b, S, M, P, C, _, O, O, O, O, m.tintFill, 0, 0, i, null, !0, A, !0) } } } t.pipelines.postBatch(e) } } }, 33629: (t, e, i) => { const s = i(83419); const n = i(26099); const r = new s({ initialize: function (t, e, i, s, r, o, a, h, l) { (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = {}), void 0 === h && (h = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = s, this.tileMargin = r, this.tileSpacing = o, this.tileProperties = a, this.tileData = h, this.tileOffset = new n(), void 0 !== l && this.tileOffset.set(l.x, l.y), this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = [] }, getTileProperties: function (t) { return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null }, getTileData: function (t) { return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null }, getTileCollisionGroup: function (t) { const e = this.getTileData(t); return e && e.objectgroup ? e.objectgroup : null }, containsTileIndex: function (t) { return t >= this.firstgid && t < this.firstgid + this.total }, getTileTextureCoordinates: function (t) { return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null }, setImage: function (t) { this.image = t; const e = t.get(); const i = t.getFrameBounds(); return this.glTexture = e.source.glTexture, e.width > i.width || e.height > i.height ? this.updateTileData(e.width, e.height) : this.updateTileData(i.width, i.height, i.x, i.y), this }, setTileSize: function (t, e) { return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this }, setSpacing: function (t, e) { return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this }, updateTileData: function (t, e, i, s) { void 0 === i && (i = 0), void 0 === s && (s = 0); let n = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let r = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing); n % 1 == 0 && r % 1 == 0 || console.warn('Image tile area not tile size multiple in: ' + this.name), n = Math.floor(n), r = Math.floor(r), this.rows = n, this.columns = r, this.total = n * r, this.texCoordinates.length = 0; for (let o = this.tileMargin + i, a = this.tileMargin + s, h = 0; h < this.rows; h++) { for (let l = 0; l < this.columns; l++) this.texCoordinates.push({ x: o, y: a }), o += this.tileWidth + this.tileSpacing; o = this.tileMargin + i, a += this.tileHeight + this.tileSpacing } return this } }); t.exports = r }, 72023: (t, e, i) => { const s = i(7423); t.exports = function (t, e, i) { const n = s(t, e, !0, i); const r = s(t, e - 1, !0, i); const o = s(t, e + 1, !0, i); const a = s(t - 1, e, !0, i); const h = s(t + 1, e, !0, i); const l = n && n.collides; return l && (n.faceTop = !0, n.faceBottom = !0, n.faceLeft = !0, n.faceRight = !0), r && r.collides && (l && (n.faceTop = !1), r.faceBottom = !l), o && o.collides && (l && (n.faceBottom = !1), o.faceTop = !l), a && a.collides && (l && (n.faceLeft = !1), a.faceRight = !l), h && h.collides && (l && (n.faceRight = !1), h.faceLeft = !l), n && !n.collides && n.resetFaces(), n } }, 42573: (t, e, i) => { const s = i(7423); const n = i(7386); t.exports = function (t, e, i, r, o) { for (let a = null, h = null, l = null, u = null, c = n(t, e, i, r, null, o), d = 0; d < c.length; d++) { const f = c[d]; f && (f.collides ? (a = s(f.x, f.y - 1, !0, o), h = s(f.x, f.y + 1, !0, o), l = s(f.x - 1, f.y, !0, o), u = s(f.x + 1, f.y, !0, o), f.faceTop = !a || !a.collides, f.faceBottom = !h || !h.collides, f.faceLeft = !l || !l.collides, f.faceRight = !u || !u.collides) : f.resetFaces()) } } }, 33528: (t, e, i) => { const s = new (i(26099))(); t.exports = function (t, e, i, n) { const r = i.tilemapLayer; const o = r.cullPaddingX; const a = r.cullPaddingY; const h = r.tilemap.tileToWorldXY(t, e, s, n, r); return h.x > n.worldView.x + r.scaleX * i.tileWidth * (-o - 0.5) && h.x < n.worldView.right + r.scaleX * i.tileWidth * (o - 0.5) && h.y > n.worldView.y + r.scaleY * i.tileHeight * (-a - 1) && h.y < n.worldView.bottom + r.scaleY * i.tileHeight * (a - 0.5) } }, 1785: (t, e, i) => { const s = i(42573); const n = i(7386); const r = i(62991); const o = i(23029); t.exports = function (t, e, i, a, h, l, u, c) { void 0 === u && (u = !0); const d = n(t, e, i, a, null, c); const f = []; d.forEach(function (t) { const e = new o(t.layer, t.index, t.x, t.y, t.width, t.height, t.baseWidth, t.baseHeight); e.copy(t), f.push(e) }); for (let p = h - t, v = l - e, g = 0; g < f.length; g++) { const m = f[g]; const y = m.x + p; const x = m.y + v; r(y, x, c) && c.data[x][y] && (m.x = y, m.y = x, m.updatePixelXY(), c.data[x][y] = m) } u && s(h - 1, l - 1, i + 2, a + 2, c), d.length = 0, f.length = 0 } }, 78419: (t, e, i) => { const s = i(62644); const n = i(7386); const r = i(27987); t.exports = function (t, e, i, o, a, h) { i || (i = {}), Array.isArray(t) || (t = [t]); const l = h.tilemapLayer; o || (o = l.scene), a || (a = o.cameras.main); let u; const c = h.width; const d = h.height; const f = n(0, 0, c, d, null, h); const p = []; const v = function (t, e, i) { for (let s = 0; s < i.length; s++) { const n = i[s]; t.hasOwnProperty(n) || (t[n] = e[n]) } }; for (u = 0; u < f.length; u++) { const g = f[u]; const m = s(i); if (t.indexOf(g.index) !== -1) { const y = l.tileToWorldXY(g.x, g.y, void 0, a, h); m.x = y.x, m.y = y.y, v(m, g, ['rotation', 'flipX', 'flipY', 'alpha', 'visible', 'tint']), m.hasOwnProperty('origin') || (m.x += 0.5 * g.width, m.y += 0.5 * g.height), m.hasOwnProperty('useSpriteSheet') && (m.key = g.tileset.image, m.frame = g.index - 1), p.push(o.make.sprite(m)) } } if (Array.isArray(e)) for (u = 0; u < t.length; u++)r(t[u], e[u], 0, 0, c, d, h); else if (e !== null) for (u = 0; u < t.length; u++)r(t[u], e, 0, 0, c, d, h); return p } }, 19545: (t, e, i) => { const s = i(87841); const n = i(63448); const r = i(56583); const o = new s(); t.exports = function (t, e) { const i = t.tilemapLayer.tilemap; const s = t.tilemapLayer; const a = Math.floor(i.tileWidth * s.scaleX); const h = Math.floor(i.tileHeight * s.scaleY); const l = r(e.worldView.x - s.x, a, 0, !0) - s.cullPaddingX; const u = n(e.worldView.right - s.x, a, 0, !0) + s.cullPaddingX; const c = r(e.worldView.y - s.y, h, 0, !0) - s.cullPaddingY; const d = n(e.worldView.bottom - s.y, h, 0, !0) + s.cullPaddingY; return o.setTo(l, c, u - l, d - c) } }, 30003: (t, e, i) => { const s = i(19545); const n = i(32483); t.exports = function (t, e, i, r) { void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0; const o = t.tilemapLayer; const a = s(t, e); return (o.skipCull || o.scrollFactorX !== 1 || o.scrollFactorY !== 1) && (a.left = 0, a.right = t.width, a.top = 0, a.bottom = t.height), n(t, a, r, i), i } }, 35137: (t, e, i) => { const s = i(7386); const n = i(42573); const r = i(20576); t.exports = function (t, e, i, o, a, h, l) { for (let u = l.collideIndexes.indexOf(t) !== -1, c = s(e, i, o, a, null, l), d = 0; d < c.length; d++)c[d].index = t, r(c[d], u); h && n(e - 1, i - 1, o + 2, a + 2, l) } }, 40253: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a, h) { return s(i, n, r, o, a, h).filter(t, e) } }, 52692: t => { t.exports = function (t, e, i, s) { void 0 === e && (e = 0), void 0 === i && (i = !1); let n; let r; let o; let a = 0; if (i) { for (r = s.height - 1; r >= 0; r--) for (n = s.width - 1; n >= 0; n--) if ((o = s.data[r][n]) && o.index === t) { if (a === e) return o; a += 1 } } else for (r = 0; r < s.height; r++) for (n = 0; n < s.width; n++) if ((o = s.data[r][n]) && o.index === t) { if (a === e) return o; a += 1 } return null } }, 66151: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a, h) { return s(i, n, r, o, a, h).find(t, e) || null } }, 97560: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a, h) { s(i, n, r, o, a, h).forEach(t, e) } }, 43305: (t, e, i) => { const s = i(91907); const n = i(30003); const r = i(9474); const o = i(14018); const a = i(29747); const h = i(54503); t.exports = function (t) { return t === s.ORTHOGONAL ? n : t === s.HEXAGONAL ? r : t === s.STAGGERED ? h : t === s.ISOMETRIC ? o : a } }, 7423: (t, e, i) => { const s = i(62991); t.exports = function (t, e, i, n) { if (void 0 === i && (i = !1), s(t, e, n)) { const r = n.data[e][t] || null; return r ? r.index === -1 ? i ? r : null : r : null } return null } }, 60540: (t, e, i) => { const s = i(7423); const n = new (i(26099))(); t.exports = function (t, e, i, r, o) { return o.tilemapLayer.worldToTileXY(t, e, !0, n, r), s(n.x, n.y, i, o) } }, 55826: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n) { let r = n.baseTileWidth; let o = n.baseTileHeight; const a = n.tilemapLayer; let h = 0; let l = 0; a && (i || (i = a.scene.cameras.main), h = a.x + i.scrollX * (1 - a.scrollFactorX), l = a.y + i.scrollY * (1 - a.scrollFactorY), r *= a.scaleX, o *= a.scaleY); const u = h + t * r; const c = l + e * o; return [new s(u, c), new s(u + r, c), new s(u + r, c + o), new s(u, c + o)] } }, 11758: (t, e, i) => { const s = i(91907); const n = i(27229); const r = i(29747); const o = i(55826); t.exports = function (t) { return t === s.ORTHOGONAL ? o : t === s.ISOMETRIC ? r : t === s.HEXAGONAL ? n : (s.STAGGERED, r) } }, 39167: (t, e, i) => { const s = i(91907); const n = i(29747); const r = i(97281); t.exports = function (t) { return t === s.ORTHOGONAL ? r : n } }, 62e3: (t, e, i) => { const s = i(91907); const n = i(19951); const r = i(14127); const o = i(29747); const a = i(97202); const h = i(70326); t.exports = function (t) { return t === s.ORTHOGONAL ? h : t === s.ISOMETRIC ? r : t === s.HEXAGONAL ? n : t === s.STAGGERED ? a : o } }, 5984: (t, e, i) => { const s = i(91907); const n = i(29747); const r = i(28054); const o = i(29650); t.exports = function (t) { return t === s.ORTHOGONAL ? o : t === s.STAGGERED ? r : n } }, 7386: (t, e, i) => { const s = i(95540); t.exports = function (t, e, i, n, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = o.width), void 0 === n && (n = o.height), r || (r = {}); const a = s(r, 'isNotEmpty', !1); const h = s(r, 'isColliding', !1); const l = s(r, 'hasInterestingFace', !1); t < 0 && (i += t, t = 0), e < 0 && (n += e, e = 0), t + i > o.width && (i = Math.max(o.width - t, 0)), e + n > o.height && (n = Math.max(o.height - e, 0)); for (var u = [], c = e; c < e + n; c++) for (let d = t; d < t + i; d++) { const f = o.data[c][d]; if (f !== null) { if (a && f.index === -1) continue; if (h && !f.collides) continue; if (l && !f.hasInterestingFace) continue; u.push(f) } } return u } }, 91141: (t, e, i) => { const s = i(55738); const n = i(7386); const r = i(91865); const o = i(29747); const a = i(26099); const h = function (t, e) { return r.RectangleToTriangle(e, t) }; const l = new a(); const u = new a(); const c = new a(); t.exports = function (t, e, i, a) { if (void 0 === t) return []; let d = o; t instanceof s.Circle ? d = r.CircleToRectangle : t instanceof s.Rectangle ? d = r.RectangleToRectangle : t instanceof s.Triangle ? d = h : t instanceof s.Line && (d = r.LineToRectangle), a.tilemapLayer.worldToTileXY(t.left, t.top, !0, u, i); const f = u.x; const p = u.y; a.tilemapLayer.worldToTileXY(t.right, t.bottom, !1, c, i); const v = Math.ceil(c.x); const g = Math.ceil(c.y); const m = Math.max(v - f, 1); const y = Math.max(g - p, 1); const x = n(f, p, m, y, e, a); let T = a.tileWidth; let w = a.tileHeight; a.tilemapLayer && (T *= a.tilemapLayer.scaleX, w *= a.tilemapLayer.scaleY); for (var b = [], S = new s.Rectangle(0, 0, T, w), E = 0; E < x.length; E++) { const A = x[E]; a.tilemapLayer.tileToWorldXY(A.x, A.y, l, i), S.x = l.x, S.y = l.y, d(t, S) && b.push(A) } return b } }, 96523: (t, e, i) => { const s = i(7386); const n = i(26099); const r = new n(); const o = new n(); t.exports = function (t, e, i, n, a, h, l) { const u = l.tilemapLayer.tilemap._convert.WorldToTileXY; u(t, e, !0, r, h, l); const c = r.x; const d = r.y; u(t + i, e + n, !1, o, h, l); const f = Math.ceil(o.x); const p = Math.ceil(o.y); return s(c, d, f - c, p - d, a, l) } }, 96113: (t, e, i) => { const s = i(91907); const n = i(20242); const r = i(10095); t.exports = function (t) { return t === s.ORTHOGONAL ? r : n } }, 16926: (t, e, i) => { const s = i(91907); const n = i(86625); const r = i(96897); const o = i(29747); const a = i(15108); const h = i(85896); t.exports = function (t) { return t === s.ORTHOGONAL ? h : t === s.ISOMETRIC ? r : t === s.HEXAGONAL ? n : t === s.STAGGERED ? a : o } }, 55762: (t, e, i) => { const s = i(91907); const n = i(20242); const r = i(51900); const o = i(63288); t.exports = function (t) { return t === s.ORTHOGONAL ? o : t === s.STAGGERED ? r : n } }, 45091: (t, e, i) => { const s = i(62991); t.exports = function (t, e, i) { if (s(t, e, i)) { const n = i.data[e][t]; return n !== null && n.index > -1 } return !1 } }, 24152: (t, e, i) => { const s = i(45091); const n = new (i(26099))(); t.exports = function (t, e, i, r) { r.tilemapLayer.worldToTileXY(t, e, !0, n, i); const o = n.x; const a = n.y; return s(o, a, r) } }, 90454: (t, e, i) => { const s = i(63448); const n = i(56583); t.exports = function (t, e) { let i; let r; let o; let a; const h = t.tilemapLayer.tilemap; const l = t.tilemapLayer; const u = Math.floor(h.tileWidth * l.scaleX); const c = Math.floor(h.tileHeight * l.scaleY); const d = t.hexSideLength; if (t.staggerAxis === 'y') { const f = (c - d) / 2 + d; i = n(e.worldView.x - l.x, u, 0, !0) - l.cullPaddingX, r = s(e.worldView.right - l.x, u, 0, !0) + l.cullPaddingX, o = n(e.worldView.y - l.y, f, 0, !0) - l.cullPaddingY, a = s(e.worldView.bottom - l.y, f, 0, !0) + l.cullPaddingY } else { const p = (u - d) / 2 + d; i = n(e.worldView.x - l.x, p, 0, !0) - l.cullPaddingX, r = s(e.worldView.right - l.x, p, 0, !0) + l.cullPaddingX, o = n(e.worldView.y - l.y, c, 0, !0) - l.cullPaddingY, a = s(e.worldView.bottom - l.y, c, 0, !0) + l.cullPaddingY } return { left: i, right: r, top: o, bottom: a } } }, 9474: (t, e, i) => { const s = i(90454); const n = i(32483); t.exports = function (t, e, i, r) { void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0; const o = t.tilemapLayer; const a = s(t, e); return o.skipCull && o.scrollFactorX === 1 && o.scrollFactorY === 1 && (a.left = 0, a.right = t.width, a.top = 0, a.bottom = t.height), n(t, a, r, i), i } }, 27229: (t, e, i) => { const s = i(19951); const n = i(26099); const r = new n(); t.exports = function (t, e, i, o) { let a = o.baseTileWidth; let h = o.baseTileHeight; const l = o.tilemapLayer; l && (a *= l.scaleX, h *= l.scaleY); let u; let c; const d = s(t, e, r, i, o); const f = []; const p = 0.5773502691896257; o.staggerAxis === 'y' ? (u = p * a, c = h / 2) : (u = a / 2, c = p * h); for (let v = 0; v < 6; v++) { const g = 2 * Math.PI * (0.5 - v) / 6; f.push(new n(d.x + u * Math.cos(g), d.y + c * Math.sin(g))) } return f } }, 19951: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r) { i || (i = new s()); let o = r.baseTileWidth; let a = r.baseTileHeight; const h = r.tilemapLayer; let l = 0; let u = 0; h && (n || (n = h.scene.cameras.main), l = h.x + n.scrollX * (1 - h.scrollFactorX), u = h.y + n.scrollY * (1 - h.scrollFactorY), o *= h.scaleX, a *= h.scaleY); let c; let d; const f = o / 2; const p = a / 2; return r.staggerAxis === 'y' ? (c = l + o * t + o, d = u + 1.5 * e * p + p, e % 2 == 0 && (this.staggerIndex === 'odd' ? c -= f : c += f)) : this.staggerAxis === 'x' && this.staggerIndex === 'odd' && (c = l + 1.5 * t * f + f, d = u + a * t + a, t % 2 == 0 && (this.staggerIndex === 'odd' ? d -= p : d += p)), i.set(c, d) } }, 86625: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r, o) { n || (n = new s()); let a = o.baseTileWidth; let h = o.baseTileHeight; const l = o.tilemapLayer; l && (r || (r = l.scene.cameras.main), t -= l.x + r.scrollX * (1 - l.scrollFactorX), e -= l.y + r.scrollY * (1 - l.scrollFactorY), a *= l.scaleX, h *= l.scaleY); let u; let c; let d; let f; let p; const v = 0.5773502691896257; const g = -0.3333333333333333; const m = 0.6666666666666666; const y = a / 2; const x = h / 2; o.staggerAxis === 'y' ? (d = v * (u = (t - y) / (v * a)) + g * (c = (e - x) / x), f = 0 * u + m * c) : (d = g * (u = (t - y) / y) + v * (c = (e - x) / (v * h)), f = m * u + 0 * c), p = -d - f; let T; let w = Math.round(d); let b = Math.round(f); const S = Math.round(p); const E = Math.abs(w - d); const A = Math.abs(b - f); const C = Math.abs(S - p); E > A && E > C ? w = -b - S : A > C && (b = -w - S); const _ = b; return T = o.staggerIndex === 'odd' ? _ % 2 == 0 ? b / 2 + w : b / 2 + w - 0.5 : _ % 2 == 0 ? b / 2 + w : b / 2 + w + 0.5, n.set(T, _) } }, 62991: t => { t.exports = function (t, e, i) { return t >= 0 && t < i.width && e >= 0 && e < i.height } }, 14018: (t, e, i) => { const s = i(33528); t.exports = function (t, e, i, n) { void 0 === i && (i = []), void 0 === n && (n = 0), i.length = 0; let r; let o; let a; const h = t.tilemapLayer; const l = t.data; const u = t.width; const c = t.height; const d = h.skipCull; const f = u; const p = c; if (n === 0) for (o = 0; o < p; o++) for (r = 0; r < f; r++)(a = l[o][r]) && a.index !== -1 && a.visible && a.alpha !== 0 && (d || s(r, o, t, e)) && i.push(a); else if (n === 1) for (o = 0; o < p; o++) for (r = f; r >= 0; r--)(a = l[o][r]) && a.index !== -1 && a.visible && a.alpha !== 0 && (d || s(r, o, t, e)) && i.push(a); else if (n === 2) for (o = p; o >= 0; o--) for (r = 0; r < f; r++)(a = l[o][r]) && a.index !== -1 && a.visible && a.alpha !== 0 && (d || s(r, o, t, e)) && i.push(a); else if (n === 3) for (o = p; o >= 0; o--) for (r = f; r >= 0; r--)(a = l[o][r]) && a.index !== -1 && a.visible && a.alpha !== 0 && (d || s(r, o, t, e)) && i.push(a); return h.tilesDrawn = i.length, h.tilesTotal = u * c, i } }, 14127: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r) { i || (i = new s()); let o = r.baseTileWidth; let a = r.baseTileHeight; const h = r.tilemapLayer; let l = 0; let u = 0; h && (n || (n = h.scene.cameras.main), l = h.x + n.scrollX * (1 - h.scrollFactorX), o *= h.scaleX, u = h.y + n.scrollY * (1 - h.scrollFactorY), a *= h.scaleY); const c = l + o / 2 * (t - e); const d = u + (t + e) * (a / 2); return i.set(c, d) } }, 96897: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r, o, a) { n || (n = new s()); let h = o.baseTileWidth; let l = o.baseTileHeight; const u = o.tilemapLayer; u && (r || (r = u.scene.cameras.main), e -= u.y + r.scrollY * (1 - u.scrollFactorY), l *= u.scaleY, t -= u.x + r.scrollX * (1 - u.scrollFactorX), h *= u.scaleX); const c = h / 2; const d = l / 2; a || (e -= l); let f = 0.5 * ((t -= c) / c + e / d); let p = 0.5 * (-t / c + e / d); return i && (f = Math.floor(f), p = Math.floor(p)), n.set(f, p) } }, 71558: (t, e, i) => { const s = i(23029); const n = i(62991); const r = i(72023); const o = i(20576); t.exports = function (t, e, i, a, h) { if (void 0 === a && (a = !0), !n(e, i, h)) return null; let l; const u = h.data[i][e]; const c = u && u.collides; t instanceof s ? (h.data[i][e] === null && (h.data[i][e] = new s(h, t.index, e, i, h.tileWidth, h.tileHeight)), h.data[i][e].copy(t)) : (l = t, h.data[i][e] === null ? h.data[i][e] = new s(h, l, e, i, h.tileWidth, h.tileHeight) : h.data[i][e].index = l); const d = h.data[i][e]; const f = h.collideIndexes.indexOf(d.index) !== -1; if ((l = t instanceof s ? t.index : t) === -1) d.width = h.tileWidth, d.height = h.tileHeight; else { const p = h.tilemapLayer.tilemap; const v = p.tiles[l][2]; const g = p.tilesets[v]; d.width = g.tileWidth, d.height = g.tileHeight } return o(d, f), a && c !== d.collides && r(e, i, h), d } }, 26303: (t, e, i) => { const s = i(71558); const n = new (i(26099))(); t.exports = function (t, e, i, r, o, a) { return a.tilemapLayer.worldToTileXY(e, i, !0, n, o, a), s(t, n.x, n.y, r, a) } }, 14051: (t, e, i) => { const s = i(42573); const n = i(71558); t.exports = function (t, e, i, r, o) { if (void 0 === r && (r = !0), !Array.isArray(t)) return null; Array.isArray(t[0]) || (t = [t]); for (var a = t.length, h = t[0].length, l = 0; l < a; l++) for (let u = 0; u < h; u++) { const c = t[l][u]; n(c, e + u, i + l, !1, o) } r && s(e - 1, i - 1, h + 2, a + 2, o) } }, 77389: (t, e, i) => { const s = i(7386); const n = i(26546); t.exports = function (t, e, i, r, o, a) { let h; const l = s(t, e, i, r, {}, a); if (!o) for (o = [], h = 0; h < l.length; h++)o.indexOf(l[h].index) === -1 && o.push(l[h].index); for (h = 0; h < l.length; h++)l[h].index = n(o) } }, 63557: (t, e, i) => { const s = i(23029); const n = i(62991); const r = i(72023); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !0), void 0 === o && (o = !0), !n(t, e, a)) return null; const h = a.data[e][t]; return h ? (a.data[e][t] = i ? null : new s(a, -1, t, e, a.tileWidth, a.tileHeight), o && h && h.collides && r(t, e, a), h) : null } }, 94178: (t, e, i) => { const s = i(63557); const n = new (i(26099))(); t.exports = function (t, e, i, r, o, a) { return a.tilemapLayer.worldToTileXY(t, e, !0, n, o, a), s(n.x, n.y, i, r, a) } }, 15533: (t, e, i) => { const s = i(7386); const n = i(3956); const r = new n(105, 210, 231, 150); const o = new n(243, 134, 48, 200); const a = new n(40, 39, 37, 150); t.exports = function (t, e, i) { void 0 === e && (e = {}); const n = void 0 !== e.tileColor ? e.tileColor : r; const h = void 0 !== e.collidingTileColor ? e.collidingTileColor : o; const l = void 0 !== e.faceColor ? e.faceColor : a; const u = s(0, 0, i.width, i.height, null, i); t.translateCanvas(i.tilemapLayer.x, i.tilemapLayer.y), t.scaleCanvas(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY); for (let c = 0; c < u.length; c++) { const d = u[c]; let f = d.width; let p = d.height; let v = d.pixelX; let g = d.pixelY; const m = d.collides ? h : n; m !== null && (t.fillStyle(m.color, m.alpha / 255), t.fillRect(v, g, f, p)), v += 1, g += 1, f -= 2, p -= 2, l !== null && (t.lineStyle(1, l.color, l.alpha / 255), d.faceTop && t.lineBetween(v, g, v + f, g), d.faceRight && t.lineBetween(v + f, g, v + f, g + p), d.faceBottom && t.lineBetween(v, g + p, v + f, g + p), d.faceLeft && t.lineBetween(v, g, v, g + p)) } } }, 27987: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a) { for (let h = s(i, n, r, o, null, a), l = 0; l < h.length; l++)h[l] && h[l].index === t && (h[l].index = e) } }, 32483: t => { t.exports = function (t, e, i, s) { let n; let r; let o; const a = t.data; const h = t.width; const l = t.height; const u = t.tilemapLayer; const c = Math.max(0, e.left); const d = Math.min(h, e.right); const f = Math.max(0, e.top); const p = Math.min(l, e.bottom); if (i === 0) for (r = f; r < p; r++) for (n = c; a[r] && n < d; n++)(o = a[r][n]) && o.index !== -1 && o.visible && o.alpha !== 0 && s.push(o); else if (i === 1) for (r = f; r < p; r++) for (n = d; a[r] && n >= c; n--)(o = a[r][n]) && o.index !== -1 && o.visible && o.alpha !== 0 && s.push(o); else if (i === 2) for (r = p; r >= f; r--) for (n = c; a[r] && n < d; n++)(o = a[r][n]) && o.index !== -1 && o.visible && o.alpha !== 0 && s.push(o); else if (i === 3) for (r = p; r >= f; r--) for (n = d; a[r] && n >= c; n--)(o = a[r][n]) && o.index !== -1 && o.visible && o.alpha !== 0 && s.push(o); return u.tilesDrawn = s.length, u.tilesTotal = h * l, s } }, 57068: (t, e, i) => { const s = i(20576); const n = i(42573); const r = i(9589); t.exports = function (t, e, i, o, a) { void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === a && (a = !0), Array.isArray(t) || (t = [t]); for (let h = 0; h < t.length; h++)r(t[h], e, o); if (a) for (let l = 0; l < o.height; l++) for (let u = 0; u < o.width; u++) { const c = o.data[l][u]; c && t.indexOf(c.index) !== -1 && s(c, e) } i && n(0, 0, o.width, o.height, o) } }, 37266: (t, e, i) => { const s = i(20576); const n = i(42573); const r = i(9589); t.exports = function (t, e, i, o, a, h) { if (void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === h && (h = !0), !(t > e)) { for (let l = t; l <= e; l++)r(l, i, a); if (h) for (let u = 0; u < a.height; u++) for (let c = 0; c < a.width; c++) { const d = a.data[u][c]; d && d.index >= t && d.index <= e && s(d, i) } o && n(0, 0, a.width, a.height, a) } } }, 75661: (t, e, i) => { const s = i(20576); const n = i(42573); const r = i(9589); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; l && t.indexOf(l.index) === -1 && (s(l, e), r(l.index, e, o)) } i && n(0, 0, o.width, o.height, o) } }, 64740: (t, e, i) => { const s = i(20576); const n = i(42573); const r = i(97022); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; if (l) for (const u in t) if (r(l.properties, u)) { let c = t[u]; Array.isArray(c) || (c = [c]); for (let d = 0; d < c.length; d++)l.properties[u] === c[d] && s(l, e) } } i && n(0, 0, o.width, o.height, o) } }, 63307: (t, e, i) => { const s = i(20576); const n = i(42573); t.exports = function (t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0); for (let r = 0; r < i.height; r++) for (let o = 0; o < i.width; o++) { const a = i.data[r][o]; if (a) { const h = a.getCollisionGroup(); h && h.objects && h.objects.length > 0 && s(a, t) } } e && n(0, 0, i.width, i.height, i) } }, 9589: t => { t.exports = function (t, e, i) { const s = i.collideIndexes.indexOf(t); e && s === -1 ? i.collideIndexes.push(t) : e || s === -1 || i.collideIndexes.splice(s, 1) } }, 20576: t => { t.exports = function (t, e) { e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1) } }, 79583: t => { t.exports = function (t, e, i, s) { if (typeof t === 'number') s.callbacks[t] = e !== null ? { callback: e, callbackContext: i } : void 0; else for (let n = 0, r = t.length; n < r; n++)s.callbacks[t[n]] = e !== null ? { callback: e, callbackContext: i } : void 0 } }, 93254: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a) { for (let h = s(t, e, i, n, null, a), l = 0; l < h.length; l++)h[l].setCollisionCallback(r, o) } }, 32903: (t, e, i) => { const s = i(7386); const n = i(33680); t.exports = function (t, e, i, r, o) { const a = s(t, e, i, r, null, o); const h = a.map(function (t) { return t.index }); n(h); for (let l = 0; l < a.length; l++)a[l].index = h[l] } }, 61325: (t, e, i) => { const s = i(63448); const n = i(56583); t.exports = function (t, e) { const i = t.tilemapLayer.tilemap; const r = t.tilemapLayer; const o = Math.floor(i.tileWidth * r.scaleX); const a = Math.floor(i.tileHeight * r.scaleY); return { left: n(e.worldView.x - r.x, o, 0, !0) - r.cullPaddingX, right: s(e.worldView.right - r.x, o, 0, !0) + r.cullPaddingX, top: n(e.worldView.y - r.y, a / 2, 0, !0) - r.cullPaddingY, bottom: s(e.worldView.bottom - r.y, a / 2, 0, !0) + r.cullPaddingY } } }, 54503: (t, e, i) => { const s = i(61325); const n = i(32483); t.exports = function (t, e, i, r) { void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0; const o = t.tilemapLayer; const a = s(t, e); return o.skipCull && o.scrollFactorX === 1 && o.scrollFactorY === 1 && (a.left = 0, a.right = t.width, a.top = 0, a.bottom = t.height), n(t, a, r, i), i } }, 97202: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r) { i || (i = new s()); let o = r.baseTileWidth; let a = r.baseTileHeight; const h = r.tilemapLayer; let l = 0; let u = 0; h && (n || (n = h.scene.cameras.main), l = h.x + n.scrollX * (1 - h.scrollFactorX), o *= h.scaleX, u = h.y + n.scrollY * (1 - h.scrollFactorY), a *= h.scaleY); const c = l + t * o + e % 2 * (o / 2); const d = u + e * (a / 2); return i.set(c, d) } }, 28054: t => { t.exports = function (t, e, i) { let s = i.baseTileHeight; const n = i.tilemapLayer; let r = 0; return n && (void 0 === e && (e = n.scene.cameras.main), r = n.y + e.scrollY * (1 - n.scrollFactorY), s *= n.scaleY), r + t * (s / 2) + s } }, 15108: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r, o) { n || (n = new s()); let a = o.baseTileWidth; let h = o.baseTileHeight; const l = o.tilemapLayer; l && (r || (r = l.scene.cameras.main), e -= l.y + r.scrollY * (1 - l.scrollFactorY), h *= l.scaleY, t -= l.x + r.scrollX * (1 - l.scrollFactorX), a *= l.scaleX); const u = i ? Math.floor(e / (h / 2)) : e / (h / 2); const c = i ? Math.floor((t + u % 2 * 0.5 * a) / a) : (t + u % 2 * 0.5 * a) / a; return n.set(c, u) } }, 51900: t => { t.exports = function (t, e, i, s) { let n = s.baseTileHeight; const r = s.tilemapLayer; return r && (i || (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), n *= r.scaleY), e ? Math.floor(t / (n / 2)) : t / (n / 2) } }, 86560: (t, e, i) => { const s = i(7386); t.exports = function (t, e, i, n, r, o, a) { for (let h = s(i, n, r, o, null, a), l = 0; l < h.length; l++)h[l] && (h[l].index === t ? h[l].index = e : h[l].index === e && (h[l].index = t)) } }, 97281: t => { t.exports = function (t, e, i) { let s = i.baseTileWidth; const n = i.tilemapLayer; let r = 0; return n && (e || (e = n.scene.cameras.main), r = n.x + e.scrollX * (1 - n.scrollFactorX), s *= n.scaleX), r + t * s } }, 70326: (t, e, i) => { const s = i(97281); const n = i(29650); const r = i(26099); t.exports = function (t, e, i, o, a) { return i || (i = new r(0, 0)), i.x = s(t, o, a), i.y = n(e, o, a), i } }, 29650: t => { t.exports = function (t, e, i) { let s = i.baseTileHeight; const n = i.tilemapLayer; let r = 0; return n && (e || (e = n.scene.cameras.main), r = n.y + e.scrollY * (1 - n.scrollFactorY), s *= n.scaleY), r + t * s } }, 77366: (t, e, i) => { const s = i(7386); const n = i(75508); t.exports = function (t, e, i, r, o, a) { if (o) { let h; const l = s(t, e, i, r, null, a); let u = 0; for (h = 0; h < o.length; h++)u += o[h].weight; if (!(u <= 0)) for (h = 0; h < l.length; h++) { for (var c = n.RND.frac() * u, d = 0, f = -1, p = 0; p < o.length; p++) if (c <= (d += o[p].weight)) { const v = o[p].index; f = Array.isArray(v) ? v[Math.floor(n.RND.frac() * v.length)] : v; break } l[h].index = f } } } }, 10095: (t, e, i) => { const s = i(85896); const n = new (i(26099))(); t.exports = function (t, e, i, r) { return s(t, 0, e, n, i, r), n.x } }, 85896: (t, e, i) => { const s = i(26099); t.exports = function (t, e, i, n, r, o) { void 0 === i && (i = !0), n || (n = new s()); let a = o.baseTileWidth; let h = o.baseTileHeight; const l = o.tilemapLayer; l && (r || (r = l.scene.cameras.main), t -= l.x + r.scrollX * (1 - l.scrollFactorX), e -= l.y + r.scrollY * (1 - l.scrollFactorY), a *= l.scaleX, h *= l.scaleY); let u = t / a; let c = e / h; return i && (u = Math.floor(u), c = Math.floor(c)), n.set(u, c) } }, 63288: (t, e, i) => { const s = i(85896); const n = new (i(26099))(); t.exports = function (t, e, i, r) { return s(0, t, e, n, i, r), n.y } }, 81086: (t, e, i) => { t.exports = { CalculateFacesAt: i(72023), CalculateFacesWithin: i(42573), CheckIsoBounds: i(33528), Copy: i(1785), CreateFromTiles: i(78419), CullBounds: i(19545), CullTiles: i(30003), Fill: i(35137), FilterTiles: i(40253), FindByIndex: i(52692), FindTile: i(66151), ForEachTile: i(97560), GetCullTilesFunction: i(43305), GetTileAt: i(7423), GetTileAtWorldXY: i(60540), GetTileCorners: i(55826), GetTileCornersFunction: i(11758), GetTilesWithin: i(7386), GetTilesWithinShape: i(91141), GetTilesWithinWorldXY: i(96523), GetTileToWorldXFunction: i(39167), GetTileToWorldXYFunction: i(62e3), GetTileToWorldYFunction: i(5984), GetWorldToTileXFunction: i(96113), GetWorldToTileXYFunction: i(16926), GetWorldToTileYFunction: i(55762), HasTileAt: i(45091), HasTileAtWorldXY: i(24152), HexagonalCullBounds: i(90454), HexagonalCullTiles: i(9474), HexagonalGetTileCorners: i(27229), HexagonalTileToWorldXY: i(19951), HexagonalWorldToTileXY: i(86625), IsInLayerBounds: i(62991), IsometricCullTiles: i(14018), IsometricTileToWorldXY: i(14127), IsometricWorldToTileXY: i(96897), PutTileAt: i(71558), PutTileAtWorldXY: i(26303), PutTilesAt: i(14051), Randomize: i(77389), RemoveTileAt: i(63557), RemoveTileAtWorldXY: i(94178), RenderDebug: i(15533), ReplaceByIndex: i(27987), RunCull: i(32483), SetCollision: i(57068), SetCollisionBetween: i(37266), SetCollisionByExclusion: i(75661), SetCollisionByProperty: i(64740), SetCollisionFromCollisionGroup: i(63307), SetLayerCollisionIndex: i(9589), SetTileCollision: i(20576), SetTileIndexCallback: i(79583), SetTileLocationCallback: i(93254), Shuffle: i(32903), StaggeredCullBounds: i(61325), StaggeredCullTiles: i(54503), StaggeredTileToWorldXY: i(97202), StaggeredTileToWorldY: i(28054), StaggeredWorldToTileXY: i(15108), StaggeredWorldToTileY: i(51900), SwapByIndex: i(86560), TileToWorldX: i(97281), TileToWorldXY: i(70326), TileToWorldY: i(29650), WeightedRandomize: i(77366), WorldToTileX: i(10095), WorldToTileXY: i(85896), WorldToTileY: i(63288) } }, 91907: t => { t.exports = { ORTHOGONAL: 0, ISOMETRIC: 1, STAGGERED: 2, HEXAGONAL: 3 } }, 21829: (t, e, i) => { const s = { ORIENTATION: i(91907) }; t.exports = s }, 62501: (t, e, i) => { const s = i(79291); const n = i(21829); let r = { Components: i(81086), Parsers: i(57442), Formats: i(80341), ImageCollection: i(16536), ParseToTilemap: i(31989), Tile: i(23029), Tilemap: i(49075), TilemapCreator: i(45939), TilemapFactory: i(46029), Tileset: i(33629), TilemapLayer: i(20442), Orientation: i(91907), LayerData: i(14977), MapData: i(87010), ObjectLayer: i(48700) }; r = s(!1, r, n.ORIENTATION), t.exports = r }, 14977: (t, e, i) => { const s = i(83419); const n = i(91907); const r = i(95540); const o = new s({ initialize: function (t) { void 0 === t && (t = {}), this.name = r(t, 'name', 'layer'), this.id = r(t, 'id', 0), this.x = r(t, 'x', 0), this.y = r(t, 'y', 0), this.width = r(t, 'width', 0), this.height = r(t, 'height', 0), this.tileWidth = r(t, 'tileWidth', 0), this.tileHeight = r(t, 'tileHeight', 0), this.baseTileWidth = r(t, 'baseTileWidth', this.tileWidth), this.baseTileHeight = r(t, 'baseTileHeight', this.tileHeight), this.orientation = r(t, 'orientation', n.ORTHOGONAL), this.widthInPixels = r(t, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = r(t, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = r(t, 'alpha', 1), this.visible = r(t, 'visible', !0), this.properties = r(t, 'properties', []), this.indexes = r(t, 'indexes', []), this.collideIndexes = r(t, 'collideIndexes', []), this.callbacks = r(t, 'callbacks', []), this.bodies = r(t, 'bodies', []), this.data = r(t, 'data', []), this.tilemapLayer = r(t, 'tilemapLayer', null), this.hexSideLength = r(t, 'hexSideLength', 0), this.staggerAxis = r(t, 'staggerAxis', 'y'), this.staggerIndex = r(t, 'staggerIndex', 'odd') } }); t.exports = o }, 87010: (t, e, i) => { const s = i(83419); const n = i(91907); const r = i(95540); const o = new s({ initialize: function (t) { void 0 === t && (t = {}), this.name = r(t, 'name', 'map'), this.width = r(t, 'width', 0), this.height = r(t, 'height', 0), this.infinite = r(t, 'infinite', !1), this.tileWidth = r(t, 'tileWidth', 0), this.tileHeight = r(t, 'tileHeight', 0), this.widthInPixels = r(t, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = r(t, 'heightInPixels', this.height * this.tileHeight), this.format = r(t, 'format', null), this.orientation = r(t, 'orientation', n.ORTHOGONAL), this.renderOrder = r(t, 'renderOrder', 'right-down'), this.version = r(t, 'version', '1'), this.properties = r(t, 'properties', {}), this.layers = r(t, 'layers', []), this.images = r(t, 'images', []), this.objects = r(t, 'objects', []), Array.isArray(this.objects) || (this.objects = []), this.collision = r(t, 'collision', {}), this.tilesets = r(t, 'tilesets', []), this.imageCollections = r(t, 'imageCollections', []), this.tiles = r(t, 'tiles', []), this.hexSideLength = r(t, 'hexSideLength', 0), this.staggerAxis = r(t, 'staggerAxis', 'y'), this.staggerIndex = r(t, 'staggerIndex', 'odd') } }); t.exports = o }, 48700: (t, e, i) => { const s = i(83419); const n = i(95540); const r = new s({ initialize: function (t) { void 0 === t && (t = {}), this.name = n(t, 'name', 'object layer'), this.id = n(t, 'id', 0), this.opacity = n(t, 'opacity', 1), this.properties = n(t, 'properties', {}), this.propertyTypes = n(t, 'propertytypes', {}), this.type = n(t, 'type', 'objectgroup'), this.visible = n(t, 'visible', !0), this.objects = n(t, 'objects', []), Array.isArray(this.objects) || (this.objects = []) } }); t.exports = r }, 6641: (t, e, i) => { const s = i(91907); t.exports = function (t) { return (t = t.toLowerCase()) === 'isometric' ? s.ISOMETRIC : t === 'staggered' ? s.STAGGERED : t === 'hexagonal' ? s.HEXAGONAL : s.ORTHOGONAL } }, 46177: (t, e, i) => { const s = i(80341); const n = i(2342); const r = i(82593); const o = i(46594); const a = i(87021); t.exports = function (t, e, i, h, l, u) { let c; switch (e) { case s.ARRAY_2D: c = n(t, i, h, l, u); break; case s.CSV: c = r(t, i, h, l, u); break; case s.TILED_JSON: c = o(t, i, u); break; case s.WELTMEISTER: c = a(t, i, u); break; default: console.warn('Unrecognized tilemap data format: ' + e), c = null } return c } }, 2342: (t, e, i) => { const s = i(80341); const n = i(14977); const r = i(87010); const o = i(23029); t.exports = function (t, e, i, a, h) { for (var l = new n({ tileWidth: i, tileHeight: a }), u = new r({ name: t, tileWidth: i, tileHeight: a, format: s.ARRAY_2D, layers: [l] }), c = [], d = e.length, f = 0, p = 0; p < e.length; p++) { c[p] = []; for (var v = e[p], g = 0; g < v.length; g++) { const m = parseInt(v[g], 10); isNaN(m) || m === -1 ? c[p][g] = h ? null : new o(l, -1, g, p, i, a) : c[p][g] = new o(l, m, g, p, i, a) } f === 0 && (f = v.length) } return u.width = l.width = f, u.height = l.height = d, u.widthInPixels = l.widthInPixels = f * i, u.heightInPixels = l.heightInPixels = d * a, l.data = c, u } }, 82593: (t, e, i) => { const s = i(80341); const n = i(2342); t.exports = function (t, e, i, r, o) { const a = e.trim().split('\n').map(function (t) { return t.split(',') }); const h = n(t, a, i, r, o); return h.format = s.CSV, h } }, 6656: (t, e, i) => { const s = i(14977); const n = i(23029); t.exports = function (t, e) { for (var i = [], r = 0; r < t.layer.length; r++) { for (var o = t.layer[r], a = new s({ name: o.name, width: o.width, height: o.height, tileWidth: o.tilesize, tileHeight: o.tilesize, visible: o.visible === 1 }), h = [], l = [], u = 0; u < o.data.length; u++) { for (let c = 0; c < o.data[u].length; c++) { var d; const f = o.data[u][c] - 1; d = f > -1 ? new n(a, f, c, u, o.tilesize, o.tilesize) : e ? null : new n(a, -1, c, u, o.tilesize, o.tilesize), h.push(d) } l.push(h), h = [] } a.data = l, i.push(a) } return i } }, 96483: (t, e, i) => { const s = i(33629); t.exports = function (t) { for (var e = [], i = [], n = 0; n < t.layer.length; n++) { const r = t.layer[n]; const o = r.tilesetName; o !== '' && i.indexOf(o) === -1 && (i.push(o), e.push(new s(o, 0, r.tilesize, r.tilesize, 0, 0))) } return e } }, 87021: (t, e, i) => { const s = i(80341); const n = i(87010); const r = i(6656); const o = i(96483); t.exports = function (t, e, i) { if (e.layer.length === 0) return console.warn('No layers found in the Weltmeister map: ' + t), null; for (var a = 0, h = 0, l = 0; l < e.layer.length; l++)e.layer[l].width > a && (a = e.layer[l].width), e.layer[l].height > h && (h = e.layer[l].height); const u = new n({ width: a, height: h, name: t, tileWidth: e.layer[0].tilesize, tileHeight: e.layer[0].tilesize, format: s.WELTMEISTER }); return u.layers = r(e, i), u.tilesets = o(e), u } }, 52833: (t, e, i) => { t.exports = { ParseTileLayers: i(6656), ParseTilesets: i(96483), ParseWeltmeister: i(87021) } }, 57442: (t, e, i) => { t.exports = { FromOrientationString: i(6641), Parse: i(46177), Parse2DArray: i(2342), ParseCSV: i(82593), Impact: i(52833), Tiled: i(96761) } }, 51233: (t, e, i) => { const s = i(79291); t.exports = function (t) { for (var e, i, n, r, o, a = 0; a < t.layers.length; a++) { e = t.layers[a], r = null; for (let h = 0; h < e.data.length; h++) { o = e.data[h]; for (let l = 0; l < o.length; l++)(i = o[l]) === null || i.index < 0 || (n = t.tiles[i.index][2], r = t.tilesets[n], i.width = r.tileWidth, i.height = r.tileHeight, r.tileProperties && r.tileProperties[i.index - r.firstgid] && (i.properties = s(i.properties, r.tileProperties[i.index - r.firstgid]))) } } } }, 41868: t => { t.exports = function (t) { for (var e = window.atob(t), i = e.length, s = new Array(i / 4), n = 0; n < i; n += 4)s[n / 4] = (e.charCodeAt(n) | e.charCodeAt(n + 1) << 8 | e.charCodeAt(n + 2) << 16 | e.charCodeAt(n + 3) << 24) >>> 0; return s } }, 84101: (t, e, i) => { const s = i(33629); t.exports = function (t) { let e; let i; const n = []; for (e = 0; e < t.imageCollections.length; e++) for (let r = t.imageCollections[e], o = r.images, a = 0; a < o.length; a++) { const h = o[a]; (i = new s(h.image, h.gid, r.imageWidth, r.imageHeight, 0, 0)).updateTileData(r.imageWidth, r.imageHeight), t.tilesets.push(i) } for (e = 0; e < t.tilesets.length; e++) for (let l = (i = t.tilesets[e]).tileMargin, u = i.tileMargin, c = 0, d = 0, f = 0, p = i.firstgid; p < i.firstgid + i.total && (n[p] = [l, u, e], l += i.tileWidth + i.tileSpacing, ++c !== i.total) && (++d !== i.columns || (l = i.tileMargin, u += i.tileHeight + i.tileSpacing, d = 0, ++f !== i.rows)); p++); return n } }, 79677: (t, e, i) => { const s = i(95540); t.exports = function (t, e, i) { if (!e) return { i: 0, layers: t.layers, name: '', opacity: 1, visible: !0, x: 0, y: 0 }; const n = e.x + s(e, 'startx', 0) * t.tilewidth + s(e, 'offsetx', 0); const r = e.y + s(e, 'starty', 0) * t.tileheight + s(e, 'offsety', 0); return { i: 0, layers: e.layers, name: i.name + e.name + '/', opacity: i.opacity * e.opacity, visible: i.visible && e.visible, x: i.x + n, y: i.y + r } } }, 29920: t => { const e = 2147483648; const i = 1073741824; const s = 536870912; t.exports = function (t) { const n = Boolean(t & e); const r = Boolean(t & i); const o = Boolean(t & s); t &= 536870911; let a = 0; let h = !1; return n && r && o ? (a = Math.PI / 2, h = !0) : n && r && !o ? (a = Math.PI, h = !1) : n && !r && o ? (a = Math.PI / 2, h = !1) : !n || r || o ? !n && r && o ? (a = 3 * Math.PI / 2, h = !1) : n || !r || o ? n || r || !o ? n || r || o || (a = 0, h = !1) : (a = 3 * Math.PI / 2, h = !0) : (a = Math.PI, h = !0) : (a = 0, h = !0), { gid: t, flippedHorizontal: n, flippedVertical: r, flippedAntiDiagonal: o, rotation: a, flipped: h } } }, 12635: (t, e, i) => { const s = i(95540); const n = i(79677); t.exports = function (t) { for (var e = [], i = [], r = n(t); r.i < r.layers.length || i.length > 0;) if (r.i >= r.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break } r = i.pop() } else { const o = r.layers[r.i]; if (r.i++, o.type === 'imagelayer') { const a = s(o, 'offsetx', 0) + s(o, 'startx', 0); const h = s(o, 'offsety', 0) + s(o, 'starty', 0); e.push({ name: r.name + o.name, image: o.image, x: r.x + a + o.x, y: r.y + h + o.y, alpha: r.opacity * o.opacity, visible: r.visible && o.visible, properties: s(o, 'properties', {}) }) } else if (o.type === 'group') { const l = n(t, o, r); i.push(r), r = l } } return e } }, 46594: (t, e, i) => { const s = i(51233); const n = i(84101); const r = i(91907); const o = i(62644); const a = i(80341); const h = i(6641); const l = i(87010); const u = i(12635); const c = i(22611); const d = i(28200); const f = i(24619); t.exports = function (t, e, i) { const p = o(e); const v = new l({ width: p.width, height: p.height, name: t, tileWidth: p.tilewidth, tileHeight: p.tileheight, orientation: h(p.orientation), format: a.TILED_JSON, version: p.version, properties: p.properties, renderOrder: p.renderorder, infinite: p.infinite }); v.orientation === r.HEXAGONAL && (v.hexSideLength = p.hexsidelength, v.staggerAxis = p.staggeraxis, v.staggerIndex = p.staggerindex), v.layers = d(p, i), v.images = u(p); const g = f(p); return v.tilesets = g.tilesets, v.imageCollections = g.imageCollections, v.objects = c(p), v.tiles = n(v), s(v), v } }, 52205: (t, e, i) => { const s = i(18254); const n = i(29920); const r = function (t) { return { x: t.x, y: t.y } }; const o = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); const a = s(t, o); if (a.x += e, a.y += i, t.gid) { const h = n(t.gid); a.gid = h.gid, a.flippedHorizontal = h.flippedHorizontal, a.flippedVertical = h.flippedVertical, a.flippedAntiDiagonal = h.flippedAntiDiagonal } else t.polyline ? a.polyline = t.polyline.map(r) : t.polygon ? a.polygon = t.polygon.map(r) : t.ellipse ? a.ellipse = t.ellipse : t.text ? a.text = t.text : t.point ? a.point = !0 : a.rectangle = !0; return a } }, 22611: (t, e, i) => { const s = i(95540); const n = i(52205); const r = i(48700); const o = i(79677); t.exports = function (t) { for (var e = [], i = [], a = o(t); a.i < a.layers.length || i.length > 0;) if (a.i >= a.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break } a = i.pop() } else { const h = a.layers[a.i]; if (a.i++, h.opacity *= a.opacity, h.visible = a.visible && h.visible, h.type === 'objectgroup') { h.name = a.name + h.name; for (var l = a.x + s(h, 'startx', 0) + s(h, 'offsetx', 0), u = a.y + s(h, 'starty', 0) + s(h, 'offsety', 0), c = [], d = 0; d < h.objects.length; d++) { const f = n(h.objects[d], l, u); c.push(f) } const p = new r(h); p.objects = c, e.push(p) } else if (h.type === 'group') { const v = o(t, h, a); i.push(a), a = v } } return e } }, 28200: (t, e, i) => { const s = i(41868); const n = i(91907); const r = i(79677); const o = i(6641); const a = i(95540); const h = i(14977); const l = i(29920); const u = i(23029); t.exports = function (t, e) { for (var i = a(t, 'infinite', !1), c = [], d = [], f = r(t); f.i < f.layers.length || d.length > 0;) if (f.i >= f.layers.length) { if (d.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break } f = d.pop() } else { const p = f.layers[f.i]; if (f.i++, p.type === 'tilelayer') if (p.compression) console.warn("TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '" + p.name + "'"); else { if (p.encoding && p.encoding === 'base64') { if (p.chunks) for (let v = 0; v < p.chunks.length; v++)p.chunks[v].data = s(p.chunks[v].data); p.data && (p.data = s(p.data)), delete p.encoding } var g; var m; var y; var x; const T = []; let w = 0; if (i) { const b = a(p, 'startx', 0) + p.x; const S = a(p, 'starty', 0) + p.y; (g = new h({ name: f.name + p.name, id: p.id, x: f.x + a(p, 'offsetx', 0) + b * t.tilewidth, y: f.y + a(p, 'offsety', 0) + S * t.tileheight, width: p.width, height: p.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: f.opacity * p.opacity, visible: f.visible && p.visible, properties: a(p, 'properties', []), orientation: o(t.orientation) })).orientation === n.HEXAGONAL && (g.hexSideLength = t.hexsidelength, g.staggerAxis = t.staggeraxis, g.staggerIndex = t.staggerindex); for (var E = 0; E < p.height; E++) { T[E] = [null]; for (let A = 0; A < p.width; A++)T[E][A] = null } for (E = 0, I = p.chunks.length; E < I; E++) for (let C = p.chunks[E], _ = C.x - b, M = C.y - S, P = 0, R = 0, L = C.data.length; R < L; R++) { const O = w + _; const F = P + M; (m = l(C.data[R])).gid > 0 ? ((y = new u(g, m.gid, O, F, t.tilewidth, t.tileheight)).rotation = m.rotation, y.flipX = m.flipped, T[F][O] = y) : (x = e ? null : new u(g, -1, O, F, t.tilewidth, t.tileheight), T[F][O] = x), ++w === C.width && (P++, w = 0) } } else { (g = new h({ name: f.name + p.name, id: p.id, x: f.x + a(p, 'offsetx', 0) + p.x, y: f.y + a(p, 'offsety', 0) + p.y, width: p.width, height: p.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: f.opacity * p.opacity, visible: f.visible && p.visible, properties: a(p, 'properties', []), orientation: o(t.orientation) })).orientation === n.HEXAGONAL && (g.hexSideLength = t.hexsidelength, g.staggerAxis = t.staggeraxis, g.staggerIndex = t.staggerindex); for (var D = [], k = 0, I = p.data.length; k < I; k++)(m = l(p.data[k])).gid > 0 ? ((y = new u(g, m.gid, w, T.length, t.tilewidth, t.tileheight)).rotation = m.rotation, y.flipX = m.flipped, D.push(y)) : (x = e ? null : new u(g, -1, w, T.length, t.tilewidth, t.tileheight), D.push(x)), ++w === p.width && (T.push(D), w = 0, D = []) } g.data = T, c.push(g) } else if (p.type === 'group') { const B = r(t, p, f); d.push(f), f = B } } return c } }, 24619: (t, e, i) => { const s = i(33629); const n = i(16536); const r = i(52205); const o = i(57880); t.exports = function (t) { for (var e, i = [], a = [], h = null, l = 0; l < t.tilesets.length; l++) { const u = t.tilesets[l]; if (u.source) console.warn('External tilesets unsupported. Use Embed Tileset and re-export'); else if (u.image) { const c = new s(u.name, u.firstgid, u.tilewidth, u.tileheight, u.margin, u.spacing, void 0, void 0, u.tileoffset); if (t.version > 1) { let d = void 0; let f = void 0; if (Array.isArray(u.tiles)) { d = d || {}, f = f || {}; for (var p = 0; p < u.tiles.length; p++) { var v = u.tiles[p]; if (v.properties) { var g = {}; v.properties.forEach(function (t) { g[t.name] = t.value }), f[v.id] = g } if (v.objectgroup && ((d[v.id] || (d[v.id] = {})).objectgroup = v.objectgroup, v.objectgroup.objects)) { const m = v.objectgroup.objects.map(function (t) { return r(t) }); d[v.id].objectgroup.objects = m } v.animation && ((d[v.id] || (d[v.id] = {})).animation = v.animation), v.type && ((d[v.id] || (d[v.id] = {})).type = v.type) } } Array.isArray(u.wangsets) && (d = d || {}, f = f || {}, o(u.wangsets, d)), d && (c.tileData = d, c.tileProperties = f) } else if (u.tileproperties && (c.tileProperties = u.tileproperties), u.tiles) for (e in c.tileData = u.tiles, c.tileData) { const y = c.tileData[e].objectgroup; if (y && y.objects) { const x = y.objects.map(function (t) { return r(t) }); c.tileData[e].objectgroup.objects = x } } c.updateTileData(u.imagewidth, u.imageheight), i.push(c) } else { const T = new n(u.name, u.firstgid, u.tilewidth, u.tileheight, u.margin, u.spacing, u.properties); let w = 0; for (p = 0; p < u.tiles.length; p++) { const b = (v = u.tiles[p]).image; const S = parseInt(v.id, 10); const E = u.firstgid + S; T.addImage(E, b), w = Math.max(S, w) } T.maxId = w, a.push(T) } h && (h.lastgid = u.firstgid - 1), h = u } return { tilesets: i, imageCollections: a } } }, 57880: t => { t.exports = function (t, e) { for (let i = 0; i < t.length; i++) { const s = t[i]; let n = i; if (s.name && s.name !== '' && (n = s.name), Array.isArray(s.wangtiles) && s.wangtiles.length > 0) { var r; var o; var a; const h = {}; const l = {}; if (Array.isArray(s.edgecolors)) for (r = 0; r < s.edgecolors.length; r++)a = 1 + r, (o = s.edgecolors[r]).name !== '' && (h[a] = o.name); if (Array.isArray(s.cornercolors)) for (r = 0; r < s.cornercolors.length; r++)a = 1 + r, (o = s.cornercolors[r]).name !== '' && (l[a] = o.name); if (Array.isArray(s.colors)) for (r = 0; r < s.colors.length; r++)a = 1 + r, (o = s.colors[r]).name !== '' && (h[a] = l[a] = o.name); for (let u = [h, l, h, l, h, l, h, l], c = 0; c < s.wangtiles.length; c++) { const d = s.wangtiles[c]; let f = e[d.tileid] || (e[d.tileid] = {}); f = f.wangid || (f.wangid = {}); for (var p = [], v = 0; v < Math.min(u.length, d.wangid.length); v++) if ((o = d.wangid[v]) !== 0) { const g = u[v][o]; void 0 === g ? p.push(o) : p.push(g) } else p.push(void 0); f[n] = p } } } } }, 96761: (t, e, i) => { t.exports = { AssignTileProperties: i(51233), Base64Decode: i(41868), BuildTilesetIndex: i(84101), CreateGroupLayer: i(79677), ParseGID: i(29920), ParseImageLayers: i(12635), ParseJSONTiled: i(46594), ParseObject: i(52205), ParseObjectLayers: i(22611), ParseTileLayers: i(28200), ParseTilesets: i(24619) } }, 33385: (t, e, i) => { const s = i(83419); const n = i(37277); const r = i(44594); const o = i(94880); const a = i(72905); const h = new s({ initialize: function (t) { this.scene = t, this.systems = t.sys, this.now = 0, this.startTime = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this) }, boot: function () { this.now = this.systems.game.loop.time, this.systems.events.once(r.DESTROY, this.destroy, this) }, start: function () { this.startTime = this.systems.game.loop.time; const t = this.systems.events; t.on(r.PRE_UPDATE, this.preUpdate, this), t.on(r.UPDATE, this.update, this), t.once(r.SHUTDOWN, this.shutdown, this) }, addEvent: function (t) { let e; return t instanceof o ? (e = t, this.removeEvent(e), e.elapsed = e.startAt, e.hasDispatched = !1, e.repeatCount = e.repeat === -1 || e.loop ? 999999999999 : e.repeat) : e = new o(t), this._pendingInsertion.push(e), e }, delayedCall: function (t, e, i, s) { return this.addEvent({ delay: t, callback: e, args: i, callbackScope: s }) }, clearPendingEvents: function () { return this._pendingInsertion = [], this }, removeEvent: function (t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; a(this._pendingRemoval, i), a(this._pendingInsertion, i), a(this._active, i) } return this }, removeAllEvents: function () { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this }, preUpdate: function () { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i, s; for (i = 0; i < t; i++) { s = this._pendingRemoval[i]; const n = this._active.indexOf(s); n > -1 && this._active.splice(n, 1), s.destroy() } for (i = 0; i < e; i++)s = this._pendingInsertion[i], this._active.push(s); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0 } }, update: function (t, e) { if (this.now = t, !this.paused) { e *= this.timeScale; for (let i = 0; i < this._active.length; i++) { const s = this._active[i]; if (!s.paused && (s.elapsed += e * s.timeScale, s.elapsed >= s.delay)) { let n = s.elapsed - s.delay; if (s.elapsed = s.delay, !s.hasDispatched && s.callback && (s.hasDispatched = !0, s.callback.apply(s.callbackScope, s.args)), s.repeatCount > 0) { if (s.repeatCount--, n >= s.delay) for (; n >= s.delay && s.repeatCount > 0;)s.callback && s.callback.apply(s.callbackScope, s.args), n -= s.delay, s.repeatCount--; s.elapsed = n, s.hasDispatched = !1 } else s.hasDispatched && this._pendingRemoval.push(s) } } } }, shutdown: function () { let t; for (t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy(); for (t = 0; t < this._active.length; t++) this._active[t].destroy(); for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off(r.PRE_UPDATE, this.preUpdate, this), e.off(r.UPDATE, this.update, this), e.off(r.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null } }); n.register('Clock', h, 'time'), t.exports = h }, 96120: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(39429); const o = i(95540); const a = i(44594); const h = i(89809); const l = new s({ Extends: n, initialize: function (t, e) { n.call(this), this.scene = t, this.systems = t.sys, this.elapsed = 0, this.paused = !0, this.complete = !1, this.totalComplete = 0, this.loop = 0, this.iteration = 0, this.events = []; const i = this.systems.events; i.on(a.PRE_UPDATE, this.preUpdate, this), i.on(a.UPDATE, this.update, this), i.once(a.SHUTDOWN, this.destroy, this), e && this.add(e) }, preUpdate: function (t, e) { this.paused || (this.elapsed += e) }, update: function () { if (!this.paused && !this.complete) { let t; let e; const i = this.events; let s = !1; const n = this.systems; for (t = 0; t < i.length; t++) { const r = i[t]; if (!r.complete && r.time <= this.elapsed) { if (r.complete = !0, this.totalComplete++, e = r.target ? r.target : this, r.if && !r.if.call(e, r)) continue; if (r.once && (s = !0), r.set && r.target) for (const o in r.set) r.target[o] = r.set[o]; this.iteration && r.repeat++, r.loop && r.repeat && r.loop.call(e), r.tween && n.tweens.add(r.tween), r.sound && (typeof r.sound === 'string' ? n.sound.play(r.sound) : n.sound.play(r.sound.key, r.sound.config)), r.event && this.emit(r.event, e), r.run && r.run.call(e), r.stop && this.stop() } } if (s) for (t = 0; t < i.length; t++)i[t].complete && i[t].once && (i.splice(t, 1), t--); this.totalComplete >= i.length && (this.loop !== 0 && (this.loop === -1 || this.loop > this.iteration) ? (this.iteration++, this.reset(!0)) : this.complete = !0), this.complete && this.emit(h.COMPLETE, this) } }, play: function (t) { return void 0 === t && (t = !0), this.paused = !1, this.complete = !1, this.totalComplete = 0, t && this.reset(), this }, pause: function () { return this.paused = !0, this }, repeat: function (t) { return void 0 !== t && !0 !== t || (t = -1), !1 === t && (t = 0), this.loop = t, this }, resume: function () { return this.paused = !1, this }, stop: function () { return this.paused = !0, this.complete = !0, this }, reset: function (t) { void 0 === t && (t = !1), this.elapsed = 0, t || (this.iteration = 0); for (let e = 0; e < this.events.length; e++) this.events[e].complete = !1, t || (this.events[e].repeat = 0); return this.play(!1) }, add: function (t) { Array.isArray(t) || (t = [t]); const e = this.events; let i = 0; e.length > 0 && (i = e[e.length - 1].time); for (let s = 0; s < t.length; s++) { const n = t[s]; let r = o(n, 'at', 0); const a = o(n, 'in', null); a !== null && (r = this.elapsed + a); const h = o(n, 'from', null); h !== null && (r = i + h), e.push({ complete: !1, time: r, repeat: 0, if: o(n, 'if', null), run: o(n, 'run', null), loop: o(n, 'loop', null), event: o(n, 'event', null), target: o(n, 'target', null), set: o(n, 'set', null), tween: o(n, 'tween', null), sound: o(n, 'sound', null), once: o(n, 'once', !1), stop: o(n, 'stop', !1) }), i = r } return this.complete = !1, this }, clear: function () { return this.events = [], this.elapsed = 0, this.paused = !0, this }, isPlaying: function () { return !this.paused && !this.complete }, getProgress: function () { return Math.min(this.totalComplete, this.events.length) / this.events.length }, destroy: function () { const t = this.systems.events; t.off(a.PRE_UPDATE, this.preUpdate, this), t.off(a.UPDATE, this.update, this), t.off(a.SHUTDOWN, this.destroy, this), this.scene = null, this.systems = null, this.events = [] } }); r.register('timeline', function (t) { return new l(this.scene, t) }), t.exports = l }, 94880: (t, e, i) => { const s = i(83419); const n = i(95540); const r = new s({ initialize: function (t) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t) }, reset: function (t) { if (this.delay = n(t, 'delay', 0), this.repeat = n(t, 'repeat', 0), this.loop = n(t, 'loop', !1), this.callback = n(t, 'callback', void 0), this.callbackScope = n(t, 'callbackScope', this), this.args = n(t, 'args', []), this.timeScale = n(t, 'timeScale', 1), this.startAt = n(t, 'startAt', 0), this.paused = n(t, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this.delay === 0 && (this.repeat > 0 || this.loop)) throw new Error('TimerEvent infinite loop created via zero delay'); return this }, getProgress: function () { return this.elapsed / this.delay }, getOverallProgress: function () { if (this.repeat > 0) { const t = this.delay + this.delay * this.repeat; return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t } return this.getProgress() }, getRepeatCount: function () { return this.repeatCount }, getElapsed: function () { return this.elapsed }, getElapsedSeconds: function () { return 0.001 * this.elapsed }, getRemaining: function () { return this.delay - this.elapsed }, getRemainingSeconds: function () { return 0.001 * this.getRemaining() }, getOverallRemaining: function () { return this.delay * (1 + this.repeatCount) - this.elapsed }, getOverallRemainingSeconds: function () { return 0.001 * this.getOverallRemaining() }, remove: function (t) { void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0 }, destroy: function () { this.callback = void 0, this.callbackScope = void 0, this.args = [] } }); t.exports = r }, 35945: t => { t.exports = 'complete' }, 89809: (t, e, i) => { t.exports = { COMPLETE: i(35945) } }, 90291: (t, e, i) => { t.exports = { Clock: i(33385), Events: i(89809), Timeline: i(96120), TimerEvent: i(94880) } }, 40382: (t, e, i) => { const s = i(72905); const n = i(83419); const r = i(43491); const o = i(88032); const a = i(37277); const h = i(44594); const l = i(93109); const u = i(86081); const c = i(8357); const d = i(43960); const f = i(26012); const p = new n({ initialize: function (t) { this.scene = t, this.events = t.sys.events, this.timeScale = 1, this.paused = !1, this.processing = !1, this.tweens = [], this.time = 0, this.startTime = 0, this.nextTime = 0, this.prevTime = 0, this.maxLag = 500, this.lagSkip = 33, this.gap = 1e3 / 240, this.events.once(h.BOOT, this.boot, this), this.events.on(h.START, this.start, this) }, boot: function () { this.events.once(h.DESTROY, this.destroy, this) }, start: function () { this.timeScale = 1, this.paused = !1, this.startTime = Date.now(), this.prevTime = this.startTime, this.nextTime = this.gap, this.events.on(h.UPDATE, this.update, this), this.events.once(h.SHUTDOWN, this.shutdown, this) }, create: function (t) { Array.isArray(t) || (t = [t]); for (var e = [], i = 0; i < t.length; i++) { const s = t[i]; s instanceof u || s instanceof d ? e.push(s) : Array.isArray(s.tweens) ? e.push(f(this, s)) : e.push(c(this, s)) } return e.length === 1 ? e[0] : e }, add: function (t) { let e = t; const i = this.tweens; return e instanceof u || e instanceof d || (e = Array.isArray(e.tweens) ? f(this, e) : c(this, e)), i.push(e.reset()), e }, addMultiple: function (t) { for (var e, i = [], s = this.tweens, n = 0; n < t.length; n++)(e = t[n]) instanceof u || e instanceof d || (e = Array.isArray(e.tweens) ? f(this, e) : c(this, e)), s.push(e.reset()), i.push(e); return i }, chain: function (t) { const e = f(this, t); return this.tweens.push(e.init()), e }, getChainedTweens: function (t) { return t.getChainedTweens() }, has: function (t) { return this.tweens.indexOf(t) > -1 }, existing: function (t) { return this.has(t) || this.tweens.push(t.reset()), this }, addCounter: function (t) { const e = o(this, t); return this.tweens.push(e.reset()), e }, stagger: function (t, e) { return l(t, e) }, setLagSmooth: function (t, e) { return void 0 === t && (t = 1 / 1e-8), void 0 === e && (e = 0), this.maxLag = t, this.lagSkip = Math.min(e, this.maxLag), this }, setFps: function (t) { return void 0 === t && (t = 240), this.gap = 1e3 / t, this.nextTime = 1e3 * this.time + this.gap, this }, getDelta: function (t) { const e = Date.now() - this.prevTime; e > this.maxLag && (this.startTime += e - this.lagSkip), this.prevTime += e; let i = this.prevTime - this.startTime; const s = i - this.nextTime; let n = i - 1e3 * this.time; return s > 0 || t ? (i /= 1e3, this.time = i, this.nextTime += s + (s >= this.gap ? 4 : this.gap - s)) : n = 0, n }, tick: function () { return this.step(!0), this }, update: function () { this.paused || this.step(!1) }, step: function (t) { void 0 === t && (t = !1); const e = this.getDelta(t); if (!(e <= 0)) { let i, s; this.processing = !0; const n = []; const r = this.tweens; for (i = 0; i < r.length; i++)(s = r[i]).update(e) && n.push(s); const o = n.length; if (o && r.length > 0) { for (i = 0; i < o; i++) { s = n[i]; const a = r.indexOf(s); a > -1 && (s.isPendingRemove() || s.isDestroyed()) && (r.splice(a, 1), s.destroy()) } n.length = 0 } this.processing = !1 } }, remove: function (t) { return this.processing ? t.setPendingRemoveState() : (s(this.tweens, t), t.setRemovedState()), this }, reset: function (t) { return this.existing(t), t.seek(), t.setActiveState(), this }, makeActive: function (t) { return this.existing(t), t.setActiveState(), this }, each: function (t, e) { let i; const s = [null]; for (i = 1; i < arguments.length; i++)s.push(arguments[i]); return this.tweens.forEach(function (i) { s[0] = i, t.apply(e, s) }), this }, getTweens: function () { return this.tweens.slice() }, getTweensOf: function (t) { for (var e = [], i = this.tweens, s = (t = Array.isArray(t) ? r(t) : [t]).length, n = 0; n < i.length; n++) for (let o = i[n], a = 0; a < s; a++)!o.isDestroyed() && o.hasTarget(t[a]) && e.push(o); return e }, getGlobalTimeScale: function () { return this.timeScale }, setGlobalTimeScale: function (t) { return this.timeScale = t, this }, isTweening: function (t) { for (var e, i = this.tweens, s = 0; s < i.length; s++) if ((e = i[s]).isPlaying() && e.hasTarget(t)) return !0; return !1 }, killAll: function () { for (var t = this.processing ? this.getTweens() : this.tweens, e = 0; e < t.length; e++)t[e].destroy(); return this.processing || (t.length = 0), this }, killTweensOf: function (t) { for (let e = this.getTweensOf(t), i = 0; i < e.length; i++)e[i].destroy(); return this }, pauseAll: function () { return this.paused = !0, this }, resumeAll: function () { return this.paused = !1, this }, shutdown: function () { this.killAll(), this.tweens = [], this.events.off(h.UPDATE, this.update, this), this.events.off(h.SHUTDOWN, this.shutdown, this) }, destroy: function () { this.shutdown(), this.events.off(h.START, this.start, this), this.scene = null, this.events = null } }); a.register('TweenManager', p, 'tweens'), t.exports = p }, 57355: t => { t.exports = function (t, e, i) { return t && t.hasOwnProperty(e) ? t[e] : i } }, 6113: (t, e, i) => { const s = i(62640); const n = i(35355); t.exports = function (t, e) { let i = s.Power0; if (typeof t === 'string') if (s.hasOwnProperty(t)) i = s[t]; else { let r = ''; if (t.indexOf('.')) { const o = (r = t.substring(t.indexOf('.') + 1)).toLowerCase(); o === 'in' ? r = 'easeIn' : o === 'out' ? r = 'easeOut' : o === 'inout' && (r = 'easeInOut') } t = n(t.substring(0, t.indexOf('.') + 1) + r), s.hasOwnProperty(t) && (i = s[t]) } else typeof t === 'function' && (i = t); if (!e) return i; const a = e.slice(0); return a.unshift(0), function (t) { return a[0] = t, i.apply(this, a) } } }, 91389: (t, e, i) => { const s = i(89318); const n = i(77259); const r = { bezier: s, catmull: n, catmullrom: n, linear: i(28392) }; t.exports = function (t) { if (t === null) return null; let e = r.linear; return typeof t === 'string' ? r.hasOwnProperty(t) && (e = r[t]) : typeof t === 'function' && (e = t), e } }, 55292: t => { t.exports = function (t, e, i) { let s; t.hasOwnProperty(e) ? s = typeof t[e] === 'function' ? function (i, s, n, r, o, a) { return t[e](i, s, n, r, o, a) } : function () { return t[e] } : s = typeof i === 'function' ? i : function () { return i }; return s } }, 82985: (t, e, i) => { const s = i(81076); t.exports = function (t) { let e; const i = []; if (t.hasOwnProperty('props')) for (e in t.props) e.substring(0, 1) !== '_' && i.push({ key: e, value: t.props[e] }); else for (e in t) s.indexOf(e) === -1 && e.substring(0, 1) !== '_' && i.push({ key: e, value: t[e] }); return i } }, 62329: (t, e, i) => { const s = i(35154); t.exports = function (t) { let e = s(t, 'targets', null); return e === null || (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e])), e } }, 17777: (t, e, i) => { const s = i(30976); const n = i(99472); function r (t) { return !!t.getActive && typeof t.getActive === 'function' } function o (t) { return !!t.getStart && typeof t.getStart === 'function' } function a (t) { return !!t.getEnd && typeof t.getEnd === 'function' } const h = function (t, e) { let i; let l; let u = function (t, e, i) { return i }; let c = function (t, e, i) { return i }; let d = null; const f = typeof e; if (f === 'number') u = function () { return e }; else if (Array.isArray(e)) c = function () { return e[0] }, u = function () { return e[e.length - 1] }; else if (f === 'string') { let p = e.toLowerCase(); const v = p.substring(0, 6) === 'random'; const g = p.substring(0, 3) === 'int'; if (v || g) { const m = p.indexOf('('); const y = p.indexOf(')'); const x = p.indexOf(','); if (!(m && y && x)) throw new Error('invalid random() format'); const T = parseFloat(p.substring(m + 1, x)); const w = parseFloat(p.substring(x + 1, y)); u = v ? function () { return n(T, w) } : function () { return s(T, w) } } else { p = p[0]; const b = parseFloat(e.substr(2)); switch (p) { case '+': u = function (t, e, i) { return i + b }; break; case '-': u = function (t, e, i) { return i - b }; break; case '*': u = function (t, e, i) { return i * b }; break; case '/': u = function (t, e, i) { return i / b }; break; default: u = function () { return parseFloat(e) } } } } else if (f === 'function') u = e; else if (f === 'object') if (o(l = e) || a(l) || r(l)) r(e) && (d = e.getActive), a(e) && (u = e.getEnd), o(e) && (c = e.getStart); else if (e.hasOwnProperty('value')) i = h(t, e.value); else { const S = e.hasOwnProperty('to'); const E = e.hasOwnProperty('from'); const A = e.hasOwnProperty('start'); if (S && (E || A)) { if (i = h(t, e.to), A) { const C = h(t, e.start); i.getActive = C.getEnd } if (E) { const _ = h(t, e.from); i.getStart = _.getEnd } } } return i || (i = { getActive: d, getEnd: u, getStart: c }), i }; t.exports = h }, 88032: (t, e, i) => { const s = i(70402); const n = i(69902); const r = i(23568); const o = i(57355); const a = i(6113); const h = i(55292); const l = i(35154); const u = i(17777); const c = i(269); const d = i(86081); t.exports = function (t, e, i) { if (e instanceof d) return e.parent = t, e; i = void 0 === i ? n : c(n, i); const f = l(e, 'from', 0); const p = l(e, 'to', 1); const v = [{ value: f }]; const g = l(e, 'delay', i.delay); const m = l(e, 'easeParams', i.easeParams); const y = l(e, 'ease', i.ease); const x = u('value', p); const T = new d(t, v); const w = T.add(0, 'value', x.getEnd, x.getStart, x.getActive, a(l(e, 'ease', y), l(e, 'easeParams', m)), h(e, 'delay', g), l(e, 'duration', i.duration), o(e, 'yoyo', i.yoyo), l(e, 'hold', i.hold), l(e, 'repeat', i.repeat), l(e, 'repeatDelay', i.repeatDelay), !1, !1); w.start = f, w.current = f, T.completeDelay = r(e, 'completeDelay', 0), T.loop = Math.round(r(e, 'loop', 0)), T.loopDelay = Math.round(r(e, 'loopDelay', 0)), T.paused = o(e, 'paused', !1), T.persist = o(e, 'persist', !1), T.callbackScope = l(e, 'callbackScope', T); for (let b = s.TYPES, S = 0; S < b.length; S++) { const E = b[S]; const A = l(e, E, !1); if (A) { const C = l(e, E + 'Params', []); T.setCallback(E, A, C) } } return T } }, 93109: (t, e, i) => { const s = i(6113); const n = i(35154); const r = i(36383); t.exports = function (t, e) { let i; void 0 === e && (e = {}); let o = n(e, 'start', 0); const a = n(e, 'ease', null); const h = n(e, 'grid', null); const l = n(e, 'from', 0); const u = l === 'first'; const c = l === 'center'; const d = l === 'last'; const f = typeof l === 'number'; const p = Array.isArray(t); const v = p ? parseFloat(t[0]) : parseFloat(t); const g = p ? parseFloat(t[1]) : 0; const m = Math.max(v, g); if (p && (o += v), h) { var y = h[0]; var x = h[1]; let T = 0; let w = 0; let b = 0; let S = 0; var E = []; d ? (T = y - 1, w = x - 1) : f ? (T = l % y, w = Math.floor(l / y)) : c && (T = (y - 1) / 2, w = (x - 1) / 2); for (var A = r.MIN_SAFE_INTEGER, C = 0; C < x; C++) { E[C] = []; for (let _ = 0; _ < y; _++) { b = T - _, S = w - C; const M = Math.sqrt(b * b + S * S); M > A && (A = M), E[C][_] = M } } } const P = a ? s(a) : null; return i = h ? function (t, e, i, s) { let n; let r = 0; const a = s % y; const h = Math.floor(s / y); if (a >= 0 && a < y && h >= 0 && h < x && (r = E[h][a]), p) { const l = g - v; n = P ? r / A * l * P(r / A) : r / A * l } else n = P ? r * v * P(r / A) : r * v; return n + o } : function (t, e, i, s, n) { let r, a, h; (n--, u ? r = s : c ? r = Math.abs(n / 2 - s) : d ? r = n - s : f && (r = Math.abs(l - s)), p) ? (h = c ? (g - v) / n * (2 * r) : (g - v) / n * r, a = P ? h * P(r / n) : h) : a = P ? n * m * P(r / n) : r * v; return a + o }, i } }, 8357: (t, e, i) => { const s = i(70402); const n = i(69902); const r = i(23568); const o = i(57355); const a = i(6113); const h = i(91389); const l = i(55292); const u = i(82985); const c = i(62329); const d = i(35154); const f = i(17777); const p = i(269); const v = i(86081); t.exports = function (t, e, i) { if (e instanceof v) return e.parent = t, e; i = void 0 === i ? n : p(n, i); let g = c(e); !g && i.targets && (g = i.targets); for (var m = u(e), y = d(e, 'delay', i.delay), x = d(e, 'duration', i.duration), T = d(e, 'easeParams', i.easeParams), w = d(e, 'ease', i.ease), b = d(e, 'hold', i.hold), S = d(e, 'repeat', i.repeat), E = d(e, 'repeatDelay', i.repeatDelay), A = o(e, 'yoyo', i.yoyo), C = o(e, 'flipX', i.flipX), _ = o(e, 'flipY', i.flipY), M = d(e, 'interpolation', i.interpolation), P = function (t, e, i, s) { if (i === 'texture') { let n = s; let r = void 0; Array.isArray(s) ? (n = s[0], r = s[1]) : s.hasOwnProperty('value') ? (n = s.value, Array.isArray(s.value) ? (n = s.value[0], r = s.value[1]) : typeof s.value === 'string' && (n = s.value)) : typeof s === 'string' && (n = s), t.addFrame(e, n, r, l(s, 'delay', y), d(s, 'duration', x), d(s, 'hold', b), d(s, 'repeat', S), d(s, 'repeatDelay', E), o(s, 'flipX', C), o(s, 'flipY', _)) } else { const u = f(i, s); const c = h(d(s, 'interpolation', M)); t.add(e, i, u.getEnd, u.getStart, u.getActive, a(d(s, 'ease', w), d(s, 'easeParams', T)), l(s, 'delay', y), d(s, 'duration', x), o(s, 'yoyo', A), d(s, 'hold', b), d(s, 'repeat', S), d(s, 'repeatDelay', E), o(s, 'flipX', C), o(s, 'flipY', _), c, c ? s : null) } }, R = new v(t, g), L = 0; L < m.length; L++) for (let O = m[L].key, F = m[L].value, D = 0; D < g.length; D++)O !== 'scale' || g[D].hasOwnProperty('scale') ? P(R, D, O, F) : (P(R, D, 'scaleX', F), P(R, D, 'scaleY', F)); R.completeDelay = r(e, 'completeDelay', 0), R.loop = Math.round(r(e, 'loop', 0)), R.loopDelay = Math.round(r(e, 'loopDelay', 0)), R.paused = o(e, 'paused', !1), R.persist = o(e, 'persist', !1), R.callbackScope = d(e, 'callbackScope', R); for (let k = s.TYPES, I = 0; I < k.length; I++) { const B = k[I]; const N = d(e, B, !1); if (N) { const U = d(e, B + 'Params', []); R.setCallback(B, N, U) } } return R } }, 26012: (t, e, i) => { const s = i(70402); const n = i(23568); const r = i(57355); const o = i(62329); const a = i(35154); const h = i(8357); const l = i(43960); t.exports = function (t, e) { if (e instanceof l) return e.parent = t, e; let i; const u = new l(t); u.startDelay = a(e, 'delay', 0), u.completeDelay = n(e, 'completeDelay', 0), u.loop = Math.round(n(e, 'loop', a(e, 'repeat', 0))), u.loopDelay = Math.round(n(e, 'loopDelay', a(e, 'repeatDelay', 0))), u.paused = r(e, 'paused', !1), u.persist = r(e, 'persist', !1), u.callbackScope = a(e, 'callbackScope', u); const c = s.TYPES; for (i = 0; i < c.length; i++) { const d = c[i]; const f = a(e, d, !1); if (f) { const p = a(e, d + 'Params', []); u.setCallback(d, f, p) } } const v = a(e, 'tweens', null); if (Array.isArray(v)) { const g = []; const m = o(e); let y = void 0; for (m && (y = { targets: m }), i = 0; i < v.length; i++)g.push(h(u, v[i], y)); u.add(g) } return u } }, 30231: (t, e, i) => { t.exports = { GetBoolean: i(57355), GetEaseFunction: i(6113), GetInterpolationFunction: i(91389), GetNewValue: i(55292), GetProps: i(82985), GetTargets: i(62329), GetValueOp: i(17777), NumberTweenBuilder: i(88032), StaggerBuilder: i(93109), TweenBuilder: i(8357) } }, 73685: t => { t.exports = 'active' }, 98540: t => { t.exports = 'complete' }, 67233: t => { t.exports = 'loop' }, 2859: t => { t.exports = 'pause' }, 98336: t => { t.exports = 'repeat' }, 25764: t => { t.exports = 'resume' }, 32193: t => { t.exports = 'start' }, 84371: t => { t.exports = 'stop' }, 70766: t => { t.exports = 'update' }, 55659: t => { t.exports = 'yoyo' }, 842: (t, e, i) => { t.exports = { TWEEN_ACTIVE: i(73685), TWEEN_COMPLETE: i(98540), TWEEN_LOOP: i(67233), TWEEN_PAUSE: i(2859), TWEEN_RESUME: i(25764), TWEEN_REPEAT: i(98336), TWEEN_START: i(32193), TWEEN_STOP: i(84371), TWEEN_UPDATE: i(70766), TWEEN_YOYO: i(55659) } }, 43066: (t, e, i) => { const s = { States: i(86353), Builders: i(30231), Events: i(842), TweenManager: i(40382), Tween: i(86081), TweenData: i(48177), TweenFrameData: i(42220), BaseTween: i(70402), TweenChain: i(43960) }; t.exports = s }, 70402: (t, e, i) => { const s = i(83419); const n = i(50792); const r = i(842); const o = i(86353); const a = new s({ Extends: n, initialize: function (t) { n.call(this), this.parent = t, this.data = [], this.totalData = 0, this.startDelay = 0, this.hasStarted = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = o.PENDING, this.paused = !1, this.callbacks = { onActive: null, onComplete: null, onLoop: null, onPause: null, onRepeat: null, onResume: null, onStart: null, onStop: null, onUpdate: null, onYoyo: null }, this.callbackScope, this.persist = !1 }, setTimeScale: function (t) { return this.timeScale = t, this }, getTimeScale: function () { return this.timeScale }, isPlaying: function () { return !this.paused && this.isActive() }, isPaused: function () { return this.paused }, pause: function () { return this.paused || (this.paused = !0, this.dispatchEvent(r.TWEEN_PAUSE, 'onPause')), this }, resume: function () { return this.paused && (this.paused = !1, this.dispatchEvent(r.TWEEN_RESUME, 'onResume')), this }, makeActive: function () { this.parent.makeActive(this), this.dispatchEvent(r.TWEEN_ACTIVE, 'onActive') }, onCompleteHandler: function () { this.setPendingRemoveState(), this.dispatchEvent(r.TWEEN_COMPLETE, 'onComplete') }, complete: function (t) { return void 0 === t && (t = 0), t ? (this.setCompleteDelayState(), this.countdown = t) : this.onCompleteHandler(), this }, completeAfterLoop: function (t) { return void 0 === t && (t = 0), this.loopCounter > t && (this.loopCounter = t), this }, remove: function () { return this.parent && this.parent.remove(this), this }, stop: function () { return !this.parent || this.isRemoved() || this.isPendingRemove() || this.isDestroyed() || (this.dispatchEvent(r.TWEEN_STOP, 'onStop'), this.setPendingRemoveState()), this }, updateLoopCountdown: function (t) { this.countdown -= t, this.countdown <= 0 && (this.setActiveState(), this.dispatchEvent(r.TWEEN_LOOP, 'onLoop')) }, updateStartCountdown: function (t) { return this.countdown -= t, this.countdown <= 0 && (this.hasStarted = !0, this.setActiveState(), this.dispatchEvent(r.TWEEN_START, 'onStart'), t = 0), t }, updateCompleteDelay: function (t) { this.countdown -= t, this.countdown <= 0 && this.onCompleteHandler() }, setCallback: function (t, e, i) { return void 0 === i && (i = []), this.callbacks.hasOwnProperty(t) && (this.callbacks[t] = { func: e, params: i }), this }, setPendingState: function () { this.state = o.PENDING }, setActiveState: function () { this.state = o.ACTIVE }, setLoopDelayState: function () { this.state = o.LOOP_DELAY }, setCompleteDelayState: function () { this.state = o.COMPLETE_DELAY }, setStartDelayState: function () { this.state = o.START_DELAY, this.countdown = this.startDelay, this.hasStarted = !1 }, setPendingRemoveState: function () { this.state = o.PENDING_REMOVE }, setRemovedState: function () { this.state = o.REMOVED }, setFinishedState: function () { this.state = o.FINISHED }, setDestroyedState: function () { this.state = o.DESTROYED }, isPending: function () { return this.state === o.PENDING }, isActive: function () { return this.state === o.ACTIVE }, isLoopDelayed: function () { return this.state === o.LOOP_DELAY }, isCompleteDelayed: function () { return this.state === o.COMPLETE_DELAY }, isStartDelayed: function () { return this.state === o.START_DELAY }, isPendingRemove: function () { return this.state === o.PENDING_REMOVE }, isRemoved: function () { return this.state === o.REMOVED }, isFinished: function () { return this.state === o.FINISHED }, isDestroyed: function () { return this.state === o.DESTROYED }, destroy: function () { this.data && this.data.forEach(function (t) { t.destroy() }), this.removeAllListeners(), this.callbacks = null, this.data = null, this.parent = null, this.setDestroyedState() } }); a.TYPES = ['onActive', 'onComplete', 'onLoop', 'onPause', 'onRepeat', 'onResume', 'onStart', 'onStop', 'onUpdate', 'onYoyo'], t.exports = a }, 95042: (t, e, i) => { const s = i(83419); const n = i(842); const r = i(86353); const o = new s({ initialize: function (t, e, i, s, n, r, o, a, h, l) { this.tween = t, this.targetIndex = e, this.duration = s, this.totalDuration = 0, this.delay = 0, this.getDelay = i, this.yoyo = n, this.hold = r, this.repeat = o, this.repeatDelay = a, this.repeatCounter = 0, this.flipX = h, this.flipY = l, this.progress = 0, this.elapsed = 0, this.state = 0, this.isCountdown = !1 }, getTarget: function () { return this.tween.targets[this.targetIndex] }, setTargetValue: function (t) { void 0 === t && (t = this.current), this.tween.targets[this.targetIndex][this.key] = t }, setCreatedState: function () { this.state = r.CREATED, this.isCountdown = !1 }, setDelayState: function () { this.state = r.DELAY, this.isCountdown = !0 }, setPendingRenderState: function () { this.state = r.PENDING_RENDER, this.isCountdown = !1 }, setPlayingForwardState: function () { this.state = r.PLAYING_FORWARD, this.isCountdown = !1 }, setPlayingBackwardState: function () { this.state = r.PLAYING_BACKWARD, this.isCountdown = !1 }, setHoldState: function () { this.state = r.HOLD_DELAY, this.isCountdown = !0 }, setRepeatState: function () { this.state = r.REPEAT_DELAY, this.isCountdown = !0 }, setCompleteState: function () { this.state = r.COMPLETE, this.isCountdown = !1 }, isCreated: function () { return this.state === r.CREATED }, isDelayed: function () { return this.state === r.DELAY }, isPendingRender: function () { return this.state === r.PENDING_RENDER }, isPlayingForward: function () { return this.state === r.PLAYING_FORWARD }, isPlayingBackward: function () { return this.state === r.PLAYING_BACKWARD }, isHolding: function () { return this.state === r.HOLD_DELAY }, isRepeating: function () { return this.state === r.REPEAT_DELAY }, isComplete: function () { return this.state === r.COMPLETE }, setStateFromEnd: function (t) { this.yoyo ? this.onRepeat(t, !0, !0) : this.repeatCounter > 0 ? this.onRepeat(t, !0, !1) : this.setCompleteState() }, setStateFromStart: function (t) { this.repeatCounter > 0 ? this.onRepeat(t, !1) : this.setCompleteState() }, reset: function () { const t = this.tween; const e = t.totalTargets; const i = this.targetIndex; const s = t.targets[i]; const n = this.key; this.progress = 0, this.elapsed = 0, this.delay = this.getDelay(s, n, 0, i, e, t), this.repeatCounter = this.repeat === -1 ? r.MAX : this.repeat, this.setPendingRenderState(); let o = this.duration + this.hold; this.yoyo && (o += this.duration); const a = o + this.repeatDelay; this.totalDuration = this.delay + o, this.repeat === -1 ? (this.totalDuration += a * r.MAX, t.isInfinite = !0) : this.repeat > 0 && (this.totalDuration += a * this.repeat), this.totalDuration > t.duration && (t.duration = this.totalDuration), this.delay < t.startDelay && (t.startDelay = this.delay), this.delay > 0 && (this.elapsed = this.delay, this.setDelayState()) }, onRepeat: function (t, e, i) { const s = this.tween; const r = s.totalTargets; const o = this.targetIndex; const a = s.targets[o]; const h = this.key; const l = h !== 'texture'; if (this.elapsed = t, this.progress = t / this.duration, this.flipX && a.toggleFlipX(), this.flipY && a.toggleFlipY(), l && (e || i) && (this.start = this.getStartValue(a, h, this.start, o, r, s)), i) return this.setPlayingBackwardState(), void this.dispatchEvent(n.TWEEN_YOYO, 'onYoyo'); this.repeatCounter--, l && (this.end = this.getEndValue(a, h, this.start, o, r, s)), this.repeatDelay > 0 ? (this.elapsed = this.repeatDelay - t, l && (this.current = this.start, a[h] = this.current), this.setRepeatState()) : (this.setPlayingForwardState(), this.dispatchEvent(n.TWEEN_REPEAT, 'onRepeat')) }, destroy: function () { this.tween = null, this.getDelay = null, this.setCompleteState() } }); t.exports = o }, 69902: t => { t.exports = { targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1, persist: !1, interpolation: null } }, 81076: t => { t.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'interpolation', 'loop', 'loopDelay', 'onActive', 'onActiveParams', 'onComplete', 'onCompleteParams', 'onLoop', 'onLoopParams', 'onPause', 'onPauseParams', 'onRepeat', 'onRepeatParams', 'onResume', 'onResumeParams', 'onStart', 'onStartParams', 'onStop', 'onStopParams', 'onUpdate', 'onUpdateParams', 'onYoyo', 'onYoyoParams', 'paused', 'persist', 'props', 'repeat', 'repeatDelay', 'targets', 'yoyo'] }, 86081: (t, e, i) => { const s = i(70402); const n = i(83419); const r = i(842); const o = i(44603); const a = i(39429); const h = i(36383); const l = i(86353); const u = i(48177); const c = i(42220); const d = new n({ Extends: s, initialize: function (t, e) { s.call(this, t), this.targets = e, this.totalTargets = e.length, this.isSeeking = !1, this.isInfinite = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0 }, add: function (t, e, i, s, n, r, o, a, h, l, c, d, f, p, v, g) { const m = new u(this, t, e, i, s, n, r, o, a, h, l, c, d, f, p, v, g); return this.totalData = this.data.push(m), m }, addFrame: function (t, e, i, s, n, r, o, a, h, l) { const u = new c(this, t, e, i, s, n, r, o, a, h, l); return this.totalData = this.data.push(u), u }, getValue: function (t) { void 0 === t && (t = 0); let e = null; return this.data && (e = this.data[t].current), e }, hasTarget: function (t) { return this.targets && this.targets.indexOf(t) !== -1 }, updateTo: function (t, e, i) { if (void 0 === i && (i = !1), t !== 'texture') for (let s = 0; s < this.totalData; s++) { const n = this.data[s]; n.key === t && (n.isPlayingForward() || n.isPlayingBackward()) && (n.end = e, i && (n.start = n.current)) } return this }, restart: function () { switch (this.state) { case l.REMOVED: case l.FINISHED: this.seek(), this.parent.makeActive(this); break; case l.PENDING: case l.PENDING_REMOVE: this.parent.reset(this); break; case l.DESTROYED: console.warn('Cannot restart destroyed Tween', this); break; default: this.seek() } return this.paused = !1, this.hasStarted = !1, this }, nextState: function () { if (this.loopCounter > 0) this.elapsed = 0, this.progress = 0, this.loopCounter--, this.initTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.setLoopDelayState()) : (this.setActiveState(), this.dispatchEvent(r.TWEEN_LOOP, 'onLoop')); else { if (!(this.completeDelay > 0)) return this.onCompleteHandler(), !0; this.countdown = this.completeDelay, this.setCompleteDelayState() } return !1 }, onCompleteHandler: function () { this.progress = 1, this.totalProgress = 1, s.prototype.onCompleteHandler.call(this) }, play: function () { return this.isDestroyed() ? (console.warn('Cannot play destroyed Tween', this), this) : ((this.isPendingRemove() || this.isFinished()) && this.seek(), this.paused = !1, this.setActiveState(), this) }, seek: function (t, e, i) { if (void 0 === t && (t = 0), void 0 === e && (e = 16.6), void 0 === i && (i = !1), this.isDestroyed()) return console.warn('Cannot seek destroyed Tween', this), this; i || (this.isSeeking = !0), this.reset(!0), this.initTweenData(!0), this.setActiveState(), this.dispatchEvent(r.TWEEN_ACTIVE, 'onActive'); const s = this.paused; if (this.paused = !1, t > 0) { for (var n = Math.floor(t / e), o = t - n * e, a = 0; a < n; a++) this.update(e); o > 0 && this.update(o) } return this.paused = s, this.isSeeking = !1, this }, initTweenData: function (t) { void 0 === t && (t = !1), this.duration = 0, this.startDelay = h.MAX_SAFE_INTEGER; for (let e = this.data, i = 0; i < this.totalData; i++)e[i].reset(t); this.duration = Math.max(this.duration, 0.01); const s = this.duration; const n = this.completeDelay; const r = this.loopCounter; const o = this.loopDelay; this.totalDuration = r > 0 ? s + n + (s + o) * r : s + n }, reset: function (t) { return void 0 === t && (t = !1), this.elapsed = 0, this.totalElapsed = 0, this.progress = 0, this.totalProgress = 0, this.loopCounter = this.loop, this.loop === -1 && (this.isInfinite = !0, this.loopCounter = l.MAX), t || (this.initTweenData(), this.setActiveState(), this.dispatchEvent(r.TWEEN_ACTIVE, 'onActive')), this }, update: function (t) { if (this.isPendingRemove() || this.isDestroyed()) return !0; if (this.paused || this.isFinished()) return !1; if (t *= this.timeScale * this.parent.timeScale, this.isLoopDelayed()) return this.updateLoopCountdown(t), !1; if (this.isCompleteDelayed()) return this.updateCompleteDelay(t), !1; this.hasStarted || (this.startDelay -= t, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchEvent(r.TWEEN_START, 'onStart'), t = 0)); let e = !1; if (this.isActive()) for (let i = this.data, s = 0; s < this.totalData; s++)i[s].update(t) && (e = !0); this.elapsed += t, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += t, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), e || this.nextState(); let n = this.isPendingRemove(); return n && this.persist && (this.setFinishedState(), n = !1), n }, forward: function (t) { return this.update(t), this }, rewind: function (t) { return this.update(-t), this }, dispatchEvent: function (t, e) { if (!this.isSeeking) { this.emit(t, this, this.targets); const i = this.callbacks[e]; i && i.func.apply(this.callbackScope, [this, this.targets].concat(i.params)) } }, destroy: function () { s.prototype.destroy.call(this), this.targets = null } }); a.register('tween', function (t) { return this.scene.sys.tweens.add(t) }), o.register('tween', function (t) { return this.scene.sys.tweens.create(t) }), t.exports = d }, 43960: (t, e, i) => { const s = i(72905); const n = i(70402); const r = i(83419); const o = i(842); const a = i(44603); const h = i(39429); const l = i(86353); const u = new r({ Extends: n, initialize: function (t) { n.call(this, t), this.currentTween = null, this.currentIndex = 0 }, init: function () { return this.loopCounter = this.loop === -1 ? l.MAX : this.loop, this.setCurrentTween(0), this.startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(), this.dispatchEvent(o.TWEEN_ACTIVE, 'onActive'), this }, add: function (t) { let e = this.parent.create(t); Array.isArray(e) || (e = [e]); for (var i = this.data, s = 0; s < e.length; s++) { const n = e[s]; n.parent = this, i.push(n.reset()) } return this.totalData = i.length, this }, remove: function (t) { return s(this.data, t), t.setRemovedState(), t === this.currentTween && this.nextTween(), this.totalData = this.data.length, this }, hasTarget: function (t) { for (let e = this.data, i = 0; i < this.totalData; i++) if (e[i].hasTarget(t)) return !0; return !1 }, restart: function () { return this.isDestroyed() ? (console.warn('Cannot restart destroyed TweenChain', this), this) : (this.isRemoved() && this.parent.makeActive(this), this.resetTweens(), this.paused = !1, this.init()) }, reset: function (t) { return t.seek(), t.setActiveState(), this }, makeActive: function (t) { return t.reset(), t.setActiveState(), this }, nextState: function () { if (this.loopCounter > 0) this.loopCounter--, this.resetTweens(), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.setLoopDelayState()) : (this.setActiveState(), this.dispatchEvent(o.TWEEN_LOOP, 'onLoop')); else { if (!(this.completeDelay > 0)) return this.onCompleteHandler(), !0; this.countdown = this.completeDelay, this.setCompleteDelayState() } return !1 }, play: function () { return this.isDestroyed() ? (console.warn('Cannot play destroyed TweenChain', this), this) : ((this.isPendingRemove() || this.isPending()) && this.resetTweens(), this.paused = !1, this.startDelay > 0 && !this.isStartDelayed() ? this.setStartDelayState() : this.setActiveState(), this) }, resetTweens: function () { for (var t = this.data, e = this.totalData, i = 0; i < e; i++)t[i].reset(!1); this.currentIndex = 0, this.currentTween = t[0] }, update: function (t) { if (this.isPendingRemove() || this.isDestroyed()) return !0; if (this.isFinished() || this.paused) return !1; t *= this.parent.timeScale, this.isLoopDelayed() ? this.updateLoopCountdown(t) : this.isCompleteDelayed() ? this.updateCompleteDelay(t) : this.isStartDelayed() && (t = this.updateStartCountdown(t)); let e = !1; return this.isActive() && this.currentTween && (this.currentTween.update(t) && this.nextTween() && this.nextState(), (e = this.isPendingRemove()) && this.persist && (this.setFinishedState(), e = !1)), e }, nextTween: function () { return this.currentIndex++, this.currentIndex === this.totalData || (this.setCurrentTween(this.currentIndex), !1) }, setCurrentTween: function (t) { this.currentIndex = t, this.currentTween = this.data[t], this.currentTween.setActiveState(), this.currentTween.dispatchEvent(o.TWEEN_ACTIVE, 'onActive') }, dispatchEvent: function (t, e) { this.emit(t, this); const i = this.callbacks[e]; i && i.func.apply(this.callbackScope, [this].concat(i.params)) }, destroy: function () { n.prototype.destroy.call(this), this.currentTween = null } }); h.register('tweenchain', function (t) { return this.scene.sys.tweens.chain(t) }), a.register('tweenchain', function (t) { return this.scene.sys.tweens.create(t) }), t.exports = u }, 48177: (t, e, i) => { const s = i(95042); const n = i(45319); const r = i(83419); const o = i(842); const a = new r({ Extends: s, initialize: function (t, e, i, n, r, o, a, h, l, u, c, d, f, p, v, g, m) { s.call(this, t, e, h, l, u, c, d, f, p, v), this.key = i, this.getActiveValue = o, this.getEndValue = n, this.getStartValue = r, this.ease = a, this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.interpolation = g, this.interpolationData = m }, reset: function (t) { s.prototype.reset.call(this); const e = this.tween.targets[this.targetIndex]; const i = this.key; t && (e[i] = this.start), this.start = 0, this.previous = 0, this.current = 0, this.end = 0, this.getActiveValue && (e[i] = this.getActiveValue(e, i, 0)) }, update: function (t) { const e = this.tween; const i = e.totalTargets; const s = this.targetIndex; const r = e.targets[s]; const a = this.key; if (!r) return this.setCompleteState(), !1; if (this.isCountdown && (this.elapsed -= t, this.elapsed <= 0 && (this.elapsed = 0, t = 0, this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(), this.dispatchEvent(o.TWEEN_REPEAT, 'onRepeat')) : this.isHolding() && this.setStateFromEnd(0))), this.isPendingRender()) return this.start = this.getStartValue(r, a, r[a], s, i, e), this.end = this.getEndValue(r, a, this.start, s, i, e), this.current = this.start, r[a] = this.start, this.setPlayingForwardState(), !0; const h = this.isPlayingForward(); const l = this.isPlayingBackward(); if (h || l) { let u = this.elapsed; const c = this.duration; let d = 0; let f = !1; (u += t) >= c ? (d = u - c, u = c, f = !0) : u < 0 && (u = 0); let p = n(u / c, 0, 1); if (this.elapsed = u, this.progress = p, this.previous = this.current, f) h ? (this.current = this.end, r[a] = this.end, this.hold > 0 ? (this.elapsed = this.hold, this.setHoldState()) : this.setStateFromEnd(d)) : (this.current = this.start, r[a] = this.start, this.setStateFromStart(d)); else { h || (p = 1 - p); const v = this.ease(p); this.interpolation ? this.current = this.interpolation(this.interpolationData, v) : this.current = this.start + (this.end - this.start) * v, r[a] = this.current } this.dispatchEvent(o.TWEEN_UPDATE, 'onUpdate') } return !this.isComplete() }, dispatchEvent: function (t, e) { const i = this.tween; if (!i.isSeeking) { const s = i.targets[this.targetIndex]; const n = this.key; const r = this.current; const o = this.previous; i.emit(t, i, n, s, r, o); const a = i.callbacks[e]; a && a.func.apply(i.callbackScope, [i, s, n, r, o].concat(a.params)) } }, destroy: function () { s.prototype.destroy.call(this), this.getActiveValue = null, this.getEndValue = null, this.getStartValue = null, this.ease = null } }); t.exports = a }, 42220: (t, e, i) => { const s = i(95042); const n = i(45319); const r = i(83419); const o = i(842); const a = new r({ Extends: s, initialize: function (t, e, i, n, r, o, a, h, l, u, c) { s.call(this, t, e, r, o, !1, a, h, l, u, c), this.key = 'texture', this.startTexture = null, this.endTexture = i, this.startFrame = null, this.endFrame = n, this.yoyo = h !== 0 }, reset: function (t) { s.prototype.reset.call(this); const e = this.tween.targets[this.targetIndex]; this.startTexture || (this.startTexture = e.texture.key, this.startFrame = e.frame.name), t && e.setTexture(this.startTexture, this.startFrame) }, update: function (t) { const e = this.tween; const i = this.targetIndex; const s = e.targets[i]; if (!s) return this.setCompleteState(), !1; if (this.isCountdown && (this.elapsed -= t, this.elapsed <= 0 && (this.elapsed = 0, t = 0, this.isDelayed() ? this.setPendingRenderState() : this.isRepeating() ? (this.setPlayingForwardState(), this.dispatchEvent(o.TWEEN_REPEAT, 'onRepeat')) : this.isHolding() && this.setStateFromEnd(0))), this.isPendingRender()) return this.startTexture && s.setTexture(this.startTexture, this.startFrame), this.setPlayingForwardState(), !0; const r = this.isPlayingForward(); const a = this.isPlayingBackward(); if (r || a) { let h = this.elapsed; const l = this.duration; let u = 0; let c = !1; (h += t) >= l ? (u = h - l, h = l, c = !0) : h < 0 && (h = 0); const d = n(h / l, 0, 1); this.elapsed = h, this.progress = d, c && (r ? (s.setTexture(this.endTexture, this.endFrame), this.hold > 0 ? (this.elapsed = this.hold, this.setHoldState()) : this.setStateFromEnd(u)) : (s.setTexture(this.startTexture, this.startFrame), this.setStateFromStart(u))), this.dispatchEvent(o.TWEEN_UPDATE, 'onUpdate') } return !this.isComplete() }, dispatchEvent: function (t, e) { const i = this.tween; if (!i.isSeeking) { const s = i.targets[this.targetIndex]; const n = this.key; i.emit(t, i, n, s); const r = i.callbacks[e]; r && r.func.apply(i.callbackScope, [i, s, n].concat(r.params)) } }, destroy: function () { s.prototype.destroy.call(this), this.startTexture = null, this.endTexture = null, this.startFrame = null, this.endFrame = null } }); t.exports = a }, 86353: t => { t.exports = { CREATED: 0, DELAY: 2, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING: 20, ACTIVE: 21, LOOP_DELAY: 22, COMPLETE_DELAY: 23, START_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26, FINISHED: 27, DESTROYED: 28, MAX: 999999999999 } }, 83419: t => { function e (t, e, i) { let s = i ? t[e] : Object.getOwnPropertyDescriptor(t, e); return !i && s.value && typeof s.value === 'object' && (s = s.value), !(!s || !(function (t) { return !!t.get && typeof t.get === 'function' || !!t.set && typeof t.set === 'function' }(s))) && (void 0 === s.enumerable && (s.enumerable = !0), void 0 === s.configurable && (s.configurable = !0), s) } function i (t, e) { let i = Object.getOwnPropertyDescriptor(t, e); return !!i && (i.value && typeof i.value === 'object' && (i = i.value), !1 === i.configurable) } function s (t, s, n, o) { for (const a in s) if (s.hasOwnProperty(a)) { const h = e(s, a, n); if (!1 !== h) { if (i((o || t).prototype, a)) { if (r.ignoreFinals) continue; throw new Error("cannot override final property '" + a + "', set Class.ignoreFinals = true to skip") } Object.defineProperty(t.prototype, a, h) } else t.prototype[a] = s[a] } } function n (t, e) { if (e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)s(t, e[i].prototype || e[i]) } } function r (t) { let e, i; if (t || (t = {}), t.initialize) { if (typeof t.initialize !== 'function') throw new Error('initialize must be a function'); e = t.initialize, delete t.initialize } else if (t.Extends) { const r = t.Extends; e = function () { r.apply(this, arguments) } } else e = function () { }; t.Extends ? (e.prototype = Object.create(t.Extends.prototype), e.prototype.constructor = e, i = t.Extends, delete t.Extends) : e.prototype.constructor = e; let o = null; return t.Mixins && (o = t.Mixins, delete t.Mixins), n(e, o), s(e, t, !0, i), e } r.extend = s, r.mixin = n, r.ignoreFinals = !1, t.exports = r }, 29747: t => { t.exports = function () { } }, 20242: t => { t.exports = function () { return null } }, 71146: t => { t.exports = function (t, e, i, s, n) { if (void 0 === n && (n = t), i > 0) { var r = i - t.length; if (r <= 0) return null } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.push(e), s && s.call(n, e), e) : null; for (var o = e.length - 1; o >= 0;)t.indexOf(e[o]) !== -1 && e.splice(o, 1), o--; if ((o = e.length) === 0) return null; i > 0 && o > r && (e.splice(r), o = r); for (let a = 0; a < o; a++) { const h = e[a]; t.push(h), s && s.call(n, h) } return e } }, 51067: t => { t.exports = function (t, e, i, s, n, r) { if (void 0 === i && (i = 0), void 0 === r && (r = t), s > 0) { var o = s - t.length; if (o <= 0) return null } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.splice(i, 0, e), n && n.call(r, e), e) : null; for (var a = e.length - 1; a >= 0;)t.indexOf(e[a]) !== -1 && e.pop(), a--; if ((a = e.length) === 0) return null; s > 0 && a > o && (e.splice(o), a = o); for (let h = a - 1; h >= 0; h--) { const l = e[h]; t.splice(i, 0, l), n && n.call(r, l) } return e } }, 66905: t => { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i < t.length && (t.splice(i, 1), t.push(e)), e } }, 21612: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { void 0 === n && (n = 0), void 0 === r && (r = t.length); let o = 0; if (s(t, n, r)) for (let a = n; a < r; a++) { t[a][e] === i && o++ } return o } }, 95428: t => { t.exports = function (t, e, i) { let s; const n = [null]; for (s = 3; s < arguments.length; s++)n.push(arguments[s]); for (s = 0; s < t.length; s++)n[0] = t[s], e.apply(i, n); return t } }, 36914: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { if (void 0 === n && (n = 0), void 0 === r && (r = t.length), s(t, n, r)) { let o; const a = [null]; for (o = 5; o < arguments.length; o++)a.push(arguments[o]); for (o = n; o < r; o++)a[0] = t[o], e.apply(i, a) } return t } }, 81957: t => { t.exports = function (t, e, i) { if (!e.length) return NaN; if (e.length === 1) return e[0]; let s; let n; let r = 1; if (i) { if (t < e[0][i]) return e[0]; for (; e[r][i] < t;)r++ } else for (; e[r] < t;)r++; return r > e.length && (r = e.length), i ? (s = e[r - 1][i], (n = e[r][i]) - t <= t - s ? e[r] : e[r - 1]) : (s = e[r - 1], (n = e[r]) - t <= t - s ? n : s) } }, 43491: t => { const e = function (t, i) { void 0 === i && (i = []); for (let s = 0; s < t.length; s++)Array.isArray(t[s]) ? e(t[s], i) : i.push(t[s]); return i }; t.exports = e }, 46710: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { void 0 === n && (n = 0), void 0 === r && (r = t.length); const o = []; if (s(t, n, r)) for (let a = n; a < r; a++) { const h = t[a]; (!e || e && void 0 === i && h.hasOwnProperty(e) || e && void 0 !== i && h[e] === i) && o.push(h) } return o } }, 58731: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { if (void 0 === n && (n = 0), void 0 === r && (r = t.length), s(t, n, r)) for (let o = n; o < r; o++) { const a = t[o]; if (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) return a } return null } }, 26546: t => { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const s = e + Math.floor(Math.random() * i); return void 0 === t[s] ? null : t[s] } }, 85835: t => { t.exports = function (t, e, i) { if (e === i) return t; const s = t.indexOf(e); const n = t.indexOf(i); if (s < 0 || n < 0) throw new Error('Supplied items must be elements of the same array'); return s > n || (t.splice(s, 1), n === t.length - 1 ? t.push(e) : t.splice(n, 0, e)), t } }, 83371: t => { t.exports = function (t, e, i) { if (e === i) return t; const s = t.indexOf(e); const n = t.indexOf(i); if (s < 0 || n < 0) throw new Error('Supplied items must be elements of the same array'); return s < n || (t.splice(s, 1), n === 0 ? t.unshift(e) : t.splice(n, 0, e)), t } }, 70864: t => { t.exports = function (t, e) { const i = t.indexOf(e); if (i > 0) { const s = t[i - 1]; const n = t.indexOf(s); t[i] = s, t[n] = e } return t } }, 69693: t => { t.exports = function (t, e, i) { const s = t.indexOf(e); if (s === -1 || i < 0 || i >= t.length) throw new Error('Supplied index out of bounds'); return s !== i && (t.splice(s, 1), t.splice(i, 0, e)), e } }, 40853: t => { t.exports = function (t, e) { const i = t.indexOf(e); if (i !== -1 && i < t.length - 1) { const s = t[i + 1]; const n = t.indexOf(s); t[i] = s, t[n] = e } return t } }, 20283: t => { t.exports = function (t, e, i, s) { let n; const r = []; let o = !1; if ((i || s) && (o = !0, i || (i = ''), s || (s = '')), e < t) for (n = t; n >= e; n--)o ? r.push(i + n.toString() + s) : r.push(n); else for (n = t; n <= e; n++)o ? r.push(i + n.toString() + s) : r.push(n); return r } }, 593: (t, e, i) => { const s = i(2284); t.exports = function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), e === null && (e = t, t = 0); for (var n = [], r = Math.max(s((e - t) / (i || 1)), 0), o = 0; o < r; o++)n.push(t), t += i; return n } }, 43886: t => { function e (t, e, i) { const s = t[e]; t[e] = t[i], t[i] = s } function i (t, e) { return t < e ? -1 : t > e ? 1 : 0 } const s = function (t, n, r, o, a) { for (void 0 === r && (r = 0), void 0 === o && (o = t.length - 1), void 0 === a && (a = i); o > r;) { if (o - r > 600) { const h = o - r + 1; const l = n - r + 1; const u = Math.log(h); const c = 0.5 * Math.exp(2 * u / 3); const d = 0.5 * Math.sqrt(u * c * (h - c) / h) * (l - h / 2 < 0 ? -1 : 1); const f = Math.max(r, Math.floor(n - l * c / h + d)); const p = Math.min(o, Math.floor(n + (h - l) * c / h + d)); s(t, n, f, p, a) } const v = t[n]; let g = r; let m = o; for (e(t, r, n), a(t[o], v) > 0 && e(t, r, o); g < m;) { for (e(t, g, m), g++, m--; a(t[g], v) < 0;)g++; for (; a(t[m], v) > 0;)m-- } a(t[r], v) === 0 ? e(t, r, m) : e(t, ++m, o), m <= n && (r = m + 1), n <= m && (o = m - 1) } }; t.exports = s }, 88492: (t, e, i) => { const s = i(35154); const n = i(33680); const r = function (t, e, i) { for (var s = [], n = 0; n < t.length; n++) for (let r = 0; r < e.length; r++) for (let o = 0; o < i; o++)s.push({ a: t[n], b: e[r] }); return s }; t.exports = function (t, e, i) { const o = s(i, 'max', 0); const a = s(i, 'qty', 1); const h = s(i, 'random', !1); const l = s(i, 'randomB', !1); let u = s(i, 'repeat', 0); const c = s(i, 'yoyo', !1); let d = []; if (l && n(e), u === -1) if (o === 0) u = 0; else { let f = t.length * e.length * a; c && (f *= 2), u = Math.ceil(o / f) } for (let p = 0; p <= u; p++) { const v = r(t, e, a); h && n(v), d = d.concat(v), c && (v.reverse(), d = d.concat(v)) } return o && d.splice(o), d } }, 72905: (t, e, i) => { const s = i(19133); t.exports = function (t, e, i, n) { let r; if (void 0 === n && (n = t), !Array.isArray(e)) return (r = t.indexOf(e)) !== -1 ? (s(t, r), i && i.call(n, e), e) : null; for (var o = e.length - 1, a = []; o >= 0;) { const h = e[o]; (r = t.indexOf(h)) !== -1 && (s(t, r), a.push(h), i && i.call(n, h)), o-- } return a } }, 60248: (t, e, i) => { const s = i(19133); t.exports = function (t, e, i, n) { if (void 0 === n && (n = t), e < 0 || e > t.length - 1) throw new Error('Index out of bounds'); const r = s(t, e); return i && i.call(n, r), r } }, 81409: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === r && (r = t), s(t, e, i)) { const o = i - e; const a = t.splice(e, o); if (n) for (let h = 0; h < a.length; h++) { const l = a[h]; n.call(r, l) } return a } return [] } }, 31856: (t, e, i) => { const s = i(19133); t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return s(t, n) } }, 42169: t => { t.exports = function (t, e, i) { const s = t.indexOf(e); const n = t.indexOf(i); return s !== -1 && n === -1 && (t[s] = i, !0) } }, 86003: t => { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, s = 0; s < e; s++)i = t.shift(), t.push(i); return i } }, 49498: t => { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, s = 0; s < e; s++)i = t.pop(), t.unshift(i); return i } }, 82011: t => { t.exports = function (t, e, i, s) { const n = t.length; if (e < 0 || e > n || e >= i || i > n) { if (s) throw new Error('Range Error: Values outside acceptable range'); return !1 } return !0 } }, 89545: t => { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i > 0 && (t.splice(i, 1), t.unshift(e)), e } }, 17810: (t, e, i) => { const s = i(82011); t.exports = function (t, e, i, n, r) { if (void 0 === n && (n = 0), void 0 === r && (r = t.length), s(t, n, r)) for (let o = n; o < r; o++) { const a = t[o]; a.hasOwnProperty(e) && (a[e] = i) } return t } }, 33680: t => { t.exports = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(Math.random() * (e + 1)); const s = t[e]; t[e] = t[i], t[i] = s } return t } }, 90126: t => { t.exports = function (t) { const e = /\D/g; return t.sort(function (t, i) { return parseInt(t.replace(e, ''), 10) - parseInt(i.replace(e, ''), 10) }), t } }, 19133: t => { t.exports = function (t, e) { if (!(e >= t.length)) { for (var i = t.length - 1, s = t[e], n = e; n < i; n++)t[n] = t[n + 1]; return t.length = i, s } } }, 19186: (t, e, i) => { const s = i(82264); function n (t, e) { return String(t).localeCompare(e) } function r (t, e, i, s) { let n; let r; let o; let a; let h; const l = t.length; let u = 0; const c = 2 * i; for (n = 0; n < l; n += c) for (o = (r = n + i) + i, r > l && (r = l), o > l && (o = l), a = n, h = r; ;) if (a < r && h < o) e(t[a], t[h]) <= 0 ? s[u++] = t[a++] : s[u++] = t[h++]; else if (a < r) s[u++] = t[a++]; else { if (!(h < o)) break; s[u++] = t[h++] } } t.exports = function (t, e) { if (void 0 === e && (e = n), !t || t.length < 2) return t; if (s.features.stableSort) return t.sort(e); const i = (function (t, e) { const i = t.length; if (i <= 1) return t; for (let s = new Array(i), n = 1; n < i; n *= 2) { r(t, e, n, s); const o = t; t = s, s = o } return t }(t, e)); return i !== t && r(i, null, t.length, t), t } }, 25630: t => { t.exports = function (t, e, i) { if (e === i) return t; const s = t.indexOf(e); const n = t.indexOf(i); if (s < 0 || n < 0) throw new Error('Supplied items must be elements of the same array'); return t[s] = i, t[n] = e, t } }, 37105: (t, e, i) => { t.exports = { Matrix: i(54915), Add: i(71146), AddAt: i(51067), BringToTop: i(66905), CountAllMatching: i(21612), Each: i(95428), EachInRange: i(36914), FindClosestInSorted: i(81957), Flatten: i(43491), GetAll: i(46710), GetFirst: i(58731), GetRandom: i(26546), MoveDown: i(70864), MoveTo: i(69693), MoveUp: i(40853), MoveAbove: i(85835), MoveBelow: i(83371), NumberArray: i(20283), NumberArrayStep: i(593), QuickSelect: i(43886), Range: i(88492), Remove: i(72905), RemoveAt: i(60248), RemoveBetween: i(81409), RemoveRandomElement: i(31856), Replace: i(42169), RotateLeft: i(86003), RotateRight: i(49498), SafeRange: i(82011), SendToBack: i(89545), SetAll: i(17810), Shuffle: i(33680), SortByDigits: i(90126), SpliceOne: i(19133), StableSort: i(19186), Swap: i(25630) } }, 86922: t => { t.exports = function (t) { if (!Array.isArray(t) || !Array.isArray(t[0])) return !1; for (let e = t[0].length, i = 1; i < t.length; i++) if (t[i].length !== e) return !1; return !0 } }, 63362: (t, e, i) => { const s = i(41836); const n = i(86922); t.exports = function (t) { let e = ''; if (!n(t)) return e; for (let i = 0; i < t.length; i++) { for (let r = 0; r < t[i].length; r++) { const o = t[i][r].toString(); e += o !== 'undefined' ? s(o, 2) : '?', r < t[i].length - 1 && (e += ' |') } if (i < t.length - 1) { e += '\n'; for (let a = 0; a < t[i].length; a++)e += '---', a < t[i].length - 1 && (e += '+'); e += '\n' } } return e } }, 92598: t => { t.exports = function (t) { return t.reverse() } }, 21224: t => { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].reverse(); return t } }, 98717: (t, e, i) => { const s = i(37829); t.exports = function (t) { return s(t, 180) } }, 44657: (t, e, i) => { const s = i(37829); t.exports = function (t, e) { void 0 === e && (e = 1); for (let i = 0; i < e; i++)t = s(t, 90); return t } }, 37829: (t, e, i) => { const s = i(86922); const n = i(2429); t.exports = function (t, e) { if (void 0 === e && (e = 90), !s(t)) return null; if (typeof e !== 'string' && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === 'rotateLeft') (t = n(t)).reverse(); else if (e === -90 || e === 270 || e === 'rotateRight') t.reverse(), t = n(t); else if (Math.abs(e) === 180 || e === 'rotate180') { for (let i = 0; i < t.length; i++)t[i].reverse(); t.reverse() } return t } }, 92632: (t, e, i) => { const s = i(37829); t.exports = function (t, e) { void 0 === e && (e = 1); for (let i = 0; i < e; i++)t = s(t, -90); return t } }, 69512: (t, e, i) => { const s = i(86003); const n = i(49498); t.exports = function (t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), i !== 0 && (i < 0 ? s(t, Math.abs(i)) : n(t, i)), e !== 0) for (let r = 0; r < t.length; r++) { const o = t[r]; e < 0 ? s(o, Math.abs(e)) : n(o, e) } return t } }, 2429: t => { t.exports = function (t) { for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) { s[n] = new Array(e); for (let r = e - 1; r > -1; r--)s[n][r] = t[r][n] } return s } }, 54915: (t, e, i) => { t.exports = { CheckMatrix: i(86922), MatrixToString: i(63362), ReverseColumns: i(92598), ReverseRows: i(21224), Rotate180: i(98717), RotateLeft: i(44657), RotateMatrix: i(37829), RotateRight: i(92632), Translate: i(69512), TransposeMatrix: i(2429) } }, 71334: t => { const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; t.exports = function (t, i) { for (var s = new Uint8Array(t), n = s.length, r = i ? 'data:' + i + ';base64,' : '', o = 0; o < n; o += 3)r += e[s[o] >> 2], r += e[(3 & s[o]) << 4 | s[o + 1] >> 4], r += e[(15 & s[o + 1]) << 2 | s[o + 2] >> 6], r += e[63 & s[o + 2]]; return n % 3 == 2 ? r = r.substring(0, r.length - 1) + '=' : n % 3 == 1 && (r = r.substring(0, r.length - 2) + '=='), r } }, 53134: t => { for (var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', i = new Uint8Array(256), s = 0; s < 64; s++)i[e.charCodeAt(s)] = s; t.exports = function (t) { let e; let s; let n; let r; const o = (t = t.substr(t.indexOf(',') + 1)).length; let a = 0.75 * o; let h = 0; t[o - 1] === '=' && (a--, t[o - 2] === '=' && a--); for (var l = new ArrayBuffer(a), u = new Uint8Array(l), c = 0; c < o; c += 4)e = i[t.charCodeAt(c)], s = i[t.charCodeAt(c + 1)], n = i[t.charCodeAt(c + 2)], r = i[t.charCodeAt(c + 3)], u[h++] = e << 2 | s >> 4, u[h++] = (15 & s) << 4 | n >> 2, u[h++] = (3 & n) << 6 | 63 & r; return l } }, 65839: (t, e, i) => { t.exports = { ArrayBufferToBase64: i(71334), Base64ToArrayBuffer: i(53134) } }, 91799: (t, e, i) => { t.exports = { Array: i(37105), Base64: i(65839), Objects: i(1183), String: i(31749), NOOP: i(29747), NULL: i(20242) } }, 41786: t => { t.exports = function (t) { const e = {}; for (const i in t) Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i]; return e } }, 62644: t => { const e = function (t) { let i, s, n; if (typeof t !== 'object' || t === null) return t; for (n in i = Array.isArray(t) ? [] : {}, t) s = t[n], i[n] = e(s); return i }; t.exports = e }, 79291: (t, e, i) => { const s = i(41212); const n = function () { let t; let e; let i; let r; let o; let a; let h = arguments[0] || {}; let l = 1; const u = arguments.length; let c = !1; for (typeof h === 'boolean' && (c = h, h = arguments[1] || {}, l = 2), u === l && (h = this, --l); l < u; l++) if ((t = arguments[l]) != null) for (e in t) i = h[e], h !== (r = t[e]) && (c && r && (s(r) || (o = Array.isArray(r))) ? (o ? (o = !1, a = i && Array.isArray(i) ? i : []) : a = i && s(i) ? i : {}, h[e] = n(c, a, r)) : void 0 !== r && (h[e] = r)); return h }; t.exports = n }, 23568: (t, e, i) => { const s = i(75508); const n = i(35154); t.exports = function (t, e, i) { const r = n(t, e, null); if (r === null) return i; if (Array.isArray(r)) return s.RND.pick(r); if (typeof r === 'object') { if (r.hasOwnProperty('randInt')) return s.RND.integerInRange(r.randInt[0], r.randInt[1]); if (r.hasOwnProperty('randFloat')) return s.RND.realInRange(r.randFloat[0], r.randFloat[1]) } else if (typeof r === 'function') return r(e); return r } }, 95540: t => { t.exports = function (t, e, i) { const s = typeof t; return t && s !== 'number' && s !== 'string' && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i } }, 82840: (t, e, i) => { const s = i(35154); const n = i(45319); t.exports = function (t, e, i, r, o) { void 0 === o && (o = i); const a = s(t, e, o); return n(a, i, r) } }, 35154: t => { t.exports = function (t, e, i, s) { if (!t && !s || typeof t === 'number') return i; if (t && t.hasOwnProperty(e)) return t[e]; if (s && s.hasOwnProperty(e)) return s[e]; if (e.indexOf('.') !== -1) { for (var n = e.split('.'), r = t, o = s, a = i, h = i, l = !0, u = !0, c = 0; c < n.length; c++)r && r.hasOwnProperty(n[c]) ? (a = r[n[c]], r = r[n[c]]) : l = !1, o && o.hasOwnProperty(n[c]) ? (h = o[n[c]], o = o[n[c]]) : u = !1; return l ? a : u ? h : i } return i } }, 69036: t => { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (!t.hasOwnProperty(e[i])) return !1; return !0 } }, 1985: t => { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (t.hasOwnProperty(e[i])) return !0; return !1 } }, 97022: t => { t.exports = function (t, e) { return t.hasOwnProperty(e) } }, 41212: t => { t.exports = function (t) { if (!t || typeof t !== 'object' || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, 'isPrototypeOf')) return !1 } catch (t) { return !1 } return !0 } }, 46975: (t, e, i) => { const s = i(41786); t.exports = function (t, e) { const i = s(t); for (const n in e) i.hasOwnProperty(n) || (i[n] = e[n]); return i } }, 269: (t, e, i) => { const s = i(41786); t.exports = function (t, e) { const i = s(t); for (const n in e) i.hasOwnProperty(n) && (i[n] = e[n]); return i } }, 18254: (t, e, i) => { const s = i(97022); t.exports = function (t, e) { for (var i = {}, n = 0; n < e.length; n++) { const r = e[n]; s(t, r) && (i[r] = t[r]) } return i } }, 61622: t => { t.exports = function (t, e, i) { if (!t || typeof t === 'number') return !1; if (t.hasOwnProperty(e)) return t[e] = i, !0; if (e.indexOf('.') !== -1) { for (var s = e.split('.'), n = t, r = t, o = 0; o < s.length; o++) { if (!n.hasOwnProperty(s[o])) return !1; r = n, n = n[s[o]] } return r[s[s.length - 1]] = i, !0 } return !1 } }, 1183: (t, e, i) => { t.exports = { Clone: i(41786), DeepCopy: i(62644), Extend: i(79291), GetAdvancedValue: i(23568), GetFastValue: i(95540), GetMinMaxValue: i(82840), GetValue: i(35154), HasAll: i(69036), HasAny: i(1985), HasValue: i(97022), IsPlainObject: i(41212), Merge: i(46975), MergeRight: i(269), Pick: i(18254), SetValue: i(61622) } }, 27902: t => { t.exports = function (t, e) { return t.replace(/%([0-9]+)/g, function (t, i) { return e[Number(i) - 1] }) } }, 41836: t => { t.exports = function (t, e, i, s) { void 0 === e && (e = 0), void 0 === i && (i = ' '), void 0 === s && (s = 3); let n = 0; if (e + 1 >= (t = t.toString()).length) switch (s) { case 1: t = new Array(e + 1 - t.length).join(i) + t; break; case 3: var r = Math.ceil((n = e - t.length) / 2); t = new Array(n - r + 1).join(i) + t + new Array(r + 1).join(i); break; default: t += new Array(e + 1 - t.length).join(i) } return t } }, 33628: t => { t.exports = function (t, e) { return e === 0 ? t.slice(1) : t.slice(0, e - 1) + t.slice(e) } }, 27671: t => { t.exports = function (t) { return t.split('').reverse().join('') } }, 45650: t => { t.exports = function () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (t) { const e = 16 * Math.random() | 0; return (t === 'x' ? e : 3 & e | 8).toString(16) }) } }, 35355: t => { t.exports = function (t) { return t && t[0].toUpperCase() + t.slice(1) } }, 31749: (t, e, i) => { t.exports = { Format: i(27902), Pad: i(41836), RemoveAt: i(33628), Reverse: i(27671), UppercaseFirst: i(35355), UUID: i(45650) } } }; const e = {}; function i (s) { const n = e[s]; if (void 0 !== n) return n.exports; const r = e[s] = { exports: {} }; return t[s](r, r.exports, i), r.exports } return i.g = (function () { if (typeof globalThis === 'object') return globalThis; try { return this || new Function('return this')() } catch (t) { if (typeof window === 'object') return window } }()), i(85454) })()))
